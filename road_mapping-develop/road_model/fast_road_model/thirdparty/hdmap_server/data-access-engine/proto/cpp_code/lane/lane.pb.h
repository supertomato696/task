// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: lane/lane.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_lane_2flane_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_lane_2flane_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "metadata/metadata.pb.h"
#include "common/common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_lane_2flane_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_lane_2flane_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[9]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_lane_2flane_2eproto;
namespace RoadPB {
class ImpassableArea;
class ImpassableAreaDefaultTypeInternal;
extern ImpassableAreaDefaultTypeInternal _ImpassableArea_default_instance_;
class Junction;
class JunctionDefaultTypeInternal;
extern JunctionDefaultTypeInternal _Junction_default_instance_;
class Lane;
class LaneDefaultTypeInternal;
extern LaneDefaultTypeInternal _Lane_default_instance_;
class LaneBoundary;
class LaneBoundaryDefaultTypeInternal;
extern LaneBoundaryDefaultTypeInternal _LaneBoundary_default_instance_;
class LaneBoundaryRange;
class LaneBoundaryRangeDefaultTypeInternal;
extern LaneBoundaryRangeDefaultTypeInternal _LaneBoundaryRange_default_instance_;
class LaneDirection;
class LaneDirectionDefaultTypeInternal;
extern LaneDirectionDefaultTypeInternal _LaneDirection_default_instance_;
class LaneGroup;
class LaneGroupDefaultTypeInternal;
extern LaneGroupDefaultTypeInternal _LaneGroup_default_instance_;
class LaneSection;
class LaneSectionDefaultTypeInternal;
extern LaneSectionDefaultTypeInternal _LaneSection_default_instance_;
class RoadBoundary;
class RoadBoundaryDefaultTypeInternal;
extern RoadBoundaryDefaultTypeInternal _RoadBoundary_default_instance_;
}  // namespace RoadPB
PROTOBUF_NAMESPACE_OPEN
template<> ::RoadPB::ImpassableArea* Arena::CreateMaybeMessage<::RoadPB::ImpassableArea>(Arena*);
template<> ::RoadPB::Junction* Arena::CreateMaybeMessage<::RoadPB::Junction>(Arena*);
template<> ::RoadPB::Lane* Arena::CreateMaybeMessage<::RoadPB::Lane>(Arena*);
template<> ::RoadPB::LaneBoundary* Arena::CreateMaybeMessage<::RoadPB::LaneBoundary>(Arena*);
template<> ::RoadPB::LaneBoundaryRange* Arena::CreateMaybeMessage<::RoadPB::LaneBoundaryRange>(Arena*);
template<> ::RoadPB::LaneDirection* Arena::CreateMaybeMessage<::RoadPB::LaneDirection>(Arena*);
template<> ::RoadPB::LaneGroup* Arena::CreateMaybeMessage<::RoadPB::LaneGroup>(Arena*);
template<> ::RoadPB::LaneSection* Arena::CreateMaybeMessage<::RoadPB::LaneSection>(Arena*);
template<> ::RoadPB::RoadBoundary* Arena::CreateMaybeMessage<::RoadPB::RoadBoundary>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace RoadPB {

enum LaneDirection_Direction : int {
  LaneDirection_Direction_FORWARD = 1,
  LaneDirection_Direction_BACKWARD = 2,
  LaneDirection_Direction_BIDIRECTION = 3,
  LaneDirection_Direction_TIDAL = 4,
  LaneDirection_Direction_NONE = 5
};
bool LaneDirection_Direction_IsValid(int value);
constexpr LaneDirection_Direction LaneDirection_Direction_Direction_MIN = LaneDirection_Direction_FORWARD;
constexpr LaneDirection_Direction LaneDirection_Direction_Direction_MAX = LaneDirection_Direction_NONE;
constexpr int LaneDirection_Direction_Direction_ARRAYSIZE = LaneDirection_Direction_Direction_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LaneDirection_Direction_descriptor();
template<typename T>
inline const std::string& LaneDirection_Direction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LaneDirection_Direction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LaneDirection_Direction_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LaneDirection_Direction_descriptor(), enum_t_value);
}
inline bool LaneDirection_Direction_Parse(
    const std::string& name, LaneDirection_Direction* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LaneDirection_Direction>(
    LaneDirection_Direction_descriptor(), name, value);
}
enum LaneBoundary_Color : int {
  LaneBoundary_Color_UNKNOWN_COLOR = 0,
  LaneBoundary_Color_WHITE = 1,
  LaneBoundary_Color_YELLOW = 2,
  LaneBoundary_Color_ORANGE = 3,
  LaneBoundary_Color_BLUE = 4,
  LaneBoundary_Color_GREEN = 5,
  LaneBoundary_Color_GRAY = 6,
  LaneBoundary_Color_LEFT_GRAY_RIGHT_YELLOW = 7,
  LaneBoundary_Color_LEFT_YELLOW_RIGHT_WHITE = 8,
  LaneBoundary_Color_LEFT_WHITE_RIGHT_YELLOW = 9
};
bool LaneBoundary_Color_IsValid(int value);
constexpr LaneBoundary_Color LaneBoundary_Color_Color_MIN = LaneBoundary_Color_UNKNOWN_COLOR;
constexpr LaneBoundary_Color LaneBoundary_Color_Color_MAX = LaneBoundary_Color_LEFT_WHITE_RIGHT_YELLOW;
constexpr int LaneBoundary_Color_Color_ARRAYSIZE = LaneBoundary_Color_Color_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LaneBoundary_Color_descriptor();
template<typename T>
inline const std::string& LaneBoundary_Color_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LaneBoundary_Color>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LaneBoundary_Color_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LaneBoundary_Color_descriptor(), enum_t_value);
}
inline bool LaneBoundary_Color_Parse(
    const std::string& name, LaneBoundary_Color* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LaneBoundary_Color>(
    LaneBoundary_Color_descriptor(), name, value);
}
enum LaneBoundary_LaneLineType_Type : int {
  LaneBoundary_LaneLineType_Type_LaneLineType_Type_UNKNOWN = 0,
  LaneBoundary_LaneLineType_Type_LaneLineType_Type_LANELINE = 1,
  LaneBoundary_LaneLineType_Type_LaneLineType_Type_CURB = 2,
  LaneBoundary_LaneLineType_Type_LaneLineType_Type_CENTER = 3,
  LaneBoundary_LaneLineType_Type_LaneLineType_Type_GUARDRAIL = 4,
  LaneBoundary_LaneLineType_Type_LaneLineType_Type_CONCRETE_BARRIER = 5,
  LaneBoundary_LaneLineType_Type_LaneLineType_Type_FENCE = 6,
  LaneBoundary_LaneLineType_Type_LaneLineType_Type_WALL = 7,
  LaneBoundary_LaneLineType_Type_LaneLineType_Type_CANOPY = 8
};
bool LaneBoundary_LaneLineType_Type_IsValid(int value);
constexpr LaneBoundary_LaneLineType_Type LaneBoundary_LaneLineType_Type_LaneLineType_Type_MIN = LaneBoundary_LaneLineType_Type_LaneLineType_Type_UNKNOWN;
constexpr LaneBoundary_LaneLineType_Type LaneBoundary_LaneLineType_Type_LaneLineType_Type_MAX = LaneBoundary_LaneLineType_Type_LaneLineType_Type_CANOPY;
constexpr int LaneBoundary_LaneLineType_Type_LaneLineType_Type_ARRAYSIZE = LaneBoundary_LaneLineType_Type_LaneLineType_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LaneBoundary_LaneLineType_Type_descriptor();
template<typename T>
inline const std::string& LaneBoundary_LaneLineType_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LaneBoundary_LaneLineType_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LaneBoundary_LaneLineType_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LaneBoundary_LaneLineType_Type_descriptor(), enum_t_value);
}
inline bool LaneBoundary_LaneLineType_Type_Parse(
    const std::string& name, LaneBoundary_LaneLineType_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LaneBoundary_LaneLineType_Type>(
    LaneBoundary_LaneLineType_Type_descriptor(), name, value);
}
enum LaneBoundary_LaneBoundaryType : int {
  LaneBoundary_LaneBoundaryType_UNKNOWN_BOUNDARY = 0,
  LaneBoundary_LaneBoundaryType_LANELINE = 1,
  LaneBoundary_LaneBoundaryType_GUARDRAIL = 2,
  LaneBoundary_LaneBoundaryType_TRAFFIC_CONE = 10,
  LaneBoundary_LaneBoundaryType_PUNCHEON = 11
};
bool LaneBoundary_LaneBoundaryType_IsValid(int value);
constexpr LaneBoundary_LaneBoundaryType LaneBoundary_LaneBoundaryType_LaneBoundaryType_MIN = LaneBoundary_LaneBoundaryType_UNKNOWN_BOUNDARY;
constexpr LaneBoundary_LaneBoundaryType LaneBoundary_LaneBoundaryType_LaneBoundaryType_MAX = LaneBoundary_LaneBoundaryType_PUNCHEON;
constexpr int LaneBoundary_LaneBoundaryType_LaneBoundaryType_ARRAYSIZE = LaneBoundary_LaneBoundaryType_LaneBoundaryType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LaneBoundary_LaneBoundaryType_descriptor();
template<typename T>
inline const std::string& LaneBoundary_LaneBoundaryType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LaneBoundary_LaneBoundaryType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LaneBoundary_LaneBoundaryType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LaneBoundary_LaneBoundaryType_descriptor(), enum_t_value);
}
inline bool LaneBoundary_LaneBoundaryType_Parse(
    const std::string& name, LaneBoundary_LaneBoundaryType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LaneBoundary_LaneBoundaryType>(
    LaneBoundary_LaneBoundaryType_descriptor(), name, value);
}
enum LaneBoundary_LineMarking : int {
  LaneBoundary_LineMarking_LineMarking_Unknown = 0,
  LaneBoundary_LineMarking_LineMarking_SolidLine = 1,
  LaneBoundary_LineMarking_LineMarking_DashedLine = 2,
  LaneBoundary_LineMarking_LineMarking_ShortDashedLine = 3,
  LaneBoundary_LineMarking_LineMarking_DoubleSolidLine = 4,
  LaneBoundary_LineMarking_LineMarking_DoubleDashedLine = 5,
  LaneBoundary_LineMarking_LineMarking_LeftSolidRightDashed = 6,
  LaneBoundary_LineMarking_LineMarking_RightSolidLeftDashed = 7,
  LaneBoundary_LineMarking_LineMarking_ShadedArea = 8,
  LaneBoundary_LineMarking_LineMarking_LaneVirtualMarking = 9,
  LaneBoundary_LineMarking_LineMarking_IntersectionVirualMarking = 10,
  LaneBoundary_LineMarking_LineMarking_CurbVirtualMarking = 11,
  LaneBoundary_LineMarking_LineMarking_UnclosedRoad = 12,
  LaneBoundary_LineMarking_LineMarking_RoadVirtualLine = 13,
  LaneBoundary_LineMarking_LineMarking_Other = 99
};
bool LaneBoundary_LineMarking_IsValid(int value);
constexpr LaneBoundary_LineMarking LaneBoundary_LineMarking_LineMarking_MIN = LaneBoundary_LineMarking_LineMarking_Unknown;
constexpr LaneBoundary_LineMarking LaneBoundary_LineMarking_LineMarking_MAX = LaneBoundary_LineMarking_LineMarking_Other;
constexpr int LaneBoundary_LineMarking_LineMarking_ARRAYSIZE = LaneBoundary_LineMarking_LineMarking_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LaneBoundary_LineMarking_descriptor();
template<typename T>
inline const std::string& LaneBoundary_LineMarking_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LaneBoundary_LineMarking>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LaneBoundary_LineMarking_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LaneBoundary_LineMarking_descriptor(), enum_t_value);
}
inline bool LaneBoundary_LineMarking_Parse(
    const std::string& name, LaneBoundary_LineMarking* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LaneBoundary_LineMarking>(
    LaneBoundary_LineMarking_descriptor(), name, value);
}
enum LaneBoundary_MarkingType : int {
  LaneBoundary_MarkingType_UNKNOWN = 0,
  LaneBoundary_MarkingType_SOLID = 1,
  LaneBoundary_MarkingType_DASHED = 2,
  LaneBoundary_MarkingType_SHORT_DASHED = 3,
  LaneBoundary_MarkingType_DOUBLE_SOLID = 4,
  LaneBoundary_MarkingType_DOUBLE_DASHED = 5,
  LaneBoundary_MarkingType_LEFT_SOLID_RIGHT_DASHED = 6,
  LaneBoundary_MarkingType_LEFT_DASHED_RIGHT_SOLID = 7,
  LaneBoundary_MarkingType_SHADED_AREA = 8,
  LaneBoundary_MarkingType_VIRTUAL_LANE = 9,
  LaneBoundary_MarkingType_VIRTUAL_JUNCTION = 10
};
bool LaneBoundary_MarkingType_IsValid(int value);
constexpr LaneBoundary_MarkingType LaneBoundary_MarkingType_MarkingType_MIN = LaneBoundary_MarkingType_UNKNOWN;
constexpr LaneBoundary_MarkingType LaneBoundary_MarkingType_MarkingType_MAX = LaneBoundary_MarkingType_VIRTUAL_JUNCTION;
constexpr int LaneBoundary_MarkingType_MarkingType_ARRAYSIZE = LaneBoundary_MarkingType_MarkingType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LaneBoundary_MarkingType_descriptor();
template<typename T>
inline const std::string& LaneBoundary_MarkingType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LaneBoundary_MarkingType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LaneBoundary_MarkingType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LaneBoundary_MarkingType_descriptor(), enum_t_value);
}
inline bool LaneBoundary_MarkingType_Parse(
    const std::string& name, LaneBoundary_MarkingType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LaneBoundary_MarkingType>(
    LaneBoundary_MarkingType_descriptor(), name, value);
}
enum RoadBoundary_RoadBoundaryType : int {
  RoadBoundary_RoadBoundaryType_UNKNOWN_BOUNDARY = 0,
  RoadBoundary_RoadBoundaryType_CURB = 2,
  RoadBoundary_RoadBoundaryType_GUARDRAIL = 4,
  RoadBoundary_RoadBoundaryType_CONCRETE_BARRIER = 5,
  RoadBoundary_RoadBoundaryType_FENCE = 6,
  RoadBoundary_RoadBoundaryType_WALL = 7,
  RoadBoundary_RoadBoundaryType_CANOPY = 8,
  RoadBoundary_RoadBoundaryType_PAVE = 9,
  RoadBoundary_RoadBoundaryType_DITCH = 10,
  RoadBoundary_RoadBoundaryType_PUNCHEON = 11
};
bool RoadBoundary_RoadBoundaryType_IsValid(int value);
constexpr RoadBoundary_RoadBoundaryType RoadBoundary_RoadBoundaryType_RoadBoundaryType_MIN = RoadBoundary_RoadBoundaryType_UNKNOWN_BOUNDARY;
constexpr RoadBoundary_RoadBoundaryType RoadBoundary_RoadBoundaryType_RoadBoundaryType_MAX = RoadBoundary_RoadBoundaryType_PUNCHEON;
constexpr int RoadBoundary_RoadBoundaryType_RoadBoundaryType_ARRAYSIZE = RoadBoundary_RoadBoundaryType_RoadBoundaryType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RoadBoundary_RoadBoundaryType_descriptor();
template<typename T>
inline const std::string& RoadBoundary_RoadBoundaryType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RoadBoundary_RoadBoundaryType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RoadBoundary_RoadBoundaryType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RoadBoundary_RoadBoundaryType_descriptor(), enum_t_value);
}
inline bool RoadBoundary_RoadBoundaryType_Parse(
    const std::string& name, RoadBoundary_RoadBoundaryType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RoadBoundary_RoadBoundaryType>(
    RoadBoundary_RoadBoundaryType_descriptor(), name, value);
}
enum Lane_Function : int {
  Lane_Function_Function_NONE = 0,
  Lane_Function_Function_CITY_DRIVING = 1,
  Lane_Function_Function_HIGH_DRIVING = 2,
  Lane_Function_Function_BIKING = 3,
  Lane_Function_Function_SIDEWALK = 4,
  Lane_Function_Function_PARKING = 5,
  Lane_Function_Function_RAMP = 6,
  Lane_Function_Function_EMERGENCY = 7,
  Lane_Function_Function_ACCELERATION = 8
};
bool Lane_Function_IsValid(int value);
constexpr Lane_Function Lane_Function_Function_MIN = Lane_Function_Function_NONE;
constexpr Lane_Function Lane_Function_Function_MAX = Lane_Function_Function_ACCELERATION;
constexpr int Lane_Function_Function_ARRAYSIZE = Lane_Function_Function_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Lane_Function_descriptor();
template<typename T>
inline const std::string& Lane_Function_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Lane_Function>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Lane_Function_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Lane_Function_descriptor(), enum_t_value);
}
inline bool Lane_Function_Parse(
    const std::string& name, Lane_Function* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Lane_Function>(
    Lane_Function_descriptor(), name, value);
}
enum Lane_LaneType : int {
  Lane_LaneType_UNKNOWN_LANETYPE = 0,
  Lane_LaneType_STANDARD_LANE = 2,
  Lane_LaneType_ACCELERATION_LANE = 3,
  Lane_LaneType_DECELERATION_LANE = 4,
  Lane_LaneType_SPEED_CHANGE_LANE = 5,
  Lane_LaneType_TOLL_LANE = 11,
  Lane_LaneType_EMERGENCY_LANE = 12,
  Lane_LaneType_BUS_LANE = 13,
  Lane_LaneType_CYCLE_PATH = 14,
  Lane_LaneType_U_TURN_LANE = 15
};
bool Lane_LaneType_IsValid(int value);
constexpr Lane_LaneType Lane_LaneType_LaneType_MIN = Lane_LaneType_UNKNOWN_LANETYPE;
constexpr Lane_LaneType Lane_LaneType_LaneType_MAX = Lane_LaneType_U_TURN_LANE;
constexpr int Lane_LaneType_LaneType_ARRAYSIZE = Lane_LaneType_LaneType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Lane_LaneType_descriptor();
template<typename T>
inline const std::string& Lane_LaneType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Lane_LaneType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Lane_LaneType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Lane_LaneType_descriptor(), enum_t_value);
}
inline bool Lane_LaneType_Parse(
    const std::string& name, Lane_LaneType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Lane_LaneType>(
    Lane_LaneType_descriptor(), name, value);
}
enum Lane_LanePriority : int {
  Lane_LanePriority_LANE_PRIORITY_UNKNOWN = 0,
  Lane_LanePriority_LANE_PRIORITY_HIGHER = 1,
  Lane_LanePriority_LANE_PRIORITY_EQUAL = 2,
  Lane_LanePriority_LANE_PRIORITY_LOWER = 3,
  Lane_LanePriority_LANE_PRIORITY_CONTROLLED_BY_SIGNAL = 4,
  Lane_LanePriority_LANE_PRIORITY_CONTROLLED_BY_STOPLINE = 5
};
bool Lane_LanePriority_IsValid(int value);
constexpr Lane_LanePriority Lane_LanePriority_LanePriority_MIN = Lane_LanePriority_LANE_PRIORITY_UNKNOWN;
constexpr Lane_LanePriority Lane_LanePriority_LanePriority_MAX = Lane_LanePriority_LANE_PRIORITY_CONTROLLED_BY_STOPLINE;
constexpr int Lane_LanePriority_LanePriority_ARRAYSIZE = Lane_LanePriority_LanePriority_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Lane_LanePriority_descriptor();
template<typename T>
inline const std::string& Lane_LanePriority_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Lane_LanePriority>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Lane_LanePriority_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Lane_LanePriority_descriptor(), enum_t_value);
}
inline bool Lane_LanePriority_Parse(
    const std::string& name, Lane_LanePriority* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Lane_LanePriority>(
    Lane_LanePriority_descriptor(), name, value);
}
enum Lane_LaneLineRestrictionType : int {
  Lane_LaneLineRestrictionType_UNKNOWN_LINE_RESTRICTION_TYPE = 0,
  Lane_LaneLineRestrictionType_BUS_LANE_LEFT_EDGE = 1,
  Lane_LaneLineRestrictionType_BUS_LANE_RIGHT_EDGE = 2,
  Lane_LaneLineRestrictionType_BIKE_LANE_LEFT_EDGE = 3,
  Lane_LaneLineRestrictionType_BIKE_LANE_RIGHT_EDGE = 4,
  Lane_LaneLineRestrictionType_OPPOSITE_NO_PASS = 5,
  Lane_LaneLineRestrictionType_OPPOSITE_CAN_PASS = 6,
  Lane_LaneLineRestrictionType_PEDESTRAIN_LANE_LEFT_EDGE = 7,
  Lane_LaneLineRestrictionType_PEDESTRAIN_LANE_RIGHT_EDGE = 8,
  Lane_LaneLineRestrictionType_WHITE_STRIP_ZONE_ON_LEFT = 9,
  Lane_LaneLineRestrictionType_WHITE_STRIP_ZONE_ON_RIGHT = 10,
  Lane_LaneLineRestrictionType_YELLOW_STRIP_ZONE_ON_LEFT = 11,
  Lane_LaneLineRestrictionType_YELLOW_STRIP_ZONE_ON_RIGHT = 12,
  Lane_LaneLineRestrictionType_CABLE_CAR_ON_LEFT = 13,
  Lane_LaneLineRestrictionType_CABLE_CAR_ON_RIGHT = 14,
  Lane_LaneLineRestrictionType_NO_CAR_ON_LEFT = 15,
  Lane_LaneLineRestrictionType_NO_CAR_ON_RIGHT = 16,
  Lane_LaneLineRestrictionType_EXIT_LANE_LEFT_EDGE = 17,
  Lane_LaneLineRestrictionType_EXIT_LANE_RIGHT_EDGE = 18,
  Lane_LaneLineRestrictionType_ENTRY_LANE_LEFT_EDGE = 19,
  Lane_LaneLineRestrictionType_ENTRY_LANE_RIGHT_EDGE = 20,
  Lane_LaneLineRestrictionType_HOV_LANE_LEFT_EDGE = 21,
  Lane_LaneLineRestrictionType_HOV_LANE_RIGHT_EDGE = 22,
  Lane_LaneLineRestrictionType_SIDEWALK_LEFT_EDGE = 23,
  Lane_LaneLineRestrictionType_SIDEWALK_RIGHT_EDGE = 24,
  Lane_LaneLineRestrictionType_PARKING_LANE_LEFT_EDGE = 25,
  Lane_LaneLineRestrictionType_PARKING_LANE_RIGHT_EDGE = 26,
  Lane_LaneLineRestrictionType_SHOULDER_LANE_LEFT_EDGE = 27,
  Lane_LaneLineRestrictionType_SHOULDER_LANE_RIGHT_EDGE = 28
};
bool Lane_LaneLineRestrictionType_IsValid(int value);
constexpr Lane_LaneLineRestrictionType Lane_LaneLineRestrictionType_LaneLineRestrictionType_MIN = Lane_LaneLineRestrictionType_UNKNOWN_LINE_RESTRICTION_TYPE;
constexpr Lane_LaneLineRestrictionType Lane_LaneLineRestrictionType_LaneLineRestrictionType_MAX = Lane_LaneLineRestrictionType_SHOULDER_LANE_RIGHT_EDGE;
constexpr int Lane_LaneLineRestrictionType_LaneLineRestrictionType_ARRAYSIZE = Lane_LaneLineRestrictionType_LaneLineRestrictionType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Lane_LaneLineRestrictionType_descriptor();
template<typename T>
inline const std::string& Lane_LaneLineRestrictionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Lane_LaneLineRestrictionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Lane_LaneLineRestrictionType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Lane_LaneLineRestrictionType_descriptor(), enum_t_value);
}
inline bool Lane_LaneLineRestrictionType_Parse(
    const std::string& name, Lane_LaneLineRestrictionType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Lane_LaneLineRestrictionType>(
    Lane_LaneLineRestrictionType_descriptor(), name, value);
}
enum Lane_LaneTransition : int {
  Lane_LaneTransition_LaneTransition_Unknown = 0,
  Lane_LaneTransition_LaneTransition_Continue = 1,
  Lane_LaneTransition_LaneTransition_Merging = 2,
  Lane_LaneTransition_LaneTransition_Splitting = 3,
  Lane_LaneTransition_LaneTransition_Other = 99
};
bool Lane_LaneTransition_IsValid(int value);
constexpr Lane_LaneTransition Lane_LaneTransition_LaneTransition_MIN = Lane_LaneTransition_LaneTransition_Unknown;
constexpr Lane_LaneTransition Lane_LaneTransition_LaneTransition_MAX = Lane_LaneTransition_LaneTransition_Other;
constexpr int Lane_LaneTransition_LaneTransition_ARRAYSIZE = Lane_LaneTransition_LaneTransition_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Lane_LaneTransition_descriptor();
template<typename T>
inline const std::string& Lane_LaneTransition_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Lane_LaneTransition>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Lane_LaneTransition_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Lane_LaneTransition_descriptor(), enum_t_value);
}
inline bool Lane_LaneTransition_Parse(
    const std::string& name, Lane_LaneTransition* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Lane_LaneTransition>(
    Lane_LaneTransition_descriptor(), name, value);
}
enum Lane_TurnLimit : int {
  Lane_TurnLimit_NONE = 0,
  Lane_TurnLimit_STRAIGHT = 1,
  Lane_TurnLimit_SLIGHT_RIGHT = 2,
  Lane_TurnLimit_RIGHT = 4,
  Lane_TurnLimit_HARD_RIGHT = 8,
  Lane_TurnLimit_UTURN = 16,
  Lane_TurnLimit_HARD_LEFT = 32,
  Lane_TurnLimit_LEFT = 64,
  Lane_TurnLimit_SLIGHT_LEFT = 128,
  Lane_TurnLimit_NA = -1
};
bool Lane_TurnLimit_IsValid(int value);
constexpr Lane_TurnLimit Lane_TurnLimit_TurnLimit_MIN = Lane_TurnLimit_NA;
constexpr Lane_TurnLimit Lane_TurnLimit_TurnLimit_MAX = Lane_TurnLimit_SLIGHT_LEFT;
constexpr int Lane_TurnLimit_TurnLimit_ARRAYSIZE = Lane_TurnLimit_TurnLimit_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Lane_TurnLimit_descriptor();
template<typename T>
inline const std::string& Lane_TurnLimit_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Lane_TurnLimit>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Lane_TurnLimit_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Lane_TurnLimit_descriptor(), enum_t_value);
}
inline bool Lane_TurnLimit_Parse(
    const std::string& name, Lane_TurnLimit* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Lane_TurnLimit>(
    Lane_TurnLimit_descriptor(), name, value);
}
enum LaneGroup_LaneGroupType : int {
  LaneGroup_LaneGroupType_UNKOWN_LANEGROUPTYPE = 0,
  LaneGroup_LaneGroupType_OTHERS = 1,
  LaneGroup_LaneGroupType_LANES_TO_TOLL = 21,
  LaneGroup_LaneGroupType_LANES_AT_TOLL = 22,
  LaneGroup_LaneGroupType_EXITING_TOLL = 23,
  LaneGroup_LaneGroupType_LANES_TO_BRIGHT = 24,
  LaneGroup_LaneGroupType_LANES_ON_BRIGHT = 25,
  LaneGroup_LaneGroupType_EXITING_BRIGHT = 26,
  LaneGroup_LaneGroupType_LANES_TO_TUNNEL = 27,
  LaneGroup_LaneGroupType_LANES_IN_TUNNEL = 28,
  LaneGroup_LaneGroupType_EXITING_TUNNEL = 29,
  LaneGroup_LaneGroupType_LANES_ON_JUNCTION = 30
};
bool LaneGroup_LaneGroupType_IsValid(int value);
constexpr LaneGroup_LaneGroupType LaneGroup_LaneGroupType_LaneGroupType_MIN = LaneGroup_LaneGroupType_UNKOWN_LANEGROUPTYPE;
constexpr LaneGroup_LaneGroupType LaneGroup_LaneGroupType_LaneGroupType_MAX = LaneGroup_LaneGroupType_LANES_ON_JUNCTION;
constexpr int LaneGroup_LaneGroupType_LaneGroupType_ARRAYSIZE = LaneGroup_LaneGroupType_LaneGroupType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LaneGroup_LaneGroupType_descriptor();
template<typename T>
inline const std::string& LaneGroup_LaneGroupType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LaneGroup_LaneGroupType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LaneGroup_LaneGroupType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LaneGroup_LaneGroupType_descriptor(), enum_t_value);
}
inline bool LaneGroup_LaneGroupType_Parse(
    const std::string& name, LaneGroup_LaneGroupType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LaneGroup_LaneGroupType>(
    LaneGroup_LaneGroupType_descriptor(), name, value);
}
enum ImpassableArea_Kind : int {
  ImpassableArea_Kind_UNKNOWN_KIND = 0,
  ImpassableArea_Kind_FLOWERBED = 1,
  ImpassableArea_Kind_SENTRY_BOX = 2,
  ImpassableArea_Kind_SAFE_ISLAND = 3
};
bool ImpassableArea_Kind_IsValid(int value);
constexpr ImpassableArea_Kind ImpassableArea_Kind_Kind_MIN = ImpassableArea_Kind_UNKNOWN_KIND;
constexpr ImpassableArea_Kind ImpassableArea_Kind_Kind_MAX = ImpassableArea_Kind_SAFE_ISLAND;
constexpr int ImpassableArea_Kind_Kind_ARRAYSIZE = ImpassableArea_Kind_Kind_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ImpassableArea_Kind_descriptor();
template<typename T>
inline const std::string& ImpassableArea_Kind_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ImpassableArea_Kind>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ImpassableArea_Kind_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ImpassableArea_Kind_descriptor(), enum_t_value);
}
inline bool ImpassableArea_Kind_Parse(
    const std::string& name, ImpassableArea_Kind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ImpassableArea_Kind>(
    ImpassableArea_Kind_descriptor(), name, value);
}
enum VehicleType : int {
  UNKNOWN_VEHICLE = 0,
  CAR = 1,
  MOTORCYCLE = 2,
  BICYCLE = 3,
  TRUCK = 4,
  TAXI = 5,
  BUS = 6,
  PEDESTRAIN = 7,
  CABLE_CAR = 8
};
bool VehicleType_IsValid(int value);
constexpr VehicleType VehicleType_MIN = UNKNOWN_VEHICLE;
constexpr VehicleType VehicleType_MAX = CABLE_CAR;
constexpr int VehicleType_ARRAYSIZE = VehicleType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VehicleType_descriptor();
template<typename T>
inline const std::string& VehicleType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VehicleType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VehicleType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    VehicleType_descriptor(), enum_t_value);
}
inline bool VehicleType_Parse(
    const std::string& name, VehicleType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<VehicleType>(
    VehicleType_descriptor(), name, value);
}
// ===================================================================

class LaneDirection PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RoadPB.LaneDirection) */ {
 public:
  inline LaneDirection() : LaneDirection(nullptr) {};
  virtual ~LaneDirection();

  LaneDirection(const LaneDirection& from);
  LaneDirection(LaneDirection&& from) noexcept
    : LaneDirection() {
    *this = ::std::move(from);
  }

  inline LaneDirection& operator=(const LaneDirection& from) {
    CopyFrom(from);
    return *this;
  }
  inline LaneDirection& operator=(LaneDirection&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LaneDirection& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LaneDirection* internal_default_instance() {
    return reinterpret_cast<const LaneDirection*>(
               &_LaneDirection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(LaneDirection& a, LaneDirection& b) {
    a.Swap(&b);
  }
  inline void Swap(LaneDirection* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LaneDirection* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LaneDirection* New() const final {
    return CreateMaybeMessage<LaneDirection>(nullptr);
  }

  LaneDirection* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LaneDirection>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LaneDirection& from);
  void MergeFrom(const LaneDirection& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LaneDirection* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RoadPB.LaneDirection";
  }
  protected:
  explicit LaneDirection(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_lane_2flane_2eproto);
    return ::descriptor_table_lane_2flane_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef LaneDirection_Direction Direction;
  static constexpr Direction FORWARD =
    LaneDirection_Direction_FORWARD;
  static constexpr Direction BACKWARD =
    LaneDirection_Direction_BACKWARD;
  static constexpr Direction BIDIRECTION =
    LaneDirection_Direction_BIDIRECTION;
  static constexpr Direction TIDAL =
    LaneDirection_Direction_TIDAL;
  static constexpr Direction NONE =
    LaneDirection_Direction_NONE;
  static inline bool Direction_IsValid(int value) {
    return LaneDirection_Direction_IsValid(value);
  }
  static constexpr Direction Direction_MIN =
    LaneDirection_Direction_Direction_MIN;
  static constexpr Direction Direction_MAX =
    LaneDirection_Direction_Direction_MAX;
  static constexpr int Direction_ARRAYSIZE =
    LaneDirection_Direction_Direction_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Direction_descriptor() {
    return LaneDirection_Direction_descriptor();
  }
  template<typename T>
  static inline const std::string& Direction_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Direction>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Direction_Name.");
    return LaneDirection_Direction_Name(enum_t_value);
  }
  static inline bool Direction_Parse(const std::string& name,
      Direction* value) {
    return LaneDirection_Direction_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAllowedVehicleTypesFieldNumber = 3,
    kValidPeriodFieldNumber = 2,
    kDirectionFieldNumber = 1,
  };
  // repeated int32 allowed_vehicle_types = 3;
  int allowed_vehicle_types_size() const;
  private:
  int _internal_allowed_vehicle_types_size() const;
  public:
  void clear_allowed_vehicle_types();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_allowed_vehicle_types(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_allowed_vehicle_types() const;
  void _internal_add_allowed_vehicle_types(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_allowed_vehicle_types();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 allowed_vehicle_types(int index) const;
  void set_allowed_vehicle_types(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_allowed_vehicle_types(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      allowed_vehicle_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_allowed_vehicle_types();

  // optional string valid_period = 2;
  bool has_valid_period() const;
  private:
  bool _internal_has_valid_period() const;
  public:
  void clear_valid_period();
  const std::string& valid_period() const;
  void set_valid_period(const std::string& value);
  void set_valid_period(std::string&& value);
  void set_valid_period(const char* value);
  void set_valid_period(const char* value, size_t size);
  std::string* mutable_valid_period();
  std::string* release_valid_period();
  void set_allocated_valid_period(std::string* valid_period);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_valid_period();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_valid_period(
      std::string* valid_period);
  private:
  const std::string& _internal_valid_period() const;
  void _internal_set_valid_period(const std::string& value);
  std::string* _internal_mutable_valid_period();
  public:

  // optional int32 direction = 1;
  bool has_direction() const;
  private:
  bool _internal_has_direction() const;
  public:
  void clear_direction();
  ::PROTOBUF_NAMESPACE_ID::int32 direction() const;
  void set_direction(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_direction() const;
  void _internal_set_direction(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:RoadPB.LaneDirection)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > allowed_vehicle_types_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr valid_period_;
  ::PROTOBUF_NAMESPACE_ID::int32 direction_;
  friend struct ::TableStruct_lane_2flane_2eproto;
};
// -------------------------------------------------------------------

class LaneBoundary PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RoadPB.LaneBoundary) */ {
 public:
  inline LaneBoundary() : LaneBoundary(nullptr) {};
  virtual ~LaneBoundary();

  LaneBoundary(const LaneBoundary& from);
  LaneBoundary(LaneBoundary&& from) noexcept
    : LaneBoundary() {
    *this = ::std::move(from);
  }

  inline LaneBoundary& operator=(const LaneBoundary& from) {
    CopyFrom(from);
    return *this;
  }
  inline LaneBoundary& operator=(LaneBoundary&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LaneBoundary& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LaneBoundary* internal_default_instance() {
    return reinterpret_cast<const LaneBoundary*>(
               &_LaneBoundary_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(LaneBoundary& a, LaneBoundary& b) {
    a.Swap(&b);
  }
  inline void Swap(LaneBoundary* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LaneBoundary* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LaneBoundary* New() const final {
    return CreateMaybeMessage<LaneBoundary>(nullptr);
  }

  LaneBoundary* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LaneBoundary>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LaneBoundary& from);
  void MergeFrom(const LaneBoundary& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LaneBoundary* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RoadPB.LaneBoundary";
  }
  protected:
  explicit LaneBoundary(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_lane_2flane_2eproto);
    return ::descriptor_table_lane_2flane_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef LaneBoundary_Color Color;
  static constexpr Color UNKNOWN_COLOR =
    LaneBoundary_Color_UNKNOWN_COLOR;
  static constexpr Color WHITE =
    LaneBoundary_Color_WHITE;
  static constexpr Color YELLOW =
    LaneBoundary_Color_YELLOW;
  static constexpr Color ORANGE =
    LaneBoundary_Color_ORANGE;
  static constexpr Color BLUE =
    LaneBoundary_Color_BLUE;
  static constexpr Color GREEN =
    LaneBoundary_Color_GREEN;
  static constexpr Color GRAY =
    LaneBoundary_Color_GRAY;
  static constexpr Color LEFT_GRAY_RIGHT_YELLOW =
    LaneBoundary_Color_LEFT_GRAY_RIGHT_YELLOW;
  static constexpr Color LEFT_YELLOW_RIGHT_WHITE =
    LaneBoundary_Color_LEFT_YELLOW_RIGHT_WHITE;
  static constexpr Color LEFT_WHITE_RIGHT_YELLOW =
    LaneBoundary_Color_LEFT_WHITE_RIGHT_YELLOW;
  static inline bool Color_IsValid(int value) {
    return LaneBoundary_Color_IsValid(value);
  }
  static constexpr Color Color_MIN =
    LaneBoundary_Color_Color_MIN;
  static constexpr Color Color_MAX =
    LaneBoundary_Color_Color_MAX;
  static constexpr int Color_ARRAYSIZE =
    LaneBoundary_Color_Color_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Color_descriptor() {
    return LaneBoundary_Color_descriptor();
  }
  template<typename T>
  static inline const std::string& Color_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Color>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Color_Name.");
    return LaneBoundary_Color_Name(enum_t_value);
  }
  static inline bool Color_Parse(const std::string& name,
      Color* value) {
    return LaneBoundary_Color_Parse(name, value);
  }

  typedef LaneBoundary_LaneLineType_Type LaneLineType_Type;
  static constexpr LaneLineType_Type LaneLineType_Type_UNKNOWN =
    LaneBoundary_LaneLineType_Type_LaneLineType_Type_UNKNOWN;
  static constexpr LaneLineType_Type LaneLineType_Type_LANELINE =
    LaneBoundary_LaneLineType_Type_LaneLineType_Type_LANELINE;
  static constexpr LaneLineType_Type LaneLineType_Type_CURB =
    LaneBoundary_LaneLineType_Type_LaneLineType_Type_CURB;
  static constexpr LaneLineType_Type LaneLineType_Type_CENTER =
    LaneBoundary_LaneLineType_Type_LaneLineType_Type_CENTER;
  static constexpr LaneLineType_Type LaneLineType_Type_GUARDRAIL =
    LaneBoundary_LaneLineType_Type_LaneLineType_Type_GUARDRAIL;
  static constexpr LaneLineType_Type LaneLineType_Type_CONCRETE_BARRIER =
    LaneBoundary_LaneLineType_Type_LaneLineType_Type_CONCRETE_BARRIER;
  static constexpr LaneLineType_Type LaneLineType_Type_FENCE =
    LaneBoundary_LaneLineType_Type_LaneLineType_Type_FENCE;
  static constexpr LaneLineType_Type LaneLineType_Type_WALL =
    LaneBoundary_LaneLineType_Type_LaneLineType_Type_WALL;
  static constexpr LaneLineType_Type LaneLineType_Type_CANOPY =
    LaneBoundary_LaneLineType_Type_LaneLineType_Type_CANOPY;
  static inline bool LaneLineType_Type_IsValid(int value) {
    return LaneBoundary_LaneLineType_Type_IsValid(value);
  }
  static constexpr LaneLineType_Type LaneLineType_Type_MIN =
    LaneBoundary_LaneLineType_Type_LaneLineType_Type_MIN;
  static constexpr LaneLineType_Type LaneLineType_Type_MAX =
    LaneBoundary_LaneLineType_Type_LaneLineType_Type_MAX;
  static constexpr int LaneLineType_Type_ARRAYSIZE =
    LaneBoundary_LaneLineType_Type_LaneLineType_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  LaneLineType_Type_descriptor() {
    return LaneBoundary_LaneLineType_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& LaneLineType_Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LaneLineType_Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LaneLineType_Type_Name.");
    return LaneBoundary_LaneLineType_Type_Name(enum_t_value);
  }
  static inline bool LaneLineType_Type_Parse(const std::string& name,
      LaneLineType_Type* value) {
    return LaneBoundary_LaneLineType_Type_Parse(name, value);
  }

  typedef LaneBoundary_LaneBoundaryType LaneBoundaryType;
  static constexpr LaneBoundaryType UNKNOWN_BOUNDARY =
    LaneBoundary_LaneBoundaryType_UNKNOWN_BOUNDARY;
  static constexpr LaneBoundaryType LANELINE =
    LaneBoundary_LaneBoundaryType_LANELINE;
  static constexpr LaneBoundaryType GUARDRAIL =
    LaneBoundary_LaneBoundaryType_GUARDRAIL;
  static constexpr LaneBoundaryType TRAFFIC_CONE =
    LaneBoundary_LaneBoundaryType_TRAFFIC_CONE;
  static constexpr LaneBoundaryType PUNCHEON =
    LaneBoundary_LaneBoundaryType_PUNCHEON;
  static inline bool LaneBoundaryType_IsValid(int value) {
    return LaneBoundary_LaneBoundaryType_IsValid(value);
  }
  static constexpr LaneBoundaryType LaneBoundaryType_MIN =
    LaneBoundary_LaneBoundaryType_LaneBoundaryType_MIN;
  static constexpr LaneBoundaryType LaneBoundaryType_MAX =
    LaneBoundary_LaneBoundaryType_LaneBoundaryType_MAX;
  static constexpr int LaneBoundaryType_ARRAYSIZE =
    LaneBoundary_LaneBoundaryType_LaneBoundaryType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  LaneBoundaryType_descriptor() {
    return LaneBoundary_LaneBoundaryType_descriptor();
  }
  template<typename T>
  static inline const std::string& LaneBoundaryType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LaneBoundaryType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LaneBoundaryType_Name.");
    return LaneBoundary_LaneBoundaryType_Name(enum_t_value);
  }
  static inline bool LaneBoundaryType_Parse(const std::string& name,
      LaneBoundaryType* value) {
    return LaneBoundary_LaneBoundaryType_Parse(name, value);
  }

  typedef LaneBoundary_LineMarking LineMarking;
  static constexpr LineMarking LineMarking_Unknown =
    LaneBoundary_LineMarking_LineMarking_Unknown;
  static constexpr LineMarking LineMarking_SolidLine =
    LaneBoundary_LineMarking_LineMarking_SolidLine;
  static constexpr LineMarking LineMarking_DashedLine =
    LaneBoundary_LineMarking_LineMarking_DashedLine;
  static constexpr LineMarking LineMarking_ShortDashedLine =
    LaneBoundary_LineMarking_LineMarking_ShortDashedLine;
  static constexpr LineMarking LineMarking_DoubleSolidLine =
    LaneBoundary_LineMarking_LineMarking_DoubleSolidLine;
  static constexpr LineMarking LineMarking_DoubleDashedLine =
    LaneBoundary_LineMarking_LineMarking_DoubleDashedLine;
  static constexpr LineMarking LineMarking_LeftSolidRightDashed =
    LaneBoundary_LineMarking_LineMarking_LeftSolidRightDashed;
  static constexpr LineMarking LineMarking_RightSolidLeftDashed =
    LaneBoundary_LineMarking_LineMarking_RightSolidLeftDashed;
  static constexpr LineMarking LineMarking_ShadedArea =
    LaneBoundary_LineMarking_LineMarking_ShadedArea;
  static constexpr LineMarking LineMarking_LaneVirtualMarking =
    LaneBoundary_LineMarking_LineMarking_LaneVirtualMarking;
  static constexpr LineMarking LineMarking_IntersectionVirualMarking =
    LaneBoundary_LineMarking_LineMarking_IntersectionVirualMarking;
  static constexpr LineMarking LineMarking_CurbVirtualMarking =
    LaneBoundary_LineMarking_LineMarking_CurbVirtualMarking;
  static constexpr LineMarking LineMarking_UnclosedRoad =
    LaneBoundary_LineMarking_LineMarking_UnclosedRoad;
  static constexpr LineMarking LineMarking_RoadVirtualLine =
    LaneBoundary_LineMarking_LineMarking_RoadVirtualLine;
  static constexpr LineMarking LineMarking_Other =
    LaneBoundary_LineMarking_LineMarking_Other;
  static inline bool LineMarking_IsValid(int value) {
    return LaneBoundary_LineMarking_IsValid(value);
  }
  static constexpr LineMarking LineMarking_MIN =
    LaneBoundary_LineMarking_LineMarking_MIN;
  static constexpr LineMarking LineMarking_MAX =
    LaneBoundary_LineMarking_LineMarking_MAX;
  static constexpr int LineMarking_ARRAYSIZE =
    LaneBoundary_LineMarking_LineMarking_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  LineMarking_descriptor() {
    return LaneBoundary_LineMarking_descriptor();
  }
  template<typename T>
  static inline const std::string& LineMarking_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LineMarking>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LineMarking_Name.");
    return LaneBoundary_LineMarking_Name(enum_t_value);
  }
  static inline bool LineMarking_Parse(const std::string& name,
      LineMarking* value) {
    return LaneBoundary_LineMarking_Parse(name, value);
  }

  typedef LaneBoundary_MarkingType MarkingType;
  static constexpr MarkingType UNKNOWN =
    LaneBoundary_MarkingType_UNKNOWN;
  static constexpr MarkingType SOLID =
    LaneBoundary_MarkingType_SOLID;
  static constexpr MarkingType DASHED =
    LaneBoundary_MarkingType_DASHED;
  static constexpr MarkingType SHORT_DASHED =
    LaneBoundary_MarkingType_SHORT_DASHED;
  static constexpr MarkingType DOUBLE_SOLID =
    LaneBoundary_MarkingType_DOUBLE_SOLID;
  static constexpr MarkingType DOUBLE_DASHED =
    LaneBoundary_MarkingType_DOUBLE_DASHED;
  static constexpr MarkingType LEFT_SOLID_RIGHT_DASHED =
    LaneBoundary_MarkingType_LEFT_SOLID_RIGHT_DASHED;
  static constexpr MarkingType LEFT_DASHED_RIGHT_SOLID =
    LaneBoundary_MarkingType_LEFT_DASHED_RIGHT_SOLID;
  static constexpr MarkingType SHADED_AREA =
    LaneBoundary_MarkingType_SHADED_AREA;
  static constexpr MarkingType VIRTUAL_LANE =
    LaneBoundary_MarkingType_VIRTUAL_LANE;
  static constexpr MarkingType VIRTUAL_JUNCTION =
    LaneBoundary_MarkingType_VIRTUAL_JUNCTION;
  static inline bool MarkingType_IsValid(int value) {
    return LaneBoundary_MarkingType_IsValid(value);
  }
  static constexpr MarkingType MarkingType_MIN =
    LaneBoundary_MarkingType_MarkingType_MIN;
  static constexpr MarkingType MarkingType_MAX =
    LaneBoundary_MarkingType_MarkingType_MAX;
  static constexpr int MarkingType_ARRAYSIZE =
    LaneBoundary_MarkingType_MarkingType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  MarkingType_descriptor() {
    return LaneBoundary_MarkingType_descriptor();
  }
  template<typename T>
  static inline const std::string& MarkingType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MarkingType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MarkingType_Name.");
    return LaneBoundary_MarkingType_Name(enum_t_value);
  }
  static inline bool MarkingType_Parse(const std::string& name,
      MarkingType* value) {
    return LaneBoundary_MarkingType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTypesFieldNumber = 4,
    kIdFieldNumber = 1,
    kGeomFieldNumber = 2,
    kColorFieldNumber = 3,
    kMarkingFieldNumber = 5,
    kLdmFieldNumber = 7,
  };
  // repeated int32 types = 4;
  int types_size() const;
  private:
  int _internal_types_size() const;
  public:
  void clear_types();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_types(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_types() const;
  void _internal_add_types(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_types();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 types(int index) const;
  void set_types(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_types(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_types();

  // optional .RoadPB.FeatureID id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::RoadPB::FeatureID& id() const;
  ::RoadPB::FeatureID* release_id();
  ::RoadPB::FeatureID* mutable_id();
  void set_allocated_id(::RoadPB::FeatureID* id);
  private:
  const ::RoadPB::FeatureID& _internal_id() const;
  ::RoadPB::FeatureID* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::RoadPB::FeatureID* id);
  ::RoadPB::FeatureID* unsafe_arena_release_id();

  // optional .RoadPB.Polyline geom = 2;
  bool has_geom() const;
  private:
  bool _internal_has_geom() const;
  public:
  void clear_geom();
  const ::RoadPB::Polyline& geom() const;
  ::RoadPB::Polyline* release_geom();
  ::RoadPB::Polyline* mutable_geom();
  void set_allocated_geom(::RoadPB::Polyline* geom);
  private:
  const ::RoadPB::Polyline& _internal_geom() const;
  ::RoadPB::Polyline* _internal_mutable_geom();
  public:
  void unsafe_arena_set_allocated_geom(
      ::RoadPB::Polyline* geom);
  ::RoadPB::Polyline* unsafe_arena_release_geom();

  // optional int32 color = 3;
  bool has_color() const;
  private:
  bool _internal_has_color() const;
  public:
  void clear_color();
  ::PROTOBUF_NAMESPACE_ID::int32 color() const;
  void set_color(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_color() const;
  void _internal_set_color(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 marking = 5;
  bool has_marking() const;
  private:
  bool _internal_has_marking() const;
  public:
  void clear_marking();
  ::PROTOBUF_NAMESPACE_ID::int32 marking() const;
  void set_marking(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_marking() const;
  void _internal_set_marking(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional bool ldm = 7;
  bool has_ldm() const;
  private:
  bool _internal_has_ldm() const;
  public:
  void clear_ldm();
  bool ldm() const;
  void set_ldm(bool value);
  private:
  bool _internal_ldm() const;
  void _internal_set_ldm(bool value);
  public:

  // @@protoc_insertion_point(class_scope:RoadPB.LaneBoundary)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > types_;
  ::RoadPB::FeatureID* id_;
  ::RoadPB::Polyline* geom_;
  ::PROTOBUF_NAMESPACE_ID::int32 color_;
  ::PROTOBUF_NAMESPACE_ID::int32 marking_;
  bool ldm_;
  friend struct ::TableStruct_lane_2flane_2eproto;
};
// -------------------------------------------------------------------

class LaneBoundaryRange PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RoadPB.LaneBoundaryRange) */ {
 public:
  inline LaneBoundaryRange() : LaneBoundaryRange(nullptr) {};
  virtual ~LaneBoundaryRange();

  LaneBoundaryRange(const LaneBoundaryRange& from);
  LaneBoundaryRange(LaneBoundaryRange&& from) noexcept
    : LaneBoundaryRange() {
    *this = ::std::move(from);
  }

  inline LaneBoundaryRange& operator=(const LaneBoundaryRange& from) {
    CopyFrom(from);
    return *this;
  }
  inline LaneBoundaryRange& operator=(LaneBoundaryRange&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LaneBoundaryRange& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LaneBoundaryRange* internal_default_instance() {
    return reinterpret_cast<const LaneBoundaryRange*>(
               &_LaneBoundaryRange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(LaneBoundaryRange& a, LaneBoundaryRange& b) {
    a.Swap(&b);
  }
  inline void Swap(LaneBoundaryRange* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LaneBoundaryRange* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LaneBoundaryRange* New() const final {
    return CreateMaybeMessage<LaneBoundaryRange>(nullptr);
  }

  LaneBoundaryRange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LaneBoundaryRange>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LaneBoundaryRange& from);
  void MergeFrom(const LaneBoundaryRange& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LaneBoundaryRange* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RoadPB.LaneBoundaryRange";
  }
  protected:
  explicit LaneBoundaryRange(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_lane_2flane_2eproto);
    return ::descriptor_table_lane_2flane_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBoundIdFieldNumber = 1,
    kStartPtFieldNumber = 2,
    kEndPtFieldNumber = 3,
  };
  // optional .RoadPB.FeatureID bound_id = 1;
  bool has_bound_id() const;
  private:
  bool _internal_has_bound_id() const;
  public:
  void clear_bound_id();
  const ::RoadPB::FeatureID& bound_id() const;
  ::RoadPB::FeatureID* release_bound_id();
  ::RoadPB::FeatureID* mutable_bound_id();
  void set_allocated_bound_id(::RoadPB::FeatureID* bound_id);
  private:
  const ::RoadPB::FeatureID& _internal_bound_id() const;
  ::RoadPB::FeatureID* _internal_mutable_bound_id();
  public:
  void unsafe_arena_set_allocated_bound_id(
      ::RoadPB::FeatureID* bound_id);
  ::RoadPB::FeatureID* unsafe_arena_release_bound_id();

  // optional .RoadPB.Point start_pt = 2;
  bool has_start_pt() const;
  private:
  bool _internal_has_start_pt() const;
  public:
  void clear_start_pt();
  const ::RoadPB::Point& start_pt() const;
  ::RoadPB::Point* release_start_pt();
  ::RoadPB::Point* mutable_start_pt();
  void set_allocated_start_pt(::RoadPB::Point* start_pt);
  private:
  const ::RoadPB::Point& _internal_start_pt() const;
  ::RoadPB::Point* _internal_mutable_start_pt();
  public:
  void unsafe_arena_set_allocated_start_pt(
      ::RoadPB::Point* start_pt);
  ::RoadPB::Point* unsafe_arena_release_start_pt();

  // optional .RoadPB.Point end_pt = 3;
  bool has_end_pt() const;
  private:
  bool _internal_has_end_pt() const;
  public:
  void clear_end_pt();
  const ::RoadPB::Point& end_pt() const;
  ::RoadPB::Point* release_end_pt();
  ::RoadPB::Point* mutable_end_pt();
  void set_allocated_end_pt(::RoadPB::Point* end_pt);
  private:
  const ::RoadPB::Point& _internal_end_pt() const;
  ::RoadPB::Point* _internal_mutable_end_pt();
  public:
  void unsafe_arena_set_allocated_end_pt(
      ::RoadPB::Point* end_pt);
  ::RoadPB::Point* unsafe_arena_release_end_pt();

  // @@protoc_insertion_point(class_scope:RoadPB.LaneBoundaryRange)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::RoadPB::FeatureID* bound_id_;
  ::RoadPB::Point* start_pt_;
  ::RoadPB::Point* end_pt_;
  friend struct ::TableStruct_lane_2flane_2eproto;
};
// -------------------------------------------------------------------

class RoadBoundary PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RoadPB.RoadBoundary) */ {
 public:
  inline RoadBoundary() : RoadBoundary(nullptr) {};
  virtual ~RoadBoundary();

  RoadBoundary(const RoadBoundary& from);
  RoadBoundary(RoadBoundary&& from) noexcept
    : RoadBoundary() {
    *this = ::std::move(from);
  }

  inline RoadBoundary& operator=(const RoadBoundary& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoadBoundary& operator=(RoadBoundary&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RoadBoundary& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoadBoundary* internal_default_instance() {
    return reinterpret_cast<const RoadBoundary*>(
               &_RoadBoundary_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RoadBoundary& a, RoadBoundary& b) {
    a.Swap(&b);
  }
  inline void Swap(RoadBoundary* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoadBoundary* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RoadBoundary* New() const final {
    return CreateMaybeMessage<RoadBoundary>(nullptr);
  }

  RoadBoundary* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RoadBoundary>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RoadBoundary& from);
  void MergeFrom(const RoadBoundary& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoadBoundary* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RoadPB.RoadBoundary";
  }
  protected:
  explicit RoadBoundary(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_lane_2flane_2eproto);
    return ::descriptor_table_lane_2flane_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef RoadBoundary_RoadBoundaryType RoadBoundaryType;
  static constexpr RoadBoundaryType UNKNOWN_BOUNDARY =
    RoadBoundary_RoadBoundaryType_UNKNOWN_BOUNDARY;
  static constexpr RoadBoundaryType CURB =
    RoadBoundary_RoadBoundaryType_CURB;
  static constexpr RoadBoundaryType GUARDRAIL =
    RoadBoundary_RoadBoundaryType_GUARDRAIL;
  static constexpr RoadBoundaryType CONCRETE_BARRIER =
    RoadBoundary_RoadBoundaryType_CONCRETE_BARRIER;
  static constexpr RoadBoundaryType FENCE =
    RoadBoundary_RoadBoundaryType_FENCE;
  static constexpr RoadBoundaryType WALL =
    RoadBoundary_RoadBoundaryType_WALL;
  static constexpr RoadBoundaryType CANOPY =
    RoadBoundary_RoadBoundaryType_CANOPY;
  static constexpr RoadBoundaryType PAVE =
    RoadBoundary_RoadBoundaryType_PAVE;
  static constexpr RoadBoundaryType DITCH =
    RoadBoundary_RoadBoundaryType_DITCH;
  static constexpr RoadBoundaryType PUNCHEON =
    RoadBoundary_RoadBoundaryType_PUNCHEON;
  static inline bool RoadBoundaryType_IsValid(int value) {
    return RoadBoundary_RoadBoundaryType_IsValid(value);
  }
  static constexpr RoadBoundaryType RoadBoundaryType_MIN =
    RoadBoundary_RoadBoundaryType_RoadBoundaryType_MIN;
  static constexpr RoadBoundaryType RoadBoundaryType_MAX =
    RoadBoundary_RoadBoundaryType_RoadBoundaryType_MAX;
  static constexpr int RoadBoundaryType_ARRAYSIZE =
    RoadBoundary_RoadBoundaryType_RoadBoundaryType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  RoadBoundaryType_descriptor() {
    return RoadBoundary_RoadBoundaryType_descriptor();
  }
  template<typename T>
  static inline const std::string& RoadBoundaryType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RoadBoundaryType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RoadBoundaryType_Name.");
    return RoadBoundary_RoadBoundaryType_Name(enum_t_value);
  }
  static inline bool RoadBoundaryType_Parse(const std::string& name,
      RoadBoundaryType* value) {
    return RoadBoundary_RoadBoundaryType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kGeomFieldNumber = 10,
    kTypeFieldNumber = 2,
  };
  // optional .RoadPB.FeatureID id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::RoadPB::FeatureID& id() const;
  ::RoadPB::FeatureID* release_id();
  ::RoadPB::FeatureID* mutable_id();
  void set_allocated_id(::RoadPB::FeatureID* id);
  private:
  const ::RoadPB::FeatureID& _internal_id() const;
  ::RoadPB::FeatureID* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::RoadPB::FeatureID* id);
  ::RoadPB::FeatureID* unsafe_arena_release_id();

  // optional .RoadPB.Polyline geom = 10;
  bool has_geom() const;
  private:
  bool _internal_has_geom() const;
  public:
  void clear_geom();
  const ::RoadPB::Polyline& geom() const;
  ::RoadPB::Polyline* release_geom();
  ::RoadPB::Polyline* mutable_geom();
  void set_allocated_geom(::RoadPB::Polyline* geom);
  private:
  const ::RoadPB::Polyline& _internal_geom() const;
  ::RoadPB::Polyline* _internal_mutable_geom();
  public:
  void unsafe_arena_set_allocated_geom(
      ::RoadPB::Polyline* geom);
  ::RoadPB::Polyline* unsafe_arena_release_geom();

  // optional int32 type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::PROTOBUF_NAMESPACE_ID::int32 type() const;
  void set_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_type() const;
  void _internal_set_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:RoadPB.RoadBoundary)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::RoadPB::FeatureID* id_;
  ::RoadPB::Polyline* geom_;
  ::PROTOBUF_NAMESPACE_ID::int32 type_;
  friend struct ::TableStruct_lane_2flane_2eproto;
};
// -------------------------------------------------------------------

class LaneSection PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RoadPB.LaneSection) */ {
 public:
  inline LaneSection() : LaneSection(nullptr) {};
  virtual ~LaneSection();

  LaneSection(const LaneSection& from);
  LaneSection(LaneSection&& from) noexcept
    : LaneSection() {
    *this = ::std::move(from);
  }

  inline LaneSection& operator=(const LaneSection& from) {
    CopyFrom(from);
    return *this;
  }
  inline LaneSection& operator=(LaneSection&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LaneSection& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LaneSection* internal_default_instance() {
    return reinterpret_cast<const LaneSection*>(
               &_LaneSection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(LaneSection& a, LaneSection& b) {
    a.Swap(&b);
  }
  inline void Swap(LaneSection* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LaneSection* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LaneSection* New() const final {
    return CreateMaybeMessage<LaneSection>(nullptr);
  }

  LaneSection* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LaneSection>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LaneSection& from);
  void MergeFrom(const LaneSection& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LaneSection* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RoadPB.LaneSection";
  }
  protected:
  explicit LaneSection(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_lane_2flane_2eproto);
    return ::descriptor_table_lane_2flane_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpeedLimitsFieldNumber = 3,
    kObjectsFieldNumber = 5,
    kTrafficsFieldNumber = 6,
    kLeftBoundaryFieldNumber = 1,
    kRightBoundaryFieldNumber = 2,
    kWidthFieldNumber = 7,
    kHeightLimitFieldNumber = 8,
    kWeightLimitFieldNumber = 9,
    kWidthLimitFieldNumber = 10,
  };
  // repeated .RoadPB.FixedSpeedLimit speed_limits = 3;
  int speed_limits_size() const;
  private:
  int _internal_speed_limits_size() const;
  public:
  void clear_speed_limits();
  ::RoadPB::FixedSpeedLimit* mutable_speed_limits(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FixedSpeedLimit >*
      mutable_speed_limits();
  private:
  const ::RoadPB::FixedSpeedLimit& _internal_speed_limits(int index) const;
  ::RoadPB::FixedSpeedLimit* _internal_add_speed_limits();
  public:
  const ::RoadPB::FixedSpeedLimit& speed_limits(int index) const;
  ::RoadPB::FixedSpeedLimit* add_speed_limits();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FixedSpeedLimit >&
      speed_limits() const;

  // repeated .RoadPB.FeatureID objects = 5;
  int objects_size() const;
  private:
  int _internal_objects_size() const;
  public:
  void clear_objects();
  ::RoadPB::FeatureID* mutable_objects(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID >*
      mutable_objects();
  private:
  const ::RoadPB::FeatureID& _internal_objects(int index) const;
  ::RoadPB::FeatureID* _internal_add_objects();
  public:
  const ::RoadPB::FeatureID& objects(int index) const;
  ::RoadPB::FeatureID* add_objects();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID >&
      objects() const;

  // repeated .RoadPB.FeatureID traffics = 6;
  int traffics_size() const;
  private:
  int _internal_traffics_size() const;
  public:
  void clear_traffics();
  ::RoadPB::FeatureID* mutable_traffics(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID >*
      mutable_traffics();
  private:
  const ::RoadPB::FeatureID& _internal_traffics(int index) const;
  ::RoadPB::FeatureID* _internal_add_traffics();
  public:
  const ::RoadPB::FeatureID& traffics(int index) const;
  ::RoadPB::FeatureID* add_traffics();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID >&
      traffics() const;

  // optional .RoadPB.LaneBoundaryRange left_boundary = 1;
  bool has_left_boundary() const;
  private:
  bool _internal_has_left_boundary() const;
  public:
  void clear_left_boundary();
  const ::RoadPB::LaneBoundaryRange& left_boundary() const;
  ::RoadPB::LaneBoundaryRange* release_left_boundary();
  ::RoadPB::LaneBoundaryRange* mutable_left_boundary();
  void set_allocated_left_boundary(::RoadPB::LaneBoundaryRange* left_boundary);
  private:
  const ::RoadPB::LaneBoundaryRange& _internal_left_boundary() const;
  ::RoadPB::LaneBoundaryRange* _internal_mutable_left_boundary();
  public:
  void unsafe_arena_set_allocated_left_boundary(
      ::RoadPB::LaneBoundaryRange* left_boundary);
  ::RoadPB::LaneBoundaryRange* unsafe_arena_release_left_boundary();

  // optional .RoadPB.LaneBoundaryRange right_boundary = 2;
  bool has_right_boundary() const;
  private:
  bool _internal_has_right_boundary() const;
  public:
  void clear_right_boundary();
  const ::RoadPB::LaneBoundaryRange& right_boundary() const;
  ::RoadPB::LaneBoundaryRange* release_right_boundary();
  ::RoadPB::LaneBoundaryRange* mutable_right_boundary();
  void set_allocated_right_boundary(::RoadPB::LaneBoundaryRange* right_boundary);
  private:
  const ::RoadPB::LaneBoundaryRange& _internal_right_boundary() const;
  ::RoadPB::LaneBoundaryRange* _internal_mutable_right_boundary();
  public:
  void unsafe_arena_set_allocated_right_boundary(
      ::RoadPB::LaneBoundaryRange* right_boundary);
  ::RoadPB::LaneBoundaryRange* unsafe_arena_release_right_boundary();

  // optional float width = 7;
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  float width() const;
  void set_width(float value);
  private:
  float _internal_width() const;
  void _internal_set_width(float value);
  public:

  // optional float height_limit = 8;
  bool has_height_limit() const;
  private:
  bool _internal_has_height_limit() const;
  public:
  void clear_height_limit();
  float height_limit() const;
  void set_height_limit(float value);
  private:
  float _internal_height_limit() const;
  void _internal_set_height_limit(float value);
  public:

  // optional float weight_limit = 9;
  bool has_weight_limit() const;
  private:
  bool _internal_has_weight_limit() const;
  public:
  void clear_weight_limit();
  float weight_limit() const;
  void set_weight_limit(float value);
  private:
  float _internal_weight_limit() const;
  void _internal_set_weight_limit(float value);
  public:

  // optional float width_limit = 10;
  bool has_width_limit() const;
  private:
  bool _internal_has_width_limit() const;
  public:
  void clear_width_limit();
  float width_limit() const;
  void set_width_limit(float value);
  private:
  float _internal_width_limit() const;
  void _internal_set_width_limit(float value);
  public:

  // @@protoc_insertion_point(class_scope:RoadPB.LaneSection)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FixedSpeedLimit > speed_limits_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID > objects_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID > traffics_;
  ::RoadPB::LaneBoundaryRange* left_boundary_;
  ::RoadPB::LaneBoundaryRange* right_boundary_;
  float width_;
  float height_limit_;
  float weight_limit_;
  float width_limit_;
  friend struct ::TableStruct_lane_2flane_2eproto;
};
// -------------------------------------------------------------------

class Lane PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RoadPB.Lane) */ {
 public:
  inline Lane() : Lane(nullptr) {};
  virtual ~Lane();

  Lane(const Lane& from);
  Lane(Lane&& from) noexcept
    : Lane() {
    *this = ::std::move(from);
  }

  inline Lane& operator=(const Lane& from) {
    CopyFrom(from);
    return *this;
  }
  inline Lane& operator=(Lane&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Lane& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Lane* internal_default_instance() {
    return reinterpret_cast<const Lane*>(
               &_Lane_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Lane& a, Lane& b) {
    a.Swap(&b);
  }
  inline void Swap(Lane* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Lane* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Lane* New() const final {
    return CreateMaybeMessage<Lane>(nullptr);
  }

  Lane* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Lane>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Lane& from);
  void MergeFrom(const Lane& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Lane* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RoadPB.Lane";
  }
  protected:
  explicit Lane(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_lane_2flane_2eproto);
    return ::descriptor_table_lane_2flane_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Lane_Function Function;
  static constexpr Function Function_NONE =
    Lane_Function_Function_NONE;
  static constexpr Function Function_CITY_DRIVING =
    Lane_Function_Function_CITY_DRIVING;
  static constexpr Function Function_HIGH_DRIVING =
    Lane_Function_Function_HIGH_DRIVING;
  static constexpr Function Function_BIKING =
    Lane_Function_Function_BIKING;
  static constexpr Function Function_SIDEWALK =
    Lane_Function_Function_SIDEWALK;
  static constexpr Function Function_PARKING =
    Lane_Function_Function_PARKING;
  static constexpr Function Function_RAMP =
    Lane_Function_Function_RAMP;
  static constexpr Function Function_EMERGENCY =
    Lane_Function_Function_EMERGENCY;
  static constexpr Function Function_ACCELERATION =
    Lane_Function_Function_ACCELERATION;
  static inline bool Function_IsValid(int value) {
    return Lane_Function_IsValid(value);
  }
  static constexpr Function Function_MIN =
    Lane_Function_Function_MIN;
  static constexpr Function Function_MAX =
    Lane_Function_Function_MAX;
  static constexpr int Function_ARRAYSIZE =
    Lane_Function_Function_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Function_descriptor() {
    return Lane_Function_descriptor();
  }
  template<typename T>
  static inline const std::string& Function_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Function>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Function_Name.");
    return Lane_Function_Name(enum_t_value);
  }
  static inline bool Function_Parse(const std::string& name,
      Function* value) {
    return Lane_Function_Parse(name, value);
  }

  typedef Lane_LaneType LaneType;
  static constexpr LaneType UNKNOWN_LANETYPE =
    Lane_LaneType_UNKNOWN_LANETYPE;
  static constexpr LaneType STANDARD_LANE =
    Lane_LaneType_STANDARD_LANE;
  static constexpr LaneType ACCELERATION_LANE =
    Lane_LaneType_ACCELERATION_LANE;
  static constexpr LaneType DECELERATION_LANE =
    Lane_LaneType_DECELERATION_LANE;
  static constexpr LaneType SPEED_CHANGE_LANE =
    Lane_LaneType_SPEED_CHANGE_LANE;
  static constexpr LaneType TOLL_LANE =
    Lane_LaneType_TOLL_LANE;
  static constexpr LaneType EMERGENCY_LANE =
    Lane_LaneType_EMERGENCY_LANE;
  static constexpr LaneType BUS_LANE =
    Lane_LaneType_BUS_LANE;
  static constexpr LaneType CYCLE_PATH =
    Lane_LaneType_CYCLE_PATH;
  static constexpr LaneType U_TURN_LANE =
    Lane_LaneType_U_TURN_LANE;
  static inline bool LaneType_IsValid(int value) {
    return Lane_LaneType_IsValid(value);
  }
  static constexpr LaneType LaneType_MIN =
    Lane_LaneType_LaneType_MIN;
  static constexpr LaneType LaneType_MAX =
    Lane_LaneType_LaneType_MAX;
  static constexpr int LaneType_ARRAYSIZE =
    Lane_LaneType_LaneType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  LaneType_descriptor() {
    return Lane_LaneType_descriptor();
  }
  template<typename T>
  static inline const std::string& LaneType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LaneType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LaneType_Name.");
    return Lane_LaneType_Name(enum_t_value);
  }
  static inline bool LaneType_Parse(const std::string& name,
      LaneType* value) {
    return Lane_LaneType_Parse(name, value);
  }

  typedef Lane_LanePriority LanePriority;
  static constexpr LanePriority LANE_PRIORITY_UNKNOWN =
    Lane_LanePriority_LANE_PRIORITY_UNKNOWN;
  static constexpr LanePriority LANE_PRIORITY_HIGHER =
    Lane_LanePriority_LANE_PRIORITY_HIGHER;
  static constexpr LanePriority LANE_PRIORITY_EQUAL =
    Lane_LanePriority_LANE_PRIORITY_EQUAL;
  static constexpr LanePriority LANE_PRIORITY_LOWER =
    Lane_LanePriority_LANE_PRIORITY_LOWER;
  static constexpr LanePriority LANE_PRIORITY_CONTROLLED_BY_SIGNAL =
    Lane_LanePriority_LANE_PRIORITY_CONTROLLED_BY_SIGNAL;
  static constexpr LanePriority LANE_PRIORITY_CONTROLLED_BY_STOPLINE =
    Lane_LanePriority_LANE_PRIORITY_CONTROLLED_BY_STOPLINE;
  static inline bool LanePriority_IsValid(int value) {
    return Lane_LanePriority_IsValid(value);
  }
  static constexpr LanePriority LanePriority_MIN =
    Lane_LanePriority_LanePriority_MIN;
  static constexpr LanePriority LanePriority_MAX =
    Lane_LanePriority_LanePriority_MAX;
  static constexpr int LanePriority_ARRAYSIZE =
    Lane_LanePriority_LanePriority_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  LanePriority_descriptor() {
    return Lane_LanePriority_descriptor();
  }
  template<typename T>
  static inline const std::string& LanePriority_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LanePriority>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LanePriority_Name.");
    return Lane_LanePriority_Name(enum_t_value);
  }
  static inline bool LanePriority_Parse(const std::string& name,
      LanePriority* value) {
    return Lane_LanePriority_Parse(name, value);
  }

  typedef Lane_LaneLineRestrictionType LaneLineRestrictionType;
  static constexpr LaneLineRestrictionType UNKNOWN_LINE_RESTRICTION_TYPE =
    Lane_LaneLineRestrictionType_UNKNOWN_LINE_RESTRICTION_TYPE;
  static constexpr LaneLineRestrictionType BUS_LANE_LEFT_EDGE =
    Lane_LaneLineRestrictionType_BUS_LANE_LEFT_EDGE;
  static constexpr LaneLineRestrictionType BUS_LANE_RIGHT_EDGE =
    Lane_LaneLineRestrictionType_BUS_LANE_RIGHT_EDGE;
  static constexpr LaneLineRestrictionType BIKE_LANE_LEFT_EDGE =
    Lane_LaneLineRestrictionType_BIKE_LANE_LEFT_EDGE;
  static constexpr LaneLineRestrictionType BIKE_LANE_RIGHT_EDGE =
    Lane_LaneLineRestrictionType_BIKE_LANE_RIGHT_EDGE;
  static constexpr LaneLineRestrictionType OPPOSITE_NO_PASS =
    Lane_LaneLineRestrictionType_OPPOSITE_NO_PASS;
  static constexpr LaneLineRestrictionType OPPOSITE_CAN_PASS =
    Lane_LaneLineRestrictionType_OPPOSITE_CAN_PASS;
  static constexpr LaneLineRestrictionType PEDESTRAIN_LANE_LEFT_EDGE =
    Lane_LaneLineRestrictionType_PEDESTRAIN_LANE_LEFT_EDGE;
  static constexpr LaneLineRestrictionType PEDESTRAIN_LANE_RIGHT_EDGE =
    Lane_LaneLineRestrictionType_PEDESTRAIN_LANE_RIGHT_EDGE;
  static constexpr LaneLineRestrictionType WHITE_STRIP_ZONE_ON_LEFT =
    Lane_LaneLineRestrictionType_WHITE_STRIP_ZONE_ON_LEFT;
  static constexpr LaneLineRestrictionType WHITE_STRIP_ZONE_ON_RIGHT =
    Lane_LaneLineRestrictionType_WHITE_STRIP_ZONE_ON_RIGHT;
  static constexpr LaneLineRestrictionType YELLOW_STRIP_ZONE_ON_LEFT =
    Lane_LaneLineRestrictionType_YELLOW_STRIP_ZONE_ON_LEFT;
  static constexpr LaneLineRestrictionType YELLOW_STRIP_ZONE_ON_RIGHT =
    Lane_LaneLineRestrictionType_YELLOW_STRIP_ZONE_ON_RIGHT;
  static constexpr LaneLineRestrictionType CABLE_CAR_ON_LEFT =
    Lane_LaneLineRestrictionType_CABLE_CAR_ON_LEFT;
  static constexpr LaneLineRestrictionType CABLE_CAR_ON_RIGHT =
    Lane_LaneLineRestrictionType_CABLE_CAR_ON_RIGHT;
  static constexpr LaneLineRestrictionType NO_CAR_ON_LEFT =
    Lane_LaneLineRestrictionType_NO_CAR_ON_LEFT;
  static constexpr LaneLineRestrictionType NO_CAR_ON_RIGHT =
    Lane_LaneLineRestrictionType_NO_CAR_ON_RIGHT;
  static constexpr LaneLineRestrictionType EXIT_LANE_LEFT_EDGE =
    Lane_LaneLineRestrictionType_EXIT_LANE_LEFT_EDGE;
  static constexpr LaneLineRestrictionType EXIT_LANE_RIGHT_EDGE =
    Lane_LaneLineRestrictionType_EXIT_LANE_RIGHT_EDGE;
  static constexpr LaneLineRestrictionType ENTRY_LANE_LEFT_EDGE =
    Lane_LaneLineRestrictionType_ENTRY_LANE_LEFT_EDGE;
  static constexpr LaneLineRestrictionType ENTRY_LANE_RIGHT_EDGE =
    Lane_LaneLineRestrictionType_ENTRY_LANE_RIGHT_EDGE;
  static constexpr LaneLineRestrictionType HOV_LANE_LEFT_EDGE =
    Lane_LaneLineRestrictionType_HOV_LANE_LEFT_EDGE;
  static constexpr LaneLineRestrictionType HOV_LANE_RIGHT_EDGE =
    Lane_LaneLineRestrictionType_HOV_LANE_RIGHT_EDGE;
  static constexpr LaneLineRestrictionType SIDEWALK_LEFT_EDGE =
    Lane_LaneLineRestrictionType_SIDEWALK_LEFT_EDGE;
  static constexpr LaneLineRestrictionType SIDEWALK_RIGHT_EDGE =
    Lane_LaneLineRestrictionType_SIDEWALK_RIGHT_EDGE;
  static constexpr LaneLineRestrictionType PARKING_LANE_LEFT_EDGE =
    Lane_LaneLineRestrictionType_PARKING_LANE_LEFT_EDGE;
  static constexpr LaneLineRestrictionType PARKING_LANE_RIGHT_EDGE =
    Lane_LaneLineRestrictionType_PARKING_LANE_RIGHT_EDGE;
  static constexpr LaneLineRestrictionType SHOULDER_LANE_LEFT_EDGE =
    Lane_LaneLineRestrictionType_SHOULDER_LANE_LEFT_EDGE;
  static constexpr LaneLineRestrictionType SHOULDER_LANE_RIGHT_EDGE =
    Lane_LaneLineRestrictionType_SHOULDER_LANE_RIGHT_EDGE;
  static inline bool LaneLineRestrictionType_IsValid(int value) {
    return Lane_LaneLineRestrictionType_IsValid(value);
  }
  static constexpr LaneLineRestrictionType LaneLineRestrictionType_MIN =
    Lane_LaneLineRestrictionType_LaneLineRestrictionType_MIN;
  static constexpr LaneLineRestrictionType LaneLineRestrictionType_MAX =
    Lane_LaneLineRestrictionType_LaneLineRestrictionType_MAX;
  static constexpr int LaneLineRestrictionType_ARRAYSIZE =
    Lane_LaneLineRestrictionType_LaneLineRestrictionType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  LaneLineRestrictionType_descriptor() {
    return Lane_LaneLineRestrictionType_descriptor();
  }
  template<typename T>
  static inline const std::string& LaneLineRestrictionType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LaneLineRestrictionType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LaneLineRestrictionType_Name.");
    return Lane_LaneLineRestrictionType_Name(enum_t_value);
  }
  static inline bool LaneLineRestrictionType_Parse(const std::string& name,
      LaneLineRestrictionType* value) {
    return Lane_LaneLineRestrictionType_Parse(name, value);
  }

  typedef Lane_LaneTransition LaneTransition;
  static constexpr LaneTransition LaneTransition_Unknown =
    Lane_LaneTransition_LaneTransition_Unknown;
  static constexpr LaneTransition LaneTransition_Continue =
    Lane_LaneTransition_LaneTransition_Continue;
  static constexpr LaneTransition LaneTransition_Merging =
    Lane_LaneTransition_LaneTransition_Merging;
  static constexpr LaneTransition LaneTransition_Splitting =
    Lane_LaneTransition_LaneTransition_Splitting;
  static constexpr LaneTransition LaneTransition_Other =
    Lane_LaneTransition_LaneTransition_Other;
  static inline bool LaneTransition_IsValid(int value) {
    return Lane_LaneTransition_IsValid(value);
  }
  static constexpr LaneTransition LaneTransition_MIN =
    Lane_LaneTransition_LaneTransition_MIN;
  static constexpr LaneTransition LaneTransition_MAX =
    Lane_LaneTransition_LaneTransition_MAX;
  static constexpr int LaneTransition_ARRAYSIZE =
    Lane_LaneTransition_LaneTransition_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  LaneTransition_descriptor() {
    return Lane_LaneTransition_descriptor();
  }
  template<typename T>
  static inline const std::string& LaneTransition_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LaneTransition>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LaneTransition_Name.");
    return Lane_LaneTransition_Name(enum_t_value);
  }
  static inline bool LaneTransition_Parse(const std::string& name,
      LaneTransition* value) {
    return Lane_LaneTransition_Parse(name, value);
  }

  typedef Lane_TurnLimit TurnLimit;
  static constexpr TurnLimit NONE =
    Lane_TurnLimit_NONE;
  static constexpr TurnLimit STRAIGHT =
    Lane_TurnLimit_STRAIGHT;
  static constexpr TurnLimit SLIGHT_RIGHT =
    Lane_TurnLimit_SLIGHT_RIGHT;
  static constexpr TurnLimit RIGHT =
    Lane_TurnLimit_RIGHT;
  static constexpr TurnLimit HARD_RIGHT =
    Lane_TurnLimit_HARD_RIGHT;
  static constexpr TurnLimit UTURN =
    Lane_TurnLimit_UTURN;
  static constexpr TurnLimit HARD_LEFT =
    Lane_TurnLimit_HARD_LEFT;
  static constexpr TurnLimit LEFT =
    Lane_TurnLimit_LEFT;
  static constexpr TurnLimit SLIGHT_LEFT =
    Lane_TurnLimit_SLIGHT_LEFT;
  static constexpr TurnLimit NA =
    Lane_TurnLimit_NA;
  static inline bool TurnLimit_IsValid(int value) {
    return Lane_TurnLimit_IsValid(value);
  }
  static constexpr TurnLimit TurnLimit_MIN =
    Lane_TurnLimit_TurnLimit_MIN;
  static constexpr TurnLimit TurnLimit_MAX =
    Lane_TurnLimit_TurnLimit_MAX;
  static constexpr int TurnLimit_ARRAYSIZE =
    Lane_TurnLimit_TurnLimit_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  TurnLimit_descriptor() {
    return Lane_TurnLimit_descriptor();
  }
  template<typename T>
  static inline const std::string& TurnLimit_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TurnLimit>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TurnLimit_Name.");
    return Lane_TurnLimit_Name(enum_t_value);
  }
  static inline bool TurnLimit_Parse(const std::string& name,
      TurnLimit* value) {
    return Lane_TurnLimit_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLanesFieldNumber = 2,
    kDrivelinesFieldNumber = 3,
    kDirectionsFieldNumber = 7,
    kPredsFieldNumber = 11,
    kSuccsFieldNumber = 12,
    kLRestrictionsFieldNumber = 13,
    kRRestrictionsFieldNumber = 14,
    kIdFieldNumber = 1,
    kTypeFieldNumber = 5,
    kFunctionFieldNumber = 4,
    kPriorityFieldNumber = 8,
    kLengthFieldNumber = 9,
    kSeqNoFieldNumber = 10,
    kTransitionFieldNumber = 15,
    kTurnLimitFieldNumber = 16,
  };
  // repeated .RoadPB.LaneSection lanes = 2;
  int lanes_size() const;
  private:
  int _internal_lanes_size() const;
  public:
  void clear_lanes();
  ::RoadPB::LaneSection* mutable_lanes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::LaneSection >*
      mutable_lanes();
  private:
  const ::RoadPB::LaneSection& _internal_lanes(int index) const;
  ::RoadPB::LaneSection* _internal_add_lanes();
  public:
  const ::RoadPB::LaneSection& lanes(int index) const;
  ::RoadPB::LaneSection* add_lanes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::LaneSection >&
      lanes() const;

  // repeated .RoadPB.FeatureID drivelines = 3;
  int drivelines_size() const;
  private:
  int _internal_drivelines_size() const;
  public:
  void clear_drivelines();
  ::RoadPB::FeatureID* mutable_drivelines(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID >*
      mutable_drivelines();
  private:
  const ::RoadPB::FeatureID& _internal_drivelines(int index) const;
  ::RoadPB::FeatureID* _internal_add_drivelines();
  public:
  const ::RoadPB::FeatureID& drivelines(int index) const;
  ::RoadPB::FeatureID* add_drivelines();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID >&
      drivelines() const;

  // repeated .RoadPB.LaneDirection directions = 7;
  int directions_size() const;
  private:
  int _internal_directions_size() const;
  public:
  void clear_directions();
  ::RoadPB::LaneDirection* mutable_directions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::LaneDirection >*
      mutable_directions();
  private:
  const ::RoadPB::LaneDirection& _internal_directions(int index) const;
  ::RoadPB::LaneDirection* _internal_add_directions();
  public:
  const ::RoadPB::LaneDirection& directions(int index) const;
  ::RoadPB::LaneDirection* add_directions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::LaneDirection >&
      directions() const;

  // repeated .RoadPB.FeatureID preds = 11;
  int preds_size() const;
  private:
  int _internal_preds_size() const;
  public:
  void clear_preds();
  ::RoadPB::FeatureID* mutable_preds(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID >*
      mutable_preds();
  private:
  const ::RoadPB::FeatureID& _internal_preds(int index) const;
  ::RoadPB::FeatureID* _internal_add_preds();
  public:
  const ::RoadPB::FeatureID& preds(int index) const;
  ::RoadPB::FeatureID* add_preds();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID >&
      preds() const;

  // repeated .RoadPB.FeatureID succs = 12;
  int succs_size() const;
  private:
  int _internal_succs_size() const;
  public:
  void clear_succs();
  ::RoadPB::FeatureID* mutable_succs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID >*
      mutable_succs();
  private:
  const ::RoadPB::FeatureID& _internal_succs(int index) const;
  ::RoadPB::FeatureID* _internal_add_succs();
  public:
  const ::RoadPB::FeatureID& succs(int index) const;
  ::RoadPB::FeatureID* add_succs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID >&
      succs() const;

  // repeated int32 l_restrictions = 13;
  int l_restrictions_size() const;
  private:
  int _internal_l_restrictions_size() const;
  public:
  void clear_l_restrictions();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_l_restrictions(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_l_restrictions() const;
  void _internal_add_l_restrictions(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_l_restrictions();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 l_restrictions(int index) const;
  void set_l_restrictions(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_l_restrictions(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      l_restrictions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_l_restrictions();

  // repeated int32 r_restrictions = 14;
  int r_restrictions_size() const;
  private:
  int _internal_r_restrictions_size() const;
  public:
  void clear_r_restrictions();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_r_restrictions(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_r_restrictions() const;
  void _internal_add_r_restrictions(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_r_restrictions();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 r_restrictions(int index) const;
  void set_r_restrictions(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_r_restrictions(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      r_restrictions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_r_restrictions();

  // optional .RoadPB.FeatureID id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::RoadPB::FeatureID& id() const;
  ::RoadPB::FeatureID* release_id();
  ::RoadPB::FeatureID* mutable_id();
  void set_allocated_id(::RoadPB::FeatureID* id);
  private:
  const ::RoadPB::FeatureID& _internal_id() const;
  ::RoadPB::FeatureID* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::RoadPB::FeatureID* id);
  ::RoadPB::FeatureID* unsafe_arena_release_id();

  // optional uint64 type = 5;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::PROTOBUF_NAMESPACE_ID::uint64 type() const;
  void set_type(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_type() const;
  void _internal_set_type(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional int32 function = 4;
  bool has_function() const;
  private:
  bool _internal_has_function() const;
  public:
  void clear_function();
  ::PROTOBUF_NAMESPACE_ID::int32 function() const;
  void set_function(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_function() const;
  void _internal_set_function(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 priority = 8;
  bool has_priority() const;
  private:
  bool _internal_has_priority() const;
  public:
  void clear_priority();
  ::PROTOBUF_NAMESPACE_ID::int32 priority() const;
  void set_priority(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_priority() const;
  void _internal_set_priority(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional float length = 9;
  bool has_length() const;
  private:
  bool _internal_has_length() const;
  public:
  void clear_length();
  float length() const;
  void set_length(float value);
  private:
  float _internal_length() const;
  void _internal_set_length(float value);
  public:

  // optional int32 seq_no = 10;
  bool has_seq_no() const;
  private:
  bool _internal_has_seq_no() const;
  public:
  void clear_seq_no();
  ::PROTOBUF_NAMESPACE_ID::int32 seq_no() const;
  void set_seq_no(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_seq_no() const;
  void _internal_set_seq_no(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 transition = 15;
  bool has_transition() const;
  private:
  bool _internal_has_transition() const;
  public:
  void clear_transition();
  ::PROTOBUF_NAMESPACE_ID::int32 transition() const;
  void set_transition(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_transition() const;
  void _internal_set_transition(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 turn_limit = 16;
  bool has_turn_limit() const;
  private:
  bool _internal_has_turn_limit() const;
  public:
  void clear_turn_limit();
  ::PROTOBUF_NAMESPACE_ID::int32 turn_limit() const;
  void set_turn_limit(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_turn_limit() const;
  void _internal_set_turn_limit(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:RoadPB.Lane)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::LaneSection > lanes_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID > drivelines_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::LaneDirection > directions_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID > preds_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID > succs_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > l_restrictions_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > r_restrictions_;
  ::RoadPB::FeatureID* id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 type_;
  ::PROTOBUF_NAMESPACE_ID::int32 function_;
  ::PROTOBUF_NAMESPACE_ID::int32 priority_;
  float length_;
  ::PROTOBUF_NAMESPACE_ID::int32 seq_no_;
  ::PROTOBUF_NAMESPACE_ID::int32 transition_;
  ::PROTOBUF_NAMESPACE_ID::int32 turn_limit_;
  friend struct ::TableStruct_lane_2flane_2eproto;
};
// -------------------------------------------------------------------

class LaneGroup PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RoadPB.LaneGroup) */ {
 public:
  inline LaneGroup() : LaneGroup(nullptr) {};
  virtual ~LaneGroup();

  LaneGroup(const LaneGroup& from);
  LaneGroup(LaneGroup&& from) noexcept
    : LaneGroup() {
    *this = ::std::move(from);
  }

  inline LaneGroup& operator=(const LaneGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline LaneGroup& operator=(LaneGroup&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LaneGroup& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LaneGroup* internal_default_instance() {
    return reinterpret_cast<const LaneGroup*>(
               &_LaneGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(LaneGroup& a, LaneGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(LaneGroup* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LaneGroup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LaneGroup* New() const final {
    return CreateMaybeMessage<LaneGroup>(nullptr);
  }

  LaneGroup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LaneGroup>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LaneGroup& from);
  void MergeFrom(const LaneGroup& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LaneGroup* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RoadPB.LaneGroup";
  }
  protected:
  explicit LaneGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_lane_2flane_2eproto);
    return ::descriptor_table_lane_2flane_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef LaneGroup_LaneGroupType LaneGroupType;
  static constexpr LaneGroupType UNKOWN_LANEGROUPTYPE =
    LaneGroup_LaneGroupType_UNKOWN_LANEGROUPTYPE;
  static constexpr LaneGroupType OTHERS =
    LaneGroup_LaneGroupType_OTHERS;
  static constexpr LaneGroupType LANES_TO_TOLL =
    LaneGroup_LaneGroupType_LANES_TO_TOLL;
  static constexpr LaneGroupType LANES_AT_TOLL =
    LaneGroup_LaneGroupType_LANES_AT_TOLL;
  static constexpr LaneGroupType EXITING_TOLL =
    LaneGroup_LaneGroupType_EXITING_TOLL;
  static constexpr LaneGroupType LANES_TO_BRIGHT =
    LaneGroup_LaneGroupType_LANES_TO_BRIGHT;
  static constexpr LaneGroupType LANES_ON_BRIGHT =
    LaneGroup_LaneGroupType_LANES_ON_BRIGHT;
  static constexpr LaneGroupType EXITING_BRIGHT =
    LaneGroup_LaneGroupType_EXITING_BRIGHT;
  static constexpr LaneGroupType LANES_TO_TUNNEL =
    LaneGroup_LaneGroupType_LANES_TO_TUNNEL;
  static constexpr LaneGroupType LANES_IN_TUNNEL =
    LaneGroup_LaneGroupType_LANES_IN_TUNNEL;
  static constexpr LaneGroupType EXITING_TUNNEL =
    LaneGroup_LaneGroupType_EXITING_TUNNEL;
  static constexpr LaneGroupType LANES_ON_JUNCTION =
    LaneGroup_LaneGroupType_LANES_ON_JUNCTION;
  static inline bool LaneGroupType_IsValid(int value) {
    return LaneGroup_LaneGroupType_IsValid(value);
  }
  static constexpr LaneGroupType LaneGroupType_MIN =
    LaneGroup_LaneGroupType_LaneGroupType_MIN;
  static constexpr LaneGroupType LaneGroupType_MAX =
    LaneGroup_LaneGroupType_LaneGroupType_MAX;
  static constexpr int LaneGroupType_ARRAYSIZE =
    LaneGroup_LaneGroupType_LaneGroupType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  LaneGroupType_descriptor() {
    return LaneGroup_LaneGroupType_descriptor();
  }
  template<typename T>
  static inline const std::string& LaneGroupType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LaneGroupType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LaneGroupType_Name.");
    return LaneGroup_LaneGroupType_Name(enum_t_value);
  }
  static inline bool LaneGroupType_Parse(const std::string& name,
      LaneGroupType* value) {
    return LaneGroup_LaneGroupType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTypesFieldNumber = 4,
    kLeftBoundarysFieldNumber = 6,
    kRightBoundarysFieldNumber = 7,
    kLanesFieldNumber = 8,
    kPredsFieldNumber = 9,
    kSuccsFieldNumber = 10,
    kIdFieldNumber = 1,
    kLinkIdFieldNumber = 2,
  };
  // repeated int32 types = 4;
  int types_size() const;
  private:
  int _internal_types_size() const;
  public:
  void clear_types();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_types(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_types() const;
  void _internal_add_types(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_types();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 types(int index) const;
  void set_types(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_types(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_types();

  // repeated .RoadPB.FeatureID left_boundarys = 6;
  int left_boundarys_size() const;
  private:
  int _internal_left_boundarys_size() const;
  public:
  void clear_left_boundarys();
  ::RoadPB::FeatureID* mutable_left_boundarys(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID >*
      mutable_left_boundarys();
  private:
  const ::RoadPB::FeatureID& _internal_left_boundarys(int index) const;
  ::RoadPB::FeatureID* _internal_add_left_boundarys();
  public:
  const ::RoadPB::FeatureID& left_boundarys(int index) const;
  ::RoadPB::FeatureID* add_left_boundarys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID >&
      left_boundarys() const;

  // repeated .RoadPB.FeatureID right_boundarys = 7;
  int right_boundarys_size() const;
  private:
  int _internal_right_boundarys_size() const;
  public:
  void clear_right_boundarys();
  ::RoadPB::FeatureID* mutable_right_boundarys(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID >*
      mutable_right_boundarys();
  private:
  const ::RoadPB::FeatureID& _internal_right_boundarys(int index) const;
  ::RoadPB::FeatureID* _internal_add_right_boundarys();
  public:
  const ::RoadPB::FeatureID& right_boundarys(int index) const;
  ::RoadPB::FeatureID* add_right_boundarys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID >&
      right_boundarys() const;

  // repeated .RoadPB.FeatureID lanes = 8;
  int lanes_size() const;
  private:
  int _internal_lanes_size() const;
  public:
  void clear_lanes();
  ::RoadPB::FeatureID* mutable_lanes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID >*
      mutable_lanes();
  private:
  const ::RoadPB::FeatureID& _internal_lanes(int index) const;
  ::RoadPB::FeatureID* _internal_add_lanes();
  public:
  const ::RoadPB::FeatureID& lanes(int index) const;
  ::RoadPB::FeatureID* add_lanes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID >&
      lanes() const;

  // repeated .RoadPB.FeatureID preds = 9;
  int preds_size() const;
  private:
  int _internal_preds_size() const;
  public:
  void clear_preds();
  ::RoadPB::FeatureID* mutable_preds(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID >*
      mutable_preds();
  private:
  const ::RoadPB::FeatureID& _internal_preds(int index) const;
  ::RoadPB::FeatureID* _internal_add_preds();
  public:
  const ::RoadPB::FeatureID& preds(int index) const;
  ::RoadPB::FeatureID* add_preds();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID >&
      preds() const;

  // repeated .RoadPB.FeatureID succs = 10;
  int succs_size() const;
  private:
  int _internal_succs_size() const;
  public:
  void clear_succs();
  ::RoadPB::FeatureID* mutable_succs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID >*
      mutable_succs();
  private:
  const ::RoadPB::FeatureID& _internal_succs(int index) const;
  ::RoadPB::FeatureID* _internal_add_succs();
  public:
  const ::RoadPB::FeatureID& succs(int index) const;
  ::RoadPB::FeatureID* add_succs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID >&
      succs() const;

  // optional .RoadPB.FeatureID id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::RoadPB::FeatureID& id() const;
  ::RoadPB::FeatureID* release_id();
  ::RoadPB::FeatureID* mutable_id();
  void set_allocated_id(::RoadPB::FeatureID* id);
  private:
  const ::RoadPB::FeatureID& _internal_id() const;
  ::RoadPB::FeatureID* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::RoadPB::FeatureID* id);
  ::RoadPB::FeatureID* unsafe_arena_release_id();

  // optional .RoadPB.FeatureID link_id = 2;
  bool has_link_id() const;
  private:
  bool _internal_has_link_id() const;
  public:
  void clear_link_id();
  const ::RoadPB::FeatureID& link_id() const;
  ::RoadPB::FeatureID* release_link_id();
  ::RoadPB::FeatureID* mutable_link_id();
  void set_allocated_link_id(::RoadPB::FeatureID* link_id);
  private:
  const ::RoadPB::FeatureID& _internal_link_id() const;
  ::RoadPB::FeatureID* _internal_mutable_link_id();
  public:
  void unsafe_arena_set_allocated_link_id(
      ::RoadPB::FeatureID* link_id);
  ::RoadPB::FeatureID* unsafe_arena_release_link_id();

  // @@protoc_insertion_point(class_scope:RoadPB.LaneGroup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > types_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID > left_boundarys_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID > right_boundarys_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID > lanes_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID > preds_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID > succs_;
  ::RoadPB::FeatureID* id_;
  ::RoadPB::FeatureID* link_id_;
  friend struct ::TableStruct_lane_2flane_2eproto;
};
// -------------------------------------------------------------------

class ImpassableArea PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RoadPB.ImpassableArea) */ {
 public:
  inline ImpassableArea() : ImpassableArea(nullptr) {};
  virtual ~ImpassableArea();

  ImpassableArea(const ImpassableArea& from);
  ImpassableArea(ImpassableArea&& from) noexcept
    : ImpassableArea() {
    *this = ::std::move(from);
  }

  inline ImpassableArea& operator=(const ImpassableArea& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImpassableArea& operator=(ImpassableArea&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ImpassableArea& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImpassableArea* internal_default_instance() {
    return reinterpret_cast<const ImpassableArea*>(
               &_ImpassableArea_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ImpassableArea& a, ImpassableArea& b) {
    a.Swap(&b);
  }
  inline void Swap(ImpassableArea* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImpassableArea* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ImpassableArea* New() const final {
    return CreateMaybeMessage<ImpassableArea>(nullptr);
  }

  ImpassableArea* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ImpassableArea>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ImpassableArea& from);
  void MergeFrom(const ImpassableArea& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImpassableArea* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RoadPB.ImpassableArea";
  }
  protected:
  explicit ImpassableArea(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_lane_2flane_2eproto);
    return ::descriptor_table_lane_2flane_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ImpassableArea_Kind Kind;
  static constexpr Kind UNKNOWN_KIND =
    ImpassableArea_Kind_UNKNOWN_KIND;
  static constexpr Kind FLOWERBED =
    ImpassableArea_Kind_FLOWERBED;
  static constexpr Kind SENTRY_BOX =
    ImpassableArea_Kind_SENTRY_BOX;
  static constexpr Kind SAFE_ISLAND =
    ImpassableArea_Kind_SAFE_ISLAND;
  static inline bool Kind_IsValid(int value) {
    return ImpassableArea_Kind_IsValid(value);
  }
  static constexpr Kind Kind_MIN =
    ImpassableArea_Kind_Kind_MIN;
  static constexpr Kind Kind_MAX =
    ImpassableArea_Kind_Kind_MAX;
  static constexpr int Kind_ARRAYSIZE =
    ImpassableArea_Kind_Kind_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Kind_descriptor() {
    return ImpassableArea_Kind_descriptor();
  }
  template<typename T>
  static inline const std::string& Kind_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Kind>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Kind_Name.");
    return ImpassableArea_Kind_Name(enum_t_value);
  }
  static inline bool Kind_Parse(const std::string& name,
      Kind* value) {
    return ImpassableArea_Kind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kGeomFieldNumber = 1,
    kTypeFieldNumber = 2,
    kKindFieldNumber = 3,
  };
  // optional .RoadPB.Polygon geom = 1;
  bool has_geom() const;
  private:
  bool _internal_has_geom() const;
  public:
  void clear_geom();
  const ::RoadPB::Polygon& geom() const;
  ::RoadPB::Polygon* release_geom();
  ::RoadPB::Polygon* mutable_geom();
  void set_allocated_geom(::RoadPB::Polygon* geom);
  private:
  const ::RoadPB::Polygon& _internal_geom() const;
  ::RoadPB::Polygon* _internal_mutable_geom();
  public:
  void unsafe_arena_set_allocated_geom(
      ::RoadPB::Polygon* geom);
  ::RoadPB::Polygon* unsafe_arena_release_geom();

  // optional int32 type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::PROTOBUF_NAMESPACE_ID::int32 type() const;
  void set_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_type() const;
  void _internal_set_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 kind = 3;
  bool has_kind() const;
  private:
  bool _internal_has_kind() const;
  public:
  void clear_kind();
  ::PROTOBUF_NAMESPACE_ID::int32 kind() const;
  void set_kind(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_kind() const;
  void _internal_set_kind(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:RoadPB.ImpassableArea)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::RoadPB::Polygon* geom_;
  ::PROTOBUF_NAMESPACE_ID::int32 type_;
  ::PROTOBUF_NAMESPACE_ID::int32 kind_;
  friend struct ::TableStruct_lane_2flane_2eproto;
};
// -------------------------------------------------------------------

class Junction PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RoadPB.Junction) */ {
 public:
  inline Junction() : Junction(nullptr) {};
  virtual ~Junction();

  Junction(const Junction& from);
  Junction(Junction&& from) noexcept
    : Junction() {
    *this = ::std::move(from);
  }

  inline Junction& operator=(const Junction& from) {
    CopyFrom(from);
    return *this;
  }
  inline Junction& operator=(Junction&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Junction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Junction* internal_default_instance() {
    return reinterpret_cast<const Junction*>(
               &_Junction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Junction& a, Junction& b) {
    a.Swap(&b);
  }
  inline void Swap(Junction* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Junction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Junction* New() const final {
    return CreateMaybeMessage<Junction>(nullptr);
  }

  Junction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Junction>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Junction& from);
  void MergeFrom(const Junction& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Junction* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RoadPB.Junction";
  }
  protected:
  explicit Junction(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_lane_2flane_2eproto);
    return ::descriptor_table_lane_2flane_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAreasFieldNumber = 5,
    kBoundarysFieldNumber = 6,
    kConnGroupsFieldNumber = 7,
    kInGroupsFieldNumber = 8,
    kOutGroupsFieldNumber = 9,
    kIdFieldNumber = 1,
    kNodeIdFieldNumber = 3,
  };
  // repeated .RoadPB.ImpassableArea areas = 5;
  int areas_size() const;
  private:
  int _internal_areas_size() const;
  public:
  void clear_areas();
  ::RoadPB::ImpassableArea* mutable_areas(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::ImpassableArea >*
      mutable_areas();
  private:
  const ::RoadPB::ImpassableArea& _internal_areas(int index) const;
  ::RoadPB::ImpassableArea* _internal_add_areas();
  public:
  const ::RoadPB::ImpassableArea& areas(int index) const;
  ::RoadPB::ImpassableArea* add_areas();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::ImpassableArea >&
      areas() const;

  // repeated .RoadPB.FeatureID boundarys = 6;
  int boundarys_size() const;
  private:
  int _internal_boundarys_size() const;
  public:
  void clear_boundarys();
  ::RoadPB::FeatureID* mutable_boundarys(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID >*
      mutable_boundarys();
  private:
  const ::RoadPB::FeatureID& _internal_boundarys(int index) const;
  ::RoadPB::FeatureID* _internal_add_boundarys();
  public:
  const ::RoadPB::FeatureID& boundarys(int index) const;
  ::RoadPB::FeatureID* add_boundarys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID >&
      boundarys() const;

  // repeated .RoadPB.FeatureID conn_groups = 7;
  int conn_groups_size() const;
  private:
  int _internal_conn_groups_size() const;
  public:
  void clear_conn_groups();
  ::RoadPB::FeatureID* mutable_conn_groups(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID >*
      mutable_conn_groups();
  private:
  const ::RoadPB::FeatureID& _internal_conn_groups(int index) const;
  ::RoadPB::FeatureID* _internal_add_conn_groups();
  public:
  const ::RoadPB::FeatureID& conn_groups(int index) const;
  ::RoadPB::FeatureID* add_conn_groups();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID >&
      conn_groups() const;

  // repeated .RoadPB.FeatureID in_groups = 8;
  int in_groups_size() const;
  private:
  int _internal_in_groups_size() const;
  public:
  void clear_in_groups();
  ::RoadPB::FeatureID* mutable_in_groups(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID >*
      mutable_in_groups();
  private:
  const ::RoadPB::FeatureID& _internal_in_groups(int index) const;
  ::RoadPB::FeatureID* _internal_add_in_groups();
  public:
  const ::RoadPB::FeatureID& in_groups(int index) const;
  ::RoadPB::FeatureID* add_in_groups();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID >&
      in_groups() const;

  // repeated .RoadPB.FeatureID out_groups = 9;
  int out_groups_size() const;
  private:
  int _internal_out_groups_size() const;
  public:
  void clear_out_groups();
  ::RoadPB::FeatureID* mutable_out_groups(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID >*
      mutable_out_groups();
  private:
  const ::RoadPB::FeatureID& _internal_out_groups(int index) const;
  ::RoadPB::FeatureID* _internal_add_out_groups();
  public:
  const ::RoadPB::FeatureID& out_groups(int index) const;
  ::RoadPB::FeatureID* add_out_groups();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID >&
      out_groups() const;

  // optional .RoadPB.FeatureID id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::RoadPB::FeatureID& id() const;
  ::RoadPB::FeatureID* release_id();
  ::RoadPB::FeatureID* mutable_id();
  void set_allocated_id(::RoadPB::FeatureID* id);
  private:
  const ::RoadPB::FeatureID& _internal_id() const;
  ::RoadPB::FeatureID* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::RoadPB::FeatureID* id);
  ::RoadPB::FeatureID* unsafe_arena_release_id();

  // optional .RoadPB.FeatureID node_id = 3;
  bool has_node_id() const;
  private:
  bool _internal_has_node_id() const;
  public:
  void clear_node_id();
  const ::RoadPB::FeatureID& node_id() const;
  ::RoadPB::FeatureID* release_node_id();
  ::RoadPB::FeatureID* mutable_node_id();
  void set_allocated_node_id(::RoadPB::FeatureID* node_id);
  private:
  const ::RoadPB::FeatureID& _internal_node_id() const;
  ::RoadPB::FeatureID* _internal_mutable_node_id();
  public:
  void unsafe_arena_set_allocated_node_id(
      ::RoadPB::FeatureID* node_id);
  ::RoadPB::FeatureID* unsafe_arena_release_node_id();

  // @@protoc_insertion_point(class_scope:RoadPB.Junction)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::ImpassableArea > areas_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID > boundarys_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID > conn_groups_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID > in_groups_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID > out_groups_;
  ::RoadPB::FeatureID* id_;
  ::RoadPB::FeatureID* node_id_;
  friend struct ::TableStruct_lane_2flane_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// LaneDirection

// optional int32 direction = 1;
inline bool LaneDirection::_internal_has_direction() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LaneDirection::has_direction() const {
  return _internal_has_direction();
}
inline void LaneDirection::clear_direction() {
  direction_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LaneDirection::_internal_direction() const {
  return direction_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LaneDirection::direction() const {
  // @@protoc_insertion_point(field_get:RoadPB.LaneDirection.direction)
  return _internal_direction();
}
inline void LaneDirection::_internal_set_direction(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  direction_ = value;
}
inline void LaneDirection::set_direction(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_direction(value);
  // @@protoc_insertion_point(field_set:RoadPB.LaneDirection.direction)
}

// optional string valid_period = 2;
inline bool LaneDirection::_internal_has_valid_period() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LaneDirection::has_valid_period() const {
  return _internal_has_valid_period();
}
inline void LaneDirection::clear_valid_period() {
  valid_period_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LaneDirection::valid_period() const {
  // @@protoc_insertion_point(field_get:RoadPB.LaneDirection.valid_period)
  return _internal_valid_period();
}
inline void LaneDirection::set_valid_period(const std::string& value) {
  _internal_set_valid_period(value);
  // @@protoc_insertion_point(field_set:RoadPB.LaneDirection.valid_period)
}
inline std::string* LaneDirection::mutable_valid_period() {
  // @@protoc_insertion_point(field_mutable:RoadPB.LaneDirection.valid_period)
  return _internal_mutable_valid_period();
}
inline const std::string& LaneDirection::_internal_valid_period() const {
  return valid_period_.Get();
}
inline void LaneDirection::_internal_set_valid_period(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  valid_period_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void LaneDirection::set_valid_period(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  valid_period_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:RoadPB.LaneDirection.valid_period)
}
inline void LaneDirection::set_valid_period(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  valid_period_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:RoadPB.LaneDirection.valid_period)
}
inline void LaneDirection::set_valid_period(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  valid_period_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:RoadPB.LaneDirection.valid_period)
}
inline std::string* LaneDirection::_internal_mutable_valid_period() {
  _has_bits_[0] |= 0x00000001u;
  return valid_period_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* LaneDirection::release_valid_period() {
  // @@protoc_insertion_point(field_release:RoadPB.LaneDirection.valid_period)
  if (!_internal_has_valid_period()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return valid_period_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LaneDirection::set_allocated_valid_period(std::string* valid_period) {
  if (valid_period != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  valid_period_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), valid_period,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:RoadPB.LaneDirection.valid_period)
}
inline std::string* LaneDirection::unsafe_arena_release_valid_period() {
  // @@protoc_insertion_point(field_unsafe_arena_release:RoadPB.LaneDirection.valid_period)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return valid_period_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void LaneDirection::unsafe_arena_set_allocated_valid_period(
    std::string* valid_period) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (valid_period != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  valid_period_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      valid_period, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RoadPB.LaneDirection.valid_period)
}

// repeated int32 allowed_vehicle_types = 3;
inline int LaneDirection::_internal_allowed_vehicle_types_size() const {
  return allowed_vehicle_types_.size();
}
inline int LaneDirection::allowed_vehicle_types_size() const {
  return _internal_allowed_vehicle_types_size();
}
inline void LaneDirection::clear_allowed_vehicle_types() {
  allowed_vehicle_types_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LaneDirection::_internal_allowed_vehicle_types(int index) const {
  return allowed_vehicle_types_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LaneDirection::allowed_vehicle_types(int index) const {
  // @@protoc_insertion_point(field_get:RoadPB.LaneDirection.allowed_vehicle_types)
  return _internal_allowed_vehicle_types(index);
}
inline void LaneDirection::set_allowed_vehicle_types(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  allowed_vehicle_types_.Set(index, value);
  // @@protoc_insertion_point(field_set:RoadPB.LaneDirection.allowed_vehicle_types)
}
inline void LaneDirection::_internal_add_allowed_vehicle_types(::PROTOBUF_NAMESPACE_ID::int32 value) {
  allowed_vehicle_types_.Add(value);
}
inline void LaneDirection::add_allowed_vehicle_types(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_allowed_vehicle_types(value);
  // @@protoc_insertion_point(field_add:RoadPB.LaneDirection.allowed_vehicle_types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
LaneDirection::_internal_allowed_vehicle_types() const {
  return allowed_vehicle_types_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
LaneDirection::allowed_vehicle_types() const {
  // @@protoc_insertion_point(field_list:RoadPB.LaneDirection.allowed_vehicle_types)
  return _internal_allowed_vehicle_types();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
LaneDirection::_internal_mutable_allowed_vehicle_types() {
  return &allowed_vehicle_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
LaneDirection::mutable_allowed_vehicle_types() {
  // @@protoc_insertion_point(field_mutable_list:RoadPB.LaneDirection.allowed_vehicle_types)
  return _internal_mutable_allowed_vehicle_types();
}

// -------------------------------------------------------------------

// LaneBoundary

// optional .RoadPB.FeatureID id = 1;
inline bool LaneBoundary::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || id_ != nullptr);
  return value;
}
inline bool LaneBoundary::has_id() const {
  return _internal_has_id();
}
inline const ::RoadPB::FeatureID& LaneBoundary::_internal_id() const {
  const ::RoadPB::FeatureID* p = id_;
  return p != nullptr ? *p : *reinterpret_cast<const ::RoadPB::FeatureID*>(
      &::RoadPB::_FeatureID_default_instance_);
}
inline const ::RoadPB::FeatureID& LaneBoundary::id() const {
  // @@protoc_insertion_point(field_get:RoadPB.LaneBoundary.id)
  return _internal_id();
}
inline void LaneBoundary::unsafe_arena_set_allocated_id(
    ::RoadPB::FeatureID* id) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  id_ = id;
  if (id) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RoadPB.LaneBoundary.id)
}
inline ::RoadPB::FeatureID* LaneBoundary::release_id() {
  auto temp = unsafe_arena_release_id();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::RoadPB::FeatureID* LaneBoundary::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:RoadPB.LaneBoundary.id)
  _has_bits_[0] &= ~0x00000001u;
  ::RoadPB::FeatureID* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::RoadPB::FeatureID* LaneBoundary::_internal_mutable_id() {
  _has_bits_[0] |= 0x00000001u;
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::RoadPB::FeatureID>(GetArena());
    id_ = p;
  }
  return id_;
}
inline ::RoadPB::FeatureID* LaneBoundary::mutable_id() {
  // @@protoc_insertion_point(field_mutable:RoadPB.LaneBoundary.id)
  return _internal_mutable_id();
}
inline void LaneBoundary::set_allocated_id(::RoadPB::FeatureID* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id)->GetArena();
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:RoadPB.LaneBoundary.id)
}

// optional .RoadPB.Polyline geom = 2;
inline bool LaneBoundary::_internal_has_geom() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || geom_ != nullptr);
  return value;
}
inline bool LaneBoundary::has_geom() const {
  return _internal_has_geom();
}
inline const ::RoadPB::Polyline& LaneBoundary::_internal_geom() const {
  const ::RoadPB::Polyline* p = geom_;
  return p != nullptr ? *p : *reinterpret_cast<const ::RoadPB::Polyline*>(
      &::RoadPB::_Polyline_default_instance_);
}
inline const ::RoadPB::Polyline& LaneBoundary::geom() const {
  // @@protoc_insertion_point(field_get:RoadPB.LaneBoundary.geom)
  return _internal_geom();
}
inline void LaneBoundary::unsafe_arena_set_allocated_geom(
    ::RoadPB::Polyline* geom) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(geom_);
  }
  geom_ = geom;
  if (geom) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RoadPB.LaneBoundary.geom)
}
inline ::RoadPB::Polyline* LaneBoundary::release_geom() {
  auto temp = unsafe_arena_release_geom();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::RoadPB::Polyline* LaneBoundary::unsafe_arena_release_geom() {
  // @@protoc_insertion_point(field_release:RoadPB.LaneBoundary.geom)
  _has_bits_[0] &= ~0x00000002u;
  ::RoadPB::Polyline* temp = geom_;
  geom_ = nullptr;
  return temp;
}
inline ::RoadPB::Polyline* LaneBoundary::_internal_mutable_geom() {
  _has_bits_[0] |= 0x00000002u;
  if (geom_ == nullptr) {
    auto* p = CreateMaybeMessage<::RoadPB::Polyline>(GetArena());
    geom_ = p;
  }
  return geom_;
}
inline ::RoadPB::Polyline* LaneBoundary::mutable_geom() {
  // @@protoc_insertion_point(field_mutable:RoadPB.LaneBoundary.geom)
  return _internal_mutable_geom();
}
inline void LaneBoundary::set_allocated_geom(::RoadPB::Polyline* geom) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(geom_);
  }
  if (geom) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(geom)->GetArena();
    if (message_arena != submessage_arena) {
      geom = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, geom, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  geom_ = geom;
  // @@protoc_insertion_point(field_set_allocated:RoadPB.LaneBoundary.geom)
}

// optional int32 color = 3;
inline bool LaneBoundary::_internal_has_color() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LaneBoundary::has_color() const {
  return _internal_has_color();
}
inline void LaneBoundary::clear_color() {
  color_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LaneBoundary::_internal_color() const {
  return color_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LaneBoundary::color() const {
  // @@protoc_insertion_point(field_get:RoadPB.LaneBoundary.color)
  return _internal_color();
}
inline void LaneBoundary::_internal_set_color(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  color_ = value;
}
inline void LaneBoundary::set_color(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_color(value);
  // @@protoc_insertion_point(field_set:RoadPB.LaneBoundary.color)
}

// repeated int32 types = 4;
inline int LaneBoundary::_internal_types_size() const {
  return types_.size();
}
inline int LaneBoundary::types_size() const {
  return _internal_types_size();
}
inline void LaneBoundary::clear_types() {
  types_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LaneBoundary::_internal_types(int index) const {
  return types_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LaneBoundary::types(int index) const {
  // @@protoc_insertion_point(field_get:RoadPB.LaneBoundary.types)
  return _internal_types(index);
}
inline void LaneBoundary::set_types(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  types_.Set(index, value);
  // @@protoc_insertion_point(field_set:RoadPB.LaneBoundary.types)
}
inline void LaneBoundary::_internal_add_types(::PROTOBUF_NAMESPACE_ID::int32 value) {
  types_.Add(value);
}
inline void LaneBoundary::add_types(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_types(value);
  // @@protoc_insertion_point(field_add:RoadPB.LaneBoundary.types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
LaneBoundary::_internal_types() const {
  return types_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
LaneBoundary::types() const {
  // @@protoc_insertion_point(field_list:RoadPB.LaneBoundary.types)
  return _internal_types();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
LaneBoundary::_internal_mutable_types() {
  return &types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
LaneBoundary::mutable_types() {
  // @@protoc_insertion_point(field_mutable_list:RoadPB.LaneBoundary.types)
  return _internal_mutable_types();
}

// optional int32 marking = 5;
inline bool LaneBoundary::_internal_has_marking() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LaneBoundary::has_marking() const {
  return _internal_has_marking();
}
inline void LaneBoundary::clear_marking() {
  marking_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LaneBoundary::_internal_marking() const {
  return marking_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LaneBoundary::marking() const {
  // @@protoc_insertion_point(field_get:RoadPB.LaneBoundary.marking)
  return _internal_marking();
}
inline void LaneBoundary::_internal_set_marking(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  marking_ = value;
}
inline void LaneBoundary::set_marking(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_marking(value);
  // @@protoc_insertion_point(field_set:RoadPB.LaneBoundary.marking)
}

// optional bool ldm = 7;
inline bool LaneBoundary::_internal_has_ldm() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool LaneBoundary::has_ldm() const {
  return _internal_has_ldm();
}
inline void LaneBoundary::clear_ldm() {
  ldm_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool LaneBoundary::_internal_ldm() const {
  return ldm_;
}
inline bool LaneBoundary::ldm() const {
  // @@protoc_insertion_point(field_get:RoadPB.LaneBoundary.ldm)
  return _internal_ldm();
}
inline void LaneBoundary::_internal_set_ldm(bool value) {
  _has_bits_[0] |= 0x00000010u;
  ldm_ = value;
}
inline void LaneBoundary::set_ldm(bool value) {
  _internal_set_ldm(value);
  // @@protoc_insertion_point(field_set:RoadPB.LaneBoundary.ldm)
}

// -------------------------------------------------------------------

// LaneBoundaryRange

// optional .RoadPB.FeatureID bound_id = 1;
inline bool LaneBoundaryRange::_internal_has_bound_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || bound_id_ != nullptr);
  return value;
}
inline bool LaneBoundaryRange::has_bound_id() const {
  return _internal_has_bound_id();
}
inline const ::RoadPB::FeatureID& LaneBoundaryRange::_internal_bound_id() const {
  const ::RoadPB::FeatureID* p = bound_id_;
  return p != nullptr ? *p : *reinterpret_cast<const ::RoadPB::FeatureID*>(
      &::RoadPB::_FeatureID_default_instance_);
}
inline const ::RoadPB::FeatureID& LaneBoundaryRange::bound_id() const {
  // @@protoc_insertion_point(field_get:RoadPB.LaneBoundaryRange.bound_id)
  return _internal_bound_id();
}
inline void LaneBoundaryRange::unsafe_arena_set_allocated_bound_id(
    ::RoadPB::FeatureID* bound_id) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bound_id_);
  }
  bound_id_ = bound_id;
  if (bound_id) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RoadPB.LaneBoundaryRange.bound_id)
}
inline ::RoadPB::FeatureID* LaneBoundaryRange::release_bound_id() {
  auto temp = unsafe_arena_release_bound_id();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::RoadPB::FeatureID* LaneBoundaryRange::unsafe_arena_release_bound_id() {
  // @@protoc_insertion_point(field_release:RoadPB.LaneBoundaryRange.bound_id)
  _has_bits_[0] &= ~0x00000001u;
  ::RoadPB::FeatureID* temp = bound_id_;
  bound_id_ = nullptr;
  return temp;
}
inline ::RoadPB::FeatureID* LaneBoundaryRange::_internal_mutable_bound_id() {
  _has_bits_[0] |= 0x00000001u;
  if (bound_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::RoadPB::FeatureID>(GetArena());
    bound_id_ = p;
  }
  return bound_id_;
}
inline ::RoadPB::FeatureID* LaneBoundaryRange::mutable_bound_id() {
  // @@protoc_insertion_point(field_mutable:RoadPB.LaneBoundaryRange.bound_id)
  return _internal_mutable_bound_id();
}
inline void LaneBoundaryRange::set_allocated_bound_id(::RoadPB::FeatureID* bound_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(bound_id_);
  }
  if (bound_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bound_id)->GetArena();
    if (message_arena != submessage_arena) {
      bound_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bound_id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  bound_id_ = bound_id;
  // @@protoc_insertion_point(field_set_allocated:RoadPB.LaneBoundaryRange.bound_id)
}

// optional .RoadPB.Point start_pt = 2;
inline bool LaneBoundaryRange::_internal_has_start_pt() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || start_pt_ != nullptr);
  return value;
}
inline bool LaneBoundaryRange::has_start_pt() const {
  return _internal_has_start_pt();
}
inline const ::RoadPB::Point& LaneBoundaryRange::_internal_start_pt() const {
  const ::RoadPB::Point* p = start_pt_;
  return p != nullptr ? *p : *reinterpret_cast<const ::RoadPB::Point*>(
      &::RoadPB::_Point_default_instance_);
}
inline const ::RoadPB::Point& LaneBoundaryRange::start_pt() const {
  // @@protoc_insertion_point(field_get:RoadPB.LaneBoundaryRange.start_pt)
  return _internal_start_pt();
}
inline void LaneBoundaryRange::unsafe_arena_set_allocated_start_pt(
    ::RoadPB::Point* start_pt) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_pt_);
  }
  start_pt_ = start_pt;
  if (start_pt) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RoadPB.LaneBoundaryRange.start_pt)
}
inline ::RoadPB::Point* LaneBoundaryRange::release_start_pt() {
  auto temp = unsafe_arena_release_start_pt();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::RoadPB::Point* LaneBoundaryRange::unsafe_arena_release_start_pt() {
  // @@protoc_insertion_point(field_release:RoadPB.LaneBoundaryRange.start_pt)
  _has_bits_[0] &= ~0x00000002u;
  ::RoadPB::Point* temp = start_pt_;
  start_pt_ = nullptr;
  return temp;
}
inline ::RoadPB::Point* LaneBoundaryRange::_internal_mutable_start_pt() {
  _has_bits_[0] |= 0x00000002u;
  if (start_pt_ == nullptr) {
    auto* p = CreateMaybeMessage<::RoadPB::Point>(GetArena());
    start_pt_ = p;
  }
  return start_pt_;
}
inline ::RoadPB::Point* LaneBoundaryRange::mutable_start_pt() {
  // @@protoc_insertion_point(field_mutable:RoadPB.LaneBoundaryRange.start_pt)
  return _internal_mutable_start_pt();
}
inline void LaneBoundaryRange::set_allocated_start_pt(::RoadPB::Point* start_pt) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_pt_);
  }
  if (start_pt) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_pt)->GetArena();
    if (message_arena != submessage_arena) {
      start_pt = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start_pt, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  start_pt_ = start_pt;
  // @@protoc_insertion_point(field_set_allocated:RoadPB.LaneBoundaryRange.start_pt)
}

// optional .RoadPB.Point end_pt = 3;
inline bool LaneBoundaryRange::_internal_has_end_pt() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || end_pt_ != nullptr);
  return value;
}
inline bool LaneBoundaryRange::has_end_pt() const {
  return _internal_has_end_pt();
}
inline const ::RoadPB::Point& LaneBoundaryRange::_internal_end_pt() const {
  const ::RoadPB::Point* p = end_pt_;
  return p != nullptr ? *p : *reinterpret_cast<const ::RoadPB::Point*>(
      &::RoadPB::_Point_default_instance_);
}
inline const ::RoadPB::Point& LaneBoundaryRange::end_pt() const {
  // @@protoc_insertion_point(field_get:RoadPB.LaneBoundaryRange.end_pt)
  return _internal_end_pt();
}
inline void LaneBoundaryRange::unsafe_arena_set_allocated_end_pt(
    ::RoadPB::Point* end_pt) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_pt_);
  }
  end_pt_ = end_pt;
  if (end_pt) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RoadPB.LaneBoundaryRange.end_pt)
}
inline ::RoadPB::Point* LaneBoundaryRange::release_end_pt() {
  auto temp = unsafe_arena_release_end_pt();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::RoadPB::Point* LaneBoundaryRange::unsafe_arena_release_end_pt() {
  // @@protoc_insertion_point(field_release:RoadPB.LaneBoundaryRange.end_pt)
  _has_bits_[0] &= ~0x00000004u;
  ::RoadPB::Point* temp = end_pt_;
  end_pt_ = nullptr;
  return temp;
}
inline ::RoadPB::Point* LaneBoundaryRange::_internal_mutable_end_pt() {
  _has_bits_[0] |= 0x00000004u;
  if (end_pt_ == nullptr) {
    auto* p = CreateMaybeMessage<::RoadPB::Point>(GetArena());
    end_pt_ = p;
  }
  return end_pt_;
}
inline ::RoadPB::Point* LaneBoundaryRange::mutable_end_pt() {
  // @@protoc_insertion_point(field_mutable:RoadPB.LaneBoundaryRange.end_pt)
  return _internal_mutable_end_pt();
}
inline void LaneBoundaryRange::set_allocated_end_pt(::RoadPB::Point* end_pt) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_pt_);
  }
  if (end_pt) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_pt)->GetArena();
    if (message_arena != submessage_arena) {
      end_pt = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end_pt, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  end_pt_ = end_pt;
  // @@protoc_insertion_point(field_set_allocated:RoadPB.LaneBoundaryRange.end_pt)
}

// -------------------------------------------------------------------

// RoadBoundary

// optional .RoadPB.FeatureID id = 1;
inline bool RoadBoundary::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || id_ != nullptr);
  return value;
}
inline bool RoadBoundary::has_id() const {
  return _internal_has_id();
}
inline const ::RoadPB::FeatureID& RoadBoundary::_internal_id() const {
  const ::RoadPB::FeatureID* p = id_;
  return p != nullptr ? *p : *reinterpret_cast<const ::RoadPB::FeatureID*>(
      &::RoadPB::_FeatureID_default_instance_);
}
inline const ::RoadPB::FeatureID& RoadBoundary::id() const {
  // @@protoc_insertion_point(field_get:RoadPB.RoadBoundary.id)
  return _internal_id();
}
inline void RoadBoundary::unsafe_arena_set_allocated_id(
    ::RoadPB::FeatureID* id) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  id_ = id;
  if (id) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RoadPB.RoadBoundary.id)
}
inline ::RoadPB::FeatureID* RoadBoundary::release_id() {
  auto temp = unsafe_arena_release_id();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::RoadPB::FeatureID* RoadBoundary::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:RoadPB.RoadBoundary.id)
  _has_bits_[0] &= ~0x00000001u;
  ::RoadPB::FeatureID* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::RoadPB::FeatureID* RoadBoundary::_internal_mutable_id() {
  _has_bits_[0] |= 0x00000001u;
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::RoadPB::FeatureID>(GetArena());
    id_ = p;
  }
  return id_;
}
inline ::RoadPB::FeatureID* RoadBoundary::mutable_id() {
  // @@protoc_insertion_point(field_mutable:RoadPB.RoadBoundary.id)
  return _internal_mutable_id();
}
inline void RoadBoundary::set_allocated_id(::RoadPB::FeatureID* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id)->GetArena();
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:RoadPB.RoadBoundary.id)
}

// optional int32 type = 2;
inline bool RoadBoundary::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RoadBoundary::has_type() const {
  return _internal_has_type();
}
inline void RoadBoundary::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RoadBoundary::_internal_type() const {
  return type_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RoadBoundary::type() const {
  // @@protoc_insertion_point(field_get:RoadPB.RoadBoundary.type)
  return _internal_type();
}
inline void RoadBoundary::_internal_set_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  type_ = value;
}
inline void RoadBoundary::set_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:RoadPB.RoadBoundary.type)
}

// optional .RoadPB.Polyline geom = 10;
inline bool RoadBoundary::_internal_has_geom() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || geom_ != nullptr);
  return value;
}
inline bool RoadBoundary::has_geom() const {
  return _internal_has_geom();
}
inline const ::RoadPB::Polyline& RoadBoundary::_internal_geom() const {
  const ::RoadPB::Polyline* p = geom_;
  return p != nullptr ? *p : *reinterpret_cast<const ::RoadPB::Polyline*>(
      &::RoadPB::_Polyline_default_instance_);
}
inline const ::RoadPB::Polyline& RoadBoundary::geom() const {
  // @@protoc_insertion_point(field_get:RoadPB.RoadBoundary.geom)
  return _internal_geom();
}
inline void RoadBoundary::unsafe_arena_set_allocated_geom(
    ::RoadPB::Polyline* geom) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(geom_);
  }
  geom_ = geom;
  if (geom) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RoadPB.RoadBoundary.geom)
}
inline ::RoadPB::Polyline* RoadBoundary::release_geom() {
  auto temp = unsafe_arena_release_geom();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::RoadPB::Polyline* RoadBoundary::unsafe_arena_release_geom() {
  // @@protoc_insertion_point(field_release:RoadPB.RoadBoundary.geom)
  _has_bits_[0] &= ~0x00000002u;
  ::RoadPB::Polyline* temp = geom_;
  geom_ = nullptr;
  return temp;
}
inline ::RoadPB::Polyline* RoadBoundary::_internal_mutable_geom() {
  _has_bits_[0] |= 0x00000002u;
  if (geom_ == nullptr) {
    auto* p = CreateMaybeMessage<::RoadPB::Polyline>(GetArena());
    geom_ = p;
  }
  return geom_;
}
inline ::RoadPB::Polyline* RoadBoundary::mutable_geom() {
  // @@protoc_insertion_point(field_mutable:RoadPB.RoadBoundary.geom)
  return _internal_mutable_geom();
}
inline void RoadBoundary::set_allocated_geom(::RoadPB::Polyline* geom) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(geom_);
  }
  if (geom) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(geom)->GetArena();
    if (message_arena != submessage_arena) {
      geom = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, geom, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  geom_ = geom;
  // @@protoc_insertion_point(field_set_allocated:RoadPB.RoadBoundary.geom)
}

// -------------------------------------------------------------------

// LaneSection

// optional .RoadPB.LaneBoundaryRange left_boundary = 1;
inline bool LaneSection::_internal_has_left_boundary() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || left_boundary_ != nullptr);
  return value;
}
inline bool LaneSection::has_left_boundary() const {
  return _internal_has_left_boundary();
}
inline void LaneSection::clear_left_boundary() {
  if (left_boundary_ != nullptr) left_boundary_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::RoadPB::LaneBoundaryRange& LaneSection::_internal_left_boundary() const {
  const ::RoadPB::LaneBoundaryRange* p = left_boundary_;
  return p != nullptr ? *p : *reinterpret_cast<const ::RoadPB::LaneBoundaryRange*>(
      &::RoadPB::_LaneBoundaryRange_default_instance_);
}
inline const ::RoadPB::LaneBoundaryRange& LaneSection::left_boundary() const {
  // @@protoc_insertion_point(field_get:RoadPB.LaneSection.left_boundary)
  return _internal_left_boundary();
}
inline void LaneSection::unsafe_arena_set_allocated_left_boundary(
    ::RoadPB::LaneBoundaryRange* left_boundary) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(left_boundary_);
  }
  left_boundary_ = left_boundary;
  if (left_boundary) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RoadPB.LaneSection.left_boundary)
}
inline ::RoadPB::LaneBoundaryRange* LaneSection::release_left_boundary() {
  auto temp = unsafe_arena_release_left_boundary();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::RoadPB::LaneBoundaryRange* LaneSection::unsafe_arena_release_left_boundary() {
  // @@protoc_insertion_point(field_release:RoadPB.LaneSection.left_boundary)
  _has_bits_[0] &= ~0x00000001u;
  ::RoadPB::LaneBoundaryRange* temp = left_boundary_;
  left_boundary_ = nullptr;
  return temp;
}
inline ::RoadPB::LaneBoundaryRange* LaneSection::_internal_mutable_left_boundary() {
  _has_bits_[0] |= 0x00000001u;
  if (left_boundary_ == nullptr) {
    auto* p = CreateMaybeMessage<::RoadPB::LaneBoundaryRange>(GetArena());
    left_boundary_ = p;
  }
  return left_boundary_;
}
inline ::RoadPB::LaneBoundaryRange* LaneSection::mutable_left_boundary() {
  // @@protoc_insertion_point(field_mutable:RoadPB.LaneSection.left_boundary)
  return _internal_mutable_left_boundary();
}
inline void LaneSection::set_allocated_left_boundary(::RoadPB::LaneBoundaryRange* left_boundary) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete left_boundary_;
  }
  if (left_boundary) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(left_boundary);
    if (message_arena != submessage_arena) {
      left_boundary = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, left_boundary, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  left_boundary_ = left_boundary;
  // @@protoc_insertion_point(field_set_allocated:RoadPB.LaneSection.left_boundary)
}

// optional .RoadPB.LaneBoundaryRange right_boundary = 2;
inline bool LaneSection::_internal_has_right_boundary() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || right_boundary_ != nullptr);
  return value;
}
inline bool LaneSection::has_right_boundary() const {
  return _internal_has_right_boundary();
}
inline void LaneSection::clear_right_boundary() {
  if (right_boundary_ != nullptr) right_boundary_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::RoadPB::LaneBoundaryRange& LaneSection::_internal_right_boundary() const {
  const ::RoadPB::LaneBoundaryRange* p = right_boundary_;
  return p != nullptr ? *p : *reinterpret_cast<const ::RoadPB::LaneBoundaryRange*>(
      &::RoadPB::_LaneBoundaryRange_default_instance_);
}
inline const ::RoadPB::LaneBoundaryRange& LaneSection::right_boundary() const {
  // @@protoc_insertion_point(field_get:RoadPB.LaneSection.right_boundary)
  return _internal_right_boundary();
}
inline void LaneSection::unsafe_arena_set_allocated_right_boundary(
    ::RoadPB::LaneBoundaryRange* right_boundary) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(right_boundary_);
  }
  right_boundary_ = right_boundary;
  if (right_boundary) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RoadPB.LaneSection.right_boundary)
}
inline ::RoadPB::LaneBoundaryRange* LaneSection::release_right_boundary() {
  auto temp = unsafe_arena_release_right_boundary();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::RoadPB::LaneBoundaryRange* LaneSection::unsafe_arena_release_right_boundary() {
  // @@protoc_insertion_point(field_release:RoadPB.LaneSection.right_boundary)
  _has_bits_[0] &= ~0x00000002u;
  ::RoadPB::LaneBoundaryRange* temp = right_boundary_;
  right_boundary_ = nullptr;
  return temp;
}
inline ::RoadPB::LaneBoundaryRange* LaneSection::_internal_mutable_right_boundary() {
  _has_bits_[0] |= 0x00000002u;
  if (right_boundary_ == nullptr) {
    auto* p = CreateMaybeMessage<::RoadPB::LaneBoundaryRange>(GetArena());
    right_boundary_ = p;
  }
  return right_boundary_;
}
inline ::RoadPB::LaneBoundaryRange* LaneSection::mutable_right_boundary() {
  // @@protoc_insertion_point(field_mutable:RoadPB.LaneSection.right_boundary)
  return _internal_mutable_right_boundary();
}
inline void LaneSection::set_allocated_right_boundary(::RoadPB::LaneBoundaryRange* right_boundary) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete right_boundary_;
  }
  if (right_boundary) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(right_boundary);
    if (message_arena != submessage_arena) {
      right_boundary = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, right_boundary, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  right_boundary_ = right_boundary;
  // @@protoc_insertion_point(field_set_allocated:RoadPB.LaneSection.right_boundary)
}

// repeated .RoadPB.FixedSpeedLimit speed_limits = 3;
inline int LaneSection::_internal_speed_limits_size() const {
  return speed_limits_.size();
}
inline int LaneSection::speed_limits_size() const {
  return _internal_speed_limits_size();
}
inline ::RoadPB::FixedSpeedLimit* LaneSection::mutable_speed_limits(int index) {
  // @@protoc_insertion_point(field_mutable:RoadPB.LaneSection.speed_limits)
  return speed_limits_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FixedSpeedLimit >*
LaneSection::mutable_speed_limits() {
  // @@protoc_insertion_point(field_mutable_list:RoadPB.LaneSection.speed_limits)
  return &speed_limits_;
}
inline const ::RoadPB::FixedSpeedLimit& LaneSection::_internal_speed_limits(int index) const {
  return speed_limits_.Get(index);
}
inline const ::RoadPB::FixedSpeedLimit& LaneSection::speed_limits(int index) const {
  // @@protoc_insertion_point(field_get:RoadPB.LaneSection.speed_limits)
  return _internal_speed_limits(index);
}
inline ::RoadPB::FixedSpeedLimit* LaneSection::_internal_add_speed_limits() {
  return speed_limits_.Add();
}
inline ::RoadPB::FixedSpeedLimit* LaneSection::add_speed_limits() {
  // @@protoc_insertion_point(field_add:RoadPB.LaneSection.speed_limits)
  return _internal_add_speed_limits();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FixedSpeedLimit >&
LaneSection::speed_limits() const {
  // @@protoc_insertion_point(field_list:RoadPB.LaneSection.speed_limits)
  return speed_limits_;
}

// repeated .RoadPB.FeatureID objects = 5;
inline int LaneSection::_internal_objects_size() const {
  return objects_.size();
}
inline int LaneSection::objects_size() const {
  return _internal_objects_size();
}
inline ::RoadPB::FeatureID* LaneSection::mutable_objects(int index) {
  // @@protoc_insertion_point(field_mutable:RoadPB.LaneSection.objects)
  return objects_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID >*
LaneSection::mutable_objects() {
  // @@protoc_insertion_point(field_mutable_list:RoadPB.LaneSection.objects)
  return &objects_;
}
inline const ::RoadPB::FeatureID& LaneSection::_internal_objects(int index) const {
  return objects_.Get(index);
}
inline const ::RoadPB::FeatureID& LaneSection::objects(int index) const {
  // @@protoc_insertion_point(field_get:RoadPB.LaneSection.objects)
  return _internal_objects(index);
}
inline ::RoadPB::FeatureID* LaneSection::_internal_add_objects() {
  return objects_.Add();
}
inline ::RoadPB::FeatureID* LaneSection::add_objects() {
  // @@protoc_insertion_point(field_add:RoadPB.LaneSection.objects)
  return _internal_add_objects();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID >&
LaneSection::objects() const {
  // @@protoc_insertion_point(field_list:RoadPB.LaneSection.objects)
  return objects_;
}

// repeated .RoadPB.FeatureID traffics = 6;
inline int LaneSection::_internal_traffics_size() const {
  return traffics_.size();
}
inline int LaneSection::traffics_size() const {
  return _internal_traffics_size();
}
inline ::RoadPB::FeatureID* LaneSection::mutable_traffics(int index) {
  // @@protoc_insertion_point(field_mutable:RoadPB.LaneSection.traffics)
  return traffics_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID >*
LaneSection::mutable_traffics() {
  // @@protoc_insertion_point(field_mutable_list:RoadPB.LaneSection.traffics)
  return &traffics_;
}
inline const ::RoadPB::FeatureID& LaneSection::_internal_traffics(int index) const {
  return traffics_.Get(index);
}
inline const ::RoadPB::FeatureID& LaneSection::traffics(int index) const {
  // @@protoc_insertion_point(field_get:RoadPB.LaneSection.traffics)
  return _internal_traffics(index);
}
inline ::RoadPB::FeatureID* LaneSection::_internal_add_traffics() {
  return traffics_.Add();
}
inline ::RoadPB::FeatureID* LaneSection::add_traffics() {
  // @@protoc_insertion_point(field_add:RoadPB.LaneSection.traffics)
  return _internal_add_traffics();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID >&
LaneSection::traffics() const {
  // @@protoc_insertion_point(field_list:RoadPB.LaneSection.traffics)
  return traffics_;
}

// optional float width = 7;
inline bool LaneSection::_internal_has_width() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LaneSection::has_width() const {
  return _internal_has_width();
}
inline void LaneSection::clear_width() {
  width_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float LaneSection::_internal_width() const {
  return width_;
}
inline float LaneSection::width() const {
  // @@protoc_insertion_point(field_get:RoadPB.LaneSection.width)
  return _internal_width();
}
inline void LaneSection::_internal_set_width(float value) {
  _has_bits_[0] |= 0x00000004u;
  width_ = value;
}
inline void LaneSection::set_width(float value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:RoadPB.LaneSection.width)
}

// optional float height_limit = 8;
inline bool LaneSection::_internal_has_height_limit() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LaneSection::has_height_limit() const {
  return _internal_has_height_limit();
}
inline void LaneSection::clear_height_limit() {
  height_limit_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float LaneSection::_internal_height_limit() const {
  return height_limit_;
}
inline float LaneSection::height_limit() const {
  // @@protoc_insertion_point(field_get:RoadPB.LaneSection.height_limit)
  return _internal_height_limit();
}
inline void LaneSection::_internal_set_height_limit(float value) {
  _has_bits_[0] |= 0x00000008u;
  height_limit_ = value;
}
inline void LaneSection::set_height_limit(float value) {
  _internal_set_height_limit(value);
  // @@protoc_insertion_point(field_set:RoadPB.LaneSection.height_limit)
}

// optional float weight_limit = 9;
inline bool LaneSection::_internal_has_weight_limit() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool LaneSection::has_weight_limit() const {
  return _internal_has_weight_limit();
}
inline void LaneSection::clear_weight_limit() {
  weight_limit_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline float LaneSection::_internal_weight_limit() const {
  return weight_limit_;
}
inline float LaneSection::weight_limit() const {
  // @@protoc_insertion_point(field_get:RoadPB.LaneSection.weight_limit)
  return _internal_weight_limit();
}
inline void LaneSection::_internal_set_weight_limit(float value) {
  _has_bits_[0] |= 0x00000010u;
  weight_limit_ = value;
}
inline void LaneSection::set_weight_limit(float value) {
  _internal_set_weight_limit(value);
  // @@protoc_insertion_point(field_set:RoadPB.LaneSection.weight_limit)
}

// optional float width_limit = 10;
inline bool LaneSection::_internal_has_width_limit() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool LaneSection::has_width_limit() const {
  return _internal_has_width_limit();
}
inline void LaneSection::clear_width_limit() {
  width_limit_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline float LaneSection::_internal_width_limit() const {
  return width_limit_;
}
inline float LaneSection::width_limit() const {
  // @@protoc_insertion_point(field_get:RoadPB.LaneSection.width_limit)
  return _internal_width_limit();
}
inline void LaneSection::_internal_set_width_limit(float value) {
  _has_bits_[0] |= 0x00000020u;
  width_limit_ = value;
}
inline void LaneSection::set_width_limit(float value) {
  _internal_set_width_limit(value);
  // @@protoc_insertion_point(field_set:RoadPB.LaneSection.width_limit)
}

// -------------------------------------------------------------------

// Lane

// optional .RoadPB.FeatureID id = 1;
inline bool Lane::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || id_ != nullptr);
  return value;
}
inline bool Lane::has_id() const {
  return _internal_has_id();
}
inline const ::RoadPB::FeatureID& Lane::_internal_id() const {
  const ::RoadPB::FeatureID* p = id_;
  return p != nullptr ? *p : *reinterpret_cast<const ::RoadPB::FeatureID*>(
      &::RoadPB::_FeatureID_default_instance_);
}
inline const ::RoadPB::FeatureID& Lane::id() const {
  // @@protoc_insertion_point(field_get:RoadPB.Lane.id)
  return _internal_id();
}
inline void Lane::unsafe_arena_set_allocated_id(
    ::RoadPB::FeatureID* id) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  id_ = id;
  if (id) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RoadPB.Lane.id)
}
inline ::RoadPB::FeatureID* Lane::release_id() {
  auto temp = unsafe_arena_release_id();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::RoadPB::FeatureID* Lane::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:RoadPB.Lane.id)
  _has_bits_[0] &= ~0x00000001u;
  ::RoadPB::FeatureID* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::RoadPB::FeatureID* Lane::_internal_mutable_id() {
  _has_bits_[0] |= 0x00000001u;
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::RoadPB::FeatureID>(GetArena());
    id_ = p;
  }
  return id_;
}
inline ::RoadPB::FeatureID* Lane::mutable_id() {
  // @@protoc_insertion_point(field_mutable:RoadPB.Lane.id)
  return _internal_mutable_id();
}
inline void Lane::set_allocated_id(::RoadPB::FeatureID* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id)->GetArena();
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:RoadPB.Lane.id)
}

// repeated .RoadPB.LaneSection lanes = 2;
inline int Lane::_internal_lanes_size() const {
  return lanes_.size();
}
inline int Lane::lanes_size() const {
  return _internal_lanes_size();
}
inline void Lane::clear_lanes() {
  lanes_.Clear();
}
inline ::RoadPB::LaneSection* Lane::mutable_lanes(int index) {
  // @@protoc_insertion_point(field_mutable:RoadPB.Lane.lanes)
  return lanes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::LaneSection >*
Lane::mutable_lanes() {
  // @@protoc_insertion_point(field_mutable_list:RoadPB.Lane.lanes)
  return &lanes_;
}
inline const ::RoadPB::LaneSection& Lane::_internal_lanes(int index) const {
  return lanes_.Get(index);
}
inline const ::RoadPB::LaneSection& Lane::lanes(int index) const {
  // @@protoc_insertion_point(field_get:RoadPB.Lane.lanes)
  return _internal_lanes(index);
}
inline ::RoadPB::LaneSection* Lane::_internal_add_lanes() {
  return lanes_.Add();
}
inline ::RoadPB::LaneSection* Lane::add_lanes() {
  // @@protoc_insertion_point(field_add:RoadPB.Lane.lanes)
  return _internal_add_lanes();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::LaneSection >&
Lane::lanes() const {
  // @@protoc_insertion_point(field_list:RoadPB.Lane.lanes)
  return lanes_;
}

// repeated .RoadPB.FeatureID drivelines = 3;
inline int Lane::_internal_drivelines_size() const {
  return drivelines_.size();
}
inline int Lane::drivelines_size() const {
  return _internal_drivelines_size();
}
inline ::RoadPB::FeatureID* Lane::mutable_drivelines(int index) {
  // @@protoc_insertion_point(field_mutable:RoadPB.Lane.drivelines)
  return drivelines_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID >*
Lane::mutable_drivelines() {
  // @@protoc_insertion_point(field_mutable_list:RoadPB.Lane.drivelines)
  return &drivelines_;
}
inline const ::RoadPB::FeatureID& Lane::_internal_drivelines(int index) const {
  return drivelines_.Get(index);
}
inline const ::RoadPB::FeatureID& Lane::drivelines(int index) const {
  // @@protoc_insertion_point(field_get:RoadPB.Lane.drivelines)
  return _internal_drivelines(index);
}
inline ::RoadPB::FeatureID* Lane::_internal_add_drivelines() {
  return drivelines_.Add();
}
inline ::RoadPB::FeatureID* Lane::add_drivelines() {
  // @@protoc_insertion_point(field_add:RoadPB.Lane.drivelines)
  return _internal_add_drivelines();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID >&
Lane::drivelines() const {
  // @@protoc_insertion_point(field_list:RoadPB.Lane.drivelines)
  return drivelines_;
}

// optional int32 function = 4;
inline bool Lane::_internal_has_function() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Lane::has_function() const {
  return _internal_has_function();
}
inline void Lane::clear_function() {
  function_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Lane::_internal_function() const {
  return function_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Lane::function() const {
  // @@protoc_insertion_point(field_get:RoadPB.Lane.function)
  return _internal_function();
}
inline void Lane::_internal_set_function(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  function_ = value;
}
inline void Lane::set_function(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_function(value);
  // @@protoc_insertion_point(field_set:RoadPB.Lane.function)
}

// optional uint64 type = 5;
inline bool Lane::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Lane::has_type() const {
  return _internal_has_type();
}
inline void Lane::clear_type() {
  type_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Lane::_internal_type() const {
  return type_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Lane::type() const {
  // @@protoc_insertion_point(field_get:RoadPB.Lane.type)
  return _internal_type();
}
inline void Lane::_internal_set_type(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  type_ = value;
}
inline void Lane::set_type(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:RoadPB.Lane.type)
}

// repeated .RoadPB.LaneDirection directions = 7;
inline int Lane::_internal_directions_size() const {
  return directions_.size();
}
inline int Lane::directions_size() const {
  return _internal_directions_size();
}
inline void Lane::clear_directions() {
  directions_.Clear();
}
inline ::RoadPB::LaneDirection* Lane::mutable_directions(int index) {
  // @@protoc_insertion_point(field_mutable:RoadPB.Lane.directions)
  return directions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::LaneDirection >*
Lane::mutable_directions() {
  // @@protoc_insertion_point(field_mutable_list:RoadPB.Lane.directions)
  return &directions_;
}
inline const ::RoadPB::LaneDirection& Lane::_internal_directions(int index) const {
  return directions_.Get(index);
}
inline const ::RoadPB::LaneDirection& Lane::directions(int index) const {
  // @@protoc_insertion_point(field_get:RoadPB.Lane.directions)
  return _internal_directions(index);
}
inline ::RoadPB::LaneDirection* Lane::_internal_add_directions() {
  return directions_.Add();
}
inline ::RoadPB::LaneDirection* Lane::add_directions() {
  // @@protoc_insertion_point(field_add:RoadPB.Lane.directions)
  return _internal_add_directions();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::LaneDirection >&
Lane::directions() const {
  // @@protoc_insertion_point(field_list:RoadPB.Lane.directions)
  return directions_;
}

// optional int32 priority = 8;
inline bool Lane::_internal_has_priority() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Lane::has_priority() const {
  return _internal_has_priority();
}
inline void Lane::clear_priority() {
  priority_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Lane::_internal_priority() const {
  return priority_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Lane::priority() const {
  // @@protoc_insertion_point(field_get:RoadPB.Lane.priority)
  return _internal_priority();
}
inline void Lane::_internal_set_priority(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  priority_ = value;
}
inline void Lane::set_priority(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_priority(value);
  // @@protoc_insertion_point(field_set:RoadPB.Lane.priority)
}

// optional float length = 9;
inline bool Lane::_internal_has_length() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Lane::has_length() const {
  return _internal_has_length();
}
inline void Lane::clear_length() {
  length_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline float Lane::_internal_length() const {
  return length_;
}
inline float Lane::length() const {
  // @@protoc_insertion_point(field_get:RoadPB.Lane.length)
  return _internal_length();
}
inline void Lane::_internal_set_length(float value) {
  _has_bits_[0] |= 0x00000010u;
  length_ = value;
}
inline void Lane::set_length(float value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:RoadPB.Lane.length)
}

// optional int32 seq_no = 10;
inline bool Lane::_internal_has_seq_no() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Lane::has_seq_no() const {
  return _internal_has_seq_no();
}
inline void Lane::clear_seq_no() {
  seq_no_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Lane::_internal_seq_no() const {
  return seq_no_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Lane::seq_no() const {
  // @@protoc_insertion_point(field_get:RoadPB.Lane.seq_no)
  return _internal_seq_no();
}
inline void Lane::_internal_set_seq_no(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000020u;
  seq_no_ = value;
}
inline void Lane::set_seq_no(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_seq_no(value);
  // @@protoc_insertion_point(field_set:RoadPB.Lane.seq_no)
}

// repeated .RoadPB.FeatureID preds = 11;
inline int Lane::_internal_preds_size() const {
  return preds_.size();
}
inline int Lane::preds_size() const {
  return _internal_preds_size();
}
inline ::RoadPB::FeatureID* Lane::mutable_preds(int index) {
  // @@protoc_insertion_point(field_mutable:RoadPB.Lane.preds)
  return preds_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID >*
Lane::mutable_preds() {
  // @@protoc_insertion_point(field_mutable_list:RoadPB.Lane.preds)
  return &preds_;
}
inline const ::RoadPB::FeatureID& Lane::_internal_preds(int index) const {
  return preds_.Get(index);
}
inline const ::RoadPB::FeatureID& Lane::preds(int index) const {
  // @@protoc_insertion_point(field_get:RoadPB.Lane.preds)
  return _internal_preds(index);
}
inline ::RoadPB::FeatureID* Lane::_internal_add_preds() {
  return preds_.Add();
}
inline ::RoadPB::FeatureID* Lane::add_preds() {
  // @@protoc_insertion_point(field_add:RoadPB.Lane.preds)
  return _internal_add_preds();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID >&
Lane::preds() const {
  // @@protoc_insertion_point(field_list:RoadPB.Lane.preds)
  return preds_;
}

// repeated .RoadPB.FeatureID succs = 12;
inline int Lane::_internal_succs_size() const {
  return succs_.size();
}
inline int Lane::succs_size() const {
  return _internal_succs_size();
}
inline ::RoadPB::FeatureID* Lane::mutable_succs(int index) {
  // @@protoc_insertion_point(field_mutable:RoadPB.Lane.succs)
  return succs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID >*
Lane::mutable_succs() {
  // @@protoc_insertion_point(field_mutable_list:RoadPB.Lane.succs)
  return &succs_;
}
inline const ::RoadPB::FeatureID& Lane::_internal_succs(int index) const {
  return succs_.Get(index);
}
inline const ::RoadPB::FeatureID& Lane::succs(int index) const {
  // @@protoc_insertion_point(field_get:RoadPB.Lane.succs)
  return _internal_succs(index);
}
inline ::RoadPB::FeatureID* Lane::_internal_add_succs() {
  return succs_.Add();
}
inline ::RoadPB::FeatureID* Lane::add_succs() {
  // @@protoc_insertion_point(field_add:RoadPB.Lane.succs)
  return _internal_add_succs();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID >&
Lane::succs() const {
  // @@protoc_insertion_point(field_list:RoadPB.Lane.succs)
  return succs_;
}

// repeated int32 l_restrictions = 13;
inline int Lane::_internal_l_restrictions_size() const {
  return l_restrictions_.size();
}
inline int Lane::l_restrictions_size() const {
  return _internal_l_restrictions_size();
}
inline void Lane::clear_l_restrictions() {
  l_restrictions_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Lane::_internal_l_restrictions(int index) const {
  return l_restrictions_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Lane::l_restrictions(int index) const {
  // @@protoc_insertion_point(field_get:RoadPB.Lane.l_restrictions)
  return _internal_l_restrictions(index);
}
inline void Lane::set_l_restrictions(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  l_restrictions_.Set(index, value);
  // @@protoc_insertion_point(field_set:RoadPB.Lane.l_restrictions)
}
inline void Lane::_internal_add_l_restrictions(::PROTOBUF_NAMESPACE_ID::int32 value) {
  l_restrictions_.Add(value);
}
inline void Lane::add_l_restrictions(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_l_restrictions(value);
  // @@protoc_insertion_point(field_add:RoadPB.Lane.l_restrictions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
Lane::_internal_l_restrictions() const {
  return l_restrictions_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
Lane::l_restrictions() const {
  // @@protoc_insertion_point(field_list:RoadPB.Lane.l_restrictions)
  return _internal_l_restrictions();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
Lane::_internal_mutable_l_restrictions() {
  return &l_restrictions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
Lane::mutable_l_restrictions() {
  // @@protoc_insertion_point(field_mutable_list:RoadPB.Lane.l_restrictions)
  return _internal_mutable_l_restrictions();
}

// repeated int32 r_restrictions = 14;
inline int Lane::_internal_r_restrictions_size() const {
  return r_restrictions_.size();
}
inline int Lane::r_restrictions_size() const {
  return _internal_r_restrictions_size();
}
inline void Lane::clear_r_restrictions() {
  r_restrictions_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Lane::_internal_r_restrictions(int index) const {
  return r_restrictions_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Lane::r_restrictions(int index) const {
  // @@protoc_insertion_point(field_get:RoadPB.Lane.r_restrictions)
  return _internal_r_restrictions(index);
}
inline void Lane::set_r_restrictions(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  r_restrictions_.Set(index, value);
  // @@protoc_insertion_point(field_set:RoadPB.Lane.r_restrictions)
}
inline void Lane::_internal_add_r_restrictions(::PROTOBUF_NAMESPACE_ID::int32 value) {
  r_restrictions_.Add(value);
}
inline void Lane::add_r_restrictions(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_r_restrictions(value);
  // @@protoc_insertion_point(field_add:RoadPB.Lane.r_restrictions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
Lane::_internal_r_restrictions() const {
  return r_restrictions_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
Lane::r_restrictions() const {
  // @@protoc_insertion_point(field_list:RoadPB.Lane.r_restrictions)
  return _internal_r_restrictions();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
Lane::_internal_mutable_r_restrictions() {
  return &r_restrictions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
Lane::mutable_r_restrictions() {
  // @@protoc_insertion_point(field_mutable_list:RoadPB.Lane.r_restrictions)
  return _internal_mutable_r_restrictions();
}

// optional int32 transition = 15;
inline bool Lane::_internal_has_transition() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Lane::has_transition() const {
  return _internal_has_transition();
}
inline void Lane::clear_transition() {
  transition_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Lane::_internal_transition() const {
  return transition_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Lane::transition() const {
  // @@protoc_insertion_point(field_get:RoadPB.Lane.transition)
  return _internal_transition();
}
inline void Lane::_internal_set_transition(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000040u;
  transition_ = value;
}
inline void Lane::set_transition(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_transition(value);
  // @@protoc_insertion_point(field_set:RoadPB.Lane.transition)
}

// optional int32 turn_limit = 16;
inline bool Lane::_internal_has_turn_limit() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Lane::has_turn_limit() const {
  return _internal_has_turn_limit();
}
inline void Lane::clear_turn_limit() {
  turn_limit_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Lane::_internal_turn_limit() const {
  return turn_limit_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Lane::turn_limit() const {
  // @@protoc_insertion_point(field_get:RoadPB.Lane.turn_limit)
  return _internal_turn_limit();
}
inline void Lane::_internal_set_turn_limit(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000080u;
  turn_limit_ = value;
}
inline void Lane::set_turn_limit(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_turn_limit(value);
  // @@protoc_insertion_point(field_set:RoadPB.Lane.turn_limit)
}

// -------------------------------------------------------------------

// LaneGroup

// optional .RoadPB.FeatureID id = 1;
inline bool LaneGroup::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || id_ != nullptr);
  return value;
}
inline bool LaneGroup::has_id() const {
  return _internal_has_id();
}
inline const ::RoadPB::FeatureID& LaneGroup::_internal_id() const {
  const ::RoadPB::FeatureID* p = id_;
  return p != nullptr ? *p : *reinterpret_cast<const ::RoadPB::FeatureID*>(
      &::RoadPB::_FeatureID_default_instance_);
}
inline const ::RoadPB::FeatureID& LaneGroup::id() const {
  // @@protoc_insertion_point(field_get:RoadPB.LaneGroup.id)
  return _internal_id();
}
inline void LaneGroup::unsafe_arena_set_allocated_id(
    ::RoadPB::FeatureID* id) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  id_ = id;
  if (id) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RoadPB.LaneGroup.id)
}
inline ::RoadPB::FeatureID* LaneGroup::release_id() {
  auto temp = unsafe_arena_release_id();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::RoadPB::FeatureID* LaneGroup::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:RoadPB.LaneGroup.id)
  _has_bits_[0] &= ~0x00000001u;
  ::RoadPB::FeatureID* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::RoadPB::FeatureID* LaneGroup::_internal_mutable_id() {
  _has_bits_[0] |= 0x00000001u;
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::RoadPB::FeatureID>(GetArena());
    id_ = p;
  }
  return id_;
}
inline ::RoadPB::FeatureID* LaneGroup::mutable_id() {
  // @@protoc_insertion_point(field_mutable:RoadPB.LaneGroup.id)
  return _internal_mutable_id();
}
inline void LaneGroup::set_allocated_id(::RoadPB::FeatureID* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id)->GetArena();
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:RoadPB.LaneGroup.id)
}

// optional .RoadPB.FeatureID link_id = 2;
inline bool LaneGroup::_internal_has_link_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || link_id_ != nullptr);
  return value;
}
inline bool LaneGroup::has_link_id() const {
  return _internal_has_link_id();
}
inline const ::RoadPB::FeatureID& LaneGroup::_internal_link_id() const {
  const ::RoadPB::FeatureID* p = link_id_;
  return p != nullptr ? *p : *reinterpret_cast<const ::RoadPB::FeatureID*>(
      &::RoadPB::_FeatureID_default_instance_);
}
inline const ::RoadPB::FeatureID& LaneGroup::link_id() const {
  // @@protoc_insertion_point(field_get:RoadPB.LaneGroup.link_id)
  return _internal_link_id();
}
inline void LaneGroup::unsafe_arena_set_allocated_link_id(
    ::RoadPB::FeatureID* link_id) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(link_id_);
  }
  link_id_ = link_id;
  if (link_id) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RoadPB.LaneGroup.link_id)
}
inline ::RoadPB::FeatureID* LaneGroup::release_link_id() {
  auto temp = unsafe_arena_release_link_id();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::RoadPB::FeatureID* LaneGroup::unsafe_arena_release_link_id() {
  // @@protoc_insertion_point(field_release:RoadPB.LaneGroup.link_id)
  _has_bits_[0] &= ~0x00000002u;
  ::RoadPB::FeatureID* temp = link_id_;
  link_id_ = nullptr;
  return temp;
}
inline ::RoadPB::FeatureID* LaneGroup::_internal_mutable_link_id() {
  _has_bits_[0] |= 0x00000002u;
  if (link_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::RoadPB::FeatureID>(GetArena());
    link_id_ = p;
  }
  return link_id_;
}
inline ::RoadPB::FeatureID* LaneGroup::mutable_link_id() {
  // @@protoc_insertion_point(field_mutable:RoadPB.LaneGroup.link_id)
  return _internal_mutable_link_id();
}
inline void LaneGroup::set_allocated_link_id(::RoadPB::FeatureID* link_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(link_id_);
  }
  if (link_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(link_id)->GetArena();
    if (message_arena != submessage_arena) {
      link_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, link_id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  link_id_ = link_id;
  // @@protoc_insertion_point(field_set_allocated:RoadPB.LaneGroup.link_id)
}

// repeated int32 types = 4;
inline int LaneGroup::_internal_types_size() const {
  return types_.size();
}
inline int LaneGroup::types_size() const {
  return _internal_types_size();
}
inline void LaneGroup::clear_types() {
  types_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LaneGroup::_internal_types(int index) const {
  return types_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LaneGroup::types(int index) const {
  // @@protoc_insertion_point(field_get:RoadPB.LaneGroup.types)
  return _internal_types(index);
}
inline void LaneGroup::set_types(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  types_.Set(index, value);
  // @@protoc_insertion_point(field_set:RoadPB.LaneGroup.types)
}
inline void LaneGroup::_internal_add_types(::PROTOBUF_NAMESPACE_ID::int32 value) {
  types_.Add(value);
}
inline void LaneGroup::add_types(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_types(value);
  // @@protoc_insertion_point(field_add:RoadPB.LaneGroup.types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
LaneGroup::_internal_types() const {
  return types_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
LaneGroup::types() const {
  // @@protoc_insertion_point(field_list:RoadPB.LaneGroup.types)
  return _internal_types();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
LaneGroup::_internal_mutable_types() {
  return &types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
LaneGroup::mutable_types() {
  // @@protoc_insertion_point(field_mutable_list:RoadPB.LaneGroup.types)
  return _internal_mutable_types();
}

// repeated .RoadPB.FeatureID left_boundarys = 6;
inline int LaneGroup::_internal_left_boundarys_size() const {
  return left_boundarys_.size();
}
inline int LaneGroup::left_boundarys_size() const {
  return _internal_left_boundarys_size();
}
inline ::RoadPB::FeatureID* LaneGroup::mutable_left_boundarys(int index) {
  // @@protoc_insertion_point(field_mutable:RoadPB.LaneGroup.left_boundarys)
  return left_boundarys_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID >*
LaneGroup::mutable_left_boundarys() {
  // @@protoc_insertion_point(field_mutable_list:RoadPB.LaneGroup.left_boundarys)
  return &left_boundarys_;
}
inline const ::RoadPB::FeatureID& LaneGroup::_internal_left_boundarys(int index) const {
  return left_boundarys_.Get(index);
}
inline const ::RoadPB::FeatureID& LaneGroup::left_boundarys(int index) const {
  // @@protoc_insertion_point(field_get:RoadPB.LaneGroup.left_boundarys)
  return _internal_left_boundarys(index);
}
inline ::RoadPB::FeatureID* LaneGroup::_internal_add_left_boundarys() {
  return left_boundarys_.Add();
}
inline ::RoadPB::FeatureID* LaneGroup::add_left_boundarys() {
  // @@protoc_insertion_point(field_add:RoadPB.LaneGroup.left_boundarys)
  return _internal_add_left_boundarys();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID >&
LaneGroup::left_boundarys() const {
  // @@protoc_insertion_point(field_list:RoadPB.LaneGroup.left_boundarys)
  return left_boundarys_;
}

// repeated .RoadPB.FeatureID right_boundarys = 7;
inline int LaneGroup::_internal_right_boundarys_size() const {
  return right_boundarys_.size();
}
inline int LaneGroup::right_boundarys_size() const {
  return _internal_right_boundarys_size();
}
inline ::RoadPB::FeatureID* LaneGroup::mutable_right_boundarys(int index) {
  // @@protoc_insertion_point(field_mutable:RoadPB.LaneGroup.right_boundarys)
  return right_boundarys_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID >*
LaneGroup::mutable_right_boundarys() {
  // @@protoc_insertion_point(field_mutable_list:RoadPB.LaneGroup.right_boundarys)
  return &right_boundarys_;
}
inline const ::RoadPB::FeatureID& LaneGroup::_internal_right_boundarys(int index) const {
  return right_boundarys_.Get(index);
}
inline const ::RoadPB::FeatureID& LaneGroup::right_boundarys(int index) const {
  // @@protoc_insertion_point(field_get:RoadPB.LaneGroup.right_boundarys)
  return _internal_right_boundarys(index);
}
inline ::RoadPB::FeatureID* LaneGroup::_internal_add_right_boundarys() {
  return right_boundarys_.Add();
}
inline ::RoadPB::FeatureID* LaneGroup::add_right_boundarys() {
  // @@protoc_insertion_point(field_add:RoadPB.LaneGroup.right_boundarys)
  return _internal_add_right_boundarys();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID >&
LaneGroup::right_boundarys() const {
  // @@protoc_insertion_point(field_list:RoadPB.LaneGroup.right_boundarys)
  return right_boundarys_;
}

// repeated .RoadPB.FeatureID lanes = 8;
inline int LaneGroup::_internal_lanes_size() const {
  return lanes_.size();
}
inline int LaneGroup::lanes_size() const {
  return _internal_lanes_size();
}
inline ::RoadPB::FeatureID* LaneGroup::mutable_lanes(int index) {
  // @@protoc_insertion_point(field_mutable:RoadPB.LaneGroup.lanes)
  return lanes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID >*
LaneGroup::mutable_lanes() {
  // @@protoc_insertion_point(field_mutable_list:RoadPB.LaneGroup.lanes)
  return &lanes_;
}
inline const ::RoadPB::FeatureID& LaneGroup::_internal_lanes(int index) const {
  return lanes_.Get(index);
}
inline const ::RoadPB::FeatureID& LaneGroup::lanes(int index) const {
  // @@protoc_insertion_point(field_get:RoadPB.LaneGroup.lanes)
  return _internal_lanes(index);
}
inline ::RoadPB::FeatureID* LaneGroup::_internal_add_lanes() {
  return lanes_.Add();
}
inline ::RoadPB::FeatureID* LaneGroup::add_lanes() {
  // @@protoc_insertion_point(field_add:RoadPB.LaneGroup.lanes)
  return _internal_add_lanes();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID >&
LaneGroup::lanes() const {
  // @@protoc_insertion_point(field_list:RoadPB.LaneGroup.lanes)
  return lanes_;
}

// repeated .RoadPB.FeatureID preds = 9;
inline int LaneGroup::_internal_preds_size() const {
  return preds_.size();
}
inline int LaneGroup::preds_size() const {
  return _internal_preds_size();
}
inline ::RoadPB::FeatureID* LaneGroup::mutable_preds(int index) {
  // @@protoc_insertion_point(field_mutable:RoadPB.LaneGroup.preds)
  return preds_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID >*
LaneGroup::mutable_preds() {
  // @@protoc_insertion_point(field_mutable_list:RoadPB.LaneGroup.preds)
  return &preds_;
}
inline const ::RoadPB::FeatureID& LaneGroup::_internal_preds(int index) const {
  return preds_.Get(index);
}
inline const ::RoadPB::FeatureID& LaneGroup::preds(int index) const {
  // @@protoc_insertion_point(field_get:RoadPB.LaneGroup.preds)
  return _internal_preds(index);
}
inline ::RoadPB::FeatureID* LaneGroup::_internal_add_preds() {
  return preds_.Add();
}
inline ::RoadPB::FeatureID* LaneGroup::add_preds() {
  // @@protoc_insertion_point(field_add:RoadPB.LaneGroup.preds)
  return _internal_add_preds();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID >&
LaneGroup::preds() const {
  // @@protoc_insertion_point(field_list:RoadPB.LaneGroup.preds)
  return preds_;
}

// repeated .RoadPB.FeatureID succs = 10;
inline int LaneGroup::_internal_succs_size() const {
  return succs_.size();
}
inline int LaneGroup::succs_size() const {
  return _internal_succs_size();
}
inline ::RoadPB::FeatureID* LaneGroup::mutable_succs(int index) {
  // @@protoc_insertion_point(field_mutable:RoadPB.LaneGroup.succs)
  return succs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID >*
LaneGroup::mutable_succs() {
  // @@protoc_insertion_point(field_mutable_list:RoadPB.LaneGroup.succs)
  return &succs_;
}
inline const ::RoadPB::FeatureID& LaneGroup::_internal_succs(int index) const {
  return succs_.Get(index);
}
inline const ::RoadPB::FeatureID& LaneGroup::succs(int index) const {
  // @@protoc_insertion_point(field_get:RoadPB.LaneGroup.succs)
  return _internal_succs(index);
}
inline ::RoadPB::FeatureID* LaneGroup::_internal_add_succs() {
  return succs_.Add();
}
inline ::RoadPB::FeatureID* LaneGroup::add_succs() {
  // @@protoc_insertion_point(field_add:RoadPB.LaneGroup.succs)
  return _internal_add_succs();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID >&
LaneGroup::succs() const {
  // @@protoc_insertion_point(field_list:RoadPB.LaneGroup.succs)
  return succs_;
}

// -------------------------------------------------------------------

// ImpassableArea

// optional .RoadPB.Polygon geom = 1;
inline bool ImpassableArea::_internal_has_geom() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || geom_ != nullptr);
  return value;
}
inline bool ImpassableArea::has_geom() const {
  return _internal_has_geom();
}
inline const ::RoadPB::Polygon& ImpassableArea::_internal_geom() const {
  const ::RoadPB::Polygon* p = geom_;
  return p != nullptr ? *p : *reinterpret_cast<const ::RoadPB::Polygon*>(
      &::RoadPB::_Polygon_default_instance_);
}
inline const ::RoadPB::Polygon& ImpassableArea::geom() const {
  // @@protoc_insertion_point(field_get:RoadPB.ImpassableArea.geom)
  return _internal_geom();
}
inline void ImpassableArea::unsafe_arena_set_allocated_geom(
    ::RoadPB::Polygon* geom) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(geom_);
  }
  geom_ = geom;
  if (geom) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RoadPB.ImpassableArea.geom)
}
inline ::RoadPB::Polygon* ImpassableArea::release_geom() {
  auto temp = unsafe_arena_release_geom();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::RoadPB::Polygon* ImpassableArea::unsafe_arena_release_geom() {
  // @@protoc_insertion_point(field_release:RoadPB.ImpassableArea.geom)
  _has_bits_[0] &= ~0x00000001u;
  ::RoadPB::Polygon* temp = geom_;
  geom_ = nullptr;
  return temp;
}
inline ::RoadPB::Polygon* ImpassableArea::_internal_mutable_geom() {
  _has_bits_[0] |= 0x00000001u;
  if (geom_ == nullptr) {
    auto* p = CreateMaybeMessage<::RoadPB::Polygon>(GetArena());
    geom_ = p;
  }
  return geom_;
}
inline ::RoadPB::Polygon* ImpassableArea::mutable_geom() {
  // @@protoc_insertion_point(field_mutable:RoadPB.ImpassableArea.geom)
  return _internal_mutable_geom();
}
inline void ImpassableArea::set_allocated_geom(::RoadPB::Polygon* geom) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(geom_);
  }
  if (geom) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(geom)->GetArena();
    if (message_arena != submessage_arena) {
      geom = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, geom, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  geom_ = geom;
  // @@protoc_insertion_point(field_set_allocated:RoadPB.ImpassableArea.geom)
}

// optional int32 type = 2;
inline bool ImpassableArea::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ImpassableArea::has_type() const {
  return _internal_has_type();
}
inline void ImpassableArea::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ImpassableArea::_internal_type() const {
  return type_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ImpassableArea::type() const {
  // @@protoc_insertion_point(field_get:RoadPB.ImpassableArea.type)
  return _internal_type();
}
inline void ImpassableArea::_internal_set_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  type_ = value;
}
inline void ImpassableArea::set_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:RoadPB.ImpassableArea.type)
}

// optional int32 kind = 3;
inline bool ImpassableArea::_internal_has_kind() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ImpassableArea::has_kind() const {
  return _internal_has_kind();
}
inline void ImpassableArea::clear_kind() {
  kind_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ImpassableArea::_internal_kind() const {
  return kind_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ImpassableArea::kind() const {
  // @@protoc_insertion_point(field_get:RoadPB.ImpassableArea.kind)
  return _internal_kind();
}
inline void ImpassableArea::_internal_set_kind(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  kind_ = value;
}
inline void ImpassableArea::set_kind(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_kind(value);
  // @@protoc_insertion_point(field_set:RoadPB.ImpassableArea.kind)
}

// -------------------------------------------------------------------

// Junction

// optional .RoadPB.FeatureID id = 1;
inline bool Junction::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || id_ != nullptr);
  return value;
}
inline bool Junction::has_id() const {
  return _internal_has_id();
}
inline const ::RoadPB::FeatureID& Junction::_internal_id() const {
  const ::RoadPB::FeatureID* p = id_;
  return p != nullptr ? *p : *reinterpret_cast<const ::RoadPB::FeatureID*>(
      &::RoadPB::_FeatureID_default_instance_);
}
inline const ::RoadPB::FeatureID& Junction::id() const {
  // @@protoc_insertion_point(field_get:RoadPB.Junction.id)
  return _internal_id();
}
inline void Junction::unsafe_arena_set_allocated_id(
    ::RoadPB::FeatureID* id) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  id_ = id;
  if (id) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RoadPB.Junction.id)
}
inline ::RoadPB::FeatureID* Junction::release_id() {
  auto temp = unsafe_arena_release_id();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::RoadPB::FeatureID* Junction::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:RoadPB.Junction.id)
  _has_bits_[0] &= ~0x00000001u;
  ::RoadPB::FeatureID* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::RoadPB::FeatureID* Junction::_internal_mutable_id() {
  _has_bits_[0] |= 0x00000001u;
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::RoadPB::FeatureID>(GetArena());
    id_ = p;
  }
  return id_;
}
inline ::RoadPB::FeatureID* Junction::mutable_id() {
  // @@protoc_insertion_point(field_mutable:RoadPB.Junction.id)
  return _internal_mutable_id();
}
inline void Junction::set_allocated_id(::RoadPB::FeatureID* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id)->GetArena();
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:RoadPB.Junction.id)
}

// optional .RoadPB.FeatureID node_id = 3;
inline bool Junction::_internal_has_node_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || node_id_ != nullptr);
  return value;
}
inline bool Junction::has_node_id() const {
  return _internal_has_node_id();
}
inline const ::RoadPB::FeatureID& Junction::_internal_node_id() const {
  const ::RoadPB::FeatureID* p = node_id_;
  return p != nullptr ? *p : *reinterpret_cast<const ::RoadPB::FeatureID*>(
      &::RoadPB::_FeatureID_default_instance_);
}
inline const ::RoadPB::FeatureID& Junction::node_id() const {
  // @@protoc_insertion_point(field_get:RoadPB.Junction.node_id)
  return _internal_node_id();
}
inline void Junction::unsafe_arena_set_allocated_node_id(
    ::RoadPB::FeatureID* node_id) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(node_id_);
  }
  node_id_ = node_id;
  if (node_id) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RoadPB.Junction.node_id)
}
inline ::RoadPB::FeatureID* Junction::release_node_id() {
  auto temp = unsafe_arena_release_node_id();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::RoadPB::FeatureID* Junction::unsafe_arena_release_node_id() {
  // @@protoc_insertion_point(field_release:RoadPB.Junction.node_id)
  _has_bits_[0] &= ~0x00000002u;
  ::RoadPB::FeatureID* temp = node_id_;
  node_id_ = nullptr;
  return temp;
}
inline ::RoadPB::FeatureID* Junction::_internal_mutable_node_id() {
  _has_bits_[0] |= 0x00000002u;
  if (node_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::RoadPB::FeatureID>(GetArena());
    node_id_ = p;
  }
  return node_id_;
}
inline ::RoadPB::FeatureID* Junction::mutable_node_id() {
  // @@protoc_insertion_point(field_mutable:RoadPB.Junction.node_id)
  return _internal_mutable_node_id();
}
inline void Junction::set_allocated_node_id(::RoadPB::FeatureID* node_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(node_id_);
  }
  if (node_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(node_id)->GetArena();
    if (message_arena != submessage_arena) {
      node_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, node_id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  node_id_ = node_id;
  // @@protoc_insertion_point(field_set_allocated:RoadPB.Junction.node_id)
}

// repeated .RoadPB.ImpassableArea areas = 5;
inline int Junction::_internal_areas_size() const {
  return areas_.size();
}
inline int Junction::areas_size() const {
  return _internal_areas_size();
}
inline void Junction::clear_areas() {
  areas_.Clear();
}
inline ::RoadPB::ImpassableArea* Junction::mutable_areas(int index) {
  // @@protoc_insertion_point(field_mutable:RoadPB.Junction.areas)
  return areas_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::ImpassableArea >*
Junction::mutable_areas() {
  // @@protoc_insertion_point(field_mutable_list:RoadPB.Junction.areas)
  return &areas_;
}
inline const ::RoadPB::ImpassableArea& Junction::_internal_areas(int index) const {
  return areas_.Get(index);
}
inline const ::RoadPB::ImpassableArea& Junction::areas(int index) const {
  // @@protoc_insertion_point(field_get:RoadPB.Junction.areas)
  return _internal_areas(index);
}
inline ::RoadPB::ImpassableArea* Junction::_internal_add_areas() {
  return areas_.Add();
}
inline ::RoadPB::ImpassableArea* Junction::add_areas() {
  // @@protoc_insertion_point(field_add:RoadPB.Junction.areas)
  return _internal_add_areas();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::ImpassableArea >&
Junction::areas() const {
  // @@protoc_insertion_point(field_list:RoadPB.Junction.areas)
  return areas_;
}

// repeated .RoadPB.FeatureID boundarys = 6;
inline int Junction::_internal_boundarys_size() const {
  return boundarys_.size();
}
inline int Junction::boundarys_size() const {
  return _internal_boundarys_size();
}
inline ::RoadPB::FeatureID* Junction::mutable_boundarys(int index) {
  // @@protoc_insertion_point(field_mutable:RoadPB.Junction.boundarys)
  return boundarys_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID >*
Junction::mutable_boundarys() {
  // @@protoc_insertion_point(field_mutable_list:RoadPB.Junction.boundarys)
  return &boundarys_;
}
inline const ::RoadPB::FeatureID& Junction::_internal_boundarys(int index) const {
  return boundarys_.Get(index);
}
inline const ::RoadPB::FeatureID& Junction::boundarys(int index) const {
  // @@protoc_insertion_point(field_get:RoadPB.Junction.boundarys)
  return _internal_boundarys(index);
}
inline ::RoadPB::FeatureID* Junction::_internal_add_boundarys() {
  return boundarys_.Add();
}
inline ::RoadPB::FeatureID* Junction::add_boundarys() {
  // @@protoc_insertion_point(field_add:RoadPB.Junction.boundarys)
  return _internal_add_boundarys();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID >&
Junction::boundarys() const {
  // @@protoc_insertion_point(field_list:RoadPB.Junction.boundarys)
  return boundarys_;
}

// repeated .RoadPB.FeatureID conn_groups = 7;
inline int Junction::_internal_conn_groups_size() const {
  return conn_groups_.size();
}
inline int Junction::conn_groups_size() const {
  return _internal_conn_groups_size();
}
inline ::RoadPB::FeatureID* Junction::mutable_conn_groups(int index) {
  // @@protoc_insertion_point(field_mutable:RoadPB.Junction.conn_groups)
  return conn_groups_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID >*
Junction::mutable_conn_groups() {
  // @@protoc_insertion_point(field_mutable_list:RoadPB.Junction.conn_groups)
  return &conn_groups_;
}
inline const ::RoadPB::FeatureID& Junction::_internal_conn_groups(int index) const {
  return conn_groups_.Get(index);
}
inline const ::RoadPB::FeatureID& Junction::conn_groups(int index) const {
  // @@protoc_insertion_point(field_get:RoadPB.Junction.conn_groups)
  return _internal_conn_groups(index);
}
inline ::RoadPB::FeatureID* Junction::_internal_add_conn_groups() {
  return conn_groups_.Add();
}
inline ::RoadPB::FeatureID* Junction::add_conn_groups() {
  // @@protoc_insertion_point(field_add:RoadPB.Junction.conn_groups)
  return _internal_add_conn_groups();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID >&
Junction::conn_groups() const {
  // @@protoc_insertion_point(field_list:RoadPB.Junction.conn_groups)
  return conn_groups_;
}

// repeated .RoadPB.FeatureID in_groups = 8;
inline int Junction::_internal_in_groups_size() const {
  return in_groups_.size();
}
inline int Junction::in_groups_size() const {
  return _internal_in_groups_size();
}
inline ::RoadPB::FeatureID* Junction::mutable_in_groups(int index) {
  // @@protoc_insertion_point(field_mutable:RoadPB.Junction.in_groups)
  return in_groups_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID >*
Junction::mutable_in_groups() {
  // @@protoc_insertion_point(field_mutable_list:RoadPB.Junction.in_groups)
  return &in_groups_;
}
inline const ::RoadPB::FeatureID& Junction::_internal_in_groups(int index) const {
  return in_groups_.Get(index);
}
inline const ::RoadPB::FeatureID& Junction::in_groups(int index) const {
  // @@protoc_insertion_point(field_get:RoadPB.Junction.in_groups)
  return _internal_in_groups(index);
}
inline ::RoadPB::FeatureID* Junction::_internal_add_in_groups() {
  return in_groups_.Add();
}
inline ::RoadPB::FeatureID* Junction::add_in_groups() {
  // @@protoc_insertion_point(field_add:RoadPB.Junction.in_groups)
  return _internal_add_in_groups();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID >&
Junction::in_groups() const {
  // @@protoc_insertion_point(field_list:RoadPB.Junction.in_groups)
  return in_groups_;
}

// repeated .RoadPB.FeatureID out_groups = 9;
inline int Junction::_internal_out_groups_size() const {
  return out_groups_.size();
}
inline int Junction::out_groups_size() const {
  return _internal_out_groups_size();
}
inline ::RoadPB::FeatureID* Junction::mutable_out_groups(int index) {
  // @@protoc_insertion_point(field_mutable:RoadPB.Junction.out_groups)
  return out_groups_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID >*
Junction::mutable_out_groups() {
  // @@protoc_insertion_point(field_mutable_list:RoadPB.Junction.out_groups)
  return &out_groups_;
}
inline const ::RoadPB::FeatureID& Junction::_internal_out_groups(int index) const {
  return out_groups_.Get(index);
}
inline const ::RoadPB::FeatureID& Junction::out_groups(int index) const {
  // @@protoc_insertion_point(field_get:RoadPB.Junction.out_groups)
  return _internal_out_groups(index);
}
inline ::RoadPB::FeatureID* Junction::_internal_add_out_groups() {
  return out_groups_.Add();
}
inline ::RoadPB::FeatureID* Junction::add_out_groups() {
  // @@protoc_insertion_point(field_add:RoadPB.Junction.out_groups)
  return _internal_add_out_groups();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID >&
Junction::out_groups() const {
  // @@protoc_insertion_point(field_list:RoadPB.Junction.out_groups)
  return out_groups_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace RoadPB

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::RoadPB::LaneDirection_Direction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RoadPB::LaneDirection_Direction>() {
  return ::RoadPB::LaneDirection_Direction_descriptor();
}
template <> struct is_proto_enum< ::RoadPB::LaneBoundary_Color> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RoadPB::LaneBoundary_Color>() {
  return ::RoadPB::LaneBoundary_Color_descriptor();
}
template <> struct is_proto_enum< ::RoadPB::LaneBoundary_LaneLineType_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RoadPB::LaneBoundary_LaneLineType_Type>() {
  return ::RoadPB::LaneBoundary_LaneLineType_Type_descriptor();
}
template <> struct is_proto_enum< ::RoadPB::LaneBoundary_LaneBoundaryType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RoadPB::LaneBoundary_LaneBoundaryType>() {
  return ::RoadPB::LaneBoundary_LaneBoundaryType_descriptor();
}
template <> struct is_proto_enum< ::RoadPB::LaneBoundary_LineMarking> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RoadPB::LaneBoundary_LineMarking>() {
  return ::RoadPB::LaneBoundary_LineMarking_descriptor();
}
template <> struct is_proto_enum< ::RoadPB::LaneBoundary_MarkingType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RoadPB::LaneBoundary_MarkingType>() {
  return ::RoadPB::LaneBoundary_MarkingType_descriptor();
}
template <> struct is_proto_enum< ::RoadPB::RoadBoundary_RoadBoundaryType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RoadPB::RoadBoundary_RoadBoundaryType>() {
  return ::RoadPB::RoadBoundary_RoadBoundaryType_descriptor();
}
template <> struct is_proto_enum< ::RoadPB::Lane_Function> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RoadPB::Lane_Function>() {
  return ::RoadPB::Lane_Function_descriptor();
}
template <> struct is_proto_enum< ::RoadPB::Lane_LaneType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RoadPB::Lane_LaneType>() {
  return ::RoadPB::Lane_LaneType_descriptor();
}
template <> struct is_proto_enum< ::RoadPB::Lane_LanePriority> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RoadPB::Lane_LanePriority>() {
  return ::RoadPB::Lane_LanePriority_descriptor();
}
template <> struct is_proto_enum< ::RoadPB::Lane_LaneLineRestrictionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RoadPB::Lane_LaneLineRestrictionType>() {
  return ::RoadPB::Lane_LaneLineRestrictionType_descriptor();
}
template <> struct is_proto_enum< ::RoadPB::Lane_LaneTransition> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RoadPB::Lane_LaneTransition>() {
  return ::RoadPB::Lane_LaneTransition_descriptor();
}
template <> struct is_proto_enum< ::RoadPB::Lane_TurnLimit> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RoadPB::Lane_TurnLimit>() {
  return ::RoadPB::Lane_TurnLimit_descriptor();
}
template <> struct is_proto_enum< ::RoadPB::LaneGroup_LaneGroupType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RoadPB::LaneGroup_LaneGroupType>() {
  return ::RoadPB::LaneGroup_LaneGroupType_descriptor();
}
template <> struct is_proto_enum< ::RoadPB::ImpassableArea_Kind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RoadPB::ImpassableArea_Kind>() {
  return ::RoadPB::ImpassableArea_Kind_descriptor();
}
template <> struct is_proto_enum< ::RoadPB::VehicleType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RoadPB::VehicleType>() {
  return ::RoadPB::VehicleType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_lane_2flane_2eproto
