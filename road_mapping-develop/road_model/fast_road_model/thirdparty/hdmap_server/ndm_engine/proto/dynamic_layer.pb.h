// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dynamic_layer.proto

#ifndef PROTOBUF_dynamic_5flayer_2eproto__INCLUDED
#define PROTOBUF_dynamic_5flayer_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "base.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_dynamic_5flayer_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[15];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsObjectAttributeImpl();
void InitDefaultsObjectAttribute();
void InitDefaultsSignalImpl();
void InitDefaultsSignal();
void InitDefaultsSignalSequenceImpl();
void InitDefaultsSignalSequence();
void InitDefaultsMoveableObjectImpl();
void InitDefaultsMoveableObject();
void InitDefaultsTrafficLightBulbStateImpl();
void InitDefaultsTrafficLightBulbState();
void InitDefaultsTrafficLightBulbSequenceImpl();
void InitDefaultsTrafficLightBulbSequence();
void InitDefaultsTrafficLightDynamicStateImpl();
void InitDefaultsTrafficLightDynamicState();
void InitDefaultsParkingSlotStateImpl();
void InitDefaultsParkingSlotState();
void InitDefaultsTrafficConeImpl();
void InitDefaultsTrafficCone();
void InitDefaultsConstructionZoneImpl();
void InitDefaultsConstructionZone();
void InitDefaultsRestrictedZoneImpl();
void InitDefaultsRestrictedZone();
void InitDefaultsStaticODDImpl();
void InitDefaultsStaticODD();
void InitDefaultsTrafficEventImpl();
void InitDefaultsTrafficEvent();
void InitDefaultsTrafficFlowImpl();
void InitDefaultsTrafficFlow();
void InitDefaultsDynamicLayerImpl();
void InitDefaultsDynamicLayer();
inline void InitDefaults() {
  InitDefaultsObjectAttribute();
  InitDefaultsSignal();
  InitDefaultsSignalSequence();
  InitDefaultsMoveableObject();
  InitDefaultsTrafficLightBulbState();
  InitDefaultsTrafficLightBulbSequence();
  InitDefaultsTrafficLightDynamicState();
  InitDefaultsParkingSlotState();
  InitDefaultsTrafficCone();
  InitDefaultsConstructionZone();
  InitDefaultsRestrictedZone();
  InitDefaultsStaticODD();
  InitDefaultsTrafficEvent();
  InitDefaultsTrafficFlow();
  InitDefaultsDynamicLayer();
}
}  // namespace protobuf_dynamic_5flayer_2eproto
namespace ndm_proto {
class ConstructionZone;
class ConstructionZoneDefaultTypeInternal;
extern ConstructionZoneDefaultTypeInternal _ConstructionZone_default_instance_;
class DynamicLayer;
class DynamicLayerDefaultTypeInternal;
extern DynamicLayerDefaultTypeInternal _DynamicLayer_default_instance_;
class MoveableObject;
class MoveableObjectDefaultTypeInternal;
extern MoveableObjectDefaultTypeInternal _MoveableObject_default_instance_;
class ObjectAttribute;
class ObjectAttributeDefaultTypeInternal;
extern ObjectAttributeDefaultTypeInternal _ObjectAttribute_default_instance_;
class ParkingSlotState;
class ParkingSlotStateDefaultTypeInternal;
extern ParkingSlotStateDefaultTypeInternal _ParkingSlotState_default_instance_;
class RestrictedZone;
class RestrictedZoneDefaultTypeInternal;
extern RestrictedZoneDefaultTypeInternal _RestrictedZone_default_instance_;
class Signal;
class SignalDefaultTypeInternal;
extern SignalDefaultTypeInternal _Signal_default_instance_;
class SignalSequence;
class SignalSequenceDefaultTypeInternal;
extern SignalSequenceDefaultTypeInternal _SignalSequence_default_instance_;
class StaticODD;
class StaticODDDefaultTypeInternal;
extern StaticODDDefaultTypeInternal _StaticODD_default_instance_;
class TrafficCone;
class TrafficConeDefaultTypeInternal;
extern TrafficConeDefaultTypeInternal _TrafficCone_default_instance_;
class TrafficEvent;
class TrafficEventDefaultTypeInternal;
extern TrafficEventDefaultTypeInternal _TrafficEvent_default_instance_;
class TrafficFlow;
class TrafficFlowDefaultTypeInternal;
extern TrafficFlowDefaultTypeInternal _TrafficFlow_default_instance_;
class TrafficLightBulbSequence;
class TrafficLightBulbSequenceDefaultTypeInternal;
extern TrafficLightBulbSequenceDefaultTypeInternal _TrafficLightBulbSequence_default_instance_;
class TrafficLightBulbState;
class TrafficLightBulbStateDefaultTypeInternal;
extern TrafficLightBulbStateDefaultTypeInternal _TrafficLightBulbState_default_instance_;
class TrafficLightDynamicState;
class TrafficLightDynamicStateDefaultTypeInternal;
extern TrafficLightDynamicStateDefaultTypeInternal _TrafficLightDynamicState_default_instance_;
}  // namespace ndm_proto
namespace ndm_proto {

enum ObjectAttribute_ObjectType {
  ObjectAttribute_ObjectType_UNKNOWN = 0,
  ObjectAttribute_ObjectType_VEHICLE = 1,
  ObjectAttribute_ObjectType_TWOWHEEL = 2,
  ObjectAttribute_ObjectType_PEDESTRIAN = 3
};
bool ObjectAttribute_ObjectType_IsValid(int value);
const ObjectAttribute_ObjectType ObjectAttribute_ObjectType_ObjectType_MIN = ObjectAttribute_ObjectType_UNKNOWN;
const ObjectAttribute_ObjectType ObjectAttribute_ObjectType_ObjectType_MAX = ObjectAttribute_ObjectType_PEDESTRIAN;
const int ObjectAttribute_ObjectType_ObjectType_ARRAYSIZE = ObjectAttribute_ObjectType_ObjectType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ObjectAttribute_ObjectType_descriptor();
inline const ::std::string& ObjectAttribute_ObjectType_Name(ObjectAttribute_ObjectType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ObjectAttribute_ObjectType_descriptor(), value);
}
inline bool ObjectAttribute_ObjectType_Parse(
    const ::std::string& name, ObjectAttribute_ObjectType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ObjectAttribute_ObjectType>(
    ObjectAttribute_ObjectType_descriptor(), name, value);
}
// ===================================================================

class ObjectAttribute : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.ObjectAttribute) */ {
 public:
  ObjectAttribute();
  virtual ~ObjectAttribute();

  ObjectAttribute(const ObjectAttribute& from);

  inline ObjectAttribute& operator=(const ObjectAttribute& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ObjectAttribute(ObjectAttribute&& from) noexcept
    : ObjectAttribute() {
    *this = ::std::move(from);
  }

  inline ObjectAttribute& operator=(ObjectAttribute&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ObjectAttribute& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObjectAttribute* internal_default_instance() {
    return reinterpret_cast<const ObjectAttribute*>(
               &_ObjectAttribute_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(ObjectAttribute* other);
  friend void swap(ObjectAttribute& a, ObjectAttribute& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ObjectAttribute* New() const PROTOBUF_FINAL { return New(NULL); }

  ObjectAttribute* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ObjectAttribute& from);
  void MergeFrom(const ObjectAttribute& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ObjectAttribute* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ObjectAttribute_ObjectType ObjectType;
  static const ObjectType UNKNOWN =
    ObjectAttribute_ObjectType_UNKNOWN;
  static const ObjectType VEHICLE =
    ObjectAttribute_ObjectType_VEHICLE;
  static const ObjectType TWOWHEEL =
    ObjectAttribute_ObjectType_TWOWHEEL;
  static const ObjectType PEDESTRIAN =
    ObjectAttribute_ObjectType_PEDESTRIAN;
  static inline bool ObjectType_IsValid(int value) {
    return ObjectAttribute_ObjectType_IsValid(value);
  }
  static const ObjectType ObjectType_MIN =
    ObjectAttribute_ObjectType_ObjectType_MIN;
  static const ObjectType ObjectType_MAX =
    ObjectAttribute_ObjectType_ObjectType_MAX;
  static const int ObjectType_ARRAYSIZE =
    ObjectAttribute_ObjectType_ObjectType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ObjectType_descriptor() {
    return ObjectAttribute_ObjectType_descriptor();
  }
  static inline const ::std::string& ObjectType_Name(ObjectType value) {
    return ObjectAttribute_ObjectType_Name(value);
  }
  static inline bool ObjectType_Parse(const ::std::string& name,
      ObjectType* value) {
    return ObjectAttribute_ObjectType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated uint32 rgb = 1;
  int rgb_size() const;
  void clear_rgb();
  static const int kRgbFieldNumber = 1;
  ::google::protobuf::uint32 rgb(int index) const;
  void set_rgb(int index, ::google::protobuf::uint32 value);
  void add_rgb(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      rgb() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_rgb();

  // repeated .ndm_proto.Point key_points = 5;
  int key_points_size() const;
  void clear_key_points();
  static const int kKeyPointsFieldNumber = 5;
  const ::ndm_proto::Point& key_points(int index) const;
  ::ndm_proto::Point* mutable_key_points(int index);
  ::ndm_proto::Point* add_key_points();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point >*
      mutable_key_points();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point >&
      key_points() const;

  // repeated .ndm_proto.Point polygon_points = 6;
  int polygon_points_size() const;
  void clear_polygon_points();
  static const int kPolygonPointsFieldNumber = 6;
  const ::ndm_proto::Point& polygon_points(int index) const;
  ::ndm_proto::Point* mutable_polygon_points(int index);
  ::ndm_proto::Point* add_polygon_points();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point >*
      mutable_polygon_points();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point >&
      polygon_points() const;

  // optional string identity = 40;
  bool has_identity() const;
  void clear_identity();
  static const int kIdentityFieldNumber = 40;
  const ::std::string& identity() const;
  void set_identity(const ::std::string& value);
  #if LANG_CXX11
  void set_identity(::std::string&& value);
  #endif
  void set_identity(const char* value);
  void set_identity(const char* value, size_t size);
  ::std::string* mutable_identity();
  ::std::string* release_identity();
  void set_allocated_identity(::std::string* identity);

  // optional .ndm_proto.Point lwh = 2;
  bool has_lwh() const;
  void clear_lwh();
  static const int kLwhFieldNumber = 2;
  const ::ndm_proto::Point& lwh() const;
  ::ndm_proto::Point* release_lwh();
  ::ndm_proto::Point* mutable_lwh();
  void set_allocated_lwh(::ndm_proto::Point* lwh);

  // optional uint32 intention_ind = 34;
  bool has_intention_ind() const;
  void clear_intention_ind();
  static const int kIntentionIndFieldNumber = 34;
  ::google::protobuf::uint32 intention_ind() const;
  void set_intention_ind(::google::protobuf::uint32 value);

  // optional .ndm_proto.ObjectAttribute.ObjectType type = 30;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 30;
  ::ndm_proto::ObjectAttribute_ObjectType type() const;
  void set_type(::ndm_proto::ObjectAttribute_ObjectType value);

  // optional uint32 class_ind = 31;
  bool has_class_ind() const;
  void clear_class_ind();
  static const int kClassIndFieldNumber = 31;
  ::google::protobuf::uint32 class_ind() const;
  void set_class_ind(::google::protobuf::uint32 value);

  // optional uint32 action_ind = 32;
  bool has_action_ind() const;
  void clear_action_ind();
  static const int kActionIndFieldNumber = 32;
  ::google::protobuf::uint32 action_ind() const;
  void set_action_ind(::google::protobuf::uint32 value);

  // optional uint32 behavior_ind = 33;
  bool has_behavior_ind() const;
  void clear_behavior_ind();
  static const int kBehaviorIndFieldNumber = 33;
  ::google::protobuf::uint32 behavior_ind() const;
  void set_behavior_ind(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ndm_proto.ObjectAttribute)
 private:
  void set_has_lwh();
  void clear_has_lwh();
  void set_has_type();
  void clear_has_type();
  void set_has_class_ind();
  void clear_has_class_ind();
  void set_has_action_ind();
  void clear_has_action_ind();
  void set_has_behavior_ind();
  void clear_has_behavior_ind();
  void set_has_intention_ind();
  void clear_has_intention_ind();
  void set_has_identity();
  void clear_has_identity();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > rgb_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point > key_points_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point > polygon_points_;
  ::google::protobuf::internal::ArenaStringPtr identity_;
  ::ndm_proto::Point* lwh_;
  ::google::protobuf::uint32 intention_ind_;
  int type_;
  ::google::protobuf::uint32 class_ind_;
  ::google::protobuf::uint32 action_ind_;
  ::google::protobuf::uint32 behavior_ind_;
  friend struct ::protobuf_dynamic_5flayer_2eproto::TableStruct;
  friend void ::protobuf_dynamic_5flayer_2eproto::InitDefaultsObjectAttributeImpl();
};
// -------------------------------------------------------------------

class Signal : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.Signal) */ {
 public:
  Signal();
  virtual ~Signal();

  Signal(const Signal& from);

  inline Signal& operator=(const Signal& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Signal(Signal&& from) noexcept
    : Signal() {
    *this = ::std::move(from);
  }

  inline Signal& operator=(Signal&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Signal& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Signal* internal_default_instance() {
    return reinterpret_cast<const Signal*>(
               &_Signal_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Signal* other);
  friend void swap(Signal& a, Signal& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Signal* New() const PROTOBUF_FINAL { return New(NULL); }

  Signal* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Signal& from);
  void MergeFrom(const Signal& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Signal* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 stamp = 1;
  bool has_stamp() const;
  void clear_stamp();
  static const int kStampFieldNumber = 1;
  ::google::protobuf::uint64 stamp() const;
  void set_stamp(::google::protobuf::uint64 value);

  // optional uint32 seq_id = 2;
  bool has_seq_id() const;
  void clear_seq_id();
  static const int kSeqIdFieldNumber = 2;
  ::google::protobuf::uint32 seq_id() const;
  void set_seq_id(::google::protobuf::uint32 value);

  // required uint32 signal = 10;
  bool has_signal() const;
  void clear_signal();
  static const int kSignalFieldNumber = 10;
  ::google::protobuf::uint32 signal() const;
  void set_signal(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ndm_proto.Signal)
 private:
  void set_has_stamp();
  void clear_has_stamp();
  void set_has_seq_id();
  void clear_has_seq_id();
  void set_has_signal();
  void clear_has_signal();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint64 stamp_;
  ::google::protobuf::uint32 seq_id_;
  ::google::protobuf::uint32 signal_;
  friend struct ::protobuf_dynamic_5flayer_2eproto::TableStruct;
  friend void ::protobuf_dynamic_5flayer_2eproto::InitDefaultsSignalImpl();
};
// -------------------------------------------------------------------

class SignalSequence : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.SignalSequence) */ {
 public:
  SignalSequence();
  virtual ~SignalSequence();

  SignalSequence(const SignalSequence& from);

  inline SignalSequence& operator=(const SignalSequence& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SignalSequence(SignalSequence&& from) noexcept
    : SignalSequence() {
    *this = ::std::move(from);
  }

  inline SignalSequence& operator=(SignalSequence&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SignalSequence& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SignalSequence* internal_default_instance() {
    return reinterpret_cast<const SignalSequence*>(
               &_SignalSequence_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(SignalSequence* other);
  friend void swap(SignalSequence& a, SignalSequence& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SignalSequence* New() const PROTOBUF_FINAL { return New(NULL); }

  SignalSequence* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SignalSequence& from);
  void MergeFrom(const SignalSequence& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SignalSequence* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ndm_proto.Signal signals = 10;
  int signals_size() const;
  void clear_signals();
  static const int kSignalsFieldNumber = 10;
  const ::ndm_proto::Signal& signals(int index) const;
  ::ndm_proto::Signal* mutable_signals(int index);
  ::ndm_proto::Signal* add_signals();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Signal >*
      mutable_signals();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Signal >&
      signals() const;

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // required uint64 stamp = 2;
  bool has_stamp() const;
  void clear_stamp();
  static const int kStampFieldNumber = 2;
  ::google::protobuf::uint64 stamp() const;
  void set_stamp(::google::protobuf::uint64 value);

  // optional uint32 seq_id = 3;
  bool has_seq_id() const;
  void clear_seq_id();
  static const int kSeqIdFieldNumber = 3;
  ::google::protobuf::uint32 seq_id() const;
  void set_seq_id(::google::protobuf::uint32 value);

  // required float life_time = 4;
  bool has_life_time() const;
  void clear_life_time();
  static const int kLifeTimeFieldNumber = 4;
  float life_time() const;
  void set_life_time(float value);

  // @@protoc_insertion_point(class_scope:ndm_proto.SignalSequence)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_stamp();
  void clear_has_stamp();
  void set_has_seq_id();
  void clear_has_seq_id();
  void set_has_life_time();
  void clear_has_life_time();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Signal > signals_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::uint64 stamp_;
  ::google::protobuf::uint32 seq_id_;
  float life_time_;
  friend struct ::protobuf_dynamic_5flayer_2eproto::TableStruct;
  friend void ::protobuf_dynamic_5flayer_2eproto::InitDefaultsSignalSequenceImpl();
};
// -------------------------------------------------------------------

class MoveableObject : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.MoveableObject) */ {
 public:
  MoveableObject();
  virtual ~MoveableObject();

  MoveableObject(const MoveableObject& from);

  inline MoveableObject& operator=(const MoveableObject& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MoveableObject(MoveableObject&& from) noexcept
    : MoveableObject() {
    *this = ::std::move(from);
  }

  inline MoveableObject& operator=(MoveableObject&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MoveableObject& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MoveableObject* internal_default_instance() {
    return reinterpret_cast<const MoveableObject*>(
               &_MoveableObject_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(MoveableObject* other);
  friend void swap(MoveableObject& a, MoveableObject& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MoveableObject* New() const PROTOBUF_FINAL { return New(NULL); }

  MoveableObject* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MoveableObject& from);
  void MergeFrom(const MoveableObject& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MoveableObject* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ndm_proto.Trajectory predict_trajectorys = 11;
  int predict_trajectorys_size() const;
  void clear_predict_trajectorys();
  static const int kPredictTrajectorysFieldNumber = 11;
  const ::ndm_proto::Trajectory& predict_trajectorys(int index) const;
  ::ndm_proto::Trajectory* mutable_predict_trajectorys(int index);
  ::ndm_proto::Trajectory* add_predict_trajectorys();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Trajectory >*
      mutable_predict_trajectorys();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Trajectory >&
      predict_trajectorys() const;

  // repeated .ndm_proto.SignalSequence predict_signal_seqs = 13;
  int predict_signal_seqs_size() const;
  void clear_predict_signal_seqs();
  static const int kPredictSignalSeqsFieldNumber = 13;
  const ::ndm_proto::SignalSequence& predict_signal_seqs(int index) const;
  ::ndm_proto::SignalSequence* mutable_predict_signal_seqs(int index);
  ::ndm_proto::SignalSequence* add_predict_signal_seqs();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::SignalSequence >*
      mutable_predict_signal_seqs();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::SignalSequence >&
      predict_signal_seqs() const;

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // optional .ndm_proto.ObjectAttribute attr = 8;
  bool has_attr() const;
  void clear_attr();
  static const int kAttrFieldNumber = 8;
  const ::ndm_proto::ObjectAttribute& attr() const;
  ::ndm_proto::ObjectAttribute* release_attr();
  ::ndm_proto::ObjectAttribute* mutable_attr();
  void set_allocated_attr(::ndm_proto::ObjectAttribute* attr);

  // required .ndm_proto.Trajectory trajectory = 10;
  bool has_trajectory() const;
  void clear_trajectory();
  static const int kTrajectoryFieldNumber = 10;
  const ::ndm_proto::Trajectory& trajectory() const;
  ::ndm_proto::Trajectory* release_trajectory();
  ::ndm_proto::Trajectory* mutable_trajectory();
  void set_allocated_trajectory(::ndm_proto::Trajectory* trajectory);

  // required .ndm_proto.SignalSequence signal_seq = 12;
  bool has_signal_seq() const;
  void clear_signal_seq();
  static const int kSignalSeqFieldNumber = 12;
  const ::ndm_proto::SignalSequence& signal_seq() const;
  ::ndm_proto::SignalSequence* release_signal_seq();
  ::ndm_proto::SignalSequence* mutable_signal_seq();
  void set_allocated_signal_seq(::ndm_proto::SignalSequence* signal_seq);

  // required uint64 stamp = 2;
  bool has_stamp() const;
  void clear_stamp();
  static const int kStampFieldNumber = 2;
  ::google::protobuf::uint64 stamp() const;
  void set_stamp(::google::protobuf::uint64 value);

  // optional uint32 seq_id = 3;
  bool has_seq_id() const;
  void clear_seq_id();
  static const int kSeqIdFieldNumber = 3;
  ::google::protobuf::uint32 seq_id() const;
  void set_seq_id(::google::protobuf::uint32 value);

  // required float life_time = 4;
  bool has_life_time() const;
  void clear_life_time();
  static const int kLifeTimeFieldNumber = 4;
  float life_time() const;
  void set_life_time(float value);

  // @@protoc_insertion_point(class_scope:ndm_proto.MoveableObject)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_stamp();
  void clear_has_stamp();
  void set_has_seq_id();
  void clear_has_seq_id();
  void set_has_life_time();
  void clear_has_life_time();
  void set_has_attr();
  void clear_has_attr();
  void set_has_trajectory();
  void clear_has_trajectory();
  void set_has_signal_seq();
  void clear_has_signal_seq();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Trajectory > predict_trajectorys_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::SignalSequence > predict_signal_seqs_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::ndm_proto::ObjectAttribute* attr_;
  ::ndm_proto::Trajectory* trajectory_;
  ::ndm_proto::SignalSequence* signal_seq_;
  ::google::protobuf::uint64 stamp_;
  ::google::protobuf::uint32 seq_id_;
  float life_time_;
  friend struct ::protobuf_dynamic_5flayer_2eproto::TableStruct;
  friend void ::protobuf_dynamic_5flayer_2eproto::InitDefaultsMoveableObjectImpl();
};
// -------------------------------------------------------------------

class TrafficLightBulbState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.TrafficLightBulbState) */ {
 public:
  TrafficLightBulbState();
  virtual ~TrafficLightBulbState();

  TrafficLightBulbState(const TrafficLightBulbState& from);

  inline TrafficLightBulbState& operator=(const TrafficLightBulbState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TrafficLightBulbState(TrafficLightBulbState&& from) noexcept
    : TrafficLightBulbState() {
    *this = ::std::move(from);
  }

  inline TrafficLightBulbState& operator=(TrafficLightBulbState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TrafficLightBulbState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrafficLightBulbState* internal_default_instance() {
    return reinterpret_cast<const TrafficLightBulbState*>(
               &_TrafficLightBulbState_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(TrafficLightBulbState* other);
  friend void swap(TrafficLightBulbState& a, TrafficLightBulbState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrafficLightBulbState* New() const PROTOBUF_FINAL { return New(NULL); }

  TrafficLightBulbState* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TrafficLightBulbState& from);
  void MergeFrom(const TrafficLightBulbState& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TrafficLightBulbState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ndm_proto.TrafficLightBulbColor color = 10;
  bool has_color() const;
  void clear_color();
  static const int kColorFieldNumber = 10;
  const ::ndm_proto::TrafficLightBulbColor& color() const;
  ::ndm_proto::TrafficLightBulbColor* release_color();
  ::ndm_proto::TrafficLightBulbColor* mutable_color();
  void set_allocated_color(::ndm_proto::TrafficLightBulbColor* color);

  // required uint64 stamp = 1;
  bool has_stamp() const;
  void clear_stamp();
  static const int kStampFieldNumber = 1;
  ::google::protobuf::uint64 stamp() const;
  void set_stamp(::google::protobuf::uint64 value);

  // optional uint32 seq_id = 2;
  bool has_seq_id() const;
  void clear_seq_id();
  static const int kSeqIdFieldNumber = 2;
  ::google::protobuf::uint32 seq_id() const;
  void set_seq_id(::google::protobuf::uint32 value);

  // optional bool is_flashing = 11;
  bool has_is_flashing() const;
  void clear_is_flashing();
  static const int kIsFlashingFieldNumber = 11;
  bool is_flashing() const;
  void set_is_flashing(bool value);

  // @@protoc_insertion_point(class_scope:ndm_proto.TrafficLightBulbState)
 private:
  void set_has_stamp();
  void clear_has_stamp();
  void set_has_seq_id();
  void clear_has_seq_id();
  void set_has_color();
  void clear_has_color();
  void set_has_is_flashing();
  void clear_has_is_flashing();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::ndm_proto::TrafficLightBulbColor* color_;
  ::google::protobuf::uint64 stamp_;
  ::google::protobuf::uint32 seq_id_;
  bool is_flashing_;
  friend struct ::protobuf_dynamic_5flayer_2eproto::TableStruct;
  friend void ::protobuf_dynamic_5flayer_2eproto::InitDefaultsTrafficLightBulbStateImpl();
};
// -------------------------------------------------------------------

class TrafficLightBulbSequence : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.TrafficLightBulbSequence) */ {
 public:
  TrafficLightBulbSequence();
  virtual ~TrafficLightBulbSequence();

  TrafficLightBulbSequence(const TrafficLightBulbSequence& from);

  inline TrafficLightBulbSequence& operator=(const TrafficLightBulbSequence& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TrafficLightBulbSequence(TrafficLightBulbSequence&& from) noexcept
    : TrafficLightBulbSequence() {
    *this = ::std::move(from);
  }

  inline TrafficLightBulbSequence& operator=(TrafficLightBulbSequence&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TrafficLightBulbSequence& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrafficLightBulbSequence* internal_default_instance() {
    return reinterpret_cast<const TrafficLightBulbSequence*>(
               &_TrafficLightBulbSequence_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(TrafficLightBulbSequence* other);
  friend void swap(TrafficLightBulbSequence& a, TrafficLightBulbSequence& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrafficLightBulbSequence* New() const PROTOBUF_FINAL { return New(NULL); }

  TrafficLightBulbSequence* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TrafficLightBulbSequence& from);
  void MergeFrom(const TrafficLightBulbSequence& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TrafficLightBulbSequence* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ndm_proto.TrafficLightBulbState bulb_states = 10;
  int bulb_states_size() const;
  void clear_bulb_states();
  static const int kBulbStatesFieldNumber = 10;
  const ::ndm_proto::TrafficLightBulbState& bulb_states(int index) const;
  ::ndm_proto::TrafficLightBulbState* mutable_bulb_states(int index);
  ::ndm_proto::TrafficLightBulbState* add_bulb_states();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::TrafficLightBulbState >*
      mutable_bulb_states();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::TrafficLightBulbState >&
      bulb_states() const;

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // required string associate_trafficlightbulb_id = 5;
  bool has_associate_trafficlightbulb_id() const;
  void clear_associate_trafficlightbulb_id();
  static const int kAssociateTrafficlightbulbIdFieldNumber = 5;
  const ::std::string& associate_trafficlightbulb_id() const;
  void set_associate_trafficlightbulb_id(const ::std::string& value);
  #if LANG_CXX11
  void set_associate_trafficlightbulb_id(::std::string&& value);
  #endif
  void set_associate_trafficlightbulb_id(const char* value);
  void set_associate_trafficlightbulb_id(const char* value, size_t size);
  ::std::string* mutable_associate_trafficlightbulb_id();
  ::std::string* release_associate_trafficlightbulb_id();
  void set_allocated_associate_trafficlightbulb_id(::std::string* associate_trafficlightbulb_id);

  // required uint64 stamp = 2;
  bool has_stamp() const;
  void clear_stamp();
  static const int kStampFieldNumber = 2;
  ::google::protobuf::uint64 stamp() const;
  void set_stamp(::google::protobuf::uint64 value);

  // optional uint32 seq_id = 3;
  bool has_seq_id() const;
  void clear_seq_id();
  static const int kSeqIdFieldNumber = 3;
  ::google::protobuf::uint32 seq_id() const;
  void set_seq_id(::google::protobuf::uint32 value);

  // required float life_time = 4;
  bool has_life_time() const;
  void clear_life_time();
  static const int kLifeTimeFieldNumber = 4;
  float life_time() const;
  void set_life_time(float value);

  // @@protoc_insertion_point(class_scope:ndm_proto.TrafficLightBulbSequence)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_stamp();
  void clear_has_stamp();
  void set_has_seq_id();
  void clear_has_seq_id();
  void set_has_life_time();
  void clear_has_life_time();
  void set_has_associate_trafficlightbulb_id();
  void clear_has_associate_trafficlightbulb_id();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::TrafficLightBulbState > bulb_states_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr associate_trafficlightbulb_id_;
  ::google::protobuf::uint64 stamp_;
  ::google::protobuf::uint32 seq_id_;
  float life_time_;
  friend struct ::protobuf_dynamic_5flayer_2eproto::TableStruct;
  friend void ::protobuf_dynamic_5flayer_2eproto::InitDefaultsTrafficLightBulbSequenceImpl();
};
// -------------------------------------------------------------------

class TrafficLightDynamicState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.TrafficLightDynamicState) */ {
 public:
  TrafficLightDynamicState();
  virtual ~TrafficLightDynamicState();

  TrafficLightDynamicState(const TrafficLightDynamicState& from);

  inline TrafficLightDynamicState& operator=(const TrafficLightDynamicState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TrafficLightDynamicState(TrafficLightDynamicState&& from) noexcept
    : TrafficLightDynamicState() {
    *this = ::std::move(from);
  }

  inline TrafficLightDynamicState& operator=(TrafficLightDynamicState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TrafficLightDynamicState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrafficLightDynamicState* internal_default_instance() {
    return reinterpret_cast<const TrafficLightDynamicState*>(
               &_TrafficLightDynamicState_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(TrafficLightDynamicState* other);
  friend void swap(TrafficLightDynamicState& a, TrafficLightDynamicState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrafficLightDynamicState* New() const PROTOBUF_FINAL { return New(NULL); }

  TrafficLightDynamicState* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TrafficLightDynamicState& from);
  void MergeFrom(const TrafficLightDynamicState& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TrafficLightDynamicState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ndm_proto.TrafficLightBulbSequence bulb_seqs = 10;
  int bulb_seqs_size() const;
  void clear_bulb_seqs();
  static const int kBulbSeqsFieldNumber = 10;
  const ::ndm_proto::TrafficLightBulbSequence& bulb_seqs(int index) const;
  ::ndm_proto::TrafficLightBulbSequence* mutable_bulb_seqs(int index);
  ::ndm_proto::TrafficLightBulbSequence* add_bulb_seqs();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::TrafficLightBulbSequence >*
      mutable_bulb_seqs();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::TrafficLightBulbSequence >&
      bulb_seqs() const;

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // required string associate_trafficlight_id = 5;
  bool has_associate_trafficlight_id() const;
  void clear_associate_trafficlight_id();
  static const int kAssociateTrafficlightIdFieldNumber = 5;
  const ::std::string& associate_trafficlight_id() const;
  void set_associate_trafficlight_id(const ::std::string& value);
  #if LANG_CXX11
  void set_associate_trafficlight_id(::std::string&& value);
  #endif
  void set_associate_trafficlight_id(const char* value);
  void set_associate_trafficlight_id(const char* value, size_t size);
  ::std::string* mutable_associate_trafficlight_id();
  ::std::string* release_associate_trafficlight_id();
  void set_allocated_associate_trafficlight_id(::std::string* associate_trafficlight_id);

  // required uint64 stamp = 2;
  bool has_stamp() const;
  void clear_stamp();
  static const int kStampFieldNumber = 2;
  ::google::protobuf::uint64 stamp() const;
  void set_stamp(::google::protobuf::uint64 value);

  // optional uint32 seq_id = 3;
  bool has_seq_id() const;
  void clear_seq_id();
  static const int kSeqIdFieldNumber = 3;
  ::google::protobuf::uint32 seq_id() const;
  void set_seq_id(::google::protobuf::uint32 value);

  // required float life_time = 4;
  bool has_life_time() const;
  void clear_life_time();
  static const int kLifeTimeFieldNumber = 4;
  float life_time() const;
  void set_life_time(float value);

  // @@protoc_insertion_point(class_scope:ndm_proto.TrafficLightDynamicState)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_stamp();
  void clear_has_stamp();
  void set_has_seq_id();
  void clear_has_seq_id();
  void set_has_life_time();
  void clear_has_life_time();
  void set_has_associate_trafficlight_id();
  void clear_has_associate_trafficlight_id();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::TrafficLightBulbSequence > bulb_seqs_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr associate_trafficlight_id_;
  ::google::protobuf::uint64 stamp_;
  ::google::protobuf::uint32 seq_id_;
  float life_time_;
  friend struct ::protobuf_dynamic_5flayer_2eproto::TableStruct;
  friend void ::protobuf_dynamic_5flayer_2eproto::InitDefaultsTrafficLightDynamicStateImpl();
};
// -------------------------------------------------------------------

class ParkingSlotState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.ParkingSlotState) */ {
 public:
  ParkingSlotState();
  virtual ~ParkingSlotState();

  ParkingSlotState(const ParkingSlotState& from);

  inline ParkingSlotState& operator=(const ParkingSlotState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ParkingSlotState(ParkingSlotState&& from) noexcept
    : ParkingSlotState() {
    *this = ::std::move(from);
  }

  inline ParkingSlotState& operator=(ParkingSlotState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ParkingSlotState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ParkingSlotState* internal_default_instance() {
    return reinterpret_cast<const ParkingSlotState*>(
               &_ParkingSlotState_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(ParkingSlotState* other);
  friend void swap(ParkingSlotState& a, ParkingSlotState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ParkingSlotState* New() const PROTOBUF_FINAL { return New(NULL); }

  ParkingSlotState* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ParkingSlotState& from);
  void MergeFrom(const ParkingSlotState& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ParkingSlotState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // required string associate_parkingslot_id = 5;
  bool has_associate_parkingslot_id() const;
  void clear_associate_parkingslot_id();
  static const int kAssociateParkingslotIdFieldNumber = 5;
  const ::std::string& associate_parkingslot_id() const;
  void set_associate_parkingslot_id(const ::std::string& value);
  #if LANG_CXX11
  void set_associate_parkingslot_id(::std::string&& value);
  #endif
  void set_associate_parkingslot_id(const char* value);
  void set_associate_parkingslot_id(const char* value, size_t size);
  ::std::string* mutable_associate_parkingslot_id();
  ::std::string* release_associate_parkingslot_id();
  void set_allocated_associate_parkingslot_id(::std::string* associate_parkingslot_id);

  // required uint64 stamp = 2;
  bool has_stamp() const;
  void clear_stamp();
  static const int kStampFieldNumber = 2;
  ::google::protobuf::uint64 stamp() const;
  void set_stamp(::google::protobuf::uint64 value);

  // optional uint32 seq_id = 3;
  bool has_seq_id() const;
  void clear_seq_id();
  static const int kSeqIdFieldNumber = 3;
  ::google::protobuf::uint32 seq_id() const;
  void set_seq_id(::google::protobuf::uint32 value);

  // required float life_time = 4;
  bool has_life_time() const;
  void clear_life_time();
  static const int kLifeTimeFieldNumber = 4;
  float life_time() const;
  void set_life_time(float value);

  // required bool is_occupied = 10;
  bool has_is_occupied() const;
  void clear_is_occupied();
  static const int kIsOccupiedFieldNumber = 10;
  bool is_occupied() const;
  void set_is_occupied(bool value);

  // @@protoc_insertion_point(class_scope:ndm_proto.ParkingSlotState)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_stamp();
  void clear_has_stamp();
  void set_has_seq_id();
  void clear_has_seq_id();
  void set_has_life_time();
  void clear_has_life_time();
  void set_has_associate_parkingslot_id();
  void clear_has_associate_parkingslot_id();
  void set_has_is_occupied();
  void clear_has_is_occupied();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr associate_parkingslot_id_;
  ::google::protobuf::uint64 stamp_;
  ::google::protobuf::uint32 seq_id_;
  float life_time_;
  bool is_occupied_;
  friend struct ::protobuf_dynamic_5flayer_2eproto::TableStruct;
  friend void ::protobuf_dynamic_5flayer_2eproto::InitDefaultsParkingSlotStateImpl();
};
// -------------------------------------------------------------------

class TrafficCone : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.TrafficCone) */ {
 public:
  TrafficCone();
  virtual ~TrafficCone();

  TrafficCone(const TrafficCone& from);

  inline TrafficCone& operator=(const TrafficCone& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TrafficCone(TrafficCone&& from) noexcept
    : TrafficCone() {
    *this = ::std::move(from);
  }

  inline TrafficCone& operator=(TrafficCone&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TrafficCone& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrafficCone* internal_default_instance() {
    return reinterpret_cast<const TrafficCone*>(
               &_TrafficCone_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(TrafficCone* other);
  friend void swap(TrafficCone& a, TrafficCone& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrafficCone* New() const PROTOBUF_FINAL { return New(NULL); }

  TrafficCone* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TrafficCone& from);
  void MergeFrom(const TrafficCone& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TrafficCone* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // required .ndm_proto.Polygon border = 2;
  bool has_border() const;
  void clear_border();
  static const int kBorderFieldNumber = 2;
  const ::ndm_proto::Polygon& border() const;
  ::ndm_proto::Polygon* release_border();
  ::ndm_proto::Polygon* mutable_border();
  void set_allocated_border(::ndm_proto::Polygon* border);

  // optional .ndm_proto.Number height = 3;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 3;
  const ::ndm_proto::Number& height() const;
  ::ndm_proto::Number* release_height();
  ::ndm_proto::Number* mutable_height();
  void set_allocated_height(::ndm_proto::Number* height);

  // optional .ndm_proto.TrafficConeType type = 4;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 4;
  ::ndm_proto::TrafficConeType type() const;
  void set_type(::ndm_proto::TrafficConeType value);

  // @@protoc_insertion_point(class_scope:ndm_proto.TrafficCone)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_border();
  void clear_has_border();
  void set_has_height();
  void clear_has_height();
  void set_has_type();
  void clear_has_type();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::ndm_proto::Polygon* border_;
  ::ndm_proto::Number* height_;
  int type_;
  friend struct ::protobuf_dynamic_5flayer_2eproto::TableStruct;
  friend void ::protobuf_dynamic_5flayer_2eproto::InitDefaultsTrafficConeImpl();
};
// -------------------------------------------------------------------

class ConstructionZone : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.ConstructionZone) */ {
 public:
  ConstructionZone();
  virtual ~ConstructionZone();

  ConstructionZone(const ConstructionZone& from);

  inline ConstructionZone& operator=(const ConstructionZone& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConstructionZone(ConstructionZone&& from) noexcept
    : ConstructionZone() {
    *this = ::std::move(from);
  }

  inline ConstructionZone& operator=(ConstructionZone&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConstructionZone& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConstructionZone* internal_default_instance() {
    return reinterpret_cast<const ConstructionZone*>(
               &_ConstructionZone_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(ConstructionZone* other);
  friend void swap(ConstructionZone& a, ConstructionZone& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConstructionZone* New() const PROTOBUF_FINAL { return New(NULL); }

  ConstructionZone* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ConstructionZone& from);
  void MergeFrom(const ConstructionZone& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ConstructionZone* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string associate_ids = 11;
  int associate_ids_size() const;
  void clear_associate_ids();
  static const int kAssociateIdsFieldNumber = 11;
  const ::std::string& associate_ids(int index) const;
  ::std::string* mutable_associate_ids(int index);
  void set_associate_ids(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_associate_ids(int index, ::std::string&& value);
  #endif
  void set_associate_ids(int index, const char* value);
  void set_associate_ids(int index, const char* value, size_t size);
  ::std::string* add_associate_ids();
  void add_associate_ids(const ::std::string& value);
  #if LANG_CXX11
  void add_associate_ids(::std::string&& value);
  #endif
  void add_associate_ids(const char* value);
  void add_associate_ids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& associate_ids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_associate_ids();

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // required .ndm_proto.Polygon border = 10;
  bool has_border() const;
  void clear_border();
  static const int kBorderFieldNumber = 10;
  const ::ndm_proto::Polygon& border() const;
  ::ndm_proto::Polygon* release_border();
  ::ndm_proto::Polygon* mutable_border();
  void set_allocated_border(::ndm_proto::Polygon* border);

  // required uint64 stamp = 2;
  bool has_stamp() const;
  void clear_stamp();
  static const int kStampFieldNumber = 2;
  ::google::protobuf::uint64 stamp() const;
  void set_stamp(::google::protobuf::uint64 value);

  // optional uint32 seq_id = 3;
  bool has_seq_id() const;
  void clear_seq_id();
  static const int kSeqIdFieldNumber = 3;
  ::google::protobuf::uint32 seq_id() const;
  void set_seq_id(::google::protobuf::uint32 value);

  // required float life_time = 4;
  bool has_life_time() const;
  void clear_life_time();
  static const int kLifeTimeFieldNumber = 4;
  float life_time() const;
  void set_life_time(float value);

  // @@protoc_insertion_point(class_scope:ndm_proto.ConstructionZone)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_stamp();
  void clear_has_stamp();
  void set_has_seq_id();
  void clear_has_seq_id();
  void set_has_life_time();
  void clear_has_life_time();
  void set_has_border();
  void clear_has_border();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> associate_ids_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::ndm_proto::Polygon* border_;
  ::google::protobuf::uint64 stamp_;
  ::google::protobuf::uint32 seq_id_;
  float life_time_;
  friend struct ::protobuf_dynamic_5flayer_2eproto::TableStruct;
  friend void ::protobuf_dynamic_5flayer_2eproto::InitDefaultsConstructionZoneImpl();
};
// -------------------------------------------------------------------

class RestrictedZone : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.RestrictedZone) */ {
 public:
  RestrictedZone();
  virtual ~RestrictedZone();

  RestrictedZone(const RestrictedZone& from);

  inline RestrictedZone& operator=(const RestrictedZone& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RestrictedZone(RestrictedZone&& from) noexcept
    : RestrictedZone() {
    *this = ::std::move(from);
  }

  inline RestrictedZone& operator=(RestrictedZone&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RestrictedZone& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RestrictedZone* internal_default_instance() {
    return reinterpret_cast<const RestrictedZone*>(
               &_RestrictedZone_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(RestrictedZone* other);
  friend void swap(RestrictedZone& a, RestrictedZone& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RestrictedZone* New() const PROTOBUF_FINAL { return New(NULL); }

  RestrictedZone* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RestrictedZone& from);
  void MergeFrom(const RestrictedZone& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RestrictedZone* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string associate_ids = 11;
  int associate_ids_size() const;
  void clear_associate_ids();
  static const int kAssociateIdsFieldNumber = 11;
  const ::std::string& associate_ids(int index) const;
  ::std::string* mutable_associate_ids(int index);
  void set_associate_ids(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_associate_ids(int index, ::std::string&& value);
  #endif
  void set_associate_ids(int index, const char* value);
  void set_associate_ids(int index, const char* value, size_t size);
  ::std::string* add_associate_ids();
  void add_associate_ids(const ::std::string& value);
  #if LANG_CXX11
  void add_associate_ids(::std::string&& value);
  #endif
  void add_associate_ids(const char* value);
  void add_associate_ids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& associate_ids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_associate_ids();

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // required .ndm_proto.Polygon border = 10;
  bool has_border() const;
  void clear_border();
  static const int kBorderFieldNumber = 10;
  const ::ndm_proto::Polygon& border() const;
  ::ndm_proto::Polygon* release_border();
  ::ndm_proto::Polygon* mutable_border();
  void set_allocated_border(::ndm_proto::Polygon* border);

  // required uint64 stamp = 2;
  bool has_stamp() const;
  void clear_stamp();
  static const int kStampFieldNumber = 2;
  ::google::protobuf::uint64 stamp() const;
  void set_stamp(::google::protobuf::uint64 value);

  // optional uint32 seq_id = 3;
  bool has_seq_id() const;
  void clear_seq_id();
  static const int kSeqIdFieldNumber = 3;
  ::google::protobuf::uint32 seq_id() const;
  void set_seq_id(::google::protobuf::uint32 value);

  // required float life_time = 4;
  bool has_life_time() const;
  void clear_life_time();
  static const int kLifeTimeFieldNumber = 4;
  float life_time() const;
  void set_life_time(float value);

  // @@protoc_insertion_point(class_scope:ndm_proto.RestrictedZone)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_stamp();
  void clear_has_stamp();
  void set_has_seq_id();
  void clear_has_seq_id();
  void set_has_life_time();
  void clear_has_life_time();
  void set_has_border();
  void clear_has_border();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> associate_ids_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::ndm_proto::Polygon* border_;
  ::google::protobuf::uint64 stamp_;
  ::google::protobuf::uint32 seq_id_;
  float life_time_;
  friend struct ::protobuf_dynamic_5flayer_2eproto::TableStruct;
  friend void ::protobuf_dynamic_5flayer_2eproto::InitDefaultsRestrictedZoneImpl();
};
// -------------------------------------------------------------------

class StaticODD : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.StaticODD) */ {
 public:
  StaticODD();
  virtual ~StaticODD();

  StaticODD(const StaticODD& from);

  inline StaticODD& operator=(const StaticODD& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StaticODD(StaticODD&& from) noexcept
    : StaticODD() {
    *this = ::std::move(from);
  }

  inline StaticODD& operator=(StaticODD&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StaticODD& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StaticODD* internal_default_instance() {
    return reinterpret_cast<const StaticODD*>(
               &_StaticODD_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(StaticODD* other);
  friend void swap(StaticODD& a, StaticODD& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StaticODD* New() const PROTOBUF_FINAL { return New(NULL); }

  StaticODD* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const StaticODD& from);
  void MergeFrom(const StaticODD& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(StaticODD* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ndm_proto.Link links = 6;
  int links_size() const;
  void clear_links();
  static const int kLinksFieldNumber = 6;
  const ::ndm_proto::Link& links(int index) const;
  ::ndm_proto::Link* mutable_links(int index);
  ::ndm_proto::Link* add_links();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Link >*
      mutable_links();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Link >&
      links() const;

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // required bool is_odd = 2;
  bool has_is_odd() const;
  void clear_is_odd();
  static const int kIsOddFieldNumber = 2;
  bool is_odd() const;
  void set_is_odd(bool value);

  // required uint32 type = 3;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::google::protobuf::uint32 type() const;
  void set_type(::google::protobuf::uint32 value);

  // required uint64 reason = 5;
  bool has_reason() const;
  void clear_reason();
  static const int kReasonFieldNumber = 5;
  ::google::protobuf::uint64 reason() const;
  void set_reason(::google::protobuf::uint64 value);

  // required uint32 action = 4;
  bool has_action() const;
  void clear_action();
  static const int kActionFieldNumber = 4;
  ::google::protobuf::uint32 action() const;
  void set_action(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ndm_proto.StaticODD)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_is_odd();
  void clear_has_is_odd();
  void set_has_type();
  void clear_has_type();
  void set_has_action();
  void clear_has_action();
  void set_has_reason();
  void clear_has_reason();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Link > links_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  bool is_odd_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint64 reason_;
  ::google::protobuf::uint32 action_;
  friend struct ::protobuf_dynamic_5flayer_2eproto::TableStruct;
  friend void ::protobuf_dynamic_5flayer_2eproto::InitDefaultsStaticODDImpl();
};
// -------------------------------------------------------------------

class TrafficEvent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.TrafficEvent) */ {
 public:
  TrafficEvent();
  virtual ~TrafficEvent();

  TrafficEvent(const TrafficEvent& from);

  inline TrafficEvent& operator=(const TrafficEvent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TrafficEvent(TrafficEvent&& from) noexcept
    : TrafficEvent() {
    *this = ::std::move(from);
  }

  inline TrafficEvent& operator=(TrafficEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TrafficEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrafficEvent* internal_default_instance() {
    return reinterpret_cast<const TrafficEvent*>(
               &_TrafficEvent_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(TrafficEvent* other);
  friend void swap(TrafficEvent& a, TrafficEvent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrafficEvent* New() const PROTOBUF_FINAL { return New(NULL); }

  TrafficEvent* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TrafficEvent& from);
  void MergeFrom(const TrafficEvent& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TrafficEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ndm_proto.Link links = 4;
  int links_size() const;
  void clear_links();
  static const int kLinksFieldNumber = 4;
  const ::ndm_proto::Link& links(int index) const;
  ::ndm_proto::Link* mutable_links(int index);
  ::ndm_proto::Link* add_links();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Link >*
      mutable_links();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Link >&
      links() const;

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // required .ndm_proto.TrafficEventType eventType = 2;
  bool has_eventtype() const;
  void clear_eventtype();
  static const int kEventTypeFieldNumber = 2;
  ::ndm_proto::TrafficEventType eventtype() const;
  void set_eventtype(::ndm_proto::TrafficEventType value);

  // required uint32 reliability = 3;
  bool has_reliability() const;
  void clear_reliability();
  static const int kReliabilityFieldNumber = 3;
  ::google::protobuf::uint32 reliability() const;
  void set_reliability(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ndm_proto.TrafficEvent)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_eventtype();
  void clear_has_eventtype();
  void set_has_reliability();
  void clear_has_reliability();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Link > links_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  int eventtype_;
  ::google::protobuf::uint32 reliability_;
  friend struct ::protobuf_dynamic_5flayer_2eproto::TableStruct;
  friend void ::protobuf_dynamic_5flayer_2eproto::InitDefaultsTrafficEventImpl();
};
// -------------------------------------------------------------------

class TrafficFlow : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.TrafficFlow) */ {
 public:
  TrafficFlow();
  virtual ~TrafficFlow();

  TrafficFlow(const TrafficFlow& from);

  inline TrafficFlow& operator=(const TrafficFlow& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TrafficFlow(TrafficFlow&& from) noexcept
    : TrafficFlow() {
    *this = ::std::move(from);
  }

  inline TrafficFlow& operator=(TrafficFlow&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TrafficFlow& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrafficFlow* internal_default_instance() {
    return reinterpret_cast<const TrafficFlow*>(
               &_TrafficFlow_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(TrafficFlow* other);
  friend void swap(TrafficFlow& a, TrafficFlow& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrafficFlow* New() const PROTOBUF_FINAL { return New(NULL); }

  TrafficFlow* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TrafficFlow& from);
  void MergeFrom(const TrafficFlow& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TrafficFlow* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ndm_proto.Link links = 4;
  int links_size() const;
  void clear_links();
  static const int kLinksFieldNumber = 4;
  const ::ndm_proto::Link& links(int index) const;
  ::ndm_proto::Link* mutable_links(int index);
  ::ndm_proto::Link* add_links();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Link >*
      mutable_links();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Link >&
      links() const;

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // required .ndm_proto.TrafficFlowStatus flowStatus = 2;
  bool has_flowstatus() const;
  void clear_flowstatus();
  static const int kFlowStatusFieldNumber = 2;
  ::ndm_proto::TrafficFlowStatus flowstatus() const;
  void set_flowstatus(::ndm_proto::TrafficFlowStatus value);

  // required uint32 reliability = 3;
  bool has_reliability() const;
  void clear_reliability();
  static const int kReliabilityFieldNumber = 3;
  ::google::protobuf::uint32 reliability() const;
  void set_reliability(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ndm_proto.TrafficFlow)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_flowstatus();
  void clear_has_flowstatus();
  void set_has_reliability();
  void clear_has_reliability();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Link > links_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  int flowstatus_;
  ::google::protobuf::uint32 reliability_;
  friend struct ::protobuf_dynamic_5flayer_2eproto::TableStruct;
  friend void ::protobuf_dynamic_5flayer_2eproto::InitDefaultsTrafficFlowImpl();
};
// -------------------------------------------------------------------

class DynamicLayer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.DynamicLayer) */ {
 public:
  DynamicLayer();
  virtual ~DynamicLayer();

  DynamicLayer(const DynamicLayer& from);

  inline DynamicLayer& operator=(const DynamicLayer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DynamicLayer(DynamicLayer&& from) noexcept
    : DynamicLayer() {
    *this = ::std::move(from);
  }

  inline DynamicLayer& operator=(DynamicLayer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DynamicLayer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DynamicLayer* internal_default_instance() {
    return reinterpret_cast<const DynamicLayer*>(
               &_DynamicLayer_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(DynamicLayer* other);
  friend void swap(DynamicLayer& a, DynamicLayer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DynamicLayer* New() const PROTOBUF_FINAL { return New(NULL); }

  DynamicLayer* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DynamicLayer& from);
  void MergeFrom(const DynamicLayer& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DynamicLayer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ndm_proto.MoveableObject moveable_objects = 1;
  int moveable_objects_size() const;
  void clear_moveable_objects();
  static const int kMoveableObjectsFieldNumber = 1;
  const ::ndm_proto::MoveableObject& moveable_objects(int index) const;
  ::ndm_proto::MoveableObject* mutable_moveable_objects(int index);
  ::ndm_proto::MoveableObject* add_moveable_objects();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::MoveableObject >*
      mutable_moveable_objects();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::MoveableObject >&
      moveable_objects() const;

  // repeated .ndm_proto.TrafficLightDynamicState trafficlight_states = 2;
  int trafficlight_states_size() const;
  void clear_trafficlight_states();
  static const int kTrafficlightStatesFieldNumber = 2;
  const ::ndm_proto::TrafficLightDynamicState& trafficlight_states(int index) const;
  ::ndm_proto::TrafficLightDynamicState* mutable_trafficlight_states(int index);
  ::ndm_proto::TrafficLightDynamicState* add_trafficlight_states();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::TrafficLightDynamicState >*
      mutable_trafficlight_states();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::TrafficLightDynamicState >&
      trafficlight_states() const;

  // repeated .ndm_proto.ParkingSlotState parkingslot_states = 3;
  int parkingslot_states_size() const;
  void clear_parkingslot_states();
  static const int kParkingslotStatesFieldNumber = 3;
  const ::ndm_proto::ParkingSlotState& parkingslot_states(int index) const;
  ::ndm_proto::ParkingSlotState* mutable_parkingslot_states(int index);
  ::ndm_proto::ParkingSlotState* add_parkingslot_states();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::ParkingSlotState >*
      mutable_parkingslot_states();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::ParkingSlotState >&
      parkingslot_states() const;

  // repeated .ndm_proto.ConstructionZone construction_zones = 4;
  int construction_zones_size() const;
  void clear_construction_zones();
  static const int kConstructionZonesFieldNumber = 4;
  const ::ndm_proto::ConstructionZone& construction_zones(int index) const;
  ::ndm_proto::ConstructionZone* mutable_construction_zones(int index);
  ::ndm_proto::ConstructionZone* add_construction_zones();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::ConstructionZone >*
      mutable_construction_zones();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::ConstructionZone >&
      construction_zones() const;

  // repeated .ndm_proto.RestrictedZone restricted_zone = 5;
  int restricted_zone_size() const;
  void clear_restricted_zone();
  static const int kRestrictedZoneFieldNumber = 5;
  const ::ndm_proto::RestrictedZone& restricted_zone(int index) const;
  ::ndm_proto::RestrictedZone* mutable_restricted_zone(int index);
  ::ndm_proto::RestrictedZone* add_restricted_zone();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::RestrictedZone >*
      mutable_restricted_zone();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::RestrictedZone >&
      restricted_zone() const;

  // repeated .ndm_proto.TrafficCone cones = 6;
  int cones_size() const;
  void clear_cones();
  static const int kConesFieldNumber = 6;
  const ::ndm_proto::TrafficCone& cones(int index) const;
  ::ndm_proto::TrafficCone* mutable_cones(int index);
  ::ndm_proto::TrafficCone* add_cones();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::TrafficCone >*
      mutable_cones();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::TrafficCone >&
      cones() const;

  // repeated .ndm_proto.StaticODD static_odds = 7;
  int static_odds_size() const;
  void clear_static_odds();
  static const int kStaticOddsFieldNumber = 7;
  const ::ndm_proto::StaticODD& static_odds(int index) const;
  ::ndm_proto::StaticODD* mutable_static_odds(int index);
  ::ndm_proto::StaticODD* add_static_odds();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::StaticODD >*
      mutable_static_odds();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::StaticODD >&
      static_odds() const;

  // repeated .ndm_proto.TrafficEvent traffic_events = 8;
  int traffic_events_size() const;
  void clear_traffic_events();
  static const int kTrafficEventsFieldNumber = 8;
  const ::ndm_proto::TrafficEvent& traffic_events(int index) const;
  ::ndm_proto::TrafficEvent* mutable_traffic_events(int index);
  ::ndm_proto::TrafficEvent* add_traffic_events();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::TrafficEvent >*
      mutable_traffic_events();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::TrafficEvent >&
      traffic_events() const;

  // repeated .ndm_proto.TrafficFlow traffic_flows = 9;
  int traffic_flows_size() const;
  void clear_traffic_flows();
  static const int kTrafficFlowsFieldNumber = 9;
  const ::ndm_proto::TrafficFlow& traffic_flows(int index) const;
  ::ndm_proto::TrafficFlow* mutable_traffic_flows(int index);
  ::ndm_proto::TrafficFlow* add_traffic_flows();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::TrafficFlow >*
      mutable_traffic_flows();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::TrafficFlow >&
      traffic_flows() const;

  // @@protoc_insertion_point(class_scope:ndm_proto.DynamicLayer)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::MoveableObject > moveable_objects_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::TrafficLightDynamicState > trafficlight_states_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::ParkingSlotState > parkingslot_states_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::ConstructionZone > construction_zones_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::RestrictedZone > restricted_zone_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::TrafficCone > cones_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::StaticODD > static_odds_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::TrafficEvent > traffic_events_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::TrafficFlow > traffic_flows_;
  friend struct ::protobuf_dynamic_5flayer_2eproto::TableStruct;
  friend void ::protobuf_dynamic_5flayer_2eproto::InitDefaultsDynamicLayerImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ObjectAttribute

// repeated uint32 rgb = 1;
inline int ObjectAttribute::rgb_size() const {
  return rgb_.size();
}
inline void ObjectAttribute::clear_rgb() {
  rgb_.Clear();
}
inline ::google::protobuf::uint32 ObjectAttribute::rgb(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.ObjectAttribute.rgb)
  return rgb_.Get(index);
}
inline void ObjectAttribute::set_rgb(int index, ::google::protobuf::uint32 value) {
  rgb_.Set(index, value);
  // @@protoc_insertion_point(field_set:ndm_proto.ObjectAttribute.rgb)
}
inline void ObjectAttribute::add_rgb(::google::protobuf::uint32 value) {
  rgb_.Add(value);
  // @@protoc_insertion_point(field_add:ndm_proto.ObjectAttribute.rgb)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ObjectAttribute::rgb() const {
  // @@protoc_insertion_point(field_list:ndm_proto.ObjectAttribute.rgb)
  return rgb_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ObjectAttribute::mutable_rgb() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.ObjectAttribute.rgb)
  return &rgb_;
}

// optional .ndm_proto.Point lwh = 2;
inline bool ObjectAttribute::has_lwh() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ObjectAttribute::set_has_lwh() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ObjectAttribute::clear_has_lwh() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ndm_proto::Point& ObjectAttribute::lwh() const {
  const ::ndm_proto::Point* p = lwh_;
  // @@protoc_insertion_point(field_get:ndm_proto.ObjectAttribute.lwh)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Point*>(
      &::ndm_proto::_Point_default_instance_);
}
inline ::ndm_proto::Point* ObjectAttribute::release_lwh() {
  // @@protoc_insertion_point(field_release:ndm_proto.ObjectAttribute.lwh)
  clear_has_lwh();
  ::ndm_proto::Point* temp = lwh_;
  lwh_ = NULL;
  return temp;
}
inline ::ndm_proto::Point* ObjectAttribute::mutable_lwh() {
  set_has_lwh();
  if (lwh_ == NULL) {
    lwh_ = new ::ndm_proto::Point;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.ObjectAttribute.lwh)
  return lwh_;
}
inline void ObjectAttribute::set_allocated_lwh(::ndm_proto::Point* lwh) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(lwh_);
  }
  if (lwh) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      lwh = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, lwh, submessage_arena);
    }
    set_has_lwh();
  } else {
    clear_has_lwh();
  }
  lwh_ = lwh;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.ObjectAttribute.lwh)
}

// repeated .ndm_proto.Point key_points = 5;
inline int ObjectAttribute::key_points_size() const {
  return key_points_.size();
}
inline const ::ndm_proto::Point& ObjectAttribute::key_points(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.ObjectAttribute.key_points)
  return key_points_.Get(index);
}
inline ::ndm_proto::Point* ObjectAttribute::mutable_key_points(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.ObjectAttribute.key_points)
  return key_points_.Mutable(index);
}
inline ::ndm_proto::Point* ObjectAttribute::add_key_points() {
  // @@protoc_insertion_point(field_add:ndm_proto.ObjectAttribute.key_points)
  return key_points_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point >*
ObjectAttribute::mutable_key_points() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.ObjectAttribute.key_points)
  return &key_points_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point >&
ObjectAttribute::key_points() const {
  // @@protoc_insertion_point(field_list:ndm_proto.ObjectAttribute.key_points)
  return key_points_;
}

// repeated .ndm_proto.Point polygon_points = 6;
inline int ObjectAttribute::polygon_points_size() const {
  return polygon_points_.size();
}
inline const ::ndm_proto::Point& ObjectAttribute::polygon_points(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.ObjectAttribute.polygon_points)
  return polygon_points_.Get(index);
}
inline ::ndm_proto::Point* ObjectAttribute::mutable_polygon_points(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.ObjectAttribute.polygon_points)
  return polygon_points_.Mutable(index);
}
inline ::ndm_proto::Point* ObjectAttribute::add_polygon_points() {
  // @@protoc_insertion_point(field_add:ndm_proto.ObjectAttribute.polygon_points)
  return polygon_points_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point >*
ObjectAttribute::mutable_polygon_points() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.ObjectAttribute.polygon_points)
  return &polygon_points_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point >&
ObjectAttribute::polygon_points() const {
  // @@protoc_insertion_point(field_list:ndm_proto.ObjectAttribute.polygon_points)
  return polygon_points_;
}

// optional .ndm_proto.ObjectAttribute.ObjectType type = 30;
inline bool ObjectAttribute::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ObjectAttribute::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ObjectAttribute::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ObjectAttribute::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::ndm_proto::ObjectAttribute_ObjectType ObjectAttribute::type() const {
  // @@protoc_insertion_point(field_get:ndm_proto.ObjectAttribute.type)
  return static_cast< ::ndm_proto::ObjectAttribute_ObjectType >(type_);
}
inline void ObjectAttribute::set_type(::ndm_proto::ObjectAttribute_ObjectType value) {
  assert(::ndm_proto::ObjectAttribute_ObjectType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.ObjectAttribute.type)
}

// optional uint32 class_ind = 31;
inline bool ObjectAttribute::has_class_ind() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ObjectAttribute::set_has_class_ind() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ObjectAttribute::clear_has_class_ind() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ObjectAttribute::clear_class_ind() {
  class_ind_ = 0u;
  clear_has_class_ind();
}
inline ::google::protobuf::uint32 ObjectAttribute::class_ind() const {
  // @@protoc_insertion_point(field_get:ndm_proto.ObjectAttribute.class_ind)
  return class_ind_;
}
inline void ObjectAttribute::set_class_ind(::google::protobuf::uint32 value) {
  set_has_class_ind();
  class_ind_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.ObjectAttribute.class_ind)
}

// optional uint32 action_ind = 32;
inline bool ObjectAttribute::has_action_ind() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ObjectAttribute::set_has_action_ind() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ObjectAttribute::clear_has_action_ind() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ObjectAttribute::clear_action_ind() {
  action_ind_ = 0u;
  clear_has_action_ind();
}
inline ::google::protobuf::uint32 ObjectAttribute::action_ind() const {
  // @@protoc_insertion_point(field_get:ndm_proto.ObjectAttribute.action_ind)
  return action_ind_;
}
inline void ObjectAttribute::set_action_ind(::google::protobuf::uint32 value) {
  set_has_action_ind();
  action_ind_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.ObjectAttribute.action_ind)
}

// optional uint32 behavior_ind = 33;
inline bool ObjectAttribute::has_behavior_ind() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ObjectAttribute::set_has_behavior_ind() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ObjectAttribute::clear_has_behavior_ind() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ObjectAttribute::clear_behavior_ind() {
  behavior_ind_ = 0u;
  clear_has_behavior_ind();
}
inline ::google::protobuf::uint32 ObjectAttribute::behavior_ind() const {
  // @@protoc_insertion_point(field_get:ndm_proto.ObjectAttribute.behavior_ind)
  return behavior_ind_;
}
inline void ObjectAttribute::set_behavior_ind(::google::protobuf::uint32 value) {
  set_has_behavior_ind();
  behavior_ind_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.ObjectAttribute.behavior_ind)
}

// optional uint32 intention_ind = 34;
inline bool ObjectAttribute::has_intention_ind() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ObjectAttribute::set_has_intention_ind() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ObjectAttribute::clear_has_intention_ind() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ObjectAttribute::clear_intention_ind() {
  intention_ind_ = 0u;
  clear_has_intention_ind();
}
inline ::google::protobuf::uint32 ObjectAttribute::intention_ind() const {
  // @@protoc_insertion_point(field_get:ndm_proto.ObjectAttribute.intention_ind)
  return intention_ind_;
}
inline void ObjectAttribute::set_intention_ind(::google::protobuf::uint32 value) {
  set_has_intention_ind();
  intention_ind_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.ObjectAttribute.intention_ind)
}

// optional string identity = 40;
inline bool ObjectAttribute::has_identity() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ObjectAttribute::set_has_identity() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ObjectAttribute::clear_has_identity() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ObjectAttribute::clear_identity() {
  identity_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_identity();
}
inline const ::std::string& ObjectAttribute::identity() const {
  // @@protoc_insertion_point(field_get:ndm_proto.ObjectAttribute.identity)
  return identity_.GetNoArena();
}
inline void ObjectAttribute::set_identity(const ::std::string& value) {
  set_has_identity();
  identity_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ndm_proto.ObjectAttribute.identity)
}
#if LANG_CXX11
inline void ObjectAttribute::set_identity(::std::string&& value) {
  set_has_identity();
  identity_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ndm_proto.ObjectAttribute.identity)
}
#endif
inline void ObjectAttribute::set_identity(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_identity();
  identity_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ndm_proto.ObjectAttribute.identity)
}
inline void ObjectAttribute::set_identity(const char* value, size_t size) {
  set_has_identity();
  identity_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.ObjectAttribute.identity)
}
inline ::std::string* ObjectAttribute::mutable_identity() {
  set_has_identity();
  // @@protoc_insertion_point(field_mutable:ndm_proto.ObjectAttribute.identity)
  return identity_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ObjectAttribute::release_identity() {
  // @@protoc_insertion_point(field_release:ndm_proto.ObjectAttribute.identity)
  clear_has_identity();
  return identity_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ObjectAttribute::set_allocated_identity(::std::string* identity) {
  if (identity != NULL) {
    set_has_identity();
  } else {
    clear_has_identity();
  }
  identity_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), identity);
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.ObjectAttribute.identity)
}

// -------------------------------------------------------------------

// Signal

// required uint64 stamp = 1;
inline bool Signal::has_stamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Signal::set_has_stamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Signal::clear_has_stamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Signal::clear_stamp() {
  stamp_ = GOOGLE_ULONGLONG(0);
  clear_has_stamp();
}
inline ::google::protobuf::uint64 Signal::stamp() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Signal.stamp)
  return stamp_;
}
inline void Signal::set_stamp(::google::protobuf::uint64 value) {
  set_has_stamp();
  stamp_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.Signal.stamp)
}

// optional uint32 seq_id = 2;
inline bool Signal::has_seq_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Signal::set_has_seq_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Signal::clear_has_seq_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Signal::clear_seq_id() {
  seq_id_ = 0u;
  clear_has_seq_id();
}
inline ::google::protobuf::uint32 Signal::seq_id() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Signal.seq_id)
  return seq_id_;
}
inline void Signal::set_seq_id(::google::protobuf::uint32 value) {
  set_has_seq_id();
  seq_id_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.Signal.seq_id)
}

// required uint32 signal = 10;
inline bool Signal::has_signal() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Signal::set_has_signal() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Signal::clear_has_signal() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Signal::clear_signal() {
  signal_ = 0u;
  clear_has_signal();
}
inline ::google::protobuf::uint32 Signal::signal() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Signal.signal)
  return signal_;
}
inline void Signal::set_signal(::google::protobuf::uint32 value) {
  set_has_signal();
  signal_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.Signal.signal)
}

// -------------------------------------------------------------------

// SignalSequence

// required string id = 1;
inline bool SignalSequence::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SignalSequence::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SignalSequence::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SignalSequence::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& SignalSequence::id() const {
  // @@protoc_insertion_point(field_get:ndm_proto.SignalSequence.id)
  return id_.GetNoArena();
}
inline void SignalSequence::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ndm_proto.SignalSequence.id)
}
#if LANG_CXX11
inline void SignalSequence::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ndm_proto.SignalSequence.id)
}
#endif
inline void SignalSequence::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ndm_proto.SignalSequence.id)
}
inline void SignalSequence::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.SignalSequence.id)
}
inline ::std::string* SignalSequence::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:ndm_proto.SignalSequence.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SignalSequence::release_id() {
  // @@protoc_insertion_point(field_release:ndm_proto.SignalSequence.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SignalSequence::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.SignalSequence.id)
}

// required uint64 stamp = 2;
inline bool SignalSequence::has_stamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SignalSequence::set_has_stamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SignalSequence::clear_has_stamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SignalSequence::clear_stamp() {
  stamp_ = GOOGLE_ULONGLONG(0);
  clear_has_stamp();
}
inline ::google::protobuf::uint64 SignalSequence::stamp() const {
  // @@protoc_insertion_point(field_get:ndm_proto.SignalSequence.stamp)
  return stamp_;
}
inline void SignalSequence::set_stamp(::google::protobuf::uint64 value) {
  set_has_stamp();
  stamp_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.SignalSequence.stamp)
}

// optional uint32 seq_id = 3;
inline bool SignalSequence::has_seq_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SignalSequence::set_has_seq_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SignalSequence::clear_has_seq_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SignalSequence::clear_seq_id() {
  seq_id_ = 0u;
  clear_has_seq_id();
}
inline ::google::protobuf::uint32 SignalSequence::seq_id() const {
  // @@protoc_insertion_point(field_get:ndm_proto.SignalSequence.seq_id)
  return seq_id_;
}
inline void SignalSequence::set_seq_id(::google::protobuf::uint32 value) {
  set_has_seq_id();
  seq_id_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.SignalSequence.seq_id)
}

// required float life_time = 4;
inline bool SignalSequence::has_life_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SignalSequence::set_has_life_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SignalSequence::clear_has_life_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SignalSequence::clear_life_time() {
  life_time_ = 0;
  clear_has_life_time();
}
inline float SignalSequence::life_time() const {
  // @@protoc_insertion_point(field_get:ndm_proto.SignalSequence.life_time)
  return life_time_;
}
inline void SignalSequence::set_life_time(float value) {
  set_has_life_time();
  life_time_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.SignalSequence.life_time)
}

// repeated .ndm_proto.Signal signals = 10;
inline int SignalSequence::signals_size() const {
  return signals_.size();
}
inline void SignalSequence::clear_signals() {
  signals_.Clear();
}
inline const ::ndm_proto::Signal& SignalSequence::signals(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.SignalSequence.signals)
  return signals_.Get(index);
}
inline ::ndm_proto::Signal* SignalSequence::mutable_signals(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.SignalSequence.signals)
  return signals_.Mutable(index);
}
inline ::ndm_proto::Signal* SignalSequence::add_signals() {
  // @@protoc_insertion_point(field_add:ndm_proto.SignalSequence.signals)
  return signals_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::Signal >*
SignalSequence::mutable_signals() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.SignalSequence.signals)
  return &signals_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Signal >&
SignalSequence::signals() const {
  // @@protoc_insertion_point(field_list:ndm_proto.SignalSequence.signals)
  return signals_;
}

// -------------------------------------------------------------------

// MoveableObject

// required string id = 1;
inline bool MoveableObject::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoveableObject::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MoveableObject::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MoveableObject::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& MoveableObject::id() const {
  // @@protoc_insertion_point(field_get:ndm_proto.MoveableObject.id)
  return id_.GetNoArena();
}
inline void MoveableObject::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ndm_proto.MoveableObject.id)
}
#if LANG_CXX11
inline void MoveableObject::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ndm_proto.MoveableObject.id)
}
#endif
inline void MoveableObject::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ndm_proto.MoveableObject.id)
}
inline void MoveableObject::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.MoveableObject.id)
}
inline ::std::string* MoveableObject::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:ndm_proto.MoveableObject.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MoveableObject::release_id() {
  // @@protoc_insertion_point(field_release:ndm_proto.MoveableObject.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MoveableObject::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.MoveableObject.id)
}

// required uint64 stamp = 2;
inline bool MoveableObject::has_stamp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MoveableObject::set_has_stamp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MoveableObject::clear_has_stamp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MoveableObject::clear_stamp() {
  stamp_ = GOOGLE_ULONGLONG(0);
  clear_has_stamp();
}
inline ::google::protobuf::uint64 MoveableObject::stamp() const {
  // @@protoc_insertion_point(field_get:ndm_proto.MoveableObject.stamp)
  return stamp_;
}
inline void MoveableObject::set_stamp(::google::protobuf::uint64 value) {
  set_has_stamp();
  stamp_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.MoveableObject.stamp)
}

// optional uint32 seq_id = 3;
inline bool MoveableObject::has_seq_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MoveableObject::set_has_seq_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MoveableObject::clear_has_seq_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MoveableObject::clear_seq_id() {
  seq_id_ = 0u;
  clear_has_seq_id();
}
inline ::google::protobuf::uint32 MoveableObject::seq_id() const {
  // @@protoc_insertion_point(field_get:ndm_proto.MoveableObject.seq_id)
  return seq_id_;
}
inline void MoveableObject::set_seq_id(::google::protobuf::uint32 value) {
  set_has_seq_id();
  seq_id_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.MoveableObject.seq_id)
}

// required float life_time = 4;
inline bool MoveableObject::has_life_time() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MoveableObject::set_has_life_time() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MoveableObject::clear_has_life_time() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MoveableObject::clear_life_time() {
  life_time_ = 0;
  clear_has_life_time();
}
inline float MoveableObject::life_time() const {
  // @@protoc_insertion_point(field_get:ndm_proto.MoveableObject.life_time)
  return life_time_;
}
inline void MoveableObject::set_life_time(float value) {
  set_has_life_time();
  life_time_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.MoveableObject.life_time)
}

// optional .ndm_proto.ObjectAttribute attr = 8;
inline bool MoveableObject::has_attr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoveableObject::set_has_attr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MoveableObject::clear_has_attr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MoveableObject::clear_attr() {
  if (attr_ != NULL) attr_->Clear();
  clear_has_attr();
}
inline const ::ndm_proto::ObjectAttribute& MoveableObject::attr() const {
  const ::ndm_proto::ObjectAttribute* p = attr_;
  // @@protoc_insertion_point(field_get:ndm_proto.MoveableObject.attr)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::ObjectAttribute*>(
      &::ndm_proto::_ObjectAttribute_default_instance_);
}
inline ::ndm_proto::ObjectAttribute* MoveableObject::release_attr() {
  // @@protoc_insertion_point(field_release:ndm_proto.MoveableObject.attr)
  clear_has_attr();
  ::ndm_proto::ObjectAttribute* temp = attr_;
  attr_ = NULL;
  return temp;
}
inline ::ndm_proto::ObjectAttribute* MoveableObject::mutable_attr() {
  set_has_attr();
  if (attr_ == NULL) {
    attr_ = new ::ndm_proto::ObjectAttribute;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.MoveableObject.attr)
  return attr_;
}
inline void MoveableObject::set_allocated_attr(::ndm_proto::ObjectAttribute* attr) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete attr_;
  }
  if (attr) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      attr = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, attr, submessage_arena);
    }
    set_has_attr();
  } else {
    clear_has_attr();
  }
  attr_ = attr;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.MoveableObject.attr)
}

// required .ndm_proto.Trajectory trajectory = 10;
inline bool MoveableObject::has_trajectory() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MoveableObject::set_has_trajectory() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MoveableObject::clear_has_trajectory() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ndm_proto::Trajectory& MoveableObject::trajectory() const {
  const ::ndm_proto::Trajectory* p = trajectory_;
  // @@protoc_insertion_point(field_get:ndm_proto.MoveableObject.trajectory)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Trajectory*>(
      &::ndm_proto::_Trajectory_default_instance_);
}
inline ::ndm_proto::Trajectory* MoveableObject::release_trajectory() {
  // @@protoc_insertion_point(field_release:ndm_proto.MoveableObject.trajectory)
  clear_has_trajectory();
  ::ndm_proto::Trajectory* temp = trajectory_;
  trajectory_ = NULL;
  return temp;
}
inline ::ndm_proto::Trajectory* MoveableObject::mutable_trajectory() {
  set_has_trajectory();
  if (trajectory_ == NULL) {
    trajectory_ = new ::ndm_proto::Trajectory;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.MoveableObject.trajectory)
  return trajectory_;
}
inline void MoveableObject::set_allocated_trajectory(::ndm_proto::Trajectory* trajectory) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(trajectory_);
  }
  if (trajectory) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      trajectory = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, trajectory, submessage_arena);
    }
    set_has_trajectory();
  } else {
    clear_has_trajectory();
  }
  trajectory_ = trajectory;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.MoveableObject.trajectory)
}

// repeated .ndm_proto.Trajectory predict_trajectorys = 11;
inline int MoveableObject::predict_trajectorys_size() const {
  return predict_trajectorys_.size();
}
inline const ::ndm_proto::Trajectory& MoveableObject::predict_trajectorys(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.MoveableObject.predict_trajectorys)
  return predict_trajectorys_.Get(index);
}
inline ::ndm_proto::Trajectory* MoveableObject::mutable_predict_trajectorys(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.MoveableObject.predict_trajectorys)
  return predict_trajectorys_.Mutable(index);
}
inline ::ndm_proto::Trajectory* MoveableObject::add_predict_trajectorys() {
  // @@protoc_insertion_point(field_add:ndm_proto.MoveableObject.predict_trajectorys)
  return predict_trajectorys_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::Trajectory >*
MoveableObject::mutable_predict_trajectorys() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.MoveableObject.predict_trajectorys)
  return &predict_trajectorys_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Trajectory >&
MoveableObject::predict_trajectorys() const {
  // @@protoc_insertion_point(field_list:ndm_proto.MoveableObject.predict_trajectorys)
  return predict_trajectorys_;
}

// required .ndm_proto.SignalSequence signal_seq = 12;
inline bool MoveableObject::has_signal_seq() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MoveableObject::set_has_signal_seq() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MoveableObject::clear_has_signal_seq() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MoveableObject::clear_signal_seq() {
  if (signal_seq_ != NULL) signal_seq_->Clear();
  clear_has_signal_seq();
}
inline const ::ndm_proto::SignalSequence& MoveableObject::signal_seq() const {
  const ::ndm_proto::SignalSequence* p = signal_seq_;
  // @@protoc_insertion_point(field_get:ndm_proto.MoveableObject.signal_seq)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::SignalSequence*>(
      &::ndm_proto::_SignalSequence_default_instance_);
}
inline ::ndm_proto::SignalSequence* MoveableObject::release_signal_seq() {
  // @@protoc_insertion_point(field_release:ndm_proto.MoveableObject.signal_seq)
  clear_has_signal_seq();
  ::ndm_proto::SignalSequence* temp = signal_seq_;
  signal_seq_ = NULL;
  return temp;
}
inline ::ndm_proto::SignalSequence* MoveableObject::mutable_signal_seq() {
  set_has_signal_seq();
  if (signal_seq_ == NULL) {
    signal_seq_ = new ::ndm_proto::SignalSequence;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.MoveableObject.signal_seq)
  return signal_seq_;
}
inline void MoveableObject::set_allocated_signal_seq(::ndm_proto::SignalSequence* signal_seq) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete signal_seq_;
  }
  if (signal_seq) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      signal_seq = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, signal_seq, submessage_arena);
    }
    set_has_signal_seq();
  } else {
    clear_has_signal_seq();
  }
  signal_seq_ = signal_seq;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.MoveableObject.signal_seq)
}

// repeated .ndm_proto.SignalSequence predict_signal_seqs = 13;
inline int MoveableObject::predict_signal_seqs_size() const {
  return predict_signal_seqs_.size();
}
inline void MoveableObject::clear_predict_signal_seqs() {
  predict_signal_seqs_.Clear();
}
inline const ::ndm_proto::SignalSequence& MoveableObject::predict_signal_seqs(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.MoveableObject.predict_signal_seqs)
  return predict_signal_seqs_.Get(index);
}
inline ::ndm_proto::SignalSequence* MoveableObject::mutable_predict_signal_seqs(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.MoveableObject.predict_signal_seqs)
  return predict_signal_seqs_.Mutable(index);
}
inline ::ndm_proto::SignalSequence* MoveableObject::add_predict_signal_seqs() {
  // @@protoc_insertion_point(field_add:ndm_proto.MoveableObject.predict_signal_seqs)
  return predict_signal_seqs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::SignalSequence >*
MoveableObject::mutable_predict_signal_seqs() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.MoveableObject.predict_signal_seqs)
  return &predict_signal_seqs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::SignalSequence >&
MoveableObject::predict_signal_seqs() const {
  // @@protoc_insertion_point(field_list:ndm_proto.MoveableObject.predict_signal_seqs)
  return predict_signal_seqs_;
}

// -------------------------------------------------------------------

// TrafficLightBulbState

// required uint64 stamp = 1;
inline bool TrafficLightBulbState::has_stamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrafficLightBulbState::set_has_stamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrafficLightBulbState::clear_has_stamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrafficLightBulbState::clear_stamp() {
  stamp_ = GOOGLE_ULONGLONG(0);
  clear_has_stamp();
}
inline ::google::protobuf::uint64 TrafficLightBulbState::stamp() const {
  // @@protoc_insertion_point(field_get:ndm_proto.TrafficLightBulbState.stamp)
  return stamp_;
}
inline void TrafficLightBulbState::set_stamp(::google::protobuf::uint64 value) {
  set_has_stamp();
  stamp_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.TrafficLightBulbState.stamp)
}

// optional uint32 seq_id = 2;
inline bool TrafficLightBulbState::has_seq_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TrafficLightBulbState::set_has_seq_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TrafficLightBulbState::clear_has_seq_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TrafficLightBulbState::clear_seq_id() {
  seq_id_ = 0u;
  clear_has_seq_id();
}
inline ::google::protobuf::uint32 TrafficLightBulbState::seq_id() const {
  // @@protoc_insertion_point(field_get:ndm_proto.TrafficLightBulbState.seq_id)
  return seq_id_;
}
inline void TrafficLightBulbState::set_seq_id(::google::protobuf::uint32 value) {
  set_has_seq_id();
  seq_id_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.TrafficLightBulbState.seq_id)
}

// required .ndm_proto.TrafficLightBulbColor color = 10;
inline bool TrafficLightBulbState::has_color() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrafficLightBulbState::set_has_color() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrafficLightBulbState::clear_has_color() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ndm_proto::TrafficLightBulbColor& TrafficLightBulbState::color() const {
  const ::ndm_proto::TrafficLightBulbColor* p = color_;
  // @@protoc_insertion_point(field_get:ndm_proto.TrafficLightBulbState.color)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::TrafficLightBulbColor*>(
      &::ndm_proto::_TrafficLightBulbColor_default_instance_);
}
inline ::ndm_proto::TrafficLightBulbColor* TrafficLightBulbState::release_color() {
  // @@protoc_insertion_point(field_release:ndm_proto.TrafficLightBulbState.color)
  clear_has_color();
  ::ndm_proto::TrafficLightBulbColor* temp = color_;
  color_ = NULL;
  return temp;
}
inline ::ndm_proto::TrafficLightBulbColor* TrafficLightBulbState::mutable_color() {
  set_has_color();
  if (color_ == NULL) {
    color_ = new ::ndm_proto::TrafficLightBulbColor;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.TrafficLightBulbState.color)
  return color_;
}
inline void TrafficLightBulbState::set_allocated_color(::ndm_proto::TrafficLightBulbColor* color) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(color_);
  }
  if (color) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      color = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    set_has_color();
  } else {
    clear_has_color();
  }
  color_ = color;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.TrafficLightBulbState.color)
}

// optional bool is_flashing = 11;
inline bool TrafficLightBulbState::has_is_flashing() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TrafficLightBulbState::set_has_is_flashing() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TrafficLightBulbState::clear_has_is_flashing() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TrafficLightBulbState::clear_is_flashing() {
  is_flashing_ = false;
  clear_has_is_flashing();
}
inline bool TrafficLightBulbState::is_flashing() const {
  // @@protoc_insertion_point(field_get:ndm_proto.TrafficLightBulbState.is_flashing)
  return is_flashing_;
}
inline void TrafficLightBulbState::set_is_flashing(bool value) {
  set_has_is_flashing();
  is_flashing_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.TrafficLightBulbState.is_flashing)
}

// -------------------------------------------------------------------

// TrafficLightBulbSequence

// required string id = 1;
inline bool TrafficLightBulbSequence::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrafficLightBulbSequence::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrafficLightBulbSequence::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrafficLightBulbSequence::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& TrafficLightBulbSequence::id() const {
  // @@protoc_insertion_point(field_get:ndm_proto.TrafficLightBulbSequence.id)
  return id_.GetNoArena();
}
inline void TrafficLightBulbSequence::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ndm_proto.TrafficLightBulbSequence.id)
}
#if LANG_CXX11
inline void TrafficLightBulbSequence::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ndm_proto.TrafficLightBulbSequence.id)
}
#endif
inline void TrafficLightBulbSequence::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ndm_proto.TrafficLightBulbSequence.id)
}
inline void TrafficLightBulbSequence::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.TrafficLightBulbSequence.id)
}
inline ::std::string* TrafficLightBulbSequence::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:ndm_proto.TrafficLightBulbSequence.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TrafficLightBulbSequence::release_id() {
  // @@protoc_insertion_point(field_release:ndm_proto.TrafficLightBulbSequence.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TrafficLightBulbSequence::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.TrafficLightBulbSequence.id)
}

// required uint64 stamp = 2;
inline bool TrafficLightBulbSequence::has_stamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TrafficLightBulbSequence::set_has_stamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TrafficLightBulbSequence::clear_has_stamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TrafficLightBulbSequence::clear_stamp() {
  stamp_ = GOOGLE_ULONGLONG(0);
  clear_has_stamp();
}
inline ::google::protobuf::uint64 TrafficLightBulbSequence::stamp() const {
  // @@protoc_insertion_point(field_get:ndm_proto.TrafficLightBulbSequence.stamp)
  return stamp_;
}
inline void TrafficLightBulbSequence::set_stamp(::google::protobuf::uint64 value) {
  set_has_stamp();
  stamp_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.TrafficLightBulbSequence.stamp)
}

// optional uint32 seq_id = 3;
inline bool TrafficLightBulbSequence::has_seq_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TrafficLightBulbSequence::set_has_seq_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TrafficLightBulbSequence::clear_has_seq_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TrafficLightBulbSequence::clear_seq_id() {
  seq_id_ = 0u;
  clear_has_seq_id();
}
inline ::google::protobuf::uint32 TrafficLightBulbSequence::seq_id() const {
  // @@protoc_insertion_point(field_get:ndm_proto.TrafficLightBulbSequence.seq_id)
  return seq_id_;
}
inline void TrafficLightBulbSequence::set_seq_id(::google::protobuf::uint32 value) {
  set_has_seq_id();
  seq_id_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.TrafficLightBulbSequence.seq_id)
}

// required float life_time = 4;
inline bool TrafficLightBulbSequence::has_life_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TrafficLightBulbSequence::set_has_life_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TrafficLightBulbSequence::clear_has_life_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TrafficLightBulbSequence::clear_life_time() {
  life_time_ = 0;
  clear_has_life_time();
}
inline float TrafficLightBulbSequence::life_time() const {
  // @@protoc_insertion_point(field_get:ndm_proto.TrafficLightBulbSequence.life_time)
  return life_time_;
}
inline void TrafficLightBulbSequence::set_life_time(float value) {
  set_has_life_time();
  life_time_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.TrafficLightBulbSequence.life_time)
}

// required string associate_trafficlightbulb_id = 5;
inline bool TrafficLightBulbSequence::has_associate_trafficlightbulb_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrafficLightBulbSequence::set_has_associate_trafficlightbulb_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrafficLightBulbSequence::clear_has_associate_trafficlightbulb_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrafficLightBulbSequence::clear_associate_trafficlightbulb_id() {
  associate_trafficlightbulb_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_associate_trafficlightbulb_id();
}
inline const ::std::string& TrafficLightBulbSequence::associate_trafficlightbulb_id() const {
  // @@protoc_insertion_point(field_get:ndm_proto.TrafficLightBulbSequence.associate_trafficlightbulb_id)
  return associate_trafficlightbulb_id_.GetNoArena();
}
inline void TrafficLightBulbSequence::set_associate_trafficlightbulb_id(const ::std::string& value) {
  set_has_associate_trafficlightbulb_id();
  associate_trafficlightbulb_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ndm_proto.TrafficLightBulbSequence.associate_trafficlightbulb_id)
}
#if LANG_CXX11
inline void TrafficLightBulbSequence::set_associate_trafficlightbulb_id(::std::string&& value) {
  set_has_associate_trafficlightbulb_id();
  associate_trafficlightbulb_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ndm_proto.TrafficLightBulbSequence.associate_trafficlightbulb_id)
}
#endif
inline void TrafficLightBulbSequence::set_associate_trafficlightbulb_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_associate_trafficlightbulb_id();
  associate_trafficlightbulb_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ndm_proto.TrafficLightBulbSequence.associate_trafficlightbulb_id)
}
inline void TrafficLightBulbSequence::set_associate_trafficlightbulb_id(const char* value, size_t size) {
  set_has_associate_trafficlightbulb_id();
  associate_trafficlightbulb_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.TrafficLightBulbSequence.associate_trafficlightbulb_id)
}
inline ::std::string* TrafficLightBulbSequence::mutable_associate_trafficlightbulb_id() {
  set_has_associate_trafficlightbulb_id();
  // @@protoc_insertion_point(field_mutable:ndm_proto.TrafficLightBulbSequence.associate_trafficlightbulb_id)
  return associate_trafficlightbulb_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TrafficLightBulbSequence::release_associate_trafficlightbulb_id() {
  // @@protoc_insertion_point(field_release:ndm_proto.TrafficLightBulbSequence.associate_trafficlightbulb_id)
  clear_has_associate_trafficlightbulb_id();
  return associate_trafficlightbulb_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TrafficLightBulbSequence::set_allocated_associate_trafficlightbulb_id(::std::string* associate_trafficlightbulb_id) {
  if (associate_trafficlightbulb_id != NULL) {
    set_has_associate_trafficlightbulb_id();
  } else {
    clear_has_associate_trafficlightbulb_id();
  }
  associate_trafficlightbulb_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), associate_trafficlightbulb_id);
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.TrafficLightBulbSequence.associate_trafficlightbulb_id)
}

// repeated .ndm_proto.TrafficLightBulbState bulb_states = 10;
inline int TrafficLightBulbSequence::bulb_states_size() const {
  return bulb_states_.size();
}
inline void TrafficLightBulbSequence::clear_bulb_states() {
  bulb_states_.Clear();
}
inline const ::ndm_proto::TrafficLightBulbState& TrafficLightBulbSequence::bulb_states(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.TrafficLightBulbSequence.bulb_states)
  return bulb_states_.Get(index);
}
inline ::ndm_proto::TrafficLightBulbState* TrafficLightBulbSequence::mutable_bulb_states(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.TrafficLightBulbSequence.bulb_states)
  return bulb_states_.Mutable(index);
}
inline ::ndm_proto::TrafficLightBulbState* TrafficLightBulbSequence::add_bulb_states() {
  // @@protoc_insertion_point(field_add:ndm_proto.TrafficLightBulbSequence.bulb_states)
  return bulb_states_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::TrafficLightBulbState >*
TrafficLightBulbSequence::mutable_bulb_states() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.TrafficLightBulbSequence.bulb_states)
  return &bulb_states_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::TrafficLightBulbState >&
TrafficLightBulbSequence::bulb_states() const {
  // @@protoc_insertion_point(field_list:ndm_proto.TrafficLightBulbSequence.bulb_states)
  return bulb_states_;
}

// -------------------------------------------------------------------

// TrafficLightDynamicState

// required string id = 1;
inline bool TrafficLightDynamicState::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrafficLightDynamicState::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrafficLightDynamicState::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrafficLightDynamicState::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& TrafficLightDynamicState::id() const {
  // @@protoc_insertion_point(field_get:ndm_proto.TrafficLightDynamicState.id)
  return id_.GetNoArena();
}
inline void TrafficLightDynamicState::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ndm_proto.TrafficLightDynamicState.id)
}
#if LANG_CXX11
inline void TrafficLightDynamicState::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ndm_proto.TrafficLightDynamicState.id)
}
#endif
inline void TrafficLightDynamicState::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ndm_proto.TrafficLightDynamicState.id)
}
inline void TrafficLightDynamicState::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.TrafficLightDynamicState.id)
}
inline ::std::string* TrafficLightDynamicState::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:ndm_proto.TrafficLightDynamicState.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TrafficLightDynamicState::release_id() {
  // @@protoc_insertion_point(field_release:ndm_proto.TrafficLightDynamicState.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TrafficLightDynamicState::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.TrafficLightDynamicState.id)
}

// required uint64 stamp = 2;
inline bool TrafficLightDynamicState::has_stamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TrafficLightDynamicState::set_has_stamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TrafficLightDynamicState::clear_has_stamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TrafficLightDynamicState::clear_stamp() {
  stamp_ = GOOGLE_ULONGLONG(0);
  clear_has_stamp();
}
inline ::google::protobuf::uint64 TrafficLightDynamicState::stamp() const {
  // @@protoc_insertion_point(field_get:ndm_proto.TrafficLightDynamicState.stamp)
  return stamp_;
}
inline void TrafficLightDynamicState::set_stamp(::google::protobuf::uint64 value) {
  set_has_stamp();
  stamp_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.TrafficLightDynamicState.stamp)
}

// optional uint32 seq_id = 3;
inline bool TrafficLightDynamicState::has_seq_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TrafficLightDynamicState::set_has_seq_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TrafficLightDynamicState::clear_has_seq_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TrafficLightDynamicState::clear_seq_id() {
  seq_id_ = 0u;
  clear_has_seq_id();
}
inline ::google::protobuf::uint32 TrafficLightDynamicState::seq_id() const {
  // @@protoc_insertion_point(field_get:ndm_proto.TrafficLightDynamicState.seq_id)
  return seq_id_;
}
inline void TrafficLightDynamicState::set_seq_id(::google::protobuf::uint32 value) {
  set_has_seq_id();
  seq_id_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.TrafficLightDynamicState.seq_id)
}

// required float life_time = 4;
inline bool TrafficLightDynamicState::has_life_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TrafficLightDynamicState::set_has_life_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TrafficLightDynamicState::clear_has_life_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TrafficLightDynamicState::clear_life_time() {
  life_time_ = 0;
  clear_has_life_time();
}
inline float TrafficLightDynamicState::life_time() const {
  // @@protoc_insertion_point(field_get:ndm_proto.TrafficLightDynamicState.life_time)
  return life_time_;
}
inline void TrafficLightDynamicState::set_life_time(float value) {
  set_has_life_time();
  life_time_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.TrafficLightDynamicState.life_time)
}

// required string associate_trafficlight_id = 5;
inline bool TrafficLightDynamicState::has_associate_trafficlight_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrafficLightDynamicState::set_has_associate_trafficlight_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrafficLightDynamicState::clear_has_associate_trafficlight_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrafficLightDynamicState::clear_associate_trafficlight_id() {
  associate_trafficlight_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_associate_trafficlight_id();
}
inline const ::std::string& TrafficLightDynamicState::associate_trafficlight_id() const {
  // @@protoc_insertion_point(field_get:ndm_proto.TrafficLightDynamicState.associate_trafficlight_id)
  return associate_trafficlight_id_.GetNoArena();
}
inline void TrafficLightDynamicState::set_associate_trafficlight_id(const ::std::string& value) {
  set_has_associate_trafficlight_id();
  associate_trafficlight_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ndm_proto.TrafficLightDynamicState.associate_trafficlight_id)
}
#if LANG_CXX11
inline void TrafficLightDynamicState::set_associate_trafficlight_id(::std::string&& value) {
  set_has_associate_trafficlight_id();
  associate_trafficlight_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ndm_proto.TrafficLightDynamicState.associate_trafficlight_id)
}
#endif
inline void TrafficLightDynamicState::set_associate_trafficlight_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_associate_trafficlight_id();
  associate_trafficlight_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ndm_proto.TrafficLightDynamicState.associate_trafficlight_id)
}
inline void TrafficLightDynamicState::set_associate_trafficlight_id(const char* value, size_t size) {
  set_has_associate_trafficlight_id();
  associate_trafficlight_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.TrafficLightDynamicState.associate_trafficlight_id)
}
inline ::std::string* TrafficLightDynamicState::mutable_associate_trafficlight_id() {
  set_has_associate_trafficlight_id();
  // @@protoc_insertion_point(field_mutable:ndm_proto.TrafficLightDynamicState.associate_trafficlight_id)
  return associate_trafficlight_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TrafficLightDynamicState::release_associate_trafficlight_id() {
  // @@protoc_insertion_point(field_release:ndm_proto.TrafficLightDynamicState.associate_trafficlight_id)
  clear_has_associate_trafficlight_id();
  return associate_trafficlight_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TrafficLightDynamicState::set_allocated_associate_trafficlight_id(::std::string* associate_trafficlight_id) {
  if (associate_trafficlight_id != NULL) {
    set_has_associate_trafficlight_id();
  } else {
    clear_has_associate_trafficlight_id();
  }
  associate_trafficlight_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), associate_trafficlight_id);
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.TrafficLightDynamicState.associate_trafficlight_id)
}

// repeated .ndm_proto.TrafficLightBulbSequence bulb_seqs = 10;
inline int TrafficLightDynamicState::bulb_seqs_size() const {
  return bulb_seqs_.size();
}
inline void TrafficLightDynamicState::clear_bulb_seqs() {
  bulb_seqs_.Clear();
}
inline const ::ndm_proto::TrafficLightBulbSequence& TrafficLightDynamicState::bulb_seqs(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.TrafficLightDynamicState.bulb_seqs)
  return bulb_seqs_.Get(index);
}
inline ::ndm_proto::TrafficLightBulbSequence* TrafficLightDynamicState::mutable_bulb_seqs(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.TrafficLightDynamicState.bulb_seqs)
  return bulb_seqs_.Mutable(index);
}
inline ::ndm_proto::TrafficLightBulbSequence* TrafficLightDynamicState::add_bulb_seqs() {
  // @@protoc_insertion_point(field_add:ndm_proto.TrafficLightDynamicState.bulb_seqs)
  return bulb_seqs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::TrafficLightBulbSequence >*
TrafficLightDynamicState::mutable_bulb_seqs() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.TrafficLightDynamicState.bulb_seqs)
  return &bulb_seqs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::TrafficLightBulbSequence >&
TrafficLightDynamicState::bulb_seqs() const {
  // @@protoc_insertion_point(field_list:ndm_proto.TrafficLightDynamicState.bulb_seqs)
  return bulb_seqs_;
}

// -------------------------------------------------------------------

// ParkingSlotState

// required string id = 1;
inline bool ParkingSlotState::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ParkingSlotState::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ParkingSlotState::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ParkingSlotState::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& ParkingSlotState::id() const {
  // @@protoc_insertion_point(field_get:ndm_proto.ParkingSlotState.id)
  return id_.GetNoArena();
}
inline void ParkingSlotState::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ndm_proto.ParkingSlotState.id)
}
#if LANG_CXX11
inline void ParkingSlotState::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ndm_proto.ParkingSlotState.id)
}
#endif
inline void ParkingSlotState::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ndm_proto.ParkingSlotState.id)
}
inline void ParkingSlotState::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.ParkingSlotState.id)
}
inline ::std::string* ParkingSlotState::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:ndm_proto.ParkingSlotState.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ParkingSlotState::release_id() {
  // @@protoc_insertion_point(field_release:ndm_proto.ParkingSlotState.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ParkingSlotState::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.ParkingSlotState.id)
}

// required uint64 stamp = 2;
inline bool ParkingSlotState::has_stamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ParkingSlotState::set_has_stamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ParkingSlotState::clear_has_stamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ParkingSlotState::clear_stamp() {
  stamp_ = GOOGLE_ULONGLONG(0);
  clear_has_stamp();
}
inline ::google::protobuf::uint64 ParkingSlotState::stamp() const {
  // @@protoc_insertion_point(field_get:ndm_proto.ParkingSlotState.stamp)
  return stamp_;
}
inline void ParkingSlotState::set_stamp(::google::protobuf::uint64 value) {
  set_has_stamp();
  stamp_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.ParkingSlotState.stamp)
}

// optional uint32 seq_id = 3;
inline bool ParkingSlotState::has_seq_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ParkingSlotState::set_has_seq_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ParkingSlotState::clear_has_seq_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ParkingSlotState::clear_seq_id() {
  seq_id_ = 0u;
  clear_has_seq_id();
}
inline ::google::protobuf::uint32 ParkingSlotState::seq_id() const {
  // @@protoc_insertion_point(field_get:ndm_proto.ParkingSlotState.seq_id)
  return seq_id_;
}
inline void ParkingSlotState::set_seq_id(::google::protobuf::uint32 value) {
  set_has_seq_id();
  seq_id_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.ParkingSlotState.seq_id)
}

// required float life_time = 4;
inline bool ParkingSlotState::has_life_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ParkingSlotState::set_has_life_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ParkingSlotState::clear_has_life_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ParkingSlotState::clear_life_time() {
  life_time_ = 0;
  clear_has_life_time();
}
inline float ParkingSlotState::life_time() const {
  // @@protoc_insertion_point(field_get:ndm_proto.ParkingSlotState.life_time)
  return life_time_;
}
inline void ParkingSlotState::set_life_time(float value) {
  set_has_life_time();
  life_time_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.ParkingSlotState.life_time)
}

// required string associate_parkingslot_id = 5;
inline bool ParkingSlotState::has_associate_parkingslot_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ParkingSlotState::set_has_associate_parkingslot_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ParkingSlotState::clear_has_associate_parkingslot_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ParkingSlotState::clear_associate_parkingslot_id() {
  associate_parkingslot_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_associate_parkingslot_id();
}
inline const ::std::string& ParkingSlotState::associate_parkingslot_id() const {
  // @@protoc_insertion_point(field_get:ndm_proto.ParkingSlotState.associate_parkingslot_id)
  return associate_parkingslot_id_.GetNoArena();
}
inline void ParkingSlotState::set_associate_parkingslot_id(const ::std::string& value) {
  set_has_associate_parkingslot_id();
  associate_parkingslot_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ndm_proto.ParkingSlotState.associate_parkingslot_id)
}
#if LANG_CXX11
inline void ParkingSlotState::set_associate_parkingslot_id(::std::string&& value) {
  set_has_associate_parkingslot_id();
  associate_parkingslot_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ndm_proto.ParkingSlotState.associate_parkingslot_id)
}
#endif
inline void ParkingSlotState::set_associate_parkingslot_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_associate_parkingslot_id();
  associate_parkingslot_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ndm_proto.ParkingSlotState.associate_parkingslot_id)
}
inline void ParkingSlotState::set_associate_parkingslot_id(const char* value, size_t size) {
  set_has_associate_parkingslot_id();
  associate_parkingslot_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.ParkingSlotState.associate_parkingslot_id)
}
inline ::std::string* ParkingSlotState::mutable_associate_parkingslot_id() {
  set_has_associate_parkingslot_id();
  // @@protoc_insertion_point(field_mutable:ndm_proto.ParkingSlotState.associate_parkingslot_id)
  return associate_parkingslot_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ParkingSlotState::release_associate_parkingslot_id() {
  // @@protoc_insertion_point(field_release:ndm_proto.ParkingSlotState.associate_parkingslot_id)
  clear_has_associate_parkingslot_id();
  return associate_parkingslot_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ParkingSlotState::set_allocated_associate_parkingslot_id(::std::string* associate_parkingslot_id) {
  if (associate_parkingslot_id != NULL) {
    set_has_associate_parkingslot_id();
  } else {
    clear_has_associate_parkingslot_id();
  }
  associate_parkingslot_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), associate_parkingslot_id);
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.ParkingSlotState.associate_parkingslot_id)
}

// required bool is_occupied = 10;
inline bool ParkingSlotState::has_is_occupied() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ParkingSlotState::set_has_is_occupied() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ParkingSlotState::clear_has_is_occupied() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ParkingSlotState::clear_is_occupied() {
  is_occupied_ = false;
  clear_has_is_occupied();
}
inline bool ParkingSlotState::is_occupied() const {
  // @@protoc_insertion_point(field_get:ndm_proto.ParkingSlotState.is_occupied)
  return is_occupied_;
}
inline void ParkingSlotState::set_is_occupied(bool value) {
  set_has_is_occupied();
  is_occupied_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.ParkingSlotState.is_occupied)
}

// -------------------------------------------------------------------

// TrafficCone

// required string id = 1;
inline bool TrafficCone::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrafficCone::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrafficCone::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrafficCone::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& TrafficCone::id() const {
  // @@protoc_insertion_point(field_get:ndm_proto.TrafficCone.id)
  return id_.GetNoArena();
}
inline void TrafficCone::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ndm_proto.TrafficCone.id)
}
#if LANG_CXX11
inline void TrafficCone::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ndm_proto.TrafficCone.id)
}
#endif
inline void TrafficCone::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ndm_proto.TrafficCone.id)
}
inline void TrafficCone::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.TrafficCone.id)
}
inline ::std::string* TrafficCone::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:ndm_proto.TrafficCone.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TrafficCone::release_id() {
  // @@protoc_insertion_point(field_release:ndm_proto.TrafficCone.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TrafficCone::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.TrafficCone.id)
}

// required .ndm_proto.Polygon border = 2;
inline bool TrafficCone::has_border() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrafficCone::set_has_border() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrafficCone::clear_has_border() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ndm_proto::Polygon& TrafficCone::border() const {
  const ::ndm_proto::Polygon* p = border_;
  // @@protoc_insertion_point(field_get:ndm_proto.TrafficCone.border)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Polygon*>(
      &::ndm_proto::_Polygon_default_instance_);
}
inline ::ndm_proto::Polygon* TrafficCone::release_border() {
  // @@protoc_insertion_point(field_release:ndm_proto.TrafficCone.border)
  clear_has_border();
  ::ndm_proto::Polygon* temp = border_;
  border_ = NULL;
  return temp;
}
inline ::ndm_proto::Polygon* TrafficCone::mutable_border() {
  set_has_border();
  if (border_ == NULL) {
    border_ = new ::ndm_proto::Polygon;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.TrafficCone.border)
  return border_;
}
inline void TrafficCone::set_allocated_border(::ndm_proto::Polygon* border) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(border_);
  }
  if (border) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      border = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, border, submessage_arena);
    }
    set_has_border();
  } else {
    clear_has_border();
  }
  border_ = border;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.TrafficCone.border)
}

// optional .ndm_proto.Number height = 3;
inline bool TrafficCone::has_height() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TrafficCone::set_has_height() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TrafficCone::clear_has_height() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ndm_proto::Number& TrafficCone::height() const {
  const ::ndm_proto::Number* p = height_;
  // @@protoc_insertion_point(field_get:ndm_proto.TrafficCone.height)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Number*>(
      &::ndm_proto::_Number_default_instance_);
}
inline ::ndm_proto::Number* TrafficCone::release_height() {
  // @@protoc_insertion_point(field_release:ndm_proto.TrafficCone.height)
  clear_has_height();
  ::ndm_proto::Number* temp = height_;
  height_ = NULL;
  return temp;
}
inline ::ndm_proto::Number* TrafficCone::mutable_height() {
  set_has_height();
  if (height_ == NULL) {
    height_ = new ::ndm_proto::Number;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.TrafficCone.height)
  return height_;
}
inline void TrafficCone::set_allocated_height(::ndm_proto::Number* height) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(height_);
  }
  if (height) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      height = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, height, submessage_arena);
    }
    set_has_height();
  } else {
    clear_has_height();
  }
  height_ = height;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.TrafficCone.height)
}

// optional .ndm_proto.TrafficConeType type = 4;
inline bool TrafficCone::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TrafficCone::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TrafficCone::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TrafficCone::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::ndm_proto::TrafficConeType TrafficCone::type() const {
  // @@protoc_insertion_point(field_get:ndm_proto.TrafficCone.type)
  return static_cast< ::ndm_proto::TrafficConeType >(type_);
}
inline void TrafficCone::set_type(::ndm_proto::TrafficConeType value) {
  assert(::ndm_proto::TrafficConeType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.TrafficCone.type)
}

// -------------------------------------------------------------------

// ConstructionZone

// required string id = 1;
inline bool ConstructionZone::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConstructionZone::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConstructionZone::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConstructionZone::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& ConstructionZone::id() const {
  // @@protoc_insertion_point(field_get:ndm_proto.ConstructionZone.id)
  return id_.GetNoArena();
}
inline void ConstructionZone::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ndm_proto.ConstructionZone.id)
}
#if LANG_CXX11
inline void ConstructionZone::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ndm_proto.ConstructionZone.id)
}
#endif
inline void ConstructionZone::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ndm_proto.ConstructionZone.id)
}
inline void ConstructionZone::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.ConstructionZone.id)
}
inline ::std::string* ConstructionZone::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:ndm_proto.ConstructionZone.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ConstructionZone::release_id() {
  // @@protoc_insertion_point(field_release:ndm_proto.ConstructionZone.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConstructionZone::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.ConstructionZone.id)
}

// required uint64 stamp = 2;
inline bool ConstructionZone::has_stamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ConstructionZone::set_has_stamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ConstructionZone::clear_has_stamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ConstructionZone::clear_stamp() {
  stamp_ = GOOGLE_ULONGLONG(0);
  clear_has_stamp();
}
inline ::google::protobuf::uint64 ConstructionZone::stamp() const {
  // @@protoc_insertion_point(field_get:ndm_proto.ConstructionZone.stamp)
  return stamp_;
}
inline void ConstructionZone::set_stamp(::google::protobuf::uint64 value) {
  set_has_stamp();
  stamp_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.ConstructionZone.stamp)
}

// optional uint32 seq_id = 3;
inline bool ConstructionZone::has_seq_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ConstructionZone::set_has_seq_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ConstructionZone::clear_has_seq_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ConstructionZone::clear_seq_id() {
  seq_id_ = 0u;
  clear_has_seq_id();
}
inline ::google::protobuf::uint32 ConstructionZone::seq_id() const {
  // @@protoc_insertion_point(field_get:ndm_proto.ConstructionZone.seq_id)
  return seq_id_;
}
inline void ConstructionZone::set_seq_id(::google::protobuf::uint32 value) {
  set_has_seq_id();
  seq_id_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.ConstructionZone.seq_id)
}

// required float life_time = 4;
inline bool ConstructionZone::has_life_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ConstructionZone::set_has_life_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ConstructionZone::clear_has_life_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ConstructionZone::clear_life_time() {
  life_time_ = 0;
  clear_has_life_time();
}
inline float ConstructionZone::life_time() const {
  // @@protoc_insertion_point(field_get:ndm_proto.ConstructionZone.life_time)
  return life_time_;
}
inline void ConstructionZone::set_life_time(float value) {
  set_has_life_time();
  life_time_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.ConstructionZone.life_time)
}

// required .ndm_proto.Polygon border = 10;
inline bool ConstructionZone::has_border() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConstructionZone::set_has_border() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConstructionZone::clear_has_border() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ndm_proto::Polygon& ConstructionZone::border() const {
  const ::ndm_proto::Polygon* p = border_;
  // @@protoc_insertion_point(field_get:ndm_proto.ConstructionZone.border)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Polygon*>(
      &::ndm_proto::_Polygon_default_instance_);
}
inline ::ndm_proto::Polygon* ConstructionZone::release_border() {
  // @@protoc_insertion_point(field_release:ndm_proto.ConstructionZone.border)
  clear_has_border();
  ::ndm_proto::Polygon* temp = border_;
  border_ = NULL;
  return temp;
}
inline ::ndm_proto::Polygon* ConstructionZone::mutable_border() {
  set_has_border();
  if (border_ == NULL) {
    border_ = new ::ndm_proto::Polygon;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.ConstructionZone.border)
  return border_;
}
inline void ConstructionZone::set_allocated_border(::ndm_proto::Polygon* border) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(border_);
  }
  if (border) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      border = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, border, submessage_arena);
    }
    set_has_border();
  } else {
    clear_has_border();
  }
  border_ = border;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.ConstructionZone.border)
}

// repeated string associate_ids = 11;
inline int ConstructionZone::associate_ids_size() const {
  return associate_ids_.size();
}
inline void ConstructionZone::clear_associate_ids() {
  associate_ids_.Clear();
}
inline const ::std::string& ConstructionZone::associate_ids(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.ConstructionZone.associate_ids)
  return associate_ids_.Get(index);
}
inline ::std::string* ConstructionZone::mutable_associate_ids(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.ConstructionZone.associate_ids)
  return associate_ids_.Mutable(index);
}
inline void ConstructionZone::set_associate_ids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ndm_proto.ConstructionZone.associate_ids)
  associate_ids_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ConstructionZone::set_associate_ids(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:ndm_proto.ConstructionZone.associate_ids)
  associate_ids_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ConstructionZone::set_associate_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  associate_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ndm_proto.ConstructionZone.associate_ids)
}
inline void ConstructionZone::set_associate_ids(int index, const char* value, size_t size) {
  associate_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.ConstructionZone.associate_ids)
}
inline ::std::string* ConstructionZone::add_associate_ids() {
  // @@protoc_insertion_point(field_add_mutable:ndm_proto.ConstructionZone.associate_ids)
  return associate_ids_.Add();
}
inline void ConstructionZone::add_associate_ids(const ::std::string& value) {
  associate_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ndm_proto.ConstructionZone.associate_ids)
}
#if LANG_CXX11
inline void ConstructionZone::add_associate_ids(::std::string&& value) {
  associate_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ndm_proto.ConstructionZone.associate_ids)
}
#endif
inline void ConstructionZone::add_associate_ids(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  associate_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ndm_proto.ConstructionZone.associate_ids)
}
inline void ConstructionZone::add_associate_ids(const char* value, size_t size) {
  associate_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ndm_proto.ConstructionZone.associate_ids)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ConstructionZone::associate_ids() const {
  // @@protoc_insertion_point(field_list:ndm_proto.ConstructionZone.associate_ids)
  return associate_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ConstructionZone::mutable_associate_ids() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.ConstructionZone.associate_ids)
  return &associate_ids_;
}

// -------------------------------------------------------------------

// RestrictedZone

// required string id = 1;
inline bool RestrictedZone::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RestrictedZone::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RestrictedZone::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RestrictedZone::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& RestrictedZone::id() const {
  // @@protoc_insertion_point(field_get:ndm_proto.RestrictedZone.id)
  return id_.GetNoArena();
}
inline void RestrictedZone::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ndm_proto.RestrictedZone.id)
}
#if LANG_CXX11
inline void RestrictedZone::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ndm_proto.RestrictedZone.id)
}
#endif
inline void RestrictedZone::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ndm_proto.RestrictedZone.id)
}
inline void RestrictedZone::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.RestrictedZone.id)
}
inline ::std::string* RestrictedZone::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:ndm_proto.RestrictedZone.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RestrictedZone::release_id() {
  // @@protoc_insertion_point(field_release:ndm_proto.RestrictedZone.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RestrictedZone::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.RestrictedZone.id)
}

// required uint64 stamp = 2;
inline bool RestrictedZone::has_stamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RestrictedZone::set_has_stamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RestrictedZone::clear_has_stamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RestrictedZone::clear_stamp() {
  stamp_ = GOOGLE_ULONGLONG(0);
  clear_has_stamp();
}
inline ::google::protobuf::uint64 RestrictedZone::stamp() const {
  // @@protoc_insertion_point(field_get:ndm_proto.RestrictedZone.stamp)
  return stamp_;
}
inline void RestrictedZone::set_stamp(::google::protobuf::uint64 value) {
  set_has_stamp();
  stamp_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.RestrictedZone.stamp)
}

// optional uint32 seq_id = 3;
inline bool RestrictedZone::has_seq_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RestrictedZone::set_has_seq_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RestrictedZone::clear_has_seq_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RestrictedZone::clear_seq_id() {
  seq_id_ = 0u;
  clear_has_seq_id();
}
inline ::google::protobuf::uint32 RestrictedZone::seq_id() const {
  // @@protoc_insertion_point(field_get:ndm_proto.RestrictedZone.seq_id)
  return seq_id_;
}
inline void RestrictedZone::set_seq_id(::google::protobuf::uint32 value) {
  set_has_seq_id();
  seq_id_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.RestrictedZone.seq_id)
}

// required float life_time = 4;
inline bool RestrictedZone::has_life_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RestrictedZone::set_has_life_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RestrictedZone::clear_has_life_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RestrictedZone::clear_life_time() {
  life_time_ = 0;
  clear_has_life_time();
}
inline float RestrictedZone::life_time() const {
  // @@protoc_insertion_point(field_get:ndm_proto.RestrictedZone.life_time)
  return life_time_;
}
inline void RestrictedZone::set_life_time(float value) {
  set_has_life_time();
  life_time_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.RestrictedZone.life_time)
}

// required .ndm_proto.Polygon border = 10;
inline bool RestrictedZone::has_border() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RestrictedZone::set_has_border() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RestrictedZone::clear_has_border() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ndm_proto::Polygon& RestrictedZone::border() const {
  const ::ndm_proto::Polygon* p = border_;
  // @@protoc_insertion_point(field_get:ndm_proto.RestrictedZone.border)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Polygon*>(
      &::ndm_proto::_Polygon_default_instance_);
}
inline ::ndm_proto::Polygon* RestrictedZone::release_border() {
  // @@protoc_insertion_point(field_release:ndm_proto.RestrictedZone.border)
  clear_has_border();
  ::ndm_proto::Polygon* temp = border_;
  border_ = NULL;
  return temp;
}
inline ::ndm_proto::Polygon* RestrictedZone::mutable_border() {
  set_has_border();
  if (border_ == NULL) {
    border_ = new ::ndm_proto::Polygon;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.RestrictedZone.border)
  return border_;
}
inline void RestrictedZone::set_allocated_border(::ndm_proto::Polygon* border) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(border_);
  }
  if (border) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      border = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, border, submessage_arena);
    }
    set_has_border();
  } else {
    clear_has_border();
  }
  border_ = border;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.RestrictedZone.border)
}

// repeated string associate_ids = 11;
inline int RestrictedZone::associate_ids_size() const {
  return associate_ids_.size();
}
inline void RestrictedZone::clear_associate_ids() {
  associate_ids_.Clear();
}
inline const ::std::string& RestrictedZone::associate_ids(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.RestrictedZone.associate_ids)
  return associate_ids_.Get(index);
}
inline ::std::string* RestrictedZone::mutable_associate_ids(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.RestrictedZone.associate_ids)
  return associate_ids_.Mutable(index);
}
inline void RestrictedZone::set_associate_ids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ndm_proto.RestrictedZone.associate_ids)
  associate_ids_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void RestrictedZone::set_associate_ids(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:ndm_proto.RestrictedZone.associate_ids)
  associate_ids_.Mutable(index)->assign(std::move(value));
}
#endif
inline void RestrictedZone::set_associate_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  associate_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ndm_proto.RestrictedZone.associate_ids)
}
inline void RestrictedZone::set_associate_ids(int index, const char* value, size_t size) {
  associate_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.RestrictedZone.associate_ids)
}
inline ::std::string* RestrictedZone::add_associate_ids() {
  // @@protoc_insertion_point(field_add_mutable:ndm_proto.RestrictedZone.associate_ids)
  return associate_ids_.Add();
}
inline void RestrictedZone::add_associate_ids(const ::std::string& value) {
  associate_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ndm_proto.RestrictedZone.associate_ids)
}
#if LANG_CXX11
inline void RestrictedZone::add_associate_ids(::std::string&& value) {
  associate_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ndm_proto.RestrictedZone.associate_ids)
}
#endif
inline void RestrictedZone::add_associate_ids(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  associate_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ndm_proto.RestrictedZone.associate_ids)
}
inline void RestrictedZone::add_associate_ids(const char* value, size_t size) {
  associate_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ndm_proto.RestrictedZone.associate_ids)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RestrictedZone::associate_ids() const {
  // @@protoc_insertion_point(field_list:ndm_proto.RestrictedZone.associate_ids)
  return associate_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RestrictedZone::mutable_associate_ids() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.RestrictedZone.associate_ids)
  return &associate_ids_;
}

// -------------------------------------------------------------------

// StaticODD

// required string id = 1;
inline bool StaticODD::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StaticODD::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StaticODD::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StaticODD::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& StaticODD::id() const {
  // @@protoc_insertion_point(field_get:ndm_proto.StaticODD.id)
  return id_.GetNoArena();
}
inline void StaticODD::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ndm_proto.StaticODD.id)
}
#if LANG_CXX11
inline void StaticODD::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ndm_proto.StaticODD.id)
}
#endif
inline void StaticODD::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ndm_proto.StaticODD.id)
}
inline void StaticODD::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.StaticODD.id)
}
inline ::std::string* StaticODD::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:ndm_proto.StaticODD.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StaticODD::release_id() {
  // @@protoc_insertion_point(field_release:ndm_proto.StaticODD.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StaticODD::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.StaticODD.id)
}

// required bool is_odd = 2;
inline bool StaticODD::has_is_odd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StaticODD::set_has_is_odd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StaticODD::clear_has_is_odd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StaticODD::clear_is_odd() {
  is_odd_ = false;
  clear_has_is_odd();
}
inline bool StaticODD::is_odd() const {
  // @@protoc_insertion_point(field_get:ndm_proto.StaticODD.is_odd)
  return is_odd_;
}
inline void StaticODD::set_is_odd(bool value) {
  set_has_is_odd();
  is_odd_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.StaticODD.is_odd)
}

// required uint32 type = 3;
inline bool StaticODD::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StaticODD::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StaticODD::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StaticODD::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 StaticODD::type() const {
  // @@protoc_insertion_point(field_get:ndm_proto.StaticODD.type)
  return type_;
}
inline void StaticODD::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.StaticODD.type)
}

// required uint32 action = 4;
inline bool StaticODD::has_action() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void StaticODD::set_has_action() {
  _has_bits_[0] |= 0x00000010u;
}
inline void StaticODD::clear_has_action() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void StaticODD::clear_action() {
  action_ = 0u;
  clear_has_action();
}
inline ::google::protobuf::uint32 StaticODD::action() const {
  // @@protoc_insertion_point(field_get:ndm_proto.StaticODD.action)
  return action_;
}
inline void StaticODD::set_action(::google::protobuf::uint32 value) {
  set_has_action();
  action_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.StaticODD.action)
}

// required uint64 reason = 5;
inline bool StaticODD::has_reason() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StaticODD::set_has_reason() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StaticODD::clear_has_reason() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StaticODD::clear_reason() {
  reason_ = GOOGLE_ULONGLONG(0);
  clear_has_reason();
}
inline ::google::protobuf::uint64 StaticODD::reason() const {
  // @@protoc_insertion_point(field_get:ndm_proto.StaticODD.reason)
  return reason_;
}
inline void StaticODD::set_reason(::google::protobuf::uint64 value) {
  set_has_reason();
  reason_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.StaticODD.reason)
}

// repeated .ndm_proto.Link links = 6;
inline int StaticODD::links_size() const {
  return links_.size();
}
inline const ::ndm_proto::Link& StaticODD::links(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.StaticODD.links)
  return links_.Get(index);
}
inline ::ndm_proto::Link* StaticODD::mutable_links(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.StaticODD.links)
  return links_.Mutable(index);
}
inline ::ndm_proto::Link* StaticODD::add_links() {
  // @@protoc_insertion_point(field_add:ndm_proto.StaticODD.links)
  return links_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::Link >*
StaticODD::mutable_links() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.StaticODD.links)
  return &links_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Link >&
StaticODD::links() const {
  // @@protoc_insertion_point(field_list:ndm_proto.StaticODD.links)
  return links_;
}

// -------------------------------------------------------------------

// TrafficEvent

// required string id = 1;
inline bool TrafficEvent::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrafficEvent::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrafficEvent::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrafficEvent::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& TrafficEvent::id() const {
  // @@protoc_insertion_point(field_get:ndm_proto.TrafficEvent.id)
  return id_.GetNoArena();
}
inline void TrafficEvent::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ndm_proto.TrafficEvent.id)
}
#if LANG_CXX11
inline void TrafficEvent::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ndm_proto.TrafficEvent.id)
}
#endif
inline void TrafficEvent::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ndm_proto.TrafficEvent.id)
}
inline void TrafficEvent::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.TrafficEvent.id)
}
inline ::std::string* TrafficEvent::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:ndm_proto.TrafficEvent.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TrafficEvent::release_id() {
  // @@protoc_insertion_point(field_release:ndm_proto.TrafficEvent.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TrafficEvent::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.TrafficEvent.id)
}

// required .ndm_proto.TrafficEventType eventType = 2;
inline bool TrafficEvent::has_eventtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrafficEvent::set_has_eventtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrafficEvent::clear_has_eventtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrafficEvent::clear_eventtype() {
  eventtype_ = 0;
  clear_has_eventtype();
}
inline ::ndm_proto::TrafficEventType TrafficEvent::eventtype() const {
  // @@protoc_insertion_point(field_get:ndm_proto.TrafficEvent.eventType)
  return static_cast< ::ndm_proto::TrafficEventType >(eventtype_);
}
inline void TrafficEvent::set_eventtype(::ndm_proto::TrafficEventType value) {
  assert(::ndm_proto::TrafficEventType_IsValid(value));
  set_has_eventtype();
  eventtype_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.TrafficEvent.eventType)
}

// required uint32 reliability = 3;
inline bool TrafficEvent::has_reliability() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TrafficEvent::set_has_reliability() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TrafficEvent::clear_has_reliability() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TrafficEvent::clear_reliability() {
  reliability_ = 0u;
  clear_has_reliability();
}
inline ::google::protobuf::uint32 TrafficEvent::reliability() const {
  // @@protoc_insertion_point(field_get:ndm_proto.TrafficEvent.reliability)
  return reliability_;
}
inline void TrafficEvent::set_reliability(::google::protobuf::uint32 value) {
  set_has_reliability();
  reliability_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.TrafficEvent.reliability)
}

// repeated .ndm_proto.Link links = 4;
inline int TrafficEvent::links_size() const {
  return links_.size();
}
inline const ::ndm_proto::Link& TrafficEvent::links(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.TrafficEvent.links)
  return links_.Get(index);
}
inline ::ndm_proto::Link* TrafficEvent::mutable_links(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.TrafficEvent.links)
  return links_.Mutable(index);
}
inline ::ndm_proto::Link* TrafficEvent::add_links() {
  // @@protoc_insertion_point(field_add:ndm_proto.TrafficEvent.links)
  return links_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::Link >*
TrafficEvent::mutable_links() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.TrafficEvent.links)
  return &links_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Link >&
TrafficEvent::links() const {
  // @@protoc_insertion_point(field_list:ndm_proto.TrafficEvent.links)
  return links_;
}

// -------------------------------------------------------------------

// TrafficFlow

// required string id = 1;
inline bool TrafficFlow::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrafficFlow::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrafficFlow::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrafficFlow::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& TrafficFlow::id() const {
  // @@protoc_insertion_point(field_get:ndm_proto.TrafficFlow.id)
  return id_.GetNoArena();
}
inline void TrafficFlow::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ndm_proto.TrafficFlow.id)
}
#if LANG_CXX11
inline void TrafficFlow::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ndm_proto.TrafficFlow.id)
}
#endif
inline void TrafficFlow::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ndm_proto.TrafficFlow.id)
}
inline void TrafficFlow::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.TrafficFlow.id)
}
inline ::std::string* TrafficFlow::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:ndm_proto.TrafficFlow.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TrafficFlow::release_id() {
  // @@protoc_insertion_point(field_release:ndm_proto.TrafficFlow.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TrafficFlow::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.TrafficFlow.id)
}

// required .ndm_proto.TrafficFlowStatus flowStatus = 2;
inline bool TrafficFlow::has_flowstatus() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrafficFlow::set_has_flowstatus() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrafficFlow::clear_has_flowstatus() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrafficFlow::clear_flowstatus() {
  flowstatus_ = 0;
  clear_has_flowstatus();
}
inline ::ndm_proto::TrafficFlowStatus TrafficFlow::flowstatus() const {
  // @@protoc_insertion_point(field_get:ndm_proto.TrafficFlow.flowStatus)
  return static_cast< ::ndm_proto::TrafficFlowStatus >(flowstatus_);
}
inline void TrafficFlow::set_flowstatus(::ndm_proto::TrafficFlowStatus value) {
  assert(::ndm_proto::TrafficFlowStatus_IsValid(value));
  set_has_flowstatus();
  flowstatus_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.TrafficFlow.flowStatus)
}

// required uint32 reliability = 3;
inline bool TrafficFlow::has_reliability() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TrafficFlow::set_has_reliability() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TrafficFlow::clear_has_reliability() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TrafficFlow::clear_reliability() {
  reliability_ = 0u;
  clear_has_reliability();
}
inline ::google::protobuf::uint32 TrafficFlow::reliability() const {
  // @@protoc_insertion_point(field_get:ndm_proto.TrafficFlow.reliability)
  return reliability_;
}
inline void TrafficFlow::set_reliability(::google::protobuf::uint32 value) {
  set_has_reliability();
  reliability_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.TrafficFlow.reliability)
}

// repeated .ndm_proto.Link links = 4;
inline int TrafficFlow::links_size() const {
  return links_.size();
}
inline const ::ndm_proto::Link& TrafficFlow::links(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.TrafficFlow.links)
  return links_.Get(index);
}
inline ::ndm_proto::Link* TrafficFlow::mutable_links(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.TrafficFlow.links)
  return links_.Mutable(index);
}
inline ::ndm_proto::Link* TrafficFlow::add_links() {
  // @@protoc_insertion_point(field_add:ndm_proto.TrafficFlow.links)
  return links_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::Link >*
TrafficFlow::mutable_links() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.TrafficFlow.links)
  return &links_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Link >&
TrafficFlow::links() const {
  // @@protoc_insertion_point(field_list:ndm_proto.TrafficFlow.links)
  return links_;
}

// -------------------------------------------------------------------

// DynamicLayer

// repeated .ndm_proto.MoveableObject moveable_objects = 1;
inline int DynamicLayer::moveable_objects_size() const {
  return moveable_objects_.size();
}
inline void DynamicLayer::clear_moveable_objects() {
  moveable_objects_.Clear();
}
inline const ::ndm_proto::MoveableObject& DynamicLayer::moveable_objects(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.DynamicLayer.moveable_objects)
  return moveable_objects_.Get(index);
}
inline ::ndm_proto::MoveableObject* DynamicLayer::mutable_moveable_objects(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.DynamicLayer.moveable_objects)
  return moveable_objects_.Mutable(index);
}
inline ::ndm_proto::MoveableObject* DynamicLayer::add_moveable_objects() {
  // @@protoc_insertion_point(field_add:ndm_proto.DynamicLayer.moveable_objects)
  return moveable_objects_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::MoveableObject >*
DynamicLayer::mutable_moveable_objects() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.DynamicLayer.moveable_objects)
  return &moveable_objects_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::MoveableObject >&
DynamicLayer::moveable_objects() const {
  // @@protoc_insertion_point(field_list:ndm_proto.DynamicLayer.moveable_objects)
  return moveable_objects_;
}

// repeated .ndm_proto.TrafficLightDynamicState trafficlight_states = 2;
inline int DynamicLayer::trafficlight_states_size() const {
  return trafficlight_states_.size();
}
inline void DynamicLayer::clear_trafficlight_states() {
  trafficlight_states_.Clear();
}
inline const ::ndm_proto::TrafficLightDynamicState& DynamicLayer::trafficlight_states(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.DynamicLayer.trafficlight_states)
  return trafficlight_states_.Get(index);
}
inline ::ndm_proto::TrafficLightDynamicState* DynamicLayer::mutable_trafficlight_states(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.DynamicLayer.trafficlight_states)
  return trafficlight_states_.Mutable(index);
}
inline ::ndm_proto::TrafficLightDynamicState* DynamicLayer::add_trafficlight_states() {
  // @@protoc_insertion_point(field_add:ndm_proto.DynamicLayer.trafficlight_states)
  return trafficlight_states_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::TrafficLightDynamicState >*
DynamicLayer::mutable_trafficlight_states() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.DynamicLayer.trafficlight_states)
  return &trafficlight_states_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::TrafficLightDynamicState >&
DynamicLayer::trafficlight_states() const {
  // @@protoc_insertion_point(field_list:ndm_proto.DynamicLayer.trafficlight_states)
  return trafficlight_states_;
}

// repeated .ndm_proto.ParkingSlotState parkingslot_states = 3;
inline int DynamicLayer::parkingslot_states_size() const {
  return parkingslot_states_.size();
}
inline void DynamicLayer::clear_parkingslot_states() {
  parkingslot_states_.Clear();
}
inline const ::ndm_proto::ParkingSlotState& DynamicLayer::parkingslot_states(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.DynamicLayer.parkingslot_states)
  return parkingslot_states_.Get(index);
}
inline ::ndm_proto::ParkingSlotState* DynamicLayer::mutable_parkingslot_states(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.DynamicLayer.parkingslot_states)
  return parkingslot_states_.Mutable(index);
}
inline ::ndm_proto::ParkingSlotState* DynamicLayer::add_parkingslot_states() {
  // @@protoc_insertion_point(field_add:ndm_proto.DynamicLayer.parkingslot_states)
  return parkingslot_states_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::ParkingSlotState >*
DynamicLayer::mutable_parkingslot_states() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.DynamicLayer.parkingslot_states)
  return &parkingslot_states_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::ParkingSlotState >&
DynamicLayer::parkingslot_states() const {
  // @@protoc_insertion_point(field_list:ndm_proto.DynamicLayer.parkingslot_states)
  return parkingslot_states_;
}

// repeated .ndm_proto.ConstructionZone construction_zones = 4;
inline int DynamicLayer::construction_zones_size() const {
  return construction_zones_.size();
}
inline void DynamicLayer::clear_construction_zones() {
  construction_zones_.Clear();
}
inline const ::ndm_proto::ConstructionZone& DynamicLayer::construction_zones(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.DynamicLayer.construction_zones)
  return construction_zones_.Get(index);
}
inline ::ndm_proto::ConstructionZone* DynamicLayer::mutable_construction_zones(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.DynamicLayer.construction_zones)
  return construction_zones_.Mutable(index);
}
inline ::ndm_proto::ConstructionZone* DynamicLayer::add_construction_zones() {
  // @@protoc_insertion_point(field_add:ndm_proto.DynamicLayer.construction_zones)
  return construction_zones_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::ConstructionZone >*
DynamicLayer::mutable_construction_zones() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.DynamicLayer.construction_zones)
  return &construction_zones_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::ConstructionZone >&
DynamicLayer::construction_zones() const {
  // @@protoc_insertion_point(field_list:ndm_proto.DynamicLayer.construction_zones)
  return construction_zones_;
}

// repeated .ndm_proto.RestrictedZone restricted_zone = 5;
inline int DynamicLayer::restricted_zone_size() const {
  return restricted_zone_.size();
}
inline void DynamicLayer::clear_restricted_zone() {
  restricted_zone_.Clear();
}
inline const ::ndm_proto::RestrictedZone& DynamicLayer::restricted_zone(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.DynamicLayer.restricted_zone)
  return restricted_zone_.Get(index);
}
inline ::ndm_proto::RestrictedZone* DynamicLayer::mutable_restricted_zone(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.DynamicLayer.restricted_zone)
  return restricted_zone_.Mutable(index);
}
inline ::ndm_proto::RestrictedZone* DynamicLayer::add_restricted_zone() {
  // @@protoc_insertion_point(field_add:ndm_proto.DynamicLayer.restricted_zone)
  return restricted_zone_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::RestrictedZone >*
DynamicLayer::mutable_restricted_zone() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.DynamicLayer.restricted_zone)
  return &restricted_zone_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::RestrictedZone >&
DynamicLayer::restricted_zone() const {
  // @@protoc_insertion_point(field_list:ndm_proto.DynamicLayer.restricted_zone)
  return restricted_zone_;
}

// repeated .ndm_proto.TrafficCone cones = 6;
inline int DynamicLayer::cones_size() const {
  return cones_.size();
}
inline void DynamicLayer::clear_cones() {
  cones_.Clear();
}
inline const ::ndm_proto::TrafficCone& DynamicLayer::cones(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.DynamicLayer.cones)
  return cones_.Get(index);
}
inline ::ndm_proto::TrafficCone* DynamicLayer::mutable_cones(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.DynamicLayer.cones)
  return cones_.Mutable(index);
}
inline ::ndm_proto::TrafficCone* DynamicLayer::add_cones() {
  // @@protoc_insertion_point(field_add:ndm_proto.DynamicLayer.cones)
  return cones_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::TrafficCone >*
DynamicLayer::mutable_cones() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.DynamicLayer.cones)
  return &cones_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::TrafficCone >&
DynamicLayer::cones() const {
  // @@protoc_insertion_point(field_list:ndm_proto.DynamicLayer.cones)
  return cones_;
}

// repeated .ndm_proto.StaticODD static_odds = 7;
inline int DynamicLayer::static_odds_size() const {
  return static_odds_.size();
}
inline void DynamicLayer::clear_static_odds() {
  static_odds_.Clear();
}
inline const ::ndm_proto::StaticODD& DynamicLayer::static_odds(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.DynamicLayer.static_odds)
  return static_odds_.Get(index);
}
inline ::ndm_proto::StaticODD* DynamicLayer::mutable_static_odds(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.DynamicLayer.static_odds)
  return static_odds_.Mutable(index);
}
inline ::ndm_proto::StaticODD* DynamicLayer::add_static_odds() {
  // @@protoc_insertion_point(field_add:ndm_proto.DynamicLayer.static_odds)
  return static_odds_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::StaticODD >*
DynamicLayer::mutable_static_odds() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.DynamicLayer.static_odds)
  return &static_odds_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::StaticODD >&
DynamicLayer::static_odds() const {
  // @@protoc_insertion_point(field_list:ndm_proto.DynamicLayer.static_odds)
  return static_odds_;
}

// repeated .ndm_proto.TrafficEvent traffic_events = 8;
inline int DynamicLayer::traffic_events_size() const {
  return traffic_events_.size();
}
inline void DynamicLayer::clear_traffic_events() {
  traffic_events_.Clear();
}
inline const ::ndm_proto::TrafficEvent& DynamicLayer::traffic_events(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.DynamicLayer.traffic_events)
  return traffic_events_.Get(index);
}
inline ::ndm_proto::TrafficEvent* DynamicLayer::mutable_traffic_events(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.DynamicLayer.traffic_events)
  return traffic_events_.Mutable(index);
}
inline ::ndm_proto::TrafficEvent* DynamicLayer::add_traffic_events() {
  // @@protoc_insertion_point(field_add:ndm_proto.DynamicLayer.traffic_events)
  return traffic_events_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::TrafficEvent >*
DynamicLayer::mutable_traffic_events() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.DynamicLayer.traffic_events)
  return &traffic_events_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::TrafficEvent >&
DynamicLayer::traffic_events() const {
  // @@protoc_insertion_point(field_list:ndm_proto.DynamicLayer.traffic_events)
  return traffic_events_;
}

// repeated .ndm_proto.TrafficFlow traffic_flows = 9;
inline int DynamicLayer::traffic_flows_size() const {
  return traffic_flows_.size();
}
inline void DynamicLayer::clear_traffic_flows() {
  traffic_flows_.Clear();
}
inline const ::ndm_proto::TrafficFlow& DynamicLayer::traffic_flows(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.DynamicLayer.traffic_flows)
  return traffic_flows_.Get(index);
}
inline ::ndm_proto::TrafficFlow* DynamicLayer::mutable_traffic_flows(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.DynamicLayer.traffic_flows)
  return traffic_flows_.Mutable(index);
}
inline ::ndm_proto::TrafficFlow* DynamicLayer::add_traffic_flows() {
  // @@protoc_insertion_point(field_add:ndm_proto.DynamicLayer.traffic_flows)
  return traffic_flows_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::TrafficFlow >*
DynamicLayer::mutable_traffic_flows() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.DynamicLayer.traffic_flows)
  return &traffic_flows_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::TrafficFlow >&
DynamicLayer::traffic_flows() const {
  // @@protoc_insertion_point(field_list:ndm_proto.DynamicLayer.traffic_flows)
  return traffic_flows_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ndm_proto

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::ndm_proto::ObjectAttribute_ObjectType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ndm_proto::ObjectAttribute_ObjectType>() {
  return ::ndm_proto::ObjectAttribute_ObjectType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_dynamic_5flayer_2eproto__INCLUDED
