// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sense.proto

#ifndef PROTOBUF_sense_2eproto__INCLUDED
#define PROTOBUF_sense_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_sense_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[13];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsHeaderImpl();
void InitDefaultsHeader();
void InitDefaultsVector2FImpl();
void InitDefaultsVector2F();
void InitDefaultsVector3DImpl();
void InitDefaultsVector3D();
void InitDefaultsVector3FImpl();
void InitDefaultsVector3F();
void InitDefaultsVector4DImpl();
void InitDefaultsVector4D();
void InitDefaultsVector4FImpl();
void InitDefaultsVector4F();
void InitDefaultsQuaternionImpl();
void InitDefaultsQuaternion();
void InitDefaultsUNPACK_IMU_ALGImpl();
void InitDefaultsUNPACK_IMU_ALG();
void InitDefaultsCANFrameImpl();
void InitDefaultsCANFrame();
void InitDefaultsVehicleMsgImpl();
void InitDefaultsVehicleMsg();
void InitDefaultsGNSSStatusImpl();
void InitDefaultsGNSSStatus();
void InitDefaultsGNSSFrameImpl();
void InitDefaultsGNSSFrame();
void InitDefaultsIMUFrameImpl();
void InitDefaultsIMUFrame();
inline void InitDefaults() {
  InitDefaultsHeader();
  InitDefaultsVector2F();
  InitDefaultsVector3D();
  InitDefaultsVector3F();
  InitDefaultsVector4D();
  InitDefaultsVector4F();
  InitDefaultsQuaternion();
  InitDefaultsUNPACK_IMU_ALG();
  InitDefaultsCANFrame();
  InitDefaultsVehicleMsg();
  InitDefaultsGNSSStatus();
  InitDefaultsGNSSFrame();
  InitDefaultsIMUFrame();
}
}  // namespace protobuf_sense_2eproto
namespace ndm_proto {
class CANFrame;
class CANFrameDefaultTypeInternal;
extern CANFrameDefaultTypeInternal _CANFrame_default_instance_;
class GNSSFrame;
class GNSSFrameDefaultTypeInternal;
extern GNSSFrameDefaultTypeInternal _GNSSFrame_default_instance_;
class GNSSStatus;
class GNSSStatusDefaultTypeInternal;
extern GNSSStatusDefaultTypeInternal _GNSSStatus_default_instance_;
class Header;
class HeaderDefaultTypeInternal;
extern HeaderDefaultTypeInternal _Header_default_instance_;
class IMUFrame;
class IMUFrameDefaultTypeInternal;
extern IMUFrameDefaultTypeInternal _IMUFrame_default_instance_;
class Quaternion;
class QuaternionDefaultTypeInternal;
extern QuaternionDefaultTypeInternal _Quaternion_default_instance_;
class UNPACK_IMU_ALG;
class UNPACK_IMU_ALGDefaultTypeInternal;
extern UNPACK_IMU_ALGDefaultTypeInternal _UNPACK_IMU_ALG_default_instance_;
class Vector2F;
class Vector2FDefaultTypeInternal;
extern Vector2FDefaultTypeInternal _Vector2F_default_instance_;
class Vector3D;
class Vector3DDefaultTypeInternal;
extern Vector3DDefaultTypeInternal _Vector3D_default_instance_;
class Vector3F;
class Vector3FDefaultTypeInternal;
extern Vector3FDefaultTypeInternal _Vector3F_default_instance_;
class Vector4D;
class Vector4DDefaultTypeInternal;
extern Vector4DDefaultTypeInternal _Vector4D_default_instance_;
class Vector4F;
class Vector4FDefaultTypeInternal;
extern Vector4FDefaultTypeInternal _Vector4F_default_instance_;
class VehicleMsg;
class VehicleMsgDefaultTypeInternal;
extern VehicleMsgDefaultTypeInternal _VehicleMsg_default_instance_;
}  // namespace ndm_proto
namespace ndm_proto {

// ===================================================================

class Header : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.Header) */ {
 public:
  Header();
  virtual ~Header();

  Header(const Header& from);

  inline Header& operator=(const Header& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Header(Header&& from) noexcept
    : Header() {
    *this = ::std::move(from);
  }

  inline Header& operator=(Header&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Header& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Header* internal_default_instance() {
    return reinterpret_cast<const Header*>(
               &_Header_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Header* other);
  friend void swap(Header& a, Header& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Header* New() const PROTOBUF_FINAL { return New(NULL); }

  Header* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Header& from);
  void MergeFrom(const Header& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Header* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string frame_id = 3;
  bool has_frame_id() const;
  void clear_frame_id();
  static const int kFrameIdFieldNumber = 3;
  const ::std::string& frame_id() const;
  void set_frame_id(const ::std::string& value);
  #if LANG_CXX11
  void set_frame_id(::std::string&& value);
  #endif
  void set_frame_id(const char* value);
  void set_frame_id(const char* value, size_t size);
  ::std::string* mutable_frame_id();
  ::std::string* release_frame_id();
  void set_allocated_frame_id(::std::string* frame_id);

  // required int64 stamp = 1;
  bool has_stamp() const;
  void clear_stamp();
  static const int kStampFieldNumber = 1;
  ::google::protobuf::int64 stamp() const;
  void set_stamp(::google::protobuf::int64 value);

  // required int64 seq = 2;
  bool has_seq() const;
  void clear_seq();
  static const int kSeqFieldNumber = 2;
  ::google::protobuf::int64 seq() const;
  void set_seq(::google::protobuf::int64 value);

  // optional int32 version = 4;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 4;
  ::google::protobuf::int32 version() const;
  void set_version(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ndm_proto.Header)
 private:
  void set_has_stamp();
  void clear_has_stamp();
  void set_has_seq();
  void clear_has_seq();
  void set_has_frame_id();
  void clear_has_frame_id();
  void set_has_version();
  void clear_has_version();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr frame_id_;
  ::google::protobuf::int64 stamp_;
  ::google::protobuf::int64 seq_;
  ::google::protobuf::int32 version_;
  friend struct ::protobuf_sense_2eproto::TableStruct;
  friend void ::protobuf_sense_2eproto::InitDefaultsHeaderImpl();
};
// -------------------------------------------------------------------

class Vector2F : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.Vector2F) */ {
 public:
  Vector2F();
  virtual ~Vector2F();

  Vector2F(const Vector2F& from);

  inline Vector2F& operator=(const Vector2F& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Vector2F(Vector2F&& from) noexcept
    : Vector2F() {
    *this = ::std::move(from);
  }

  inline Vector2F& operator=(Vector2F&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vector2F& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vector2F* internal_default_instance() {
    return reinterpret_cast<const Vector2F*>(
               &_Vector2F_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Vector2F* other);
  friend void swap(Vector2F& a, Vector2F& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Vector2F* New() const PROTOBUF_FINAL { return New(NULL); }

  Vector2F* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Vector2F& from);
  void MergeFrom(const Vector2F& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Vector2F* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // optional float y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // @@protoc_insertion_point(class_scope:ndm_proto.Vector2F)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float x_;
  float y_;
  friend struct ::protobuf_sense_2eproto::TableStruct;
  friend void ::protobuf_sense_2eproto::InitDefaultsVector2FImpl();
};
// -------------------------------------------------------------------

class Vector3D : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.Vector3D) */ {
 public:
  Vector3D();
  virtual ~Vector3D();

  Vector3D(const Vector3D& from);

  inline Vector3D& operator=(const Vector3D& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Vector3D(Vector3D&& from) noexcept
    : Vector3D() {
    *this = ::std::move(from);
  }

  inline Vector3D& operator=(Vector3D&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vector3D& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vector3D* internal_default_instance() {
    return reinterpret_cast<const Vector3D*>(
               &_Vector3D_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(Vector3D* other);
  friend void swap(Vector3D& a, Vector3D& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Vector3D* New() const PROTOBUF_FINAL { return New(NULL); }

  Vector3D* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Vector3D& from);
  void MergeFrom(const Vector3D& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Vector3D* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // optional double y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // optional double z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  double z() const;
  void set_z(double value);

  // @@protoc_insertion_point(class_scope:ndm_proto.Vector3D)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_z();
  void clear_has_z();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double x_;
  double y_;
  double z_;
  friend struct ::protobuf_sense_2eproto::TableStruct;
  friend void ::protobuf_sense_2eproto::InitDefaultsVector3DImpl();
};
// -------------------------------------------------------------------

class Vector3F : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.Vector3F) */ {
 public:
  Vector3F();
  virtual ~Vector3F();

  Vector3F(const Vector3F& from);

  inline Vector3F& operator=(const Vector3F& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Vector3F(Vector3F&& from) noexcept
    : Vector3F() {
    *this = ::std::move(from);
  }

  inline Vector3F& operator=(Vector3F&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vector3F& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vector3F* internal_default_instance() {
    return reinterpret_cast<const Vector3F*>(
               &_Vector3F_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(Vector3F* other);
  friend void swap(Vector3F& a, Vector3F& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Vector3F* New() const PROTOBUF_FINAL { return New(NULL); }

  Vector3F* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Vector3F& from);
  void MergeFrom(const Vector3F& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Vector3F* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // optional float y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // optional float z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  float z() const;
  void set_z(float value);

  // @@protoc_insertion_point(class_scope:ndm_proto.Vector3F)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_z();
  void clear_has_z();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float x_;
  float y_;
  float z_;
  friend struct ::protobuf_sense_2eproto::TableStruct;
  friend void ::protobuf_sense_2eproto::InitDefaultsVector3FImpl();
};
// -------------------------------------------------------------------

class Vector4D : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.Vector4D) */ {
 public:
  Vector4D();
  virtual ~Vector4D();

  Vector4D(const Vector4D& from);

  inline Vector4D& operator=(const Vector4D& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Vector4D(Vector4D&& from) noexcept
    : Vector4D() {
    *this = ::std::move(from);
  }

  inline Vector4D& operator=(Vector4D&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vector4D& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vector4D* internal_default_instance() {
    return reinterpret_cast<const Vector4D*>(
               &_Vector4D_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(Vector4D* other);
  friend void swap(Vector4D& a, Vector4D& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Vector4D* New() const PROTOBUF_FINAL { return New(NULL); }

  Vector4D* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Vector4D& from);
  void MergeFrom(const Vector4D& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Vector4D* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // optional double y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // optional double z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  double z() const;
  void set_z(double value);

  // optional double w = 4;
  bool has_w() const;
  void clear_w();
  static const int kWFieldNumber = 4;
  double w() const;
  void set_w(double value);

  // @@protoc_insertion_point(class_scope:ndm_proto.Vector4D)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_z();
  void clear_has_z();
  void set_has_w();
  void clear_has_w();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double x_;
  double y_;
  double z_;
  double w_;
  friend struct ::protobuf_sense_2eproto::TableStruct;
  friend void ::protobuf_sense_2eproto::InitDefaultsVector4DImpl();
};
// -------------------------------------------------------------------

class Vector4F : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.Vector4F) */ {
 public:
  Vector4F();
  virtual ~Vector4F();

  Vector4F(const Vector4F& from);

  inline Vector4F& operator=(const Vector4F& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Vector4F(Vector4F&& from) noexcept
    : Vector4F() {
    *this = ::std::move(from);
  }

  inline Vector4F& operator=(Vector4F&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vector4F& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vector4F* internal_default_instance() {
    return reinterpret_cast<const Vector4F*>(
               &_Vector4F_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(Vector4F* other);
  friend void swap(Vector4F& a, Vector4F& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Vector4F* New() const PROTOBUF_FINAL { return New(NULL); }

  Vector4F* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Vector4F& from);
  void MergeFrom(const Vector4F& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Vector4F* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // optional float y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // optional float z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  float z() const;
  void set_z(float value);

  // optional float w = 4;
  bool has_w() const;
  void clear_w();
  static const int kWFieldNumber = 4;
  float w() const;
  void set_w(float value);

  // @@protoc_insertion_point(class_scope:ndm_proto.Vector4F)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_z();
  void clear_has_z();
  void set_has_w();
  void clear_has_w();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float x_;
  float y_;
  float z_;
  float w_;
  friend struct ::protobuf_sense_2eproto::TableStruct;
  friend void ::protobuf_sense_2eproto::InitDefaultsVector4FImpl();
};
// -------------------------------------------------------------------

class Quaternion : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.Quaternion) */ {
 public:
  Quaternion();
  virtual ~Quaternion();

  Quaternion(const Quaternion& from);

  inline Quaternion& operator=(const Quaternion& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Quaternion(Quaternion&& from) noexcept
    : Quaternion() {
    *this = ::std::move(from);
  }

  inline Quaternion& operator=(Quaternion&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Quaternion& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Quaternion* internal_default_instance() {
    return reinterpret_cast<const Quaternion*>(
               &_Quaternion_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(Quaternion* other);
  friend void swap(Quaternion& a, Quaternion& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Quaternion* New() const PROTOBUF_FINAL { return New(NULL); }

  Quaternion* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Quaternion& from);
  void MergeFrom(const Quaternion& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Quaternion* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // optional float y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // optional float z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  float z() const;
  void set_z(float value);

  // optional float w = 4;
  bool has_w() const;
  void clear_w();
  static const int kWFieldNumber = 4;
  float w() const;
  void set_w(float value);

  // @@protoc_insertion_point(class_scope:ndm_proto.Quaternion)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_z();
  void clear_has_z();
  void set_has_w();
  void clear_has_w();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float x_;
  float y_;
  float z_;
  float w_;
  friend struct ::protobuf_sense_2eproto::TableStruct;
  friend void ::protobuf_sense_2eproto::InitDefaultsQuaternionImpl();
};
// -------------------------------------------------------------------

class UNPACK_IMU_ALG : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.UNPACK_IMU_ALG) */ {
 public:
  UNPACK_IMU_ALG();
  virtual ~UNPACK_IMU_ALG();

  UNPACK_IMU_ALG(const UNPACK_IMU_ALG& from);

  inline UNPACK_IMU_ALG& operator=(const UNPACK_IMU_ALG& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UNPACK_IMU_ALG(UNPACK_IMU_ALG&& from) noexcept
    : UNPACK_IMU_ALG() {
    *this = ::std::move(from);
  }

  inline UNPACK_IMU_ALG& operator=(UNPACK_IMU_ALG&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UNPACK_IMU_ALG& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UNPACK_IMU_ALG* internal_default_instance() {
    return reinterpret_cast<const UNPACK_IMU_ALG*>(
               &_UNPACK_IMU_ALG_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(UNPACK_IMU_ALG* other);
  friend void swap(UNPACK_IMU_ALG& a, UNPACK_IMU_ALG& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UNPACK_IMU_ALG* New() const PROTOBUF_FINAL { return New(NULL); }

  UNPACK_IMU_ALG* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UNPACK_IMU_ALG& from);
  void MergeFrom(const UNPACK_IMU_ALG& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UNPACK_IMU_ALG* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ndm_proto.Vector3D trans = 3;
  bool has_trans() const;
  void clear_trans();
  static const int kTransFieldNumber = 3;
  const ::ndm_proto::Vector3D& trans() const;
  ::ndm_proto::Vector3D* release_trans();
  ::ndm_proto::Vector3D* mutable_trans();
  void set_allocated_trans(::ndm_proto::Vector3D* trans);

  // optional .ndm_proto.Vector4D orientation = 4;
  bool has_orientation() const;
  void clear_orientation();
  static const int kOrientationFieldNumber = 4;
  const ::ndm_proto::Vector4D& orientation() const;
  ::ndm_proto::Vector4D* release_orientation();
  ::ndm_proto::Vector4D* mutable_orientation();
  void set_allocated_orientation(::ndm_proto::Vector4D* orientation);

  // optional int32 automntalgon = 1;
  bool has_automntalgon() const;
  void clear_automntalgon();
  static const int kAutomntalgonFieldNumber = 1;
  ::google::protobuf::int32 automntalgon() const;
  void set_automntalgon(::google::protobuf::int32 value);

  // optional int32 status = 2;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 2;
  ::google::protobuf::int32 status() const;
  void set_status(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ndm_proto.UNPACK_IMU_ALG)
 private:
  void set_has_automntalgon();
  void clear_has_automntalgon();
  void set_has_status();
  void clear_has_status();
  void set_has_trans();
  void clear_has_trans();
  void set_has_orientation();
  void clear_has_orientation();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::ndm_proto::Vector3D* trans_;
  ::ndm_proto::Vector4D* orientation_;
  ::google::protobuf::int32 automntalgon_;
  ::google::protobuf::int32 status_;
  friend struct ::protobuf_sense_2eproto::TableStruct;
  friend void ::protobuf_sense_2eproto::InitDefaultsUNPACK_IMU_ALGImpl();
};
// -------------------------------------------------------------------

class CANFrame : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.CANFrame) */ {
 public:
  CANFrame();
  virtual ~CANFrame();

  CANFrame(const CANFrame& from);

  inline CANFrame& operator=(const CANFrame& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CANFrame(CANFrame&& from) noexcept
    : CANFrame() {
    *this = ::std::move(from);
  }

  inline CANFrame& operator=(CANFrame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CANFrame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CANFrame* internal_default_instance() {
    return reinterpret_cast<const CANFrame*>(
               &_CANFrame_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(CANFrame* other);
  friend void swap(CANFrame& a, CANFrame& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CANFrame* New() const PROTOBUF_FINAL { return New(NULL); }

  CANFrame* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CANFrame& from);
  void MergeFrom(const CANFrame& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CANFrame* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ndm_proto.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::ndm_proto::Header& header() const;
  ::ndm_proto::Header* release_header();
  ::ndm_proto::Header* mutable_header();
  void set_allocated_header(::ndm_proto::Header* header);

  // required int64 stamp = 2;
  bool has_stamp() const;
  void clear_stamp();
  static const int kStampFieldNumber = 2;
  ::google::protobuf::int64 stamp() const;
  void set_stamp(::google::protobuf::int64 value);

  // required double speed = 3;
  bool has_speed() const;
  void clear_speed();
  static const int kSpeedFieldNumber = 3;
  double speed() const;
  void set_speed(double value);

  // required double yawrate = 4;
  bool has_yawrate() const;
  void clear_yawrate();
  static const int kYawrateFieldNumber = 4;
  double yawrate() const;
  void set_yawrate(double value);

  // required double steerangle = 5;
  bool has_steerangle() const;
  void clear_steerangle();
  static const int kSteerangleFieldNumber = 5;
  double steerangle() const;
  void set_steerangle(double value);

  // required uint32 gear = 6;
  bool has_gear() const;
  void clear_gear();
  static const int kGearFieldNumber = 6;
  ::google::protobuf::uint32 gear() const;
  void set_gear(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ndm_proto.CANFrame)
 private:
  void set_has_header();
  void clear_has_header();
  void set_has_stamp();
  void clear_has_stamp();
  void set_has_speed();
  void clear_has_speed();
  void set_has_yawrate();
  void clear_has_yawrate();
  void set_has_steerangle();
  void clear_has_steerangle();
  void set_has_gear();
  void clear_has_gear();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::ndm_proto::Header* header_;
  ::google::protobuf::int64 stamp_;
  double speed_;
  double yawrate_;
  double steerangle_;
  ::google::protobuf::uint32 gear_;
  friend struct ::protobuf_sense_2eproto::TableStruct;
  friend void ::protobuf_sense_2eproto::InitDefaultsCANFrameImpl();
};
// -------------------------------------------------------------------

class VehicleMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.VehicleMsg) */ {
 public:
  VehicleMsg();
  virtual ~VehicleMsg();

  VehicleMsg(const VehicleMsg& from);

  inline VehicleMsg& operator=(const VehicleMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VehicleMsg(VehicleMsg&& from) noexcept
    : VehicleMsg() {
    *this = ::std::move(from);
  }

  inline VehicleMsg& operator=(VehicleMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VehicleMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VehicleMsg* internal_default_instance() {
    return reinterpret_cast<const VehicleMsg*>(
               &_VehicleMsg_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(VehicleMsg* other);
  friend void swap(VehicleMsg& a, VehicleMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VehicleMsg* New() const PROTOBUF_FINAL { return New(NULL); }

  VehicleMsg* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const VehicleMsg& from);
  void MergeFrom(const VehicleMsg& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(VehicleMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 sensor_stamp = 1;
  bool has_sensor_stamp() const;
  void clear_sensor_stamp();
  static const int kSensorStampFieldNumber = 1;
  ::google::protobuf::int64 sensor_stamp() const;
  void set_sensor_stamp(::google::protobuf::int64 value);

  // required int64 sample_stamp = 2;
  bool has_sample_stamp() const;
  void clear_sample_stamp();
  static const int kSampleStampFieldNumber = 2;
  ::google::protobuf::int64 sample_stamp() const;
  void set_sample_stamp(::google::protobuf::int64 value);

  // optional float speed = 3;
  bool has_speed() const;
  void clear_speed();
  static const int kSpeedFieldNumber = 3;
  float speed() const;
  void set_speed(float value);

  // optional float steer_angle = 4;
  bool has_steer_angle() const;
  void clear_steer_angle();
  static const int kSteerAngleFieldNumber = 4;
  float steer_angle() const;
  void set_steer_angle(float value);

  // optional float yaw_rate = 5;
  bool has_yaw_rate() const;
  void clear_yaw_rate();
  static const int kYawRateFieldNumber = 5;
  float yaw_rate() const;
  void set_yaw_rate(float value);

  // optional float yaw_rate_raw = 6;
  bool has_yaw_rate_raw() const;
  void clear_yaw_rate_raw();
  static const int kYawRateRawFieldNumber = 6;
  float yaw_rate_raw() const;
  void set_yaw_rate_raw(float value);

  // optional float yaw_rate_bias = 7;
  bool has_yaw_rate_bias() const;
  void clear_yaw_rate_bias();
  static const int kYawRateBiasFieldNumber = 7;
  float yaw_rate_bias() const;
  void set_yaw_rate_bias(float value);

  // optional float long_acc = 8;
  bool has_long_acc() const;
  void clear_long_acc();
  static const int kLongAccFieldNumber = 8;
  float long_acc() const;
  void set_long_acc(float value);

  // optional float long_acc_raw = 9;
  bool has_long_acc_raw() const;
  void clear_long_acc_raw();
  static const int kLongAccRawFieldNumber = 9;
  float long_acc_raw() const;
  void set_long_acc_raw(float value);

  // optional float long_acc_bias = 10;
  bool has_long_acc_bias() const;
  void clear_long_acc_bias();
  static const int kLongAccBiasFieldNumber = 10;
  float long_acc_bias() const;
  void set_long_acc_bias(float value);

  // optional float lat_acc = 11;
  bool has_lat_acc() const;
  void clear_lat_acc();
  static const int kLatAccFieldNumber = 11;
  float lat_acc() const;
  void set_lat_acc(float value);

  // optional float lat_acc_raw = 12;
  bool has_lat_acc_raw() const;
  void clear_lat_acc_raw();
  static const int kLatAccRawFieldNumber = 12;
  float lat_acc_raw() const;
  void set_lat_acc_raw(float value);

  // optional float lat_acc_bias = 13;
  bool has_lat_acc_bias() const;
  void clear_lat_acc_bias();
  static const int kLatAccBiasFieldNumber = 13;
  float lat_acc_bias() const;
  void set_lat_acc_bias(float value);

  // optional int32 gear = 14;
  bool has_gear() const;
  void clear_gear();
  static const int kGearFieldNumber = 14;
  ::google::protobuf::int32 gear() const;
  void set_gear(::google::protobuf::int32 value);

  // optional int32 high_beam = 15;
  bool has_high_beam() const;
  void clear_high_beam();
  static const int kHighBeamFieldNumber = 15;
  ::google::protobuf::int32 high_beam() const;
  void set_high_beam(::google::protobuf::int32 value);

  // optional int32 low_beam = 16;
  bool has_low_beam() const;
  void clear_low_beam();
  static const int kLowBeamFieldNumber = 16;
  ::google::protobuf::int32 low_beam() const;
  void set_low_beam(::google::protobuf::int32 value);

  // optional int32 turn_signal = 17;
  bool has_turn_signal() const;
  void clear_turn_signal();
  static const int kTurnSignalFieldNumber = 17;
  ::google::protobuf::int32 turn_signal() const;
  void set_turn_signal(::google::protobuf::int32 value);

  // optional int32 wiper = 18;
  bool has_wiper() const;
  void clear_wiper();
  static const int kWiperFieldNumber = 18;
  ::google::protobuf::int32 wiper() const;
  void set_wiper(::google::protobuf::int32 value);

  // optional int32 udlc_left = 19;
  bool has_udlc_left() const;
  void clear_udlc_left();
  static const int kUdlcLeftFieldNumber = 19;
  ::google::protobuf::int32 udlc_left() const;
  void set_udlc_left(::google::protobuf::int32 value);

  // optional int32 udlc_right = 20;
  bool has_udlc_right() const;
  void clear_udlc_right();
  static const int kUdlcRightFieldNumber = 20;
  ::google::protobuf::int32 udlc_right() const;
  void set_udlc_right(::google::protobuf::int32 value);

  // optional float vrl = 21;
  bool has_vrl() const;
  void clear_vrl();
  static const int kVrlFieldNumber = 21;
  float vrl() const;
  void set_vrl(float value);

  // optional float vrr = 22;
  bool has_vrr() const;
  void clear_vrr();
  static const int kVrrFieldNumber = 22;
  float vrr() const;
  void set_vrr(float value);

  // optional float vfl = 23;
  bool has_vfl() const;
  void clear_vfl();
  static const int kVflFieldNumber = 23;
  float vfl() const;
  void set_vfl(float value);

  // optional float vfr = 24;
  bool has_vfr() const;
  void clear_vfr();
  static const int kVfrFieldNumber = 24;
  float vfr() const;
  void set_vfr(float value);

  // optional float prl = 25;
  bool has_prl() const;
  void clear_prl();
  static const int kPrlFieldNumber = 25;
  float prl() const;
  void set_prl(float value);

  // optional float prr = 26;
  bool has_prr() const;
  void clear_prr();
  static const int kPrrFieldNumber = 26;
  float prr() const;
  void set_prr(float value);

  // optional float pfl = 27;
  bool has_pfl() const;
  void clear_pfl();
  static const int kPflFieldNumber = 27;
  float pfl() const;
  void set_pfl(float value);

  // optional float pfr = 28;
  bool has_pfr() const;
  void clear_pfr();
  static const int kPfrFieldNumber = 28;
  float pfr() const;
  void set_pfr(float value);

  // @@protoc_insertion_point(class_scope:ndm_proto.VehicleMsg)
 private:
  void set_has_sensor_stamp();
  void clear_has_sensor_stamp();
  void set_has_sample_stamp();
  void clear_has_sample_stamp();
  void set_has_speed();
  void clear_has_speed();
  void set_has_steer_angle();
  void clear_has_steer_angle();
  void set_has_yaw_rate();
  void clear_has_yaw_rate();
  void set_has_yaw_rate_raw();
  void clear_has_yaw_rate_raw();
  void set_has_yaw_rate_bias();
  void clear_has_yaw_rate_bias();
  void set_has_long_acc();
  void clear_has_long_acc();
  void set_has_long_acc_raw();
  void clear_has_long_acc_raw();
  void set_has_long_acc_bias();
  void clear_has_long_acc_bias();
  void set_has_lat_acc();
  void clear_has_lat_acc();
  void set_has_lat_acc_raw();
  void clear_has_lat_acc_raw();
  void set_has_lat_acc_bias();
  void clear_has_lat_acc_bias();
  void set_has_gear();
  void clear_has_gear();
  void set_has_high_beam();
  void clear_has_high_beam();
  void set_has_low_beam();
  void clear_has_low_beam();
  void set_has_turn_signal();
  void clear_has_turn_signal();
  void set_has_wiper();
  void clear_has_wiper();
  void set_has_udlc_left();
  void clear_has_udlc_left();
  void set_has_udlc_right();
  void clear_has_udlc_right();
  void set_has_vrl();
  void clear_has_vrl();
  void set_has_vrr();
  void clear_has_vrr();
  void set_has_vfl();
  void clear_has_vfl();
  void set_has_vfr();
  void clear_has_vfr();
  void set_has_prl();
  void clear_has_prl();
  void set_has_prr();
  void clear_has_prr();
  void set_has_pfl();
  void clear_has_pfl();
  void set_has_pfr();
  void clear_has_pfr();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int64 sensor_stamp_;
  ::google::protobuf::int64 sample_stamp_;
  float speed_;
  float steer_angle_;
  float yaw_rate_;
  float yaw_rate_raw_;
  float yaw_rate_bias_;
  float long_acc_;
  float long_acc_raw_;
  float long_acc_bias_;
  float lat_acc_;
  float lat_acc_raw_;
  float lat_acc_bias_;
  ::google::protobuf::int32 gear_;
  ::google::protobuf::int32 high_beam_;
  ::google::protobuf::int32 low_beam_;
  ::google::protobuf::int32 turn_signal_;
  ::google::protobuf::int32 wiper_;
  ::google::protobuf::int32 udlc_left_;
  ::google::protobuf::int32 udlc_right_;
  float vrl_;
  float vrr_;
  float vfl_;
  float vfr_;
  float prl_;
  float prr_;
  float pfl_;
  float pfr_;
  friend struct ::protobuf_sense_2eproto::TableStruct;
  friend void ::protobuf_sense_2eproto::InitDefaultsVehicleMsgImpl();
};
// -------------------------------------------------------------------

class GNSSStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.GNSSStatus) */ {
 public:
  GNSSStatus();
  virtual ~GNSSStatus();

  GNSSStatus(const GNSSStatus& from);

  inline GNSSStatus& operator=(const GNSSStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GNSSStatus(GNSSStatus&& from) noexcept
    : GNSSStatus() {
    *this = ::std::move(from);
  }

  inline GNSSStatus& operator=(GNSSStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GNSSStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GNSSStatus* internal_default_instance() {
    return reinterpret_cast<const GNSSStatus*>(
               &_GNSSStatus_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(GNSSStatus* other);
  friend void swap(GNSSStatus& a, GNSSStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GNSSStatus* New() const PROTOBUF_FINAL { return New(NULL); }

  GNSSStatus* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GNSSStatus& from);
  void MergeFrom(const GNSSStatus& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GNSSStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string sol_status = 1;
  bool has_sol_status() const;
  void clear_sol_status();
  static const int kSolStatusFieldNumber = 1;
  const ::std::string& sol_status() const;
  void set_sol_status(const ::std::string& value);
  #if LANG_CXX11
  void set_sol_status(::std::string&& value);
  #endif
  void set_sol_status(const char* value);
  void set_sol_status(const char* value, size_t size);
  ::std::string* mutable_sol_status();
  ::std::string* release_sol_status();
  void set_allocated_sol_status(::std::string* sol_status);

  // optional string type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // @@protoc_insertion_point(class_scope:ndm_proto.GNSSStatus)
 private:
  void set_has_sol_status();
  void clear_has_sol_status();
  void set_has_type();
  void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr sol_status_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  friend struct ::protobuf_sense_2eproto::TableStruct;
  friend void ::protobuf_sense_2eproto::InitDefaultsGNSSStatusImpl();
};
// -------------------------------------------------------------------

class GNSSFrame : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.GNSSFrame) */ {
 public:
  GNSSFrame();
  virtual ~GNSSFrame();

  GNSSFrame(const GNSSFrame& from);

  inline GNSSFrame& operator=(const GNSSFrame& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GNSSFrame(GNSSFrame&& from) noexcept
    : GNSSFrame() {
    *this = ::std::move(from);
  }

  inline GNSSFrame& operator=(GNSSFrame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GNSSFrame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GNSSFrame* internal_default_instance() {
    return reinterpret_cast<const GNSSFrame*>(
               &_GNSSFrame_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(GNSSFrame* other);
  friend void swap(GNSSFrame& a, GNSSFrame& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GNSSFrame* New() const PROTOBUF_FINAL { return New(NULL); }

  GNSSFrame* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GNSSFrame& from);
  void MergeFrom(const GNSSFrame& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GNSSFrame* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double pose_covariance = 22;
  int pose_covariance_size() const;
  void clear_pose_covariance();
  static const int kPoseCovarianceFieldNumber = 22;
  double pose_covariance(int index) const;
  void set_pose_covariance(int index, double value);
  void add_pose_covariance(double value);
  const ::google::protobuf::RepeatedField< double >&
      pose_covariance() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_pose_covariance();

  // repeated string nmea_sentence = 23;
  int nmea_sentence_size() const;
  void clear_nmea_sentence();
  static const int kNmeaSentenceFieldNumber = 23;
  const ::std::string& nmea_sentence(int index) const;
  ::std::string* mutable_nmea_sentence(int index);
  void set_nmea_sentence(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_nmea_sentence(int index, ::std::string&& value);
  #endif
  void set_nmea_sentence(int index, const char* value);
  void set_nmea_sentence(int index, const char* value, size_t size);
  ::std::string* add_nmea_sentence();
  void add_nmea_sentence(const ::std::string& value);
  #if LANG_CXX11
  void add_nmea_sentence(::std::string&& value);
  #endif
  void add_nmea_sentence(const char* value);
  void add_nmea_sentence(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& nmea_sentence() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_nmea_sentence();

  // optional string raw_data = 4;
  bool has_raw_data() const;
  void clear_raw_data();
  static const int kRawDataFieldNumber = 4;
  const ::std::string& raw_data() const;
  void set_raw_data(const ::std::string& value);
  #if LANG_CXX11
  void set_raw_data(::std::string&& value);
  #endif
  void set_raw_data(const char* value);
  void set_raw_data(const char* value, size_t size);
  ::std::string* mutable_raw_data();
  ::std::string* release_raw_data();
  void set_allocated_raw_data(::std::string* raw_data);

  // optional string solve_status = 12;
  bool has_solve_status() const;
  void clear_solve_status();
  static const int kSolveStatusFieldNumber = 12;
  const ::std::string& solve_status() const;
  void set_solve_status(const ::std::string& value);
  #if LANG_CXX11
  void set_solve_status(::std::string&& value);
  #endif
  void set_solve_status(const char* value);
  void set_solve_status(const char* value, size_t size);
  ::std::string* mutable_solve_status();
  ::std::string* release_solve_status();
  void set_allocated_solve_status(::std::string* solve_status);

  // optional string ins_status = 13;
  bool has_ins_status() const;
  void clear_ins_status();
  static const int kInsStatusFieldNumber = 13;
  const ::std::string& ins_status() const;
  void set_ins_status(const ::std::string& value);
  #if LANG_CXX11
  void set_ins_status(::std::string&& value);
  #endif
  void set_ins_status(const char* value);
  void set_ins_status(const char* value, size_t size);
  ::std::string* mutable_ins_status();
  ::std::string* release_ins_status();
  void set_allocated_ins_status(::std::string* ins_status);

  // optional string desc = 35;
  bool has_desc() const;
  void clear_desc();
  static const int kDescFieldNumber = 35;
  const ::std::string& desc() const;
  void set_desc(const ::std::string& value);
  #if LANG_CXX11
  void set_desc(::std::string&& value);
  #endif
  void set_desc(const char* value);
  void set_desc(const char* value, size_t size);
  ::std::string* mutable_desc();
  ::std::string* release_desc();
  void set_allocated_desc(::std::string* desc);

  // required .ndm_proto.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::ndm_proto::Header& header() const;
  ::ndm_proto::Header* release_header();
  ::ndm_proto::Header* mutable_header();
  void set_allocated_header(::ndm_proto::Header* header);

  // optional .ndm_proto.Vector3D position = 5;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 5;
  const ::ndm_proto::Vector3D& position() const;
  ::ndm_proto::Vector3D* release_position();
  ::ndm_proto::Vector3D* mutable_position();
  void set_allocated_position(::ndm_proto::Vector3D* position);

  // optional .ndm_proto.Vector3F position_std_dev = 6;
  bool has_position_std_dev() const;
  void clear_position_std_dev();
  static const int kPositionStdDevFieldNumber = 6;
  const ::ndm_proto::Vector3F& position_std_dev() const;
  ::ndm_proto::Vector3F* release_position_std_dev();
  ::ndm_proto::Vector3F* mutable_position_std_dev();
  void set_allocated_position_std_dev(::ndm_proto::Vector3F* position_std_dev);

  // optional .ndm_proto.Vector3F velocity = 7;
  bool has_velocity() const;
  void clear_velocity();
  static const int kVelocityFieldNumber = 7;
  const ::ndm_proto::Vector3F& velocity() const;
  ::ndm_proto::Vector3F* release_velocity();
  ::ndm_proto::Vector3F* mutable_velocity();
  void set_allocated_velocity(::ndm_proto::Vector3F* velocity);

  // optional .ndm_proto.Vector3F velocity_std_dev = 8;
  bool has_velocity_std_dev() const;
  void clear_velocity_std_dev();
  static const int kVelocityStdDevFieldNumber = 8;
  const ::ndm_proto::Vector3F& velocity_std_dev() const;
  ::ndm_proto::Vector3F* release_velocity_std_dev();
  ::ndm_proto::Vector3F* mutable_velocity_std_dev();
  void set_allocated_velocity_std_dev(::ndm_proto::Vector3F* velocity_std_dev);

  // optional .ndm_proto.Vector3F angular = 9;
  bool has_angular() const;
  void clear_angular();
  static const int kAngularFieldNumber = 9;
  const ::ndm_proto::Vector3F& angular() const;
  ::ndm_proto::Vector3F* release_angular();
  ::ndm_proto::Vector3F* mutable_angular();
  void set_allocated_angular(::ndm_proto::Vector3F* angular);

  // optional .ndm_proto.Vector3F angular_std_dev = 10;
  bool has_angular_std_dev() const;
  void clear_angular_std_dev();
  static const int kAngularStdDevFieldNumber = 10;
  const ::ndm_proto::Vector3F& angular_std_dev() const;
  ::ndm_proto::Vector3F* release_angular_std_dev();
  ::ndm_proto::Vector3F* mutable_angular_std_dev();
  void set_allocated_angular_std_dev(::ndm_proto::Vector3F* angular_std_dev);

  // optional .ndm_proto.GNSSStatus pos_status = 18;
  bool has_pos_status() const;
  void clear_pos_status();
  static const int kPosStatusFieldNumber = 18;
  const ::ndm_proto::GNSSStatus& pos_status() const;
  ::ndm_proto::GNSSStatus* release_pos_status();
  ::ndm_proto::GNSSStatus* mutable_pos_status();
  void set_allocated_pos_status(::ndm_proto::GNSSStatus* pos_status);

  // optional .ndm_proto.GNSSStatus vel_status = 19;
  bool has_vel_status() const;
  void clear_vel_status();
  static const int kVelStatusFieldNumber = 19;
  const ::ndm_proto::GNSSStatus& vel_status() const;
  ::ndm_proto::GNSSStatus* release_vel_status();
  ::ndm_proto::GNSSStatus* mutable_vel_status();
  void set_allocated_vel_status(::ndm_proto::GNSSStatus* vel_status);

  // optional .ndm_proto.GNSSStatus head_status = 20;
  bool has_head_status() const;
  void clear_head_status();
  static const int kHeadStatusFieldNumber = 20;
  const ::ndm_proto::GNSSStatus& head_status() const;
  ::ndm_proto::GNSSStatus* release_head_status();
  ::ndm_proto::GNSSStatus* mutable_head_status();
  void set_allocated_head_status(::ndm_proto::GNSSStatus* head_status);

  // optional .ndm_proto.Vector4D orientation = 21;
  bool has_orientation() const;
  void clear_orientation();
  static const int kOrientationFieldNumber = 21;
  const ::ndm_proto::Vector4D& orientation() const;
  ::ndm_proto::Vector4D* release_orientation();
  ::ndm_proto::Vector4D* mutable_orientation();
  void set_allocated_orientation(::ndm_proto::Vector4D* orientation);

  // optional .ndm_proto.Vector3D position_gps = 31;
  bool has_position_gps() const;
  void clear_position_gps();
  static const int kPositionGpsFieldNumber = 31;
  const ::ndm_proto::Vector3D& position_gps() const;
  ::ndm_proto::Vector3D* release_position_gps();
  ::ndm_proto::Vector3D* mutable_position_gps();
  void set_allocated_position_gps(::ndm_proto::Vector3D* position_gps);

  // optional .ndm_proto.Vector3D acc = 32;
  bool has_acc() const;
  void clear_acc();
  static const int kAccFieldNumber = 32;
  const ::ndm_proto::Vector3D& acc() const;
  ::ndm_proto::Vector3D* release_acc();
  ::ndm_proto::Vector3D* mutable_acc();
  void set_allocated_acc(::ndm_proto::Vector3D* acc);

  // optional .ndm_proto.Vector3D accgyo = 33;
  bool has_accgyo() const;
  void clear_accgyo();
  static const int kAccgyoFieldNumber = 33;
  const ::ndm_proto::Vector3D& accgyo() const;
  ::ndm_proto::Vector3D* release_accgyo();
  ::ndm_proto::Vector3D* mutable_accgyo();
  void set_allocated_accgyo(::ndm_proto::Vector3D* accgyo);

  // optional int64 sensor_stamp = 2;
  bool has_sensor_stamp() const;
  void clear_sensor_stamp();
  static const int kSensorStampFieldNumber = 2;
  ::google::protobuf::int64 sensor_stamp() const;
  void set_sensor_stamp(::google::protobuf::int64 value);

  // optional int64 sample_stamp = 3;
  bool has_sample_stamp() const;
  void clear_sample_stamp();
  static const int kSampleStampFieldNumber = 3;
  ::google::protobuf::int64 sample_stamp() const;
  void set_sample_stamp(::google::protobuf::int64 value);

  // optional int32 num_sates = 11;
  bool has_num_sates() const;
  void clear_num_sates();
  static const int kNumSatesFieldNumber = 11;
  ::google::protobuf::int32 num_sates() const;
  void set_num_sates(::google::protobuf::int32 value);

  // optional int32 mode = 15;
  bool has_mode() const;
  void clear_mode();
  static const int kModeFieldNumber = 15;
  ::google::protobuf::int32 mode() const;
  void set_mode(::google::protobuf::int32 value);

  // optional double speed = 14;
  bool has_speed() const;
  void clear_speed();
  static const int kSpeedFieldNumber = 14;
  double speed() const;
  void set_speed(double value);

  // optional double height_of_ellipse = 16;
  bool has_height_of_ellipse() const;
  void clear_height_of_ellipse();
  static const int kHeightOfEllipseFieldNumber = 16;
  double height_of_ellipse() const;
  void set_height_of_ellipse(double value);

  // optional int32 gps_fix_info = 17;
  bool has_gps_fix_info() const;
  void clear_gps_fix_info();
  static const int kGpsFixInfoFieldNumber = 17;
  ::google::protobuf::int32 gps_fix_info() const;
  void set_gps_fix_info(::google::protobuf::int32 value);

  // optional float pitch = 24;
  bool has_pitch() const;
  void clear_pitch();
  static const int kPitchFieldNumber = 24;
  float pitch() const;
  void set_pitch(float value);

  // optional float yaw = 25;
  bool has_yaw() const;
  void clear_yaw();
  static const int kYawFieldNumber = 25;
  float yaw() const;
  void set_yaw(float value);

  // optional float roll = 26;
  bool has_roll() const;
  void clear_roll();
  static const int kRollFieldNumber = 26;
  float roll() const;
  void set_roll(float value);

  // optional float x_offset = 27;
  bool has_x_offset() const;
  void clear_x_offset();
  static const int kXOffsetFieldNumber = 27;
  float x_offset() const;
  void set_x_offset(float value);

  // optional float y_offset = 28;
  bool has_y_offset() const;
  void clear_y_offset();
  static const int kYOffsetFieldNumber = 28;
  float y_offset() const;
  void set_y_offset(float value);

  // optional float z_offset = 29;
  bool has_z_offset() const;
  void clear_z_offset();
  static const int kZOffsetFieldNumber = 29;
  float z_offset() const;
  void set_z_offset(float value);

  // optional int32 zone_id = 30;
  bool has_zone_id() const;
  void clear_zone_id();
  static const int kZoneIdFieldNumber = 30;
  ::google::protobuf::int32 zone_id() const;
  void set_zone_id(::google::protobuf::int32 value);

  // optional int32 channel_id = 34;
  bool has_channel_id() const;
  void clear_channel_id();
  static const int kChannelIdFieldNumber = 34;
  ::google::protobuf::int32 channel_id() const;
  void set_channel_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ndm_proto.GNSSFrame)
 private:
  void set_has_header();
  void clear_has_header();
  void set_has_sensor_stamp();
  void clear_has_sensor_stamp();
  void set_has_sample_stamp();
  void clear_has_sample_stamp();
  void set_has_raw_data();
  void clear_has_raw_data();
  void set_has_position();
  void clear_has_position();
  void set_has_position_std_dev();
  void clear_has_position_std_dev();
  void set_has_velocity();
  void clear_has_velocity();
  void set_has_velocity_std_dev();
  void clear_has_velocity_std_dev();
  void set_has_angular();
  void clear_has_angular();
  void set_has_angular_std_dev();
  void clear_has_angular_std_dev();
  void set_has_num_sates();
  void clear_has_num_sates();
  void set_has_solve_status();
  void clear_has_solve_status();
  void set_has_ins_status();
  void clear_has_ins_status();
  void set_has_speed();
  void clear_has_speed();
  void set_has_mode();
  void clear_has_mode();
  void set_has_height_of_ellipse();
  void clear_has_height_of_ellipse();
  void set_has_gps_fix_info();
  void clear_has_gps_fix_info();
  void set_has_pos_status();
  void clear_has_pos_status();
  void set_has_vel_status();
  void clear_has_vel_status();
  void set_has_head_status();
  void clear_has_head_status();
  void set_has_orientation();
  void clear_has_orientation();
  void set_has_pitch();
  void clear_has_pitch();
  void set_has_yaw();
  void clear_has_yaw();
  void set_has_roll();
  void clear_has_roll();
  void set_has_x_offset();
  void clear_has_x_offset();
  void set_has_y_offset();
  void clear_has_y_offset();
  void set_has_z_offset();
  void clear_has_z_offset();
  void set_has_zone_id();
  void clear_has_zone_id();
  void set_has_position_gps();
  void clear_has_position_gps();
  void set_has_acc();
  void clear_has_acc();
  void set_has_accgyo();
  void clear_has_accgyo();
  void set_has_channel_id();
  void clear_has_channel_id();
  void set_has_desc();
  void clear_has_desc();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<2> _has_bits_;
  ::google::protobuf::RepeatedField< double > pose_covariance_;
  ::google::protobuf::RepeatedPtrField< ::std::string> nmea_sentence_;
  ::google::protobuf::internal::ArenaStringPtr raw_data_;
  ::google::protobuf::internal::ArenaStringPtr solve_status_;
  ::google::protobuf::internal::ArenaStringPtr ins_status_;
  ::google::protobuf::internal::ArenaStringPtr desc_;
  ::ndm_proto::Header* header_;
  ::ndm_proto::Vector3D* position_;
  ::ndm_proto::Vector3F* position_std_dev_;
  ::ndm_proto::Vector3F* velocity_;
  ::ndm_proto::Vector3F* velocity_std_dev_;
  ::ndm_proto::Vector3F* angular_;
  ::ndm_proto::Vector3F* angular_std_dev_;
  ::ndm_proto::GNSSStatus* pos_status_;
  ::ndm_proto::GNSSStatus* vel_status_;
  ::ndm_proto::GNSSStatus* head_status_;
  ::ndm_proto::Vector4D* orientation_;
  ::ndm_proto::Vector3D* position_gps_;
  ::ndm_proto::Vector3D* acc_;
  ::ndm_proto::Vector3D* accgyo_;
  ::google::protobuf::int64 sensor_stamp_;
  ::google::protobuf::int64 sample_stamp_;
  ::google::protobuf::int32 num_sates_;
  ::google::protobuf::int32 mode_;
  double speed_;
  double height_of_ellipse_;
  ::google::protobuf::int32 gps_fix_info_;
  float pitch_;
  float yaw_;
  float roll_;
  float x_offset_;
  float y_offset_;
  float z_offset_;
  ::google::protobuf::int32 zone_id_;
  ::google::protobuf::int32 channel_id_;
  mutable int _cached_size_;
  friend struct ::protobuf_sense_2eproto::TableStruct;
  friend void ::protobuf_sense_2eproto::InitDefaultsGNSSFrameImpl();
};
// -------------------------------------------------------------------

class IMUFrame : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.IMUFrame) */ {
 public:
  IMUFrame();
  virtual ~IMUFrame();

  IMUFrame(const IMUFrame& from);

  inline IMUFrame& operator=(const IMUFrame& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IMUFrame(IMUFrame&& from) noexcept
    : IMUFrame() {
    *this = ::std::move(from);
  }

  inline IMUFrame& operator=(IMUFrame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IMUFrame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IMUFrame* internal_default_instance() {
    return reinterpret_cast<const IMUFrame*>(
               &_IMUFrame_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(IMUFrame* other);
  friend void swap(IMUFrame& a, IMUFrame& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IMUFrame* New() const PROTOBUF_FINAL { return New(NULL); }

  IMUFrame* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const IMUFrame& from);
  void MergeFrom(const IMUFrame& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(IMUFrame* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes raw_array = 24;
  int raw_array_size() const;
  void clear_raw_array();
  static const int kRawArrayFieldNumber = 24;
  const ::std::string& raw_array(int index) const;
  ::std::string* mutable_raw_array(int index);
  void set_raw_array(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_raw_array(int index, ::std::string&& value);
  #endif
  void set_raw_array(int index, const char* value);
  void set_raw_array(int index, const void* value, size_t size);
  ::std::string* add_raw_array();
  void add_raw_array(const ::std::string& value);
  #if LANG_CXX11
  void add_raw_array(::std::string&& value);
  #endif
  void add_raw_array(const char* value);
  void add_raw_array(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& raw_array() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_raw_array();

  // optional bytes raw_data = 4;
  bool has_raw_data() const;
  void clear_raw_data();
  static const int kRawDataFieldNumber = 4;
  const ::std::string& raw_data() const;
  void set_raw_data(const ::std::string& value);
  #if LANG_CXX11
  void set_raw_data(::std::string&& value);
  #endif
  void set_raw_data(const char* value);
  void set_raw_data(const void* value, size_t size);
  ::std::string* mutable_raw_data();
  ::std::string* release_raw_data();
  void set_allocated_raw_data(::std::string* raw_data);

  // required .ndm_proto.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::ndm_proto::Header& header() const;
  ::ndm_proto::Header* release_header();
  ::ndm_proto::Header* mutable_header();
  void set_allocated_header(::ndm_proto::Header* header);

  // optional .ndm_proto.Vector3F acc = 2;
  bool has_acc() const;
  void clear_acc();
  static const int kAccFieldNumber = 2;
  const ::ndm_proto::Vector3F& acc() const;
  ::ndm_proto::Vector3F* release_acc();
  ::ndm_proto::Vector3F* mutable_acc();
  void set_allocated_acc(::ndm_proto::Vector3F* acc);

  // optional .ndm_proto.Vector3F gyro = 3;
  bool has_gyro() const;
  void clear_gyro();
  static const int kGyroFieldNumber = 3;
  const ::ndm_proto::Vector3F& gyro() const;
  ::ndm_proto::Vector3F* release_gyro();
  ::ndm_proto::Vector3F* mutable_gyro();
  void set_allocated_gyro(::ndm_proto::Vector3F* gyro);

  // optional .ndm_proto.Quaternion quaterntion = 11;
  bool has_quaterntion() const;
  void clear_quaterntion();
  static const int kQuaterntionFieldNumber = 11;
  const ::ndm_proto::Quaternion& quaterntion() const;
  ::ndm_proto::Quaternion* release_quaterntion();
  ::ndm_proto::Quaternion* mutable_quaterntion();
  void set_allocated_quaterntion(::ndm_proto::Quaternion* quaterntion);

  // optional .ndm_proto.Vector3F delta_v = 13;
  bool has_delta_v() const;
  void clear_delta_v();
  static const int kDeltaVFieldNumber = 13;
  const ::ndm_proto::Vector3F& delta_v() const;
  ::ndm_proto::Vector3F* release_delta_v();
  ::ndm_proto::Vector3F* mutable_delta_v();
  void set_allocated_delta_v(::ndm_proto::Vector3F* delta_v);

  // optional .ndm_proto.Vector4F delta_q = 14;
  bool has_delta_q() const;
  void clear_delta_q();
  static const int kDeltaQFieldNumber = 14;
  const ::ndm_proto::Vector4F& delta_q() const;
  ::ndm_proto::Vector4F* release_delta_q();
  ::ndm_proto::Vector4F* mutable_delta_q();
  void set_allocated_delta_q(::ndm_proto::Vector4F* delta_q);

  // optional .ndm_proto.Vector3F free_accleration = 15;
  bool has_free_accleration() const;
  void clear_free_accleration();
  static const int kFreeAcclerationFieldNumber = 15;
  const ::ndm_proto::Vector3F& free_accleration() const;
  ::ndm_proto::Vector3F* release_free_accleration();
  ::ndm_proto::Vector3F* mutable_free_accleration();
  void set_allocated_free_accleration(::ndm_proto::Vector3F* free_accleration);

  // optional .ndm_proto.Vector3F magnetic = 16;
  bool has_magnetic() const;
  void clear_magnetic();
  static const int kMagneticFieldNumber = 16;
  const ::ndm_proto::Vector3F& magnetic() const;
  ::ndm_proto::Vector3F* release_magnetic();
  ::ndm_proto::Vector3F* mutable_magnetic();
  void set_allocated_magnetic(::ndm_proto::Vector3F* magnetic);

  // optional .ndm_proto.UNPACK_IMU_ALG unpack_imu_alg = 25;
  bool has_unpack_imu_alg() const;
  void clear_unpack_imu_alg();
  static const int kUnpackImuAlgFieldNumber = 25;
  const ::ndm_proto::UNPACK_IMU_ALG& unpack_imu_alg() const;
  ::ndm_proto::UNPACK_IMU_ALG* release_unpack_imu_alg();
  ::ndm_proto::UNPACK_IMU_ALG* mutable_unpack_imu_alg();
  void set_allocated_unpack_imu_alg(::ndm_proto::UNPACK_IMU_ALG* unpack_imu_alg);

  // optional int64 sensor_stamp = 5;
  bool has_sensor_stamp() const;
  void clear_sensor_stamp();
  static const int kSensorStampFieldNumber = 5;
  ::google::protobuf::int64 sensor_stamp() const;
  void set_sensor_stamp(::google::protobuf::int64 value);

  // optional int64 sample_stamp = 6;
  bool has_sample_stamp() const;
  void clear_sample_stamp();
  static const int kSampleStampFieldNumber = 6;
  ::google::protobuf::int64 sample_stamp() const;
  void set_sample_stamp(::google::protobuf::int64 value);

  // optional float temperature = 7;
  bool has_temperature() const;
  void clear_temperature();
  static const int kTemperatureFieldNumber = 7;
  float temperature() const;
  void set_temperature(float value);

  // optional int32 packet_counter = 8;
  bool has_packet_counter() const;
  void clear_packet_counter();
  static const int kPacketCounterFieldNumber = 8;
  ::google::protobuf::int32 packet_counter() const;
  void set_packet_counter(::google::protobuf::int32 value);

  // optional int32 sample_time_fine = 9;
  bool has_sample_time_fine() const;
  void clear_sample_time_fine();
  static const int kSampleTimeFineFieldNumber = 9;
  ::google::protobuf::int32 sample_time_fine() const;
  void set_sample_time_fine(::google::protobuf::int32 value);

  // optional int32 sample_time_coarse = 10;
  bool has_sample_time_coarse() const;
  void clear_sample_time_coarse();
  static const int kSampleTimeCoarseFieldNumber = 10;
  ::google::protobuf::int32 sample_time_coarse() const;
  void set_sample_time_coarse(::google::protobuf::int32 value);

  // optional int32 baro_pressure = 12;
  bool has_baro_pressure() const;
  void clear_baro_pressure();
  static const int kBaroPressureFieldNumber = 12;
  ::google::protobuf::int32 baro_pressure() const;
  void set_baro_pressure(::google::protobuf::int32 value);

  // optional int32 status_word = 17;
  bool has_status_word() const;
  void clear_status_word();
  static const int kStatusWordFieldNumber = 17;
  ::google::protobuf::int32 status_word() const;
  void set_status_word(::google::protobuf::int32 value);

  // optional float pitch = 18;
  bool has_pitch() const;
  void clear_pitch();
  static const int kPitchFieldNumber = 18;
  float pitch() const;
  void set_pitch(float value);

  // optional float yaw = 19;
  bool has_yaw() const;
  void clear_yaw();
  static const int kYawFieldNumber = 19;
  float yaw() const;
  void set_yaw(float value);

  // optional float roll = 20;
  bool has_roll() const;
  void clear_roll();
  static const int kRollFieldNumber = 20;
  float roll() const;
  void set_roll(float value);

  // optional float x_offset = 21;
  bool has_x_offset() const;
  void clear_x_offset();
  static const int kXOffsetFieldNumber = 21;
  float x_offset() const;
  void set_x_offset(float value);

  // optional float y_offset = 22;
  bool has_y_offset() const;
  void clear_y_offset();
  static const int kYOffsetFieldNumber = 22;
  float y_offset() const;
  void set_y_offset(float value);

  // optional float z_offset = 23;
  bool has_z_offset() const;
  void clear_z_offset();
  static const int kZOffsetFieldNumber = 23;
  float z_offset() const;
  void set_z_offset(float value);

  // optional bool flag_imu_alg = 26;
  bool has_flag_imu_alg() const;
  void clear_flag_imu_alg();
  static const int kFlagImuAlgFieldNumber = 26;
  bool flag_imu_alg() const;
  void set_flag_imu_alg(bool value);

  // @@protoc_insertion_point(class_scope:ndm_proto.IMUFrame)
 private:
  void set_has_header();
  void clear_has_header();
  void set_has_acc();
  void clear_has_acc();
  void set_has_gyro();
  void clear_has_gyro();
  void set_has_raw_data();
  void clear_has_raw_data();
  void set_has_sensor_stamp();
  void clear_has_sensor_stamp();
  void set_has_sample_stamp();
  void clear_has_sample_stamp();
  void set_has_temperature();
  void clear_has_temperature();
  void set_has_packet_counter();
  void clear_has_packet_counter();
  void set_has_sample_time_fine();
  void clear_has_sample_time_fine();
  void set_has_sample_time_coarse();
  void clear_has_sample_time_coarse();
  void set_has_quaterntion();
  void clear_has_quaterntion();
  void set_has_baro_pressure();
  void clear_has_baro_pressure();
  void set_has_delta_v();
  void clear_has_delta_v();
  void set_has_delta_q();
  void clear_has_delta_q();
  void set_has_free_accleration();
  void clear_has_free_accleration();
  void set_has_magnetic();
  void clear_has_magnetic();
  void set_has_status_word();
  void clear_has_status_word();
  void set_has_pitch();
  void clear_has_pitch();
  void set_has_yaw();
  void clear_has_yaw();
  void set_has_roll();
  void clear_has_roll();
  void set_has_x_offset();
  void clear_has_x_offset();
  void set_has_y_offset();
  void clear_has_y_offset();
  void set_has_z_offset();
  void clear_has_z_offset();
  void set_has_unpack_imu_alg();
  void clear_has_unpack_imu_alg();
  void set_has_flag_imu_alg();
  void clear_has_flag_imu_alg();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> raw_array_;
  ::google::protobuf::internal::ArenaStringPtr raw_data_;
  ::ndm_proto::Header* header_;
  ::ndm_proto::Vector3F* acc_;
  ::ndm_proto::Vector3F* gyro_;
  ::ndm_proto::Quaternion* quaterntion_;
  ::ndm_proto::Vector3F* delta_v_;
  ::ndm_proto::Vector4F* delta_q_;
  ::ndm_proto::Vector3F* free_accleration_;
  ::ndm_proto::Vector3F* magnetic_;
  ::ndm_proto::UNPACK_IMU_ALG* unpack_imu_alg_;
  ::google::protobuf::int64 sensor_stamp_;
  ::google::protobuf::int64 sample_stamp_;
  float temperature_;
  ::google::protobuf::int32 packet_counter_;
  ::google::protobuf::int32 sample_time_fine_;
  ::google::protobuf::int32 sample_time_coarse_;
  ::google::protobuf::int32 baro_pressure_;
  ::google::protobuf::int32 status_word_;
  float pitch_;
  float yaw_;
  float roll_;
  float x_offset_;
  float y_offset_;
  float z_offset_;
  bool flag_imu_alg_;
  friend struct ::protobuf_sense_2eproto::TableStruct;
  friend void ::protobuf_sense_2eproto::InitDefaultsIMUFrameImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Header

// required int64 stamp = 1;
inline bool Header::has_stamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Header::set_has_stamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Header::clear_has_stamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Header::clear_stamp() {
  stamp_ = GOOGLE_LONGLONG(0);
  clear_has_stamp();
}
inline ::google::protobuf::int64 Header::stamp() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Header.stamp)
  return stamp_;
}
inline void Header::set_stamp(::google::protobuf::int64 value) {
  set_has_stamp();
  stamp_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.Header.stamp)
}

// required int64 seq = 2;
inline bool Header::has_seq() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Header::set_has_seq() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Header::clear_has_seq() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Header::clear_seq() {
  seq_ = GOOGLE_LONGLONG(0);
  clear_has_seq();
}
inline ::google::protobuf::int64 Header::seq() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Header.seq)
  return seq_;
}
inline void Header::set_seq(::google::protobuf::int64 value) {
  set_has_seq();
  seq_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.Header.seq)
}

// required string frame_id = 3;
inline bool Header::has_frame_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Header::set_has_frame_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Header::clear_has_frame_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Header::clear_frame_id() {
  frame_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_frame_id();
}
inline const ::std::string& Header::frame_id() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Header.frame_id)
  return frame_id_.GetNoArena();
}
inline void Header::set_frame_id(const ::std::string& value) {
  set_has_frame_id();
  frame_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ndm_proto.Header.frame_id)
}
#if LANG_CXX11
inline void Header::set_frame_id(::std::string&& value) {
  set_has_frame_id();
  frame_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ndm_proto.Header.frame_id)
}
#endif
inline void Header::set_frame_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_frame_id();
  frame_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ndm_proto.Header.frame_id)
}
inline void Header::set_frame_id(const char* value, size_t size) {
  set_has_frame_id();
  frame_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.Header.frame_id)
}
inline ::std::string* Header::mutable_frame_id() {
  set_has_frame_id();
  // @@protoc_insertion_point(field_mutable:ndm_proto.Header.frame_id)
  return frame_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Header::release_frame_id() {
  // @@protoc_insertion_point(field_release:ndm_proto.Header.frame_id)
  clear_has_frame_id();
  return frame_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_allocated_frame_id(::std::string* frame_id) {
  if (frame_id != NULL) {
    set_has_frame_id();
  } else {
    clear_has_frame_id();
  }
  frame_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), frame_id);
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.Header.frame_id)
}

// optional int32 version = 4;
inline bool Header::has_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Header::set_has_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Header::clear_has_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Header::clear_version() {
  version_ = 0;
  clear_has_version();
}
inline ::google::protobuf::int32 Header::version() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Header.version)
  return version_;
}
inline void Header::set_version(::google::protobuf::int32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.Header.version)
}

// -------------------------------------------------------------------

// Vector2F

// optional float x = 1;
inline bool Vector2F::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vector2F::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vector2F::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vector2F::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Vector2F::x() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Vector2F.x)
  return x_;
}
inline void Vector2F::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.Vector2F.x)
}

// optional float y = 2;
inline bool Vector2F::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vector2F::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vector2F::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vector2F::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Vector2F::y() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Vector2F.y)
  return y_;
}
inline void Vector2F::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.Vector2F.y)
}

// -------------------------------------------------------------------

// Vector3D

// optional double x = 1;
inline bool Vector3D::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vector3D::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vector3D::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vector3D::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double Vector3D::x() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Vector3D.x)
  return x_;
}
inline void Vector3D::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.Vector3D.x)
}

// optional double y = 2;
inline bool Vector3D::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vector3D::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vector3D::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vector3D::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double Vector3D::y() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Vector3D.y)
  return y_;
}
inline void Vector3D::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.Vector3D.y)
}

// optional double z = 3;
inline bool Vector3D::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Vector3D::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Vector3D::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Vector3D::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double Vector3D::z() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Vector3D.z)
  return z_;
}
inline void Vector3D::set_z(double value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.Vector3D.z)
}

// -------------------------------------------------------------------

// Vector3F

// optional float x = 1;
inline bool Vector3F::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vector3F::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vector3F::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vector3F::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Vector3F::x() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Vector3F.x)
  return x_;
}
inline void Vector3F::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.Vector3F.x)
}

// optional float y = 2;
inline bool Vector3F::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vector3F::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vector3F::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vector3F::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Vector3F::y() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Vector3F.y)
  return y_;
}
inline void Vector3F::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.Vector3F.y)
}

// optional float z = 3;
inline bool Vector3F::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Vector3F::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Vector3F::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Vector3F::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float Vector3F::z() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Vector3F.z)
  return z_;
}
inline void Vector3F::set_z(float value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.Vector3F.z)
}

// -------------------------------------------------------------------

// Vector4D

// optional double x = 1;
inline bool Vector4D::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vector4D::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vector4D::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vector4D::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double Vector4D::x() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Vector4D.x)
  return x_;
}
inline void Vector4D::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.Vector4D.x)
}

// optional double y = 2;
inline bool Vector4D::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vector4D::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vector4D::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vector4D::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double Vector4D::y() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Vector4D.y)
  return y_;
}
inline void Vector4D::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.Vector4D.y)
}

// optional double z = 3;
inline bool Vector4D::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Vector4D::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Vector4D::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Vector4D::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double Vector4D::z() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Vector4D.z)
  return z_;
}
inline void Vector4D::set_z(double value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.Vector4D.z)
}

// optional double w = 4;
inline bool Vector4D::has_w() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Vector4D::set_has_w() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Vector4D::clear_has_w() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Vector4D::clear_w() {
  w_ = 0;
  clear_has_w();
}
inline double Vector4D::w() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Vector4D.w)
  return w_;
}
inline void Vector4D::set_w(double value) {
  set_has_w();
  w_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.Vector4D.w)
}

// -------------------------------------------------------------------

// Vector4F

// optional float x = 1;
inline bool Vector4F::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vector4F::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vector4F::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vector4F::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Vector4F::x() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Vector4F.x)
  return x_;
}
inline void Vector4F::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.Vector4F.x)
}

// optional float y = 2;
inline bool Vector4F::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vector4F::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vector4F::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vector4F::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Vector4F::y() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Vector4F.y)
  return y_;
}
inline void Vector4F::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.Vector4F.y)
}

// optional float z = 3;
inline bool Vector4F::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Vector4F::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Vector4F::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Vector4F::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float Vector4F::z() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Vector4F.z)
  return z_;
}
inline void Vector4F::set_z(float value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.Vector4F.z)
}

// optional float w = 4;
inline bool Vector4F::has_w() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Vector4F::set_has_w() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Vector4F::clear_has_w() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Vector4F::clear_w() {
  w_ = 0;
  clear_has_w();
}
inline float Vector4F::w() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Vector4F.w)
  return w_;
}
inline void Vector4F::set_w(float value) {
  set_has_w();
  w_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.Vector4F.w)
}

// -------------------------------------------------------------------

// Quaternion

// optional float x = 1;
inline bool Quaternion::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Quaternion::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Quaternion::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Quaternion::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Quaternion::x() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Quaternion.x)
  return x_;
}
inline void Quaternion::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.Quaternion.x)
}

// optional float y = 2;
inline bool Quaternion::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Quaternion::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Quaternion::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Quaternion::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Quaternion::y() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Quaternion.y)
  return y_;
}
inline void Quaternion::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.Quaternion.y)
}

// optional float z = 3;
inline bool Quaternion::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Quaternion::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Quaternion::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Quaternion::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float Quaternion::z() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Quaternion.z)
  return z_;
}
inline void Quaternion::set_z(float value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.Quaternion.z)
}

// optional float w = 4;
inline bool Quaternion::has_w() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Quaternion::set_has_w() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Quaternion::clear_has_w() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Quaternion::clear_w() {
  w_ = 0;
  clear_has_w();
}
inline float Quaternion::w() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Quaternion.w)
  return w_;
}
inline void Quaternion::set_w(float value) {
  set_has_w();
  w_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.Quaternion.w)
}

// -------------------------------------------------------------------

// UNPACK_IMU_ALG

// optional int32 automntalgon = 1;
inline bool UNPACK_IMU_ALG::has_automntalgon() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UNPACK_IMU_ALG::set_has_automntalgon() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UNPACK_IMU_ALG::clear_has_automntalgon() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UNPACK_IMU_ALG::clear_automntalgon() {
  automntalgon_ = 0;
  clear_has_automntalgon();
}
inline ::google::protobuf::int32 UNPACK_IMU_ALG::automntalgon() const {
  // @@protoc_insertion_point(field_get:ndm_proto.UNPACK_IMU_ALG.automntalgon)
  return automntalgon_;
}
inline void UNPACK_IMU_ALG::set_automntalgon(::google::protobuf::int32 value) {
  set_has_automntalgon();
  automntalgon_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.UNPACK_IMU_ALG.automntalgon)
}

// optional int32 status = 2;
inline bool UNPACK_IMU_ALG::has_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UNPACK_IMU_ALG::set_has_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UNPACK_IMU_ALG::clear_has_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UNPACK_IMU_ALG::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 UNPACK_IMU_ALG::status() const {
  // @@protoc_insertion_point(field_get:ndm_proto.UNPACK_IMU_ALG.status)
  return status_;
}
inline void UNPACK_IMU_ALG::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.UNPACK_IMU_ALG.status)
}

// optional .ndm_proto.Vector3D trans = 3;
inline bool UNPACK_IMU_ALG::has_trans() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UNPACK_IMU_ALG::set_has_trans() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UNPACK_IMU_ALG::clear_has_trans() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UNPACK_IMU_ALG::clear_trans() {
  if (trans_ != NULL) trans_->Clear();
  clear_has_trans();
}
inline const ::ndm_proto::Vector3D& UNPACK_IMU_ALG::trans() const {
  const ::ndm_proto::Vector3D* p = trans_;
  // @@protoc_insertion_point(field_get:ndm_proto.UNPACK_IMU_ALG.trans)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Vector3D*>(
      &::ndm_proto::_Vector3D_default_instance_);
}
inline ::ndm_proto::Vector3D* UNPACK_IMU_ALG::release_trans() {
  // @@protoc_insertion_point(field_release:ndm_proto.UNPACK_IMU_ALG.trans)
  clear_has_trans();
  ::ndm_proto::Vector3D* temp = trans_;
  trans_ = NULL;
  return temp;
}
inline ::ndm_proto::Vector3D* UNPACK_IMU_ALG::mutable_trans() {
  set_has_trans();
  if (trans_ == NULL) {
    trans_ = new ::ndm_proto::Vector3D;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.UNPACK_IMU_ALG.trans)
  return trans_;
}
inline void UNPACK_IMU_ALG::set_allocated_trans(::ndm_proto::Vector3D* trans) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete trans_;
  }
  if (trans) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      trans = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, trans, submessage_arena);
    }
    set_has_trans();
  } else {
    clear_has_trans();
  }
  trans_ = trans;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.UNPACK_IMU_ALG.trans)
}

// optional .ndm_proto.Vector4D orientation = 4;
inline bool UNPACK_IMU_ALG::has_orientation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UNPACK_IMU_ALG::set_has_orientation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UNPACK_IMU_ALG::clear_has_orientation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UNPACK_IMU_ALG::clear_orientation() {
  if (orientation_ != NULL) orientation_->Clear();
  clear_has_orientation();
}
inline const ::ndm_proto::Vector4D& UNPACK_IMU_ALG::orientation() const {
  const ::ndm_proto::Vector4D* p = orientation_;
  // @@protoc_insertion_point(field_get:ndm_proto.UNPACK_IMU_ALG.orientation)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Vector4D*>(
      &::ndm_proto::_Vector4D_default_instance_);
}
inline ::ndm_proto::Vector4D* UNPACK_IMU_ALG::release_orientation() {
  // @@protoc_insertion_point(field_release:ndm_proto.UNPACK_IMU_ALG.orientation)
  clear_has_orientation();
  ::ndm_proto::Vector4D* temp = orientation_;
  orientation_ = NULL;
  return temp;
}
inline ::ndm_proto::Vector4D* UNPACK_IMU_ALG::mutable_orientation() {
  set_has_orientation();
  if (orientation_ == NULL) {
    orientation_ = new ::ndm_proto::Vector4D;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.UNPACK_IMU_ALG.orientation)
  return orientation_;
}
inline void UNPACK_IMU_ALG::set_allocated_orientation(::ndm_proto::Vector4D* orientation) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete orientation_;
  }
  if (orientation) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      orientation = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, orientation, submessage_arena);
    }
    set_has_orientation();
  } else {
    clear_has_orientation();
  }
  orientation_ = orientation;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.UNPACK_IMU_ALG.orientation)
}

// -------------------------------------------------------------------

// CANFrame

// required .ndm_proto.Header header = 1;
inline bool CANFrame::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CANFrame::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CANFrame::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CANFrame::clear_header() {
  if (header_ != NULL) header_->Clear();
  clear_has_header();
}
inline const ::ndm_proto::Header& CANFrame::header() const {
  const ::ndm_proto::Header* p = header_;
  // @@protoc_insertion_point(field_get:ndm_proto.CANFrame.header)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Header*>(
      &::ndm_proto::_Header_default_instance_);
}
inline ::ndm_proto::Header* CANFrame::release_header() {
  // @@protoc_insertion_point(field_release:ndm_proto.CANFrame.header)
  clear_has_header();
  ::ndm_proto::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::ndm_proto::Header* CANFrame::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::ndm_proto::Header;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.CANFrame.header)
  return header_;
}
inline void CANFrame::set_allocated_header(::ndm_proto::Header* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    set_has_header();
  } else {
    clear_has_header();
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.CANFrame.header)
}

// required int64 stamp = 2;
inline bool CANFrame::has_stamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CANFrame::set_has_stamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CANFrame::clear_has_stamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CANFrame::clear_stamp() {
  stamp_ = GOOGLE_LONGLONG(0);
  clear_has_stamp();
}
inline ::google::protobuf::int64 CANFrame::stamp() const {
  // @@protoc_insertion_point(field_get:ndm_proto.CANFrame.stamp)
  return stamp_;
}
inline void CANFrame::set_stamp(::google::protobuf::int64 value) {
  set_has_stamp();
  stamp_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.CANFrame.stamp)
}

// required double speed = 3;
inline bool CANFrame::has_speed() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CANFrame::set_has_speed() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CANFrame::clear_has_speed() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CANFrame::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
inline double CANFrame::speed() const {
  // @@protoc_insertion_point(field_get:ndm_proto.CANFrame.speed)
  return speed_;
}
inline void CANFrame::set_speed(double value) {
  set_has_speed();
  speed_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.CANFrame.speed)
}

// required double yawrate = 4;
inline bool CANFrame::has_yawrate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CANFrame::set_has_yawrate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CANFrame::clear_has_yawrate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CANFrame::clear_yawrate() {
  yawrate_ = 0;
  clear_has_yawrate();
}
inline double CANFrame::yawrate() const {
  // @@protoc_insertion_point(field_get:ndm_proto.CANFrame.yawrate)
  return yawrate_;
}
inline void CANFrame::set_yawrate(double value) {
  set_has_yawrate();
  yawrate_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.CANFrame.yawrate)
}

// required double steerangle = 5;
inline bool CANFrame::has_steerangle() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CANFrame::set_has_steerangle() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CANFrame::clear_has_steerangle() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CANFrame::clear_steerangle() {
  steerangle_ = 0;
  clear_has_steerangle();
}
inline double CANFrame::steerangle() const {
  // @@protoc_insertion_point(field_get:ndm_proto.CANFrame.steerangle)
  return steerangle_;
}
inline void CANFrame::set_steerangle(double value) {
  set_has_steerangle();
  steerangle_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.CANFrame.steerangle)
}

// required uint32 gear = 6;
inline bool CANFrame::has_gear() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CANFrame::set_has_gear() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CANFrame::clear_has_gear() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CANFrame::clear_gear() {
  gear_ = 0u;
  clear_has_gear();
}
inline ::google::protobuf::uint32 CANFrame::gear() const {
  // @@protoc_insertion_point(field_get:ndm_proto.CANFrame.gear)
  return gear_;
}
inline void CANFrame::set_gear(::google::protobuf::uint32 value) {
  set_has_gear();
  gear_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.CANFrame.gear)
}

// -------------------------------------------------------------------

// VehicleMsg

// required int64 sensor_stamp = 1;
inline bool VehicleMsg::has_sensor_stamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VehicleMsg::set_has_sensor_stamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VehicleMsg::clear_has_sensor_stamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VehicleMsg::clear_sensor_stamp() {
  sensor_stamp_ = GOOGLE_LONGLONG(0);
  clear_has_sensor_stamp();
}
inline ::google::protobuf::int64 VehicleMsg::sensor_stamp() const {
  // @@protoc_insertion_point(field_get:ndm_proto.VehicleMsg.sensor_stamp)
  return sensor_stamp_;
}
inline void VehicleMsg::set_sensor_stamp(::google::protobuf::int64 value) {
  set_has_sensor_stamp();
  sensor_stamp_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.VehicleMsg.sensor_stamp)
}

// required int64 sample_stamp = 2;
inline bool VehicleMsg::has_sample_stamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VehicleMsg::set_has_sample_stamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VehicleMsg::clear_has_sample_stamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VehicleMsg::clear_sample_stamp() {
  sample_stamp_ = GOOGLE_LONGLONG(0);
  clear_has_sample_stamp();
}
inline ::google::protobuf::int64 VehicleMsg::sample_stamp() const {
  // @@protoc_insertion_point(field_get:ndm_proto.VehicleMsg.sample_stamp)
  return sample_stamp_;
}
inline void VehicleMsg::set_sample_stamp(::google::protobuf::int64 value) {
  set_has_sample_stamp();
  sample_stamp_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.VehicleMsg.sample_stamp)
}

// optional float speed = 3;
inline bool VehicleMsg::has_speed() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VehicleMsg::set_has_speed() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VehicleMsg::clear_has_speed() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VehicleMsg::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
inline float VehicleMsg::speed() const {
  // @@protoc_insertion_point(field_get:ndm_proto.VehicleMsg.speed)
  return speed_;
}
inline void VehicleMsg::set_speed(float value) {
  set_has_speed();
  speed_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.VehicleMsg.speed)
}

// optional float steer_angle = 4;
inline bool VehicleMsg::has_steer_angle() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VehicleMsg::set_has_steer_angle() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VehicleMsg::clear_has_steer_angle() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VehicleMsg::clear_steer_angle() {
  steer_angle_ = 0;
  clear_has_steer_angle();
}
inline float VehicleMsg::steer_angle() const {
  // @@protoc_insertion_point(field_get:ndm_proto.VehicleMsg.steer_angle)
  return steer_angle_;
}
inline void VehicleMsg::set_steer_angle(float value) {
  set_has_steer_angle();
  steer_angle_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.VehicleMsg.steer_angle)
}

// optional float yaw_rate = 5;
inline bool VehicleMsg::has_yaw_rate() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VehicleMsg::set_has_yaw_rate() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VehicleMsg::clear_has_yaw_rate() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VehicleMsg::clear_yaw_rate() {
  yaw_rate_ = 0;
  clear_has_yaw_rate();
}
inline float VehicleMsg::yaw_rate() const {
  // @@protoc_insertion_point(field_get:ndm_proto.VehicleMsg.yaw_rate)
  return yaw_rate_;
}
inline void VehicleMsg::set_yaw_rate(float value) {
  set_has_yaw_rate();
  yaw_rate_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.VehicleMsg.yaw_rate)
}

// optional float yaw_rate_raw = 6;
inline bool VehicleMsg::has_yaw_rate_raw() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void VehicleMsg::set_has_yaw_rate_raw() {
  _has_bits_[0] |= 0x00000020u;
}
inline void VehicleMsg::clear_has_yaw_rate_raw() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void VehicleMsg::clear_yaw_rate_raw() {
  yaw_rate_raw_ = 0;
  clear_has_yaw_rate_raw();
}
inline float VehicleMsg::yaw_rate_raw() const {
  // @@protoc_insertion_point(field_get:ndm_proto.VehicleMsg.yaw_rate_raw)
  return yaw_rate_raw_;
}
inline void VehicleMsg::set_yaw_rate_raw(float value) {
  set_has_yaw_rate_raw();
  yaw_rate_raw_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.VehicleMsg.yaw_rate_raw)
}

// optional float yaw_rate_bias = 7;
inline bool VehicleMsg::has_yaw_rate_bias() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void VehicleMsg::set_has_yaw_rate_bias() {
  _has_bits_[0] |= 0x00000040u;
}
inline void VehicleMsg::clear_has_yaw_rate_bias() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void VehicleMsg::clear_yaw_rate_bias() {
  yaw_rate_bias_ = 0;
  clear_has_yaw_rate_bias();
}
inline float VehicleMsg::yaw_rate_bias() const {
  // @@protoc_insertion_point(field_get:ndm_proto.VehicleMsg.yaw_rate_bias)
  return yaw_rate_bias_;
}
inline void VehicleMsg::set_yaw_rate_bias(float value) {
  set_has_yaw_rate_bias();
  yaw_rate_bias_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.VehicleMsg.yaw_rate_bias)
}

// optional float long_acc = 8;
inline bool VehicleMsg::has_long_acc() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void VehicleMsg::set_has_long_acc() {
  _has_bits_[0] |= 0x00000080u;
}
inline void VehicleMsg::clear_has_long_acc() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void VehicleMsg::clear_long_acc() {
  long_acc_ = 0;
  clear_has_long_acc();
}
inline float VehicleMsg::long_acc() const {
  // @@protoc_insertion_point(field_get:ndm_proto.VehicleMsg.long_acc)
  return long_acc_;
}
inline void VehicleMsg::set_long_acc(float value) {
  set_has_long_acc();
  long_acc_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.VehicleMsg.long_acc)
}

// optional float long_acc_raw = 9;
inline bool VehicleMsg::has_long_acc_raw() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void VehicleMsg::set_has_long_acc_raw() {
  _has_bits_[0] |= 0x00000100u;
}
inline void VehicleMsg::clear_has_long_acc_raw() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void VehicleMsg::clear_long_acc_raw() {
  long_acc_raw_ = 0;
  clear_has_long_acc_raw();
}
inline float VehicleMsg::long_acc_raw() const {
  // @@protoc_insertion_point(field_get:ndm_proto.VehicleMsg.long_acc_raw)
  return long_acc_raw_;
}
inline void VehicleMsg::set_long_acc_raw(float value) {
  set_has_long_acc_raw();
  long_acc_raw_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.VehicleMsg.long_acc_raw)
}

// optional float long_acc_bias = 10;
inline bool VehicleMsg::has_long_acc_bias() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void VehicleMsg::set_has_long_acc_bias() {
  _has_bits_[0] |= 0x00000200u;
}
inline void VehicleMsg::clear_has_long_acc_bias() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void VehicleMsg::clear_long_acc_bias() {
  long_acc_bias_ = 0;
  clear_has_long_acc_bias();
}
inline float VehicleMsg::long_acc_bias() const {
  // @@protoc_insertion_point(field_get:ndm_proto.VehicleMsg.long_acc_bias)
  return long_acc_bias_;
}
inline void VehicleMsg::set_long_acc_bias(float value) {
  set_has_long_acc_bias();
  long_acc_bias_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.VehicleMsg.long_acc_bias)
}

// optional float lat_acc = 11;
inline bool VehicleMsg::has_lat_acc() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void VehicleMsg::set_has_lat_acc() {
  _has_bits_[0] |= 0x00000400u;
}
inline void VehicleMsg::clear_has_lat_acc() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void VehicleMsg::clear_lat_acc() {
  lat_acc_ = 0;
  clear_has_lat_acc();
}
inline float VehicleMsg::lat_acc() const {
  // @@protoc_insertion_point(field_get:ndm_proto.VehicleMsg.lat_acc)
  return lat_acc_;
}
inline void VehicleMsg::set_lat_acc(float value) {
  set_has_lat_acc();
  lat_acc_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.VehicleMsg.lat_acc)
}

// optional float lat_acc_raw = 12;
inline bool VehicleMsg::has_lat_acc_raw() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void VehicleMsg::set_has_lat_acc_raw() {
  _has_bits_[0] |= 0x00000800u;
}
inline void VehicleMsg::clear_has_lat_acc_raw() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void VehicleMsg::clear_lat_acc_raw() {
  lat_acc_raw_ = 0;
  clear_has_lat_acc_raw();
}
inline float VehicleMsg::lat_acc_raw() const {
  // @@protoc_insertion_point(field_get:ndm_proto.VehicleMsg.lat_acc_raw)
  return lat_acc_raw_;
}
inline void VehicleMsg::set_lat_acc_raw(float value) {
  set_has_lat_acc_raw();
  lat_acc_raw_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.VehicleMsg.lat_acc_raw)
}

// optional float lat_acc_bias = 13;
inline bool VehicleMsg::has_lat_acc_bias() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void VehicleMsg::set_has_lat_acc_bias() {
  _has_bits_[0] |= 0x00001000u;
}
inline void VehicleMsg::clear_has_lat_acc_bias() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void VehicleMsg::clear_lat_acc_bias() {
  lat_acc_bias_ = 0;
  clear_has_lat_acc_bias();
}
inline float VehicleMsg::lat_acc_bias() const {
  // @@protoc_insertion_point(field_get:ndm_proto.VehicleMsg.lat_acc_bias)
  return lat_acc_bias_;
}
inline void VehicleMsg::set_lat_acc_bias(float value) {
  set_has_lat_acc_bias();
  lat_acc_bias_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.VehicleMsg.lat_acc_bias)
}

// optional int32 gear = 14;
inline bool VehicleMsg::has_gear() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void VehicleMsg::set_has_gear() {
  _has_bits_[0] |= 0x00002000u;
}
inline void VehicleMsg::clear_has_gear() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void VehicleMsg::clear_gear() {
  gear_ = 0;
  clear_has_gear();
}
inline ::google::protobuf::int32 VehicleMsg::gear() const {
  // @@protoc_insertion_point(field_get:ndm_proto.VehicleMsg.gear)
  return gear_;
}
inline void VehicleMsg::set_gear(::google::protobuf::int32 value) {
  set_has_gear();
  gear_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.VehicleMsg.gear)
}

// optional int32 high_beam = 15;
inline bool VehicleMsg::has_high_beam() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void VehicleMsg::set_has_high_beam() {
  _has_bits_[0] |= 0x00004000u;
}
inline void VehicleMsg::clear_has_high_beam() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void VehicleMsg::clear_high_beam() {
  high_beam_ = 0;
  clear_has_high_beam();
}
inline ::google::protobuf::int32 VehicleMsg::high_beam() const {
  // @@protoc_insertion_point(field_get:ndm_proto.VehicleMsg.high_beam)
  return high_beam_;
}
inline void VehicleMsg::set_high_beam(::google::protobuf::int32 value) {
  set_has_high_beam();
  high_beam_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.VehicleMsg.high_beam)
}

// optional int32 low_beam = 16;
inline bool VehicleMsg::has_low_beam() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void VehicleMsg::set_has_low_beam() {
  _has_bits_[0] |= 0x00008000u;
}
inline void VehicleMsg::clear_has_low_beam() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void VehicleMsg::clear_low_beam() {
  low_beam_ = 0;
  clear_has_low_beam();
}
inline ::google::protobuf::int32 VehicleMsg::low_beam() const {
  // @@protoc_insertion_point(field_get:ndm_proto.VehicleMsg.low_beam)
  return low_beam_;
}
inline void VehicleMsg::set_low_beam(::google::protobuf::int32 value) {
  set_has_low_beam();
  low_beam_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.VehicleMsg.low_beam)
}

// optional int32 turn_signal = 17;
inline bool VehicleMsg::has_turn_signal() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void VehicleMsg::set_has_turn_signal() {
  _has_bits_[0] |= 0x00010000u;
}
inline void VehicleMsg::clear_has_turn_signal() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void VehicleMsg::clear_turn_signal() {
  turn_signal_ = 0;
  clear_has_turn_signal();
}
inline ::google::protobuf::int32 VehicleMsg::turn_signal() const {
  // @@protoc_insertion_point(field_get:ndm_proto.VehicleMsg.turn_signal)
  return turn_signal_;
}
inline void VehicleMsg::set_turn_signal(::google::protobuf::int32 value) {
  set_has_turn_signal();
  turn_signal_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.VehicleMsg.turn_signal)
}

// optional int32 wiper = 18;
inline bool VehicleMsg::has_wiper() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void VehicleMsg::set_has_wiper() {
  _has_bits_[0] |= 0x00020000u;
}
inline void VehicleMsg::clear_has_wiper() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void VehicleMsg::clear_wiper() {
  wiper_ = 0;
  clear_has_wiper();
}
inline ::google::protobuf::int32 VehicleMsg::wiper() const {
  // @@protoc_insertion_point(field_get:ndm_proto.VehicleMsg.wiper)
  return wiper_;
}
inline void VehicleMsg::set_wiper(::google::protobuf::int32 value) {
  set_has_wiper();
  wiper_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.VehicleMsg.wiper)
}

// optional int32 udlc_left = 19;
inline bool VehicleMsg::has_udlc_left() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void VehicleMsg::set_has_udlc_left() {
  _has_bits_[0] |= 0x00040000u;
}
inline void VehicleMsg::clear_has_udlc_left() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void VehicleMsg::clear_udlc_left() {
  udlc_left_ = 0;
  clear_has_udlc_left();
}
inline ::google::protobuf::int32 VehicleMsg::udlc_left() const {
  // @@protoc_insertion_point(field_get:ndm_proto.VehicleMsg.udlc_left)
  return udlc_left_;
}
inline void VehicleMsg::set_udlc_left(::google::protobuf::int32 value) {
  set_has_udlc_left();
  udlc_left_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.VehicleMsg.udlc_left)
}

// optional int32 udlc_right = 20;
inline bool VehicleMsg::has_udlc_right() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void VehicleMsg::set_has_udlc_right() {
  _has_bits_[0] |= 0x00080000u;
}
inline void VehicleMsg::clear_has_udlc_right() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void VehicleMsg::clear_udlc_right() {
  udlc_right_ = 0;
  clear_has_udlc_right();
}
inline ::google::protobuf::int32 VehicleMsg::udlc_right() const {
  // @@protoc_insertion_point(field_get:ndm_proto.VehicleMsg.udlc_right)
  return udlc_right_;
}
inline void VehicleMsg::set_udlc_right(::google::protobuf::int32 value) {
  set_has_udlc_right();
  udlc_right_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.VehicleMsg.udlc_right)
}

// optional float vrl = 21;
inline bool VehicleMsg::has_vrl() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void VehicleMsg::set_has_vrl() {
  _has_bits_[0] |= 0x00100000u;
}
inline void VehicleMsg::clear_has_vrl() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void VehicleMsg::clear_vrl() {
  vrl_ = 0;
  clear_has_vrl();
}
inline float VehicleMsg::vrl() const {
  // @@protoc_insertion_point(field_get:ndm_proto.VehicleMsg.vrl)
  return vrl_;
}
inline void VehicleMsg::set_vrl(float value) {
  set_has_vrl();
  vrl_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.VehicleMsg.vrl)
}

// optional float vrr = 22;
inline bool VehicleMsg::has_vrr() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void VehicleMsg::set_has_vrr() {
  _has_bits_[0] |= 0x00200000u;
}
inline void VehicleMsg::clear_has_vrr() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void VehicleMsg::clear_vrr() {
  vrr_ = 0;
  clear_has_vrr();
}
inline float VehicleMsg::vrr() const {
  // @@protoc_insertion_point(field_get:ndm_proto.VehicleMsg.vrr)
  return vrr_;
}
inline void VehicleMsg::set_vrr(float value) {
  set_has_vrr();
  vrr_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.VehicleMsg.vrr)
}

// optional float vfl = 23;
inline bool VehicleMsg::has_vfl() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void VehicleMsg::set_has_vfl() {
  _has_bits_[0] |= 0x00400000u;
}
inline void VehicleMsg::clear_has_vfl() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void VehicleMsg::clear_vfl() {
  vfl_ = 0;
  clear_has_vfl();
}
inline float VehicleMsg::vfl() const {
  // @@protoc_insertion_point(field_get:ndm_proto.VehicleMsg.vfl)
  return vfl_;
}
inline void VehicleMsg::set_vfl(float value) {
  set_has_vfl();
  vfl_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.VehicleMsg.vfl)
}

// optional float vfr = 24;
inline bool VehicleMsg::has_vfr() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void VehicleMsg::set_has_vfr() {
  _has_bits_[0] |= 0x00800000u;
}
inline void VehicleMsg::clear_has_vfr() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void VehicleMsg::clear_vfr() {
  vfr_ = 0;
  clear_has_vfr();
}
inline float VehicleMsg::vfr() const {
  // @@protoc_insertion_point(field_get:ndm_proto.VehicleMsg.vfr)
  return vfr_;
}
inline void VehicleMsg::set_vfr(float value) {
  set_has_vfr();
  vfr_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.VehicleMsg.vfr)
}

// optional float prl = 25;
inline bool VehicleMsg::has_prl() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void VehicleMsg::set_has_prl() {
  _has_bits_[0] |= 0x01000000u;
}
inline void VehicleMsg::clear_has_prl() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void VehicleMsg::clear_prl() {
  prl_ = 0;
  clear_has_prl();
}
inline float VehicleMsg::prl() const {
  // @@protoc_insertion_point(field_get:ndm_proto.VehicleMsg.prl)
  return prl_;
}
inline void VehicleMsg::set_prl(float value) {
  set_has_prl();
  prl_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.VehicleMsg.prl)
}

// optional float prr = 26;
inline bool VehicleMsg::has_prr() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void VehicleMsg::set_has_prr() {
  _has_bits_[0] |= 0x02000000u;
}
inline void VehicleMsg::clear_has_prr() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void VehicleMsg::clear_prr() {
  prr_ = 0;
  clear_has_prr();
}
inline float VehicleMsg::prr() const {
  // @@protoc_insertion_point(field_get:ndm_proto.VehicleMsg.prr)
  return prr_;
}
inline void VehicleMsg::set_prr(float value) {
  set_has_prr();
  prr_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.VehicleMsg.prr)
}

// optional float pfl = 27;
inline bool VehicleMsg::has_pfl() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void VehicleMsg::set_has_pfl() {
  _has_bits_[0] |= 0x04000000u;
}
inline void VehicleMsg::clear_has_pfl() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void VehicleMsg::clear_pfl() {
  pfl_ = 0;
  clear_has_pfl();
}
inline float VehicleMsg::pfl() const {
  // @@protoc_insertion_point(field_get:ndm_proto.VehicleMsg.pfl)
  return pfl_;
}
inline void VehicleMsg::set_pfl(float value) {
  set_has_pfl();
  pfl_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.VehicleMsg.pfl)
}

// optional float pfr = 28;
inline bool VehicleMsg::has_pfr() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void VehicleMsg::set_has_pfr() {
  _has_bits_[0] |= 0x08000000u;
}
inline void VehicleMsg::clear_has_pfr() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void VehicleMsg::clear_pfr() {
  pfr_ = 0;
  clear_has_pfr();
}
inline float VehicleMsg::pfr() const {
  // @@protoc_insertion_point(field_get:ndm_proto.VehicleMsg.pfr)
  return pfr_;
}
inline void VehicleMsg::set_pfr(float value) {
  set_has_pfr();
  pfr_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.VehicleMsg.pfr)
}

// -------------------------------------------------------------------

// GNSSStatus

// optional string sol_status = 1;
inline bool GNSSStatus::has_sol_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GNSSStatus::set_has_sol_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GNSSStatus::clear_has_sol_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GNSSStatus::clear_sol_status() {
  sol_status_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sol_status();
}
inline const ::std::string& GNSSStatus::sol_status() const {
  // @@protoc_insertion_point(field_get:ndm_proto.GNSSStatus.sol_status)
  return sol_status_.GetNoArena();
}
inline void GNSSStatus::set_sol_status(const ::std::string& value) {
  set_has_sol_status();
  sol_status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ndm_proto.GNSSStatus.sol_status)
}
#if LANG_CXX11
inline void GNSSStatus::set_sol_status(::std::string&& value) {
  set_has_sol_status();
  sol_status_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ndm_proto.GNSSStatus.sol_status)
}
#endif
inline void GNSSStatus::set_sol_status(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_sol_status();
  sol_status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ndm_proto.GNSSStatus.sol_status)
}
inline void GNSSStatus::set_sol_status(const char* value, size_t size) {
  set_has_sol_status();
  sol_status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.GNSSStatus.sol_status)
}
inline ::std::string* GNSSStatus::mutable_sol_status() {
  set_has_sol_status();
  // @@protoc_insertion_point(field_mutable:ndm_proto.GNSSStatus.sol_status)
  return sol_status_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GNSSStatus::release_sol_status() {
  // @@protoc_insertion_point(field_release:ndm_proto.GNSSStatus.sol_status)
  clear_has_sol_status();
  return sol_status_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GNSSStatus::set_allocated_sol_status(::std::string* sol_status) {
  if (sol_status != NULL) {
    set_has_sol_status();
  } else {
    clear_has_sol_status();
  }
  sol_status_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sol_status);
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.GNSSStatus.sol_status)
}

// optional string type = 2;
inline bool GNSSStatus::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GNSSStatus::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GNSSStatus::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GNSSStatus::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_type();
}
inline const ::std::string& GNSSStatus::type() const {
  // @@protoc_insertion_point(field_get:ndm_proto.GNSSStatus.type)
  return type_.GetNoArena();
}
inline void GNSSStatus::set_type(const ::std::string& value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ndm_proto.GNSSStatus.type)
}
#if LANG_CXX11
inline void GNSSStatus::set_type(::std::string&& value) {
  set_has_type();
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ndm_proto.GNSSStatus.type)
}
#endif
inline void GNSSStatus::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ndm_proto.GNSSStatus.type)
}
inline void GNSSStatus::set_type(const char* value, size_t size) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.GNSSStatus.type)
}
inline ::std::string* GNSSStatus::mutable_type() {
  set_has_type();
  // @@protoc_insertion_point(field_mutable:ndm_proto.GNSSStatus.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GNSSStatus::release_type() {
  // @@protoc_insertion_point(field_release:ndm_proto.GNSSStatus.type)
  clear_has_type();
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GNSSStatus::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    set_has_type();
  } else {
    clear_has_type();
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.GNSSStatus.type)
}

// -------------------------------------------------------------------

// GNSSFrame

// required .ndm_proto.Header header = 1;
inline bool GNSSFrame::has_header() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GNSSFrame::set_has_header() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GNSSFrame::clear_has_header() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GNSSFrame::clear_header() {
  if (header_ != NULL) header_->Clear();
  clear_has_header();
}
inline const ::ndm_proto::Header& GNSSFrame::header() const {
  const ::ndm_proto::Header* p = header_;
  // @@protoc_insertion_point(field_get:ndm_proto.GNSSFrame.header)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Header*>(
      &::ndm_proto::_Header_default_instance_);
}
inline ::ndm_proto::Header* GNSSFrame::release_header() {
  // @@protoc_insertion_point(field_release:ndm_proto.GNSSFrame.header)
  clear_has_header();
  ::ndm_proto::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::ndm_proto::Header* GNSSFrame::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::ndm_proto::Header;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.GNSSFrame.header)
  return header_;
}
inline void GNSSFrame::set_allocated_header(::ndm_proto::Header* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    set_has_header();
  } else {
    clear_has_header();
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.GNSSFrame.header)
}

// optional int64 sensor_stamp = 2;
inline bool GNSSFrame::has_sensor_stamp() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void GNSSFrame::set_has_sensor_stamp() {
  _has_bits_[0] |= 0x00040000u;
}
inline void GNSSFrame::clear_has_sensor_stamp() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void GNSSFrame::clear_sensor_stamp() {
  sensor_stamp_ = GOOGLE_LONGLONG(0);
  clear_has_sensor_stamp();
}
inline ::google::protobuf::int64 GNSSFrame::sensor_stamp() const {
  // @@protoc_insertion_point(field_get:ndm_proto.GNSSFrame.sensor_stamp)
  return sensor_stamp_;
}
inline void GNSSFrame::set_sensor_stamp(::google::protobuf::int64 value) {
  set_has_sensor_stamp();
  sensor_stamp_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.GNSSFrame.sensor_stamp)
}

// optional int64 sample_stamp = 3;
inline bool GNSSFrame::has_sample_stamp() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void GNSSFrame::set_has_sample_stamp() {
  _has_bits_[0] |= 0x00080000u;
}
inline void GNSSFrame::clear_has_sample_stamp() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void GNSSFrame::clear_sample_stamp() {
  sample_stamp_ = GOOGLE_LONGLONG(0);
  clear_has_sample_stamp();
}
inline ::google::protobuf::int64 GNSSFrame::sample_stamp() const {
  // @@protoc_insertion_point(field_get:ndm_proto.GNSSFrame.sample_stamp)
  return sample_stamp_;
}
inline void GNSSFrame::set_sample_stamp(::google::protobuf::int64 value) {
  set_has_sample_stamp();
  sample_stamp_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.GNSSFrame.sample_stamp)
}

// optional string raw_data = 4;
inline bool GNSSFrame::has_raw_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GNSSFrame::set_has_raw_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GNSSFrame::clear_has_raw_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GNSSFrame::clear_raw_data() {
  raw_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_raw_data();
}
inline const ::std::string& GNSSFrame::raw_data() const {
  // @@protoc_insertion_point(field_get:ndm_proto.GNSSFrame.raw_data)
  return raw_data_.GetNoArena();
}
inline void GNSSFrame::set_raw_data(const ::std::string& value) {
  set_has_raw_data();
  raw_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ndm_proto.GNSSFrame.raw_data)
}
#if LANG_CXX11
inline void GNSSFrame::set_raw_data(::std::string&& value) {
  set_has_raw_data();
  raw_data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ndm_proto.GNSSFrame.raw_data)
}
#endif
inline void GNSSFrame::set_raw_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_raw_data();
  raw_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ndm_proto.GNSSFrame.raw_data)
}
inline void GNSSFrame::set_raw_data(const char* value, size_t size) {
  set_has_raw_data();
  raw_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.GNSSFrame.raw_data)
}
inline ::std::string* GNSSFrame::mutable_raw_data() {
  set_has_raw_data();
  // @@protoc_insertion_point(field_mutable:ndm_proto.GNSSFrame.raw_data)
  return raw_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GNSSFrame::release_raw_data() {
  // @@protoc_insertion_point(field_release:ndm_proto.GNSSFrame.raw_data)
  clear_has_raw_data();
  return raw_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GNSSFrame::set_allocated_raw_data(::std::string* raw_data) {
  if (raw_data != NULL) {
    set_has_raw_data();
  } else {
    clear_has_raw_data();
  }
  raw_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), raw_data);
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.GNSSFrame.raw_data)
}

// optional .ndm_proto.Vector3D position = 5;
inline bool GNSSFrame::has_position() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GNSSFrame::set_has_position() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GNSSFrame::clear_has_position() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GNSSFrame::clear_position() {
  if (position_ != NULL) position_->Clear();
  clear_has_position();
}
inline const ::ndm_proto::Vector3D& GNSSFrame::position() const {
  const ::ndm_proto::Vector3D* p = position_;
  // @@protoc_insertion_point(field_get:ndm_proto.GNSSFrame.position)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Vector3D*>(
      &::ndm_proto::_Vector3D_default_instance_);
}
inline ::ndm_proto::Vector3D* GNSSFrame::release_position() {
  // @@protoc_insertion_point(field_release:ndm_proto.GNSSFrame.position)
  clear_has_position();
  ::ndm_proto::Vector3D* temp = position_;
  position_ = NULL;
  return temp;
}
inline ::ndm_proto::Vector3D* GNSSFrame::mutable_position() {
  set_has_position();
  if (position_ == NULL) {
    position_ = new ::ndm_proto::Vector3D;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.GNSSFrame.position)
  return position_;
}
inline void GNSSFrame::set_allocated_position(::ndm_proto::Vector3D* position) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete position_;
  }
  if (position) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      position = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    set_has_position();
  } else {
    clear_has_position();
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.GNSSFrame.position)
}

// optional .ndm_proto.Vector3F position_std_dev = 6;
inline bool GNSSFrame::has_position_std_dev() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GNSSFrame::set_has_position_std_dev() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GNSSFrame::clear_has_position_std_dev() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GNSSFrame::clear_position_std_dev() {
  if (position_std_dev_ != NULL) position_std_dev_->Clear();
  clear_has_position_std_dev();
}
inline const ::ndm_proto::Vector3F& GNSSFrame::position_std_dev() const {
  const ::ndm_proto::Vector3F* p = position_std_dev_;
  // @@protoc_insertion_point(field_get:ndm_proto.GNSSFrame.position_std_dev)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Vector3F*>(
      &::ndm_proto::_Vector3F_default_instance_);
}
inline ::ndm_proto::Vector3F* GNSSFrame::release_position_std_dev() {
  // @@protoc_insertion_point(field_release:ndm_proto.GNSSFrame.position_std_dev)
  clear_has_position_std_dev();
  ::ndm_proto::Vector3F* temp = position_std_dev_;
  position_std_dev_ = NULL;
  return temp;
}
inline ::ndm_proto::Vector3F* GNSSFrame::mutable_position_std_dev() {
  set_has_position_std_dev();
  if (position_std_dev_ == NULL) {
    position_std_dev_ = new ::ndm_proto::Vector3F;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.GNSSFrame.position_std_dev)
  return position_std_dev_;
}
inline void GNSSFrame::set_allocated_position_std_dev(::ndm_proto::Vector3F* position_std_dev) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete position_std_dev_;
  }
  if (position_std_dev) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      position_std_dev = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, position_std_dev, submessage_arena);
    }
    set_has_position_std_dev();
  } else {
    clear_has_position_std_dev();
  }
  position_std_dev_ = position_std_dev;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.GNSSFrame.position_std_dev)
}

// optional .ndm_proto.Vector3F velocity = 7;
inline bool GNSSFrame::has_velocity() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GNSSFrame::set_has_velocity() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GNSSFrame::clear_has_velocity() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GNSSFrame::clear_velocity() {
  if (velocity_ != NULL) velocity_->Clear();
  clear_has_velocity();
}
inline const ::ndm_proto::Vector3F& GNSSFrame::velocity() const {
  const ::ndm_proto::Vector3F* p = velocity_;
  // @@protoc_insertion_point(field_get:ndm_proto.GNSSFrame.velocity)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Vector3F*>(
      &::ndm_proto::_Vector3F_default_instance_);
}
inline ::ndm_proto::Vector3F* GNSSFrame::release_velocity() {
  // @@protoc_insertion_point(field_release:ndm_proto.GNSSFrame.velocity)
  clear_has_velocity();
  ::ndm_proto::Vector3F* temp = velocity_;
  velocity_ = NULL;
  return temp;
}
inline ::ndm_proto::Vector3F* GNSSFrame::mutable_velocity() {
  set_has_velocity();
  if (velocity_ == NULL) {
    velocity_ = new ::ndm_proto::Vector3F;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.GNSSFrame.velocity)
  return velocity_;
}
inline void GNSSFrame::set_allocated_velocity(::ndm_proto::Vector3F* velocity) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete velocity_;
  }
  if (velocity) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      velocity = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, velocity, submessage_arena);
    }
    set_has_velocity();
  } else {
    clear_has_velocity();
  }
  velocity_ = velocity;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.GNSSFrame.velocity)
}

// optional .ndm_proto.Vector3F velocity_std_dev = 8;
inline bool GNSSFrame::has_velocity_std_dev() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GNSSFrame::set_has_velocity_std_dev() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GNSSFrame::clear_has_velocity_std_dev() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GNSSFrame::clear_velocity_std_dev() {
  if (velocity_std_dev_ != NULL) velocity_std_dev_->Clear();
  clear_has_velocity_std_dev();
}
inline const ::ndm_proto::Vector3F& GNSSFrame::velocity_std_dev() const {
  const ::ndm_proto::Vector3F* p = velocity_std_dev_;
  // @@protoc_insertion_point(field_get:ndm_proto.GNSSFrame.velocity_std_dev)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Vector3F*>(
      &::ndm_proto::_Vector3F_default_instance_);
}
inline ::ndm_proto::Vector3F* GNSSFrame::release_velocity_std_dev() {
  // @@protoc_insertion_point(field_release:ndm_proto.GNSSFrame.velocity_std_dev)
  clear_has_velocity_std_dev();
  ::ndm_proto::Vector3F* temp = velocity_std_dev_;
  velocity_std_dev_ = NULL;
  return temp;
}
inline ::ndm_proto::Vector3F* GNSSFrame::mutable_velocity_std_dev() {
  set_has_velocity_std_dev();
  if (velocity_std_dev_ == NULL) {
    velocity_std_dev_ = new ::ndm_proto::Vector3F;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.GNSSFrame.velocity_std_dev)
  return velocity_std_dev_;
}
inline void GNSSFrame::set_allocated_velocity_std_dev(::ndm_proto::Vector3F* velocity_std_dev) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete velocity_std_dev_;
  }
  if (velocity_std_dev) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      velocity_std_dev = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, velocity_std_dev, submessage_arena);
    }
    set_has_velocity_std_dev();
  } else {
    clear_has_velocity_std_dev();
  }
  velocity_std_dev_ = velocity_std_dev;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.GNSSFrame.velocity_std_dev)
}

// optional .ndm_proto.Vector3F angular = 9;
inline bool GNSSFrame::has_angular() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GNSSFrame::set_has_angular() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GNSSFrame::clear_has_angular() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GNSSFrame::clear_angular() {
  if (angular_ != NULL) angular_->Clear();
  clear_has_angular();
}
inline const ::ndm_proto::Vector3F& GNSSFrame::angular() const {
  const ::ndm_proto::Vector3F* p = angular_;
  // @@protoc_insertion_point(field_get:ndm_proto.GNSSFrame.angular)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Vector3F*>(
      &::ndm_proto::_Vector3F_default_instance_);
}
inline ::ndm_proto::Vector3F* GNSSFrame::release_angular() {
  // @@protoc_insertion_point(field_release:ndm_proto.GNSSFrame.angular)
  clear_has_angular();
  ::ndm_proto::Vector3F* temp = angular_;
  angular_ = NULL;
  return temp;
}
inline ::ndm_proto::Vector3F* GNSSFrame::mutable_angular() {
  set_has_angular();
  if (angular_ == NULL) {
    angular_ = new ::ndm_proto::Vector3F;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.GNSSFrame.angular)
  return angular_;
}
inline void GNSSFrame::set_allocated_angular(::ndm_proto::Vector3F* angular) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete angular_;
  }
  if (angular) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      angular = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, angular, submessage_arena);
    }
    set_has_angular();
  } else {
    clear_has_angular();
  }
  angular_ = angular;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.GNSSFrame.angular)
}

// optional .ndm_proto.Vector3F angular_std_dev = 10;
inline bool GNSSFrame::has_angular_std_dev() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GNSSFrame::set_has_angular_std_dev() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GNSSFrame::clear_has_angular_std_dev() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GNSSFrame::clear_angular_std_dev() {
  if (angular_std_dev_ != NULL) angular_std_dev_->Clear();
  clear_has_angular_std_dev();
}
inline const ::ndm_proto::Vector3F& GNSSFrame::angular_std_dev() const {
  const ::ndm_proto::Vector3F* p = angular_std_dev_;
  // @@protoc_insertion_point(field_get:ndm_proto.GNSSFrame.angular_std_dev)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Vector3F*>(
      &::ndm_proto::_Vector3F_default_instance_);
}
inline ::ndm_proto::Vector3F* GNSSFrame::release_angular_std_dev() {
  // @@protoc_insertion_point(field_release:ndm_proto.GNSSFrame.angular_std_dev)
  clear_has_angular_std_dev();
  ::ndm_proto::Vector3F* temp = angular_std_dev_;
  angular_std_dev_ = NULL;
  return temp;
}
inline ::ndm_proto::Vector3F* GNSSFrame::mutable_angular_std_dev() {
  set_has_angular_std_dev();
  if (angular_std_dev_ == NULL) {
    angular_std_dev_ = new ::ndm_proto::Vector3F;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.GNSSFrame.angular_std_dev)
  return angular_std_dev_;
}
inline void GNSSFrame::set_allocated_angular_std_dev(::ndm_proto::Vector3F* angular_std_dev) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete angular_std_dev_;
  }
  if (angular_std_dev) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      angular_std_dev = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, angular_std_dev, submessage_arena);
    }
    set_has_angular_std_dev();
  } else {
    clear_has_angular_std_dev();
  }
  angular_std_dev_ = angular_std_dev;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.GNSSFrame.angular_std_dev)
}

// optional int32 num_sates = 11;
inline bool GNSSFrame::has_num_sates() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void GNSSFrame::set_has_num_sates() {
  _has_bits_[0] |= 0x00100000u;
}
inline void GNSSFrame::clear_has_num_sates() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void GNSSFrame::clear_num_sates() {
  num_sates_ = 0;
  clear_has_num_sates();
}
inline ::google::protobuf::int32 GNSSFrame::num_sates() const {
  // @@protoc_insertion_point(field_get:ndm_proto.GNSSFrame.num_sates)
  return num_sates_;
}
inline void GNSSFrame::set_num_sates(::google::protobuf::int32 value) {
  set_has_num_sates();
  num_sates_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.GNSSFrame.num_sates)
}

// optional string solve_status = 12;
inline bool GNSSFrame::has_solve_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GNSSFrame::set_has_solve_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GNSSFrame::clear_has_solve_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GNSSFrame::clear_solve_status() {
  solve_status_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_solve_status();
}
inline const ::std::string& GNSSFrame::solve_status() const {
  // @@protoc_insertion_point(field_get:ndm_proto.GNSSFrame.solve_status)
  return solve_status_.GetNoArena();
}
inline void GNSSFrame::set_solve_status(const ::std::string& value) {
  set_has_solve_status();
  solve_status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ndm_proto.GNSSFrame.solve_status)
}
#if LANG_CXX11
inline void GNSSFrame::set_solve_status(::std::string&& value) {
  set_has_solve_status();
  solve_status_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ndm_proto.GNSSFrame.solve_status)
}
#endif
inline void GNSSFrame::set_solve_status(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_solve_status();
  solve_status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ndm_proto.GNSSFrame.solve_status)
}
inline void GNSSFrame::set_solve_status(const char* value, size_t size) {
  set_has_solve_status();
  solve_status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.GNSSFrame.solve_status)
}
inline ::std::string* GNSSFrame::mutable_solve_status() {
  set_has_solve_status();
  // @@protoc_insertion_point(field_mutable:ndm_proto.GNSSFrame.solve_status)
  return solve_status_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GNSSFrame::release_solve_status() {
  // @@protoc_insertion_point(field_release:ndm_proto.GNSSFrame.solve_status)
  clear_has_solve_status();
  return solve_status_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GNSSFrame::set_allocated_solve_status(::std::string* solve_status) {
  if (solve_status != NULL) {
    set_has_solve_status();
  } else {
    clear_has_solve_status();
  }
  solve_status_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), solve_status);
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.GNSSFrame.solve_status)
}

// optional string ins_status = 13;
inline bool GNSSFrame::has_ins_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GNSSFrame::set_has_ins_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GNSSFrame::clear_has_ins_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GNSSFrame::clear_ins_status() {
  ins_status_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ins_status();
}
inline const ::std::string& GNSSFrame::ins_status() const {
  // @@protoc_insertion_point(field_get:ndm_proto.GNSSFrame.ins_status)
  return ins_status_.GetNoArena();
}
inline void GNSSFrame::set_ins_status(const ::std::string& value) {
  set_has_ins_status();
  ins_status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ndm_proto.GNSSFrame.ins_status)
}
#if LANG_CXX11
inline void GNSSFrame::set_ins_status(::std::string&& value) {
  set_has_ins_status();
  ins_status_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ndm_proto.GNSSFrame.ins_status)
}
#endif
inline void GNSSFrame::set_ins_status(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ins_status();
  ins_status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ndm_proto.GNSSFrame.ins_status)
}
inline void GNSSFrame::set_ins_status(const char* value, size_t size) {
  set_has_ins_status();
  ins_status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.GNSSFrame.ins_status)
}
inline ::std::string* GNSSFrame::mutable_ins_status() {
  set_has_ins_status();
  // @@protoc_insertion_point(field_mutable:ndm_proto.GNSSFrame.ins_status)
  return ins_status_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GNSSFrame::release_ins_status() {
  // @@protoc_insertion_point(field_release:ndm_proto.GNSSFrame.ins_status)
  clear_has_ins_status();
  return ins_status_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GNSSFrame::set_allocated_ins_status(::std::string* ins_status) {
  if (ins_status != NULL) {
    set_has_ins_status();
  } else {
    clear_has_ins_status();
  }
  ins_status_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ins_status);
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.GNSSFrame.ins_status)
}

// optional double speed = 14;
inline bool GNSSFrame::has_speed() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void GNSSFrame::set_has_speed() {
  _has_bits_[0] |= 0x00400000u;
}
inline void GNSSFrame::clear_has_speed() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void GNSSFrame::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
inline double GNSSFrame::speed() const {
  // @@protoc_insertion_point(field_get:ndm_proto.GNSSFrame.speed)
  return speed_;
}
inline void GNSSFrame::set_speed(double value) {
  set_has_speed();
  speed_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.GNSSFrame.speed)
}

// optional int32 mode = 15;
inline bool GNSSFrame::has_mode() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void GNSSFrame::set_has_mode() {
  _has_bits_[0] |= 0x00200000u;
}
inline void GNSSFrame::clear_has_mode() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void GNSSFrame::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::google::protobuf::int32 GNSSFrame::mode() const {
  // @@protoc_insertion_point(field_get:ndm_proto.GNSSFrame.mode)
  return mode_;
}
inline void GNSSFrame::set_mode(::google::protobuf::int32 value) {
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.GNSSFrame.mode)
}

// optional double height_of_ellipse = 16;
inline bool GNSSFrame::has_height_of_ellipse() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void GNSSFrame::set_has_height_of_ellipse() {
  _has_bits_[0] |= 0x00800000u;
}
inline void GNSSFrame::clear_has_height_of_ellipse() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void GNSSFrame::clear_height_of_ellipse() {
  height_of_ellipse_ = 0;
  clear_has_height_of_ellipse();
}
inline double GNSSFrame::height_of_ellipse() const {
  // @@protoc_insertion_point(field_get:ndm_proto.GNSSFrame.height_of_ellipse)
  return height_of_ellipse_;
}
inline void GNSSFrame::set_height_of_ellipse(double value) {
  set_has_height_of_ellipse();
  height_of_ellipse_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.GNSSFrame.height_of_ellipse)
}

// optional int32 gps_fix_info = 17;
inline bool GNSSFrame::has_gps_fix_info() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void GNSSFrame::set_has_gps_fix_info() {
  _has_bits_[0] |= 0x01000000u;
}
inline void GNSSFrame::clear_has_gps_fix_info() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void GNSSFrame::clear_gps_fix_info() {
  gps_fix_info_ = 0;
  clear_has_gps_fix_info();
}
inline ::google::protobuf::int32 GNSSFrame::gps_fix_info() const {
  // @@protoc_insertion_point(field_get:ndm_proto.GNSSFrame.gps_fix_info)
  return gps_fix_info_;
}
inline void GNSSFrame::set_gps_fix_info(::google::protobuf::int32 value) {
  set_has_gps_fix_info();
  gps_fix_info_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.GNSSFrame.gps_fix_info)
}

// optional .ndm_proto.GNSSStatus pos_status = 18;
inline bool GNSSFrame::has_pos_status() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void GNSSFrame::set_has_pos_status() {
  _has_bits_[0] |= 0x00000800u;
}
inline void GNSSFrame::clear_has_pos_status() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void GNSSFrame::clear_pos_status() {
  if (pos_status_ != NULL) pos_status_->Clear();
  clear_has_pos_status();
}
inline const ::ndm_proto::GNSSStatus& GNSSFrame::pos_status() const {
  const ::ndm_proto::GNSSStatus* p = pos_status_;
  // @@protoc_insertion_point(field_get:ndm_proto.GNSSFrame.pos_status)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::GNSSStatus*>(
      &::ndm_proto::_GNSSStatus_default_instance_);
}
inline ::ndm_proto::GNSSStatus* GNSSFrame::release_pos_status() {
  // @@protoc_insertion_point(field_release:ndm_proto.GNSSFrame.pos_status)
  clear_has_pos_status();
  ::ndm_proto::GNSSStatus* temp = pos_status_;
  pos_status_ = NULL;
  return temp;
}
inline ::ndm_proto::GNSSStatus* GNSSFrame::mutable_pos_status() {
  set_has_pos_status();
  if (pos_status_ == NULL) {
    pos_status_ = new ::ndm_proto::GNSSStatus;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.GNSSFrame.pos_status)
  return pos_status_;
}
inline void GNSSFrame::set_allocated_pos_status(::ndm_proto::GNSSStatus* pos_status) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete pos_status_;
  }
  if (pos_status) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pos_status = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pos_status, submessage_arena);
    }
    set_has_pos_status();
  } else {
    clear_has_pos_status();
  }
  pos_status_ = pos_status;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.GNSSFrame.pos_status)
}

// optional .ndm_proto.GNSSStatus vel_status = 19;
inline bool GNSSFrame::has_vel_status() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void GNSSFrame::set_has_vel_status() {
  _has_bits_[0] |= 0x00001000u;
}
inline void GNSSFrame::clear_has_vel_status() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void GNSSFrame::clear_vel_status() {
  if (vel_status_ != NULL) vel_status_->Clear();
  clear_has_vel_status();
}
inline const ::ndm_proto::GNSSStatus& GNSSFrame::vel_status() const {
  const ::ndm_proto::GNSSStatus* p = vel_status_;
  // @@protoc_insertion_point(field_get:ndm_proto.GNSSFrame.vel_status)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::GNSSStatus*>(
      &::ndm_proto::_GNSSStatus_default_instance_);
}
inline ::ndm_proto::GNSSStatus* GNSSFrame::release_vel_status() {
  // @@protoc_insertion_point(field_release:ndm_proto.GNSSFrame.vel_status)
  clear_has_vel_status();
  ::ndm_proto::GNSSStatus* temp = vel_status_;
  vel_status_ = NULL;
  return temp;
}
inline ::ndm_proto::GNSSStatus* GNSSFrame::mutable_vel_status() {
  set_has_vel_status();
  if (vel_status_ == NULL) {
    vel_status_ = new ::ndm_proto::GNSSStatus;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.GNSSFrame.vel_status)
  return vel_status_;
}
inline void GNSSFrame::set_allocated_vel_status(::ndm_proto::GNSSStatus* vel_status) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete vel_status_;
  }
  if (vel_status) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      vel_status = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, vel_status, submessage_arena);
    }
    set_has_vel_status();
  } else {
    clear_has_vel_status();
  }
  vel_status_ = vel_status;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.GNSSFrame.vel_status)
}

// optional .ndm_proto.GNSSStatus head_status = 20;
inline bool GNSSFrame::has_head_status() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void GNSSFrame::set_has_head_status() {
  _has_bits_[0] |= 0x00002000u;
}
inline void GNSSFrame::clear_has_head_status() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void GNSSFrame::clear_head_status() {
  if (head_status_ != NULL) head_status_->Clear();
  clear_has_head_status();
}
inline const ::ndm_proto::GNSSStatus& GNSSFrame::head_status() const {
  const ::ndm_proto::GNSSStatus* p = head_status_;
  // @@protoc_insertion_point(field_get:ndm_proto.GNSSFrame.head_status)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::GNSSStatus*>(
      &::ndm_proto::_GNSSStatus_default_instance_);
}
inline ::ndm_proto::GNSSStatus* GNSSFrame::release_head_status() {
  // @@protoc_insertion_point(field_release:ndm_proto.GNSSFrame.head_status)
  clear_has_head_status();
  ::ndm_proto::GNSSStatus* temp = head_status_;
  head_status_ = NULL;
  return temp;
}
inline ::ndm_proto::GNSSStatus* GNSSFrame::mutable_head_status() {
  set_has_head_status();
  if (head_status_ == NULL) {
    head_status_ = new ::ndm_proto::GNSSStatus;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.GNSSFrame.head_status)
  return head_status_;
}
inline void GNSSFrame::set_allocated_head_status(::ndm_proto::GNSSStatus* head_status) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete head_status_;
  }
  if (head_status) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      head_status = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, head_status, submessage_arena);
    }
    set_has_head_status();
  } else {
    clear_has_head_status();
  }
  head_status_ = head_status;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.GNSSFrame.head_status)
}

// optional .ndm_proto.Vector4D orientation = 21;
inline bool GNSSFrame::has_orientation() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void GNSSFrame::set_has_orientation() {
  _has_bits_[0] |= 0x00004000u;
}
inline void GNSSFrame::clear_has_orientation() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void GNSSFrame::clear_orientation() {
  if (orientation_ != NULL) orientation_->Clear();
  clear_has_orientation();
}
inline const ::ndm_proto::Vector4D& GNSSFrame::orientation() const {
  const ::ndm_proto::Vector4D* p = orientation_;
  // @@protoc_insertion_point(field_get:ndm_proto.GNSSFrame.orientation)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Vector4D*>(
      &::ndm_proto::_Vector4D_default_instance_);
}
inline ::ndm_proto::Vector4D* GNSSFrame::release_orientation() {
  // @@protoc_insertion_point(field_release:ndm_proto.GNSSFrame.orientation)
  clear_has_orientation();
  ::ndm_proto::Vector4D* temp = orientation_;
  orientation_ = NULL;
  return temp;
}
inline ::ndm_proto::Vector4D* GNSSFrame::mutable_orientation() {
  set_has_orientation();
  if (orientation_ == NULL) {
    orientation_ = new ::ndm_proto::Vector4D;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.GNSSFrame.orientation)
  return orientation_;
}
inline void GNSSFrame::set_allocated_orientation(::ndm_proto::Vector4D* orientation) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete orientation_;
  }
  if (orientation) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      orientation = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, orientation, submessage_arena);
    }
    set_has_orientation();
  } else {
    clear_has_orientation();
  }
  orientation_ = orientation;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.GNSSFrame.orientation)
}

// repeated double pose_covariance = 22;
inline int GNSSFrame::pose_covariance_size() const {
  return pose_covariance_.size();
}
inline void GNSSFrame::clear_pose_covariance() {
  pose_covariance_.Clear();
}
inline double GNSSFrame::pose_covariance(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.GNSSFrame.pose_covariance)
  return pose_covariance_.Get(index);
}
inline void GNSSFrame::set_pose_covariance(int index, double value) {
  pose_covariance_.Set(index, value);
  // @@protoc_insertion_point(field_set:ndm_proto.GNSSFrame.pose_covariance)
}
inline void GNSSFrame::add_pose_covariance(double value) {
  pose_covariance_.Add(value);
  // @@protoc_insertion_point(field_add:ndm_proto.GNSSFrame.pose_covariance)
}
inline const ::google::protobuf::RepeatedField< double >&
GNSSFrame::pose_covariance() const {
  // @@protoc_insertion_point(field_list:ndm_proto.GNSSFrame.pose_covariance)
  return pose_covariance_;
}
inline ::google::protobuf::RepeatedField< double >*
GNSSFrame::mutable_pose_covariance() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.GNSSFrame.pose_covariance)
  return &pose_covariance_;
}

// repeated string nmea_sentence = 23;
inline int GNSSFrame::nmea_sentence_size() const {
  return nmea_sentence_.size();
}
inline void GNSSFrame::clear_nmea_sentence() {
  nmea_sentence_.Clear();
}
inline const ::std::string& GNSSFrame::nmea_sentence(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.GNSSFrame.nmea_sentence)
  return nmea_sentence_.Get(index);
}
inline ::std::string* GNSSFrame::mutable_nmea_sentence(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.GNSSFrame.nmea_sentence)
  return nmea_sentence_.Mutable(index);
}
inline void GNSSFrame::set_nmea_sentence(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ndm_proto.GNSSFrame.nmea_sentence)
  nmea_sentence_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void GNSSFrame::set_nmea_sentence(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:ndm_proto.GNSSFrame.nmea_sentence)
  nmea_sentence_.Mutable(index)->assign(std::move(value));
}
#endif
inline void GNSSFrame::set_nmea_sentence(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  nmea_sentence_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ndm_proto.GNSSFrame.nmea_sentence)
}
inline void GNSSFrame::set_nmea_sentence(int index, const char* value, size_t size) {
  nmea_sentence_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.GNSSFrame.nmea_sentence)
}
inline ::std::string* GNSSFrame::add_nmea_sentence() {
  // @@protoc_insertion_point(field_add_mutable:ndm_proto.GNSSFrame.nmea_sentence)
  return nmea_sentence_.Add();
}
inline void GNSSFrame::add_nmea_sentence(const ::std::string& value) {
  nmea_sentence_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ndm_proto.GNSSFrame.nmea_sentence)
}
#if LANG_CXX11
inline void GNSSFrame::add_nmea_sentence(::std::string&& value) {
  nmea_sentence_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ndm_proto.GNSSFrame.nmea_sentence)
}
#endif
inline void GNSSFrame::add_nmea_sentence(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  nmea_sentence_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ndm_proto.GNSSFrame.nmea_sentence)
}
inline void GNSSFrame::add_nmea_sentence(const char* value, size_t size) {
  nmea_sentence_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ndm_proto.GNSSFrame.nmea_sentence)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GNSSFrame::nmea_sentence() const {
  // @@protoc_insertion_point(field_list:ndm_proto.GNSSFrame.nmea_sentence)
  return nmea_sentence_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GNSSFrame::mutable_nmea_sentence() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.GNSSFrame.nmea_sentence)
  return &nmea_sentence_;
}

// optional float pitch = 24;
inline bool GNSSFrame::has_pitch() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void GNSSFrame::set_has_pitch() {
  _has_bits_[0] |= 0x02000000u;
}
inline void GNSSFrame::clear_has_pitch() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void GNSSFrame::clear_pitch() {
  pitch_ = 0;
  clear_has_pitch();
}
inline float GNSSFrame::pitch() const {
  // @@protoc_insertion_point(field_get:ndm_proto.GNSSFrame.pitch)
  return pitch_;
}
inline void GNSSFrame::set_pitch(float value) {
  set_has_pitch();
  pitch_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.GNSSFrame.pitch)
}

// optional float yaw = 25;
inline bool GNSSFrame::has_yaw() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void GNSSFrame::set_has_yaw() {
  _has_bits_[0] |= 0x04000000u;
}
inline void GNSSFrame::clear_has_yaw() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void GNSSFrame::clear_yaw() {
  yaw_ = 0;
  clear_has_yaw();
}
inline float GNSSFrame::yaw() const {
  // @@protoc_insertion_point(field_get:ndm_proto.GNSSFrame.yaw)
  return yaw_;
}
inline void GNSSFrame::set_yaw(float value) {
  set_has_yaw();
  yaw_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.GNSSFrame.yaw)
}

// optional float roll = 26;
inline bool GNSSFrame::has_roll() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void GNSSFrame::set_has_roll() {
  _has_bits_[0] |= 0x08000000u;
}
inline void GNSSFrame::clear_has_roll() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void GNSSFrame::clear_roll() {
  roll_ = 0;
  clear_has_roll();
}
inline float GNSSFrame::roll() const {
  // @@protoc_insertion_point(field_get:ndm_proto.GNSSFrame.roll)
  return roll_;
}
inline void GNSSFrame::set_roll(float value) {
  set_has_roll();
  roll_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.GNSSFrame.roll)
}

// optional float x_offset = 27;
inline bool GNSSFrame::has_x_offset() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void GNSSFrame::set_has_x_offset() {
  _has_bits_[0] |= 0x10000000u;
}
inline void GNSSFrame::clear_has_x_offset() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void GNSSFrame::clear_x_offset() {
  x_offset_ = 0;
  clear_has_x_offset();
}
inline float GNSSFrame::x_offset() const {
  // @@protoc_insertion_point(field_get:ndm_proto.GNSSFrame.x_offset)
  return x_offset_;
}
inline void GNSSFrame::set_x_offset(float value) {
  set_has_x_offset();
  x_offset_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.GNSSFrame.x_offset)
}

// optional float y_offset = 28;
inline bool GNSSFrame::has_y_offset() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void GNSSFrame::set_has_y_offset() {
  _has_bits_[0] |= 0x20000000u;
}
inline void GNSSFrame::clear_has_y_offset() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void GNSSFrame::clear_y_offset() {
  y_offset_ = 0;
  clear_has_y_offset();
}
inline float GNSSFrame::y_offset() const {
  // @@protoc_insertion_point(field_get:ndm_proto.GNSSFrame.y_offset)
  return y_offset_;
}
inline void GNSSFrame::set_y_offset(float value) {
  set_has_y_offset();
  y_offset_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.GNSSFrame.y_offset)
}

// optional float z_offset = 29;
inline bool GNSSFrame::has_z_offset() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void GNSSFrame::set_has_z_offset() {
  _has_bits_[0] |= 0x40000000u;
}
inline void GNSSFrame::clear_has_z_offset() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void GNSSFrame::clear_z_offset() {
  z_offset_ = 0;
  clear_has_z_offset();
}
inline float GNSSFrame::z_offset() const {
  // @@protoc_insertion_point(field_get:ndm_proto.GNSSFrame.z_offset)
  return z_offset_;
}
inline void GNSSFrame::set_z_offset(float value) {
  set_has_z_offset();
  z_offset_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.GNSSFrame.z_offset)
}

// optional int32 zone_id = 30;
inline bool GNSSFrame::has_zone_id() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void GNSSFrame::set_has_zone_id() {
  _has_bits_[0] |= 0x80000000u;
}
inline void GNSSFrame::clear_has_zone_id() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void GNSSFrame::clear_zone_id() {
  zone_id_ = 0;
  clear_has_zone_id();
}
inline ::google::protobuf::int32 GNSSFrame::zone_id() const {
  // @@protoc_insertion_point(field_get:ndm_proto.GNSSFrame.zone_id)
  return zone_id_;
}
inline void GNSSFrame::set_zone_id(::google::protobuf::int32 value) {
  set_has_zone_id();
  zone_id_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.GNSSFrame.zone_id)
}

// optional .ndm_proto.Vector3D position_gps = 31;
inline bool GNSSFrame::has_position_gps() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void GNSSFrame::set_has_position_gps() {
  _has_bits_[0] |= 0x00008000u;
}
inline void GNSSFrame::clear_has_position_gps() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void GNSSFrame::clear_position_gps() {
  if (position_gps_ != NULL) position_gps_->Clear();
  clear_has_position_gps();
}
inline const ::ndm_proto::Vector3D& GNSSFrame::position_gps() const {
  const ::ndm_proto::Vector3D* p = position_gps_;
  // @@protoc_insertion_point(field_get:ndm_proto.GNSSFrame.position_gps)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Vector3D*>(
      &::ndm_proto::_Vector3D_default_instance_);
}
inline ::ndm_proto::Vector3D* GNSSFrame::release_position_gps() {
  // @@protoc_insertion_point(field_release:ndm_proto.GNSSFrame.position_gps)
  clear_has_position_gps();
  ::ndm_proto::Vector3D* temp = position_gps_;
  position_gps_ = NULL;
  return temp;
}
inline ::ndm_proto::Vector3D* GNSSFrame::mutable_position_gps() {
  set_has_position_gps();
  if (position_gps_ == NULL) {
    position_gps_ = new ::ndm_proto::Vector3D;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.GNSSFrame.position_gps)
  return position_gps_;
}
inline void GNSSFrame::set_allocated_position_gps(::ndm_proto::Vector3D* position_gps) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete position_gps_;
  }
  if (position_gps) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      position_gps = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, position_gps, submessage_arena);
    }
    set_has_position_gps();
  } else {
    clear_has_position_gps();
  }
  position_gps_ = position_gps;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.GNSSFrame.position_gps)
}

// optional .ndm_proto.Vector3D acc = 32;
inline bool GNSSFrame::has_acc() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void GNSSFrame::set_has_acc() {
  _has_bits_[0] |= 0x00010000u;
}
inline void GNSSFrame::clear_has_acc() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void GNSSFrame::clear_acc() {
  if (acc_ != NULL) acc_->Clear();
  clear_has_acc();
}
inline const ::ndm_proto::Vector3D& GNSSFrame::acc() const {
  const ::ndm_proto::Vector3D* p = acc_;
  // @@protoc_insertion_point(field_get:ndm_proto.GNSSFrame.acc)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Vector3D*>(
      &::ndm_proto::_Vector3D_default_instance_);
}
inline ::ndm_proto::Vector3D* GNSSFrame::release_acc() {
  // @@protoc_insertion_point(field_release:ndm_proto.GNSSFrame.acc)
  clear_has_acc();
  ::ndm_proto::Vector3D* temp = acc_;
  acc_ = NULL;
  return temp;
}
inline ::ndm_proto::Vector3D* GNSSFrame::mutable_acc() {
  set_has_acc();
  if (acc_ == NULL) {
    acc_ = new ::ndm_proto::Vector3D;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.GNSSFrame.acc)
  return acc_;
}
inline void GNSSFrame::set_allocated_acc(::ndm_proto::Vector3D* acc) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete acc_;
  }
  if (acc) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      acc = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, acc, submessage_arena);
    }
    set_has_acc();
  } else {
    clear_has_acc();
  }
  acc_ = acc;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.GNSSFrame.acc)
}

// optional .ndm_proto.Vector3D accgyo = 33;
inline bool GNSSFrame::has_accgyo() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void GNSSFrame::set_has_accgyo() {
  _has_bits_[0] |= 0x00020000u;
}
inline void GNSSFrame::clear_has_accgyo() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void GNSSFrame::clear_accgyo() {
  if (accgyo_ != NULL) accgyo_->Clear();
  clear_has_accgyo();
}
inline const ::ndm_proto::Vector3D& GNSSFrame::accgyo() const {
  const ::ndm_proto::Vector3D* p = accgyo_;
  // @@protoc_insertion_point(field_get:ndm_proto.GNSSFrame.accgyo)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Vector3D*>(
      &::ndm_proto::_Vector3D_default_instance_);
}
inline ::ndm_proto::Vector3D* GNSSFrame::release_accgyo() {
  // @@protoc_insertion_point(field_release:ndm_proto.GNSSFrame.accgyo)
  clear_has_accgyo();
  ::ndm_proto::Vector3D* temp = accgyo_;
  accgyo_ = NULL;
  return temp;
}
inline ::ndm_proto::Vector3D* GNSSFrame::mutable_accgyo() {
  set_has_accgyo();
  if (accgyo_ == NULL) {
    accgyo_ = new ::ndm_proto::Vector3D;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.GNSSFrame.accgyo)
  return accgyo_;
}
inline void GNSSFrame::set_allocated_accgyo(::ndm_proto::Vector3D* accgyo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete accgyo_;
  }
  if (accgyo) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      accgyo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, accgyo, submessage_arena);
    }
    set_has_accgyo();
  } else {
    clear_has_accgyo();
  }
  accgyo_ = accgyo;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.GNSSFrame.accgyo)
}

// optional int32 channel_id = 34;
inline bool GNSSFrame::has_channel_id() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void GNSSFrame::set_has_channel_id() {
  _has_bits_[1] |= 0x00000001u;
}
inline void GNSSFrame::clear_has_channel_id() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void GNSSFrame::clear_channel_id() {
  channel_id_ = 0;
  clear_has_channel_id();
}
inline ::google::protobuf::int32 GNSSFrame::channel_id() const {
  // @@protoc_insertion_point(field_get:ndm_proto.GNSSFrame.channel_id)
  return channel_id_;
}
inline void GNSSFrame::set_channel_id(::google::protobuf::int32 value) {
  set_has_channel_id();
  channel_id_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.GNSSFrame.channel_id)
}

// optional string desc = 35;
inline bool GNSSFrame::has_desc() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GNSSFrame::set_has_desc() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GNSSFrame::clear_has_desc() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GNSSFrame::clear_desc() {
  desc_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_desc();
}
inline const ::std::string& GNSSFrame::desc() const {
  // @@protoc_insertion_point(field_get:ndm_proto.GNSSFrame.desc)
  return desc_.GetNoArena();
}
inline void GNSSFrame::set_desc(const ::std::string& value) {
  set_has_desc();
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ndm_proto.GNSSFrame.desc)
}
#if LANG_CXX11
inline void GNSSFrame::set_desc(::std::string&& value) {
  set_has_desc();
  desc_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ndm_proto.GNSSFrame.desc)
}
#endif
inline void GNSSFrame::set_desc(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_desc();
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ndm_proto.GNSSFrame.desc)
}
inline void GNSSFrame::set_desc(const char* value, size_t size) {
  set_has_desc();
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.GNSSFrame.desc)
}
inline ::std::string* GNSSFrame::mutable_desc() {
  set_has_desc();
  // @@protoc_insertion_point(field_mutable:ndm_proto.GNSSFrame.desc)
  return desc_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GNSSFrame::release_desc() {
  // @@protoc_insertion_point(field_release:ndm_proto.GNSSFrame.desc)
  clear_has_desc();
  return desc_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GNSSFrame::set_allocated_desc(::std::string* desc) {
  if (desc != NULL) {
    set_has_desc();
  } else {
    clear_has_desc();
  }
  desc_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), desc);
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.GNSSFrame.desc)
}

// -------------------------------------------------------------------

// IMUFrame

// required .ndm_proto.Header header = 1;
inline bool IMUFrame::has_header() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMUFrame::set_has_header() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMUFrame::clear_has_header() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMUFrame::clear_header() {
  if (header_ != NULL) header_->Clear();
  clear_has_header();
}
inline const ::ndm_proto::Header& IMUFrame::header() const {
  const ::ndm_proto::Header* p = header_;
  // @@protoc_insertion_point(field_get:ndm_proto.IMUFrame.header)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Header*>(
      &::ndm_proto::_Header_default_instance_);
}
inline ::ndm_proto::Header* IMUFrame::release_header() {
  // @@protoc_insertion_point(field_release:ndm_proto.IMUFrame.header)
  clear_has_header();
  ::ndm_proto::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::ndm_proto::Header* IMUFrame::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::ndm_proto::Header;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.IMUFrame.header)
  return header_;
}
inline void IMUFrame::set_allocated_header(::ndm_proto::Header* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    set_has_header();
  } else {
    clear_has_header();
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.IMUFrame.header)
}

// optional .ndm_proto.Vector3F acc = 2;
inline bool IMUFrame::has_acc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMUFrame::set_has_acc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMUFrame::clear_has_acc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMUFrame::clear_acc() {
  if (acc_ != NULL) acc_->Clear();
  clear_has_acc();
}
inline const ::ndm_proto::Vector3F& IMUFrame::acc() const {
  const ::ndm_proto::Vector3F* p = acc_;
  // @@protoc_insertion_point(field_get:ndm_proto.IMUFrame.acc)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Vector3F*>(
      &::ndm_proto::_Vector3F_default_instance_);
}
inline ::ndm_proto::Vector3F* IMUFrame::release_acc() {
  // @@protoc_insertion_point(field_release:ndm_proto.IMUFrame.acc)
  clear_has_acc();
  ::ndm_proto::Vector3F* temp = acc_;
  acc_ = NULL;
  return temp;
}
inline ::ndm_proto::Vector3F* IMUFrame::mutable_acc() {
  set_has_acc();
  if (acc_ == NULL) {
    acc_ = new ::ndm_proto::Vector3F;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.IMUFrame.acc)
  return acc_;
}
inline void IMUFrame::set_allocated_acc(::ndm_proto::Vector3F* acc) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete acc_;
  }
  if (acc) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      acc = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, acc, submessage_arena);
    }
    set_has_acc();
  } else {
    clear_has_acc();
  }
  acc_ = acc;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.IMUFrame.acc)
}

// optional .ndm_proto.Vector3F gyro = 3;
inline bool IMUFrame::has_gyro() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMUFrame::set_has_gyro() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMUFrame::clear_has_gyro() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMUFrame::clear_gyro() {
  if (gyro_ != NULL) gyro_->Clear();
  clear_has_gyro();
}
inline const ::ndm_proto::Vector3F& IMUFrame::gyro() const {
  const ::ndm_proto::Vector3F* p = gyro_;
  // @@protoc_insertion_point(field_get:ndm_proto.IMUFrame.gyro)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Vector3F*>(
      &::ndm_proto::_Vector3F_default_instance_);
}
inline ::ndm_proto::Vector3F* IMUFrame::release_gyro() {
  // @@protoc_insertion_point(field_release:ndm_proto.IMUFrame.gyro)
  clear_has_gyro();
  ::ndm_proto::Vector3F* temp = gyro_;
  gyro_ = NULL;
  return temp;
}
inline ::ndm_proto::Vector3F* IMUFrame::mutable_gyro() {
  set_has_gyro();
  if (gyro_ == NULL) {
    gyro_ = new ::ndm_proto::Vector3F;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.IMUFrame.gyro)
  return gyro_;
}
inline void IMUFrame::set_allocated_gyro(::ndm_proto::Vector3F* gyro) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete gyro_;
  }
  if (gyro) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      gyro = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, gyro, submessage_arena);
    }
    set_has_gyro();
  } else {
    clear_has_gyro();
  }
  gyro_ = gyro;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.IMUFrame.gyro)
}

// optional bytes raw_data = 4;
inline bool IMUFrame::has_raw_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMUFrame::set_has_raw_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMUFrame::clear_has_raw_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMUFrame::clear_raw_data() {
  raw_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_raw_data();
}
inline const ::std::string& IMUFrame::raw_data() const {
  // @@protoc_insertion_point(field_get:ndm_proto.IMUFrame.raw_data)
  return raw_data_.GetNoArena();
}
inline void IMUFrame::set_raw_data(const ::std::string& value) {
  set_has_raw_data();
  raw_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ndm_proto.IMUFrame.raw_data)
}
#if LANG_CXX11
inline void IMUFrame::set_raw_data(::std::string&& value) {
  set_has_raw_data();
  raw_data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ndm_proto.IMUFrame.raw_data)
}
#endif
inline void IMUFrame::set_raw_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_raw_data();
  raw_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ndm_proto.IMUFrame.raw_data)
}
inline void IMUFrame::set_raw_data(const void* value, size_t size) {
  set_has_raw_data();
  raw_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.IMUFrame.raw_data)
}
inline ::std::string* IMUFrame::mutable_raw_data() {
  set_has_raw_data();
  // @@protoc_insertion_point(field_mutable:ndm_proto.IMUFrame.raw_data)
  return raw_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IMUFrame::release_raw_data() {
  // @@protoc_insertion_point(field_release:ndm_proto.IMUFrame.raw_data)
  clear_has_raw_data();
  return raw_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMUFrame::set_allocated_raw_data(::std::string* raw_data) {
  if (raw_data != NULL) {
    set_has_raw_data();
  } else {
    clear_has_raw_data();
  }
  raw_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), raw_data);
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.IMUFrame.raw_data)
}

// optional int64 sensor_stamp = 5;
inline bool IMUFrame::has_sensor_stamp() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void IMUFrame::set_has_sensor_stamp() {
  _has_bits_[0] |= 0x00000400u;
}
inline void IMUFrame::clear_has_sensor_stamp() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void IMUFrame::clear_sensor_stamp() {
  sensor_stamp_ = GOOGLE_LONGLONG(0);
  clear_has_sensor_stamp();
}
inline ::google::protobuf::int64 IMUFrame::sensor_stamp() const {
  // @@protoc_insertion_point(field_get:ndm_proto.IMUFrame.sensor_stamp)
  return sensor_stamp_;
}
inline void IMUFrame::set_sensor_stamp(::google::protobuf::int64 value) {
  set_has_sensor_stamp();
  sensor_stamp_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.IMUFrame.sensor_stamp)
}

// optional int64 sample_stamp = 6;
inline bool IMUFrame::has_sample_stamp() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void IMUFrame::set_has_sample_stamp() {
  _has_bits_[0] |= 0x00000800u;
}
inline void IMUFrame::clear_has_sample_stamp() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void IMUFrame::clear_sample_stamp() {
  sample_stamp_ = GOOGLE_LONGLONG(0);
  clear_has_sample_stamp();
}
inline ::google::protobuf::int64 IMUFrame::sample_stamp() const {
  // @@protoc_insertion_point(field_get:ndm_proto.IMUFrame.sample_stamp)
  return sample_stamp_;
}
inline void IMUFrame::set_sample_stamp(::google::protobuf::int64 value) {
  set_has_sample_stamp();
  sample_stamp_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.IMUFrame.sample_stamp)
}

// optional float temperature = 7;
inline bool IMUFrame::has_temperature() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void IMUFrame::set_has_temperature() {
  _has_bits_[0] |= 0x00001000u;
}
inline void IMUFrame::clear_has_temperature() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void IMUFrame::clear_temperature() {
  temperature_ = 0;
  clear_has_temperature();
}
inline float IMUFrame::temperature() const {
  // @@protoc_insertion_point(field_get:ndm_proto.IMUFrame.temperature)
  return temperature_;
}
inline void IMUFrame::set_temperature(float value) {
  set_has_temperature();
  temperature_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.IMUFrame.temperature)
}

// optional int32 packet_counter = 8;
inline bool IMUFrame::has_packet_counter() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void IMUFrame::set_has_packet_counter() {
  _has_bits_[0] |= 0x00002000u;
}
inline void IMUFrame::clear_has_packet_counter() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void IMUFrame::clear_packet_counter() {
  packet_counter_ = 0;
  clear_has_packet_counter();
}
inline ::google::protobuf::int32 IMUFrame::packet_counter() const {
  // @@protoc_insertion_point(field_get:ndm_proto.IMUFrame.packet_counter)
  return packet_counter_;
}
inline void IMUFrame::set_packet_counter(::google::protobuf::int32 value) {
  set_has_packet_counter();
  packet_counter_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.IMUFrame.packet_counter)
}

// optional int32 sample_time_fine = 9;
inline bool IMUFrame::has_sample_time_fine() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void IMUFrame::set_has_sample_time_fine() {
  _has_bits_[0] |= 0x00004000u;
}
inline void IMUFrame::clear_has_sample_time_fine() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void IMUFrame::clear_sample_time_fine() {
  sample_time_fine_ = 0;
  clear_has_sample_time_fine();
}
inline ::google::protobuf::int32 IMUFrame::sample_time_fine() const {
  // @@protoc_insertion_point(field_get:ndm_proto.IMUFrame.sample_time_fine)
  return sample_time_fine_;
}
inline void IMUFrame::set_sample_time_fine(::google::protobuf::int32 value) {
  set_has_sample_time_fine();
  sample_time_fine_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.IMUFrame.sample_time_fine)
}

// optional int32 sample_time_coarse = 10;
inline bool IMUFrame::has_sample_time_coarse() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void IMUFrame::set_has_sample_time_coarse() {
  _has_bits_[0] |= 0x00008000u;
}
inline void IMUFrame::clear_has_sample_time_coarse() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void IMUFrame::clear_sample_time_coarse() {
  sample_time_coarse_ = 0;
  clear_has_sample_time_coarse();
}
inline ::google::protobuf::int32 IMUFrame::sample_time_coarse() const {
  // @@protoc_insertion_point(field_get:ndm_proto.IMUFrame.sample_time_coarse)
  return sample_time_coarse_;
}
inline void IMUFrame::set_sample_time_coarse(::google::protobuf::int32 value) {
  set_has_sample_time_coarse();
  sample_time_coarse_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.IMUFrame.sample_time_coarse)
}

// optional .ndm_proto.Quaternion quaterntion = 11;
inline bool IMUFrame::has_quaterntion() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IMUFrame::set_has_quaterntion() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IMUFrame::clear_has_quaterntion() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IMUFrame::clear_quaterntion() {
  if (quaterntion_ != NULL) quaterntion_->Clear();
  clear_has_quaterntion();
}
inline const ::ndm_proto::Quaternion& IMUFrame::quaterntion() const {
  const ::ndm_proto::Quaternion* p = quaterntion_;
  // @@protoc_insertion_point(field_get:ndm_proto.IMUFrame.quaterntion)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Quaternion*>(
      &::ndm_proto::_Quaternion_default_instance_);
}
inline ::ndm_proto::Quaternion* IMUFrame::release_quaterntion() {
  // @@protoc_insertion_point(field_release:ndm_proto.IMUFrame.quaterntion)
  clear_has_quaterntion();
  ::ndm_proto::Quaternion* temp = quaterntion_;
  quaterntion_ = NULL;
  return temp;
}
inline ::ndm_proto::Quaternion* IMUFrame::mutable_quaterntion() {
  set_has_quaterntion();
  if (quaterntion_ == NULL) {
    quaterntion_ = new ::ndm_proto::Quaternion;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.IMUFrame.quaterntion)
  return quaterntion_;
}
inline void IMUFrame::set_allocated_quaterntion(::ndm_proto::Quaternion* quaterntion) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete quaterntion_;
  }
  if (quaterntion) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      quaterntion = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, quaterntion, submessage_arena);
    }
    set_has_quaterntion();
  } else {
    clear_has_quaterntion();
  }
  quaterntion_ = quaterntion;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.IMUFrame.quaterntion)
}

// optional int32 baro_pressure = 12;
inline bool IMUFrame::has_baro_pressure() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void IMUFrame::set_has_baro_pressure() {
  _has_bits_[0] |= 0x00010000u;
}
inline void IMUFrame::clear_has_baro_pressure() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void IMUFrame::clear_baro_pressure() {
  baro_pressure_ = 0;
  clear_has_baro_pressure();
}
inline ::google::protobuf::int32 IMUFrame::baro_pressure() const {
  // @@protoc_insertion_point(field_get:ndm_proto.IMUFrame.baro_pressure)
  return baro_pressure_;
}
inline void IMUFrame::set_baro_pressure(::google::protobuf::int32 value) {
  set_has_baro_pressure();
  baro_pressure_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.IMUFrame.baro_pressure)
}

// optional .ndm_proto.Vector3F delta_v = 13;
inline bool IMUFrame::has_delta_v() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void IMUFrame::set_has_delta_v() {
  _has_bits_[0] |= 0x00000020u;
}
inline void IMUFrame::clear_has_delta_v() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void IMUFrame::clear_delta_v() {
  if (delta_v_ != NULL) delta_v_->Clear();
  clear_has_delta_v();
}
inline const ::ndm_proto::Vector3F& IMUFrame::delta_v() const {
  const ::ndm_proto::Vector3F* p = delta_v_;
  // @@protoc_insertion_point(field_get:ndm_proto.IMUFrame.delta_v)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Vector3F*>(
      &::ndm_proto::_Vector3F_default_instance_);
}
inline ::ndm_proto::Vector3F* IMUFrame::release_delta_v() {
  // @@protoc_insertion_point(field_release:ndm_proto.IMUFrame.delta_v)
  clear_has_delta_v();
  ::ndm_proto::Vector3F* temp = delta_v_;
  delta_v_ = NULL;
  return temp;
}
inline ::ndm_proto::Vector3F* IMUFrame::mutable_delta_v() {
  set_has_delta_v();
  if (delta_v_ == NULL) {
    delta_v_ = new ::ndm_proto::Vector3F;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.IMUFrame.delta_v)
  return delta_v_;
}
inline void IMUFrame::set_allocated_delta_v(::ndm_proto::Vector3F* delta_v) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete delta_v_;
  }
  if (delta_v) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      delta_v = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, delta_v, submessage_arena);
    }
    set_has_delta_v();
  } else {
    clear_has_delta_v();
  }
  delta_v_ = delta_v;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.IMUFrame.delta_v)
}

// optional .ndm_proto.Vector4F delta_q = 14;
inline bool IMUFrame::has_delta_q() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void IMUFrame::set_has_delta_q() {
  _has_bits_[0] |= 0x00000040u;
}
inline void IMUFrame::clear_has_delta_q() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void IMUFrame::clear_delta_q() {
  if (delta_q_ != NULL) delta_q_->Clear();
  clear_has_delta_q();
}
inline const ::ndm_proto::Vector4F& IMUFrame::delta_q() const {
  const ::ndm_proto::Vector4F* p = delta_q_;
  // @@protoc_insertion_point(field_get:ndm_proto.IMUFrame.delta_q)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Vector4F*>(
      &::ndm_proto::_Vector4F_default_instance_);
}
inline ::ndm_proto::Vector4F* IMUFrame::release_delta_q() {
  // @@protoc_insertion_point(field_release:ndm_proto.IMUFrame.delta_q)
  clear_has_delta_q();
  ::ndm_proto::Vector4F* temp = delta_q_;
  delta_q_ = NULL;
  return temp;
}
inline ::ndm_proto::Vector4F* IMUFrame::mutable_delta_q() {
  set_has_delta_q();
  if (delta_q_ == NULL) {
    delta_q_ = new ::ndm_proto::Vector4F;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.IMUFrame.delta_q)
  return delta_q_;
}
inline void IMUFrame::set_allocated_delta_q(::ndm_proto::Vector4F* delta_q) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete delta_q_;
  }
  if (delta_q) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      delta_q = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, delta_q, submessage_arena);
    }
    set_has_delta_q();
  } else {
    clear_has_delta_q();
  }
  delta_q_ = delta_q;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.IMUFrame.delta_q)
}

// optional .ndm_proto.Vector3F free_accleration = 15;
inline bool IMUFrame::has_free_accleration() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void IMUFrame::set_has_free_accleration() {
  _has_bits_[0] |= 0x00000080u;
}
inline void IMUFrame::clear_has_free_accleration() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void IMUFrame::clear_free_accleration() {
  if (free_accleration_ != NULL) free_accleration_->Clear();
  clear_has_free_accleration();
}
inline const ::ndm_proto::Vector3F& IMUFrame::free_accleration() const {
  const ::ndm_proto::Vector3F* p = free_accleration_;
  // @@protoc_insertion_point(field_get:ndm_proto.IMUFrame.free_accleration)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Vector3F*>(
      &::ndm_proto::_Vector3F_default_instance_);
}
inline ::ndm_proto::Vector3F* IMUFrame::release_free_accleration() {
  // @@protoc_insertion_point(field_release:ndm_proto.IMUFrame.free_accleration)
  clear_has_free_accleration();
  ::ndm_proto::Vector3F* temp = free_accleration_;
  free_accleration_ = NULL;
  return temp;
}
inline ::ndm_proto::Vector3F* IMUFrame::mutable_free_accleration() {
  set_has_free_accleration();
  if (free_accleration_ == NULL) {
    free_accleration_ = new ::ndm_proto::Vector3F;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.IMUFrame.free_accleration)
  return free_accleration_;
}
inline void IMUFrame::set_allocated_free_accleration(::ndm_proto::Vector3F* free_accleration) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete free_accleration_;
  }
  if (free_accleration) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      free_accleration = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, free_accleration, submessage_arena);
    }
    set_has_free_accleration();
  } else {
    clear_has_free_accleration();
  }
  free_accleration_ = free_accleration;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.IMUFrame.free_accleration)
}

// optional .ndm_proto.Vector3F magnetic = 16;
inline bool IMUFrame::has_magnetic() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void IMUFrame::set_has_magnetic() {
  _has_bits_[0] |= 0x00000100u;
}
inline void IMUFrame::clear_has_magnetic() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void IMUFrame::clear_magnetic() {
  if (magnetic_ != NULL) magnetic_->Clear();
  clear_has_magnetic();
}
inline const ::ndm_proto::Vector3F& IMUFrame::magnetic() const {
  const ::ndm_proto::Vector3F* p = magnetic_;
  // @@protoc_insertion_point(field_get:ndm_proto.IMUFrame.magnetic)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Vector3F*>(
      &::ndm_proto::_Vector3F_default_instance_);
}
inline ::ndm_proto::Vector3F* IMUFrame::release_magnetic() {
  // @@protoc_insertion_point(field_release:ndm_proto.IMUFrame.magnetic)
  clear_has_magnetic();
  ::ndm_proto::Vector3F* temp = magnetic_;
  magnetic_ = NULL;
  return temp;
}
inline ::ndm_proto::Vector3F* IMUFrame::mutable_magnetic() {
  set_has_magnetic();
  if (magnetic_ == NULL) {
    magnetic_ = new ::ndm_proto::Vector3F;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.IMUFrame.magnetic)
  return magnetic_;
}
inline void IMUFrame::set_allocated_magnetic(::ndm_proto::Vector3F* magnetic) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete magnetic_;
  }
  if (magnetic) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      magnetic = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, magnetic, submessage_arena);
    }
    set_has_magnetic();
  } else {
    clear_has_magnetic();
  }
  magnetic_ = magnetic;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.IMUFrame.magnetic)
}

// optional int32 status_word = 17;
inline bool IMUFrame::has_status_word() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void IMUFrame::set_has_status_word() {
  _has_bits_[0] |= 0x00020000u;
}
inline void IMUFrame::clear_has_status_word() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void IMUFrame::clear_status_word() {
  status_word_ = 0;
  clear_has_status_word();
}
inline ::google::protobuf::int32 IMUFrame::status_word() const {
  // @@protoc_insertion_point(field_get:ndm_proto.IMUFrame.status_word)
  return status_word_;
}
inline void IMUFrame::set_status_word(::google::protobuf::int32 value) {
  set_has_status_word();
  status_word_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.IMUFrame.status_word)
}

// optional float pitch = 18;
inline bool IMUFrame::has_pitch() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void IMUFrame::set_has_pitch() {
  _has_bits_[0] |= 0x00040000u;
}
inline void IMUFrame::clear_has_pitch() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void IMUFrame::clear_pitch() {
  pitch_ = 0;
  clear_has_pitch();
}
inline float IMUFrame::pitch() const {
  // @@protoc_insertion_point(field_get:ndm_proto.IMUFrame.pitch)
  return pitch_;
}
inline void IMUFrame::set_pitch(float value) {
  set_has_pitch();
  pitch_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.IMUFrame.pitch)
}

// optional float yaw = 19;
inline bool IMUFrame::has_yaw() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void IMUFrame::set_has_yaw() {
  _has_bits_[0] |= 0x00080000u;
}
inline void IMUFrame::clear_has_yaw() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void IMUFrame::clear_yaw() {
  yaw_ = 0;
  clear_has_yaw();
}
inline float IMUFrame::yaw() const {
  // @@protoc_insertion_point(field_get:ndm_proto.IMUFrame.yaw)
  return yaw_;
}
inline void IMUFrame::set_yaw(float value) {
  set_has_yaw();
  yaw_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.IMUFrame.yaw)
}

// optional float roll = 20;
inline bool IMUFrame::has_roll() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void IMUFrame::set_has_roll() {
  _has_bits_[0] |= 0x00100000u;
}
inline void IMUFrame::clear_has_roll() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void IMUFrame::clear_roll() {
  roll_ = 0;
  clear_has_roll();
}
inline float IMUFrame::roll() const {
  // @@protoc_insertion_point(field_get:ndm_proto.IMUFrame.roll)
  return roll_;
}
inline void IMUFrame::set_roll(float value) {
  set_has_roll();
  roll_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.IMUFrame.roll)
}

// optional float x_offset = 21;
inline bool IMUFrame::has_x_offset() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void IMUFrame::set_has_x_offset() {
  _has_bits_[0] |= 0x00200000u;
}
inline void IMUFrame::clear_has_x_offset() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void IMUFrame::clear_x_offset() {
  x_offset_ = 0;
  clear_has_x_offset();
}
inline float IMUFrame::x_offset() const {
  // @@protoc_insertion_point(field_get:ndm_proto.IMUFrame.x_offset)
  return x_offset_;
}
inline void IMUFrame::set_x_offset(float value) {
  set_has_x_offset();
  x_offset_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.IMUFrame.x_offset)
}

// optional float y_offset = 22;
inline bool IMUFrame::has_y_offset() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void IMUFrame::set_has_y_offset() {
  _has_bits_[0] |= 0x00400000u;
}
inline void IMUFrame::clear_has_y_offset() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void IMUFrame::clear_y_offset() {
  y_offset_ = 0;
  clear_has_y_offset();
}
inline float IMUFrame::y_offset() const {
  // @@protoc_insertion_point(field_get:ndm_proto.IMUFrame.y_offset)
  return y_offset_;
}
inline void IMUFrame::set_y_offset(float value) {
  set_has_y_offset();
  y_offset_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.IMUFrame.y_offset)
}

// optional float z_offset = 23;
inline bool IMUFrame::has_z_offset() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void IMUFrame::set_has_z_offset() {
  _has_bits_[0] |= 0x00800000u;
}
inline void IMUFrame::clear_has_z_offset() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void IMUFrame::clear_z_offset() {
  z_offset_ = 0;
  clear_has_z_offset();
}
inline float IMUFrame::z_offset() const {
  // @@protoc_insertion_point(field_get:ndm_proto.IMUFrame.z_offset)
  return z_offset_;
}
inline void IMUFrame::set_z_offset(float value) {
  set_has_z_offset();
  z_offset_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.IMUFrame.z_offset)
}

// repeated bytes raw_array = 24;
inline int IMUFrame::raw_array_size() const {
  return raw_array_.size();
}
inline void IMUFrame::clear_raw_array() {
  raw_array_.Clear();
}
inline const ::std::string& IMUFrame::raw_array(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.IMUFrame.raw_array)
  return raw_array_.Get(index);
}
inline ::std::string* IMUFrame::mutable_raw_array(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.IMUFrame.raw_array)
  return raw_array_.Mutable(index);
}
inline void IMUFrame::set_raw_array(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ndm_proto.IMUFrame.raw_array)
  raw_array_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void IMUFrame::set_raw_array(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:ndm_proto.IMUFrame.raw_array)
  raw_array_.Mutable(index)->assign(std::move(value));
}
#endif
inline void IMUFrame::set_raw_array(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  raw_array_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ndm_proto.IMUFrame.raw_array)
}
inline void IMUFrame::set_raw_array(int index, const void* value, size_t size) {
  raw_array_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.IMUFrame.raw_array)
}
inline ::std::string* IMUFrame::add_raw_array() {
  // @@protoc_insertion_point(field_add_mutable:ndm_proto.IMUFrame.raw_array)
  return raw_array_.Add();
}
inline void IMUFrame::add_raw_array(const ::std::string& value) {
  raw_array_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ndm_proto.IMUFrame.raw_array)
}
#if LANG_CXX11
inline void IMUFrame::add_raw_array(::std::string&& value) {
  raw_array_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ndm_proto.IMUFrame.raw_array)
}
#endif
inline void IMUFrame::add_raw_array(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  raw_array_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ndm_proto.IMUFrame.raw_array)
}
inline void IMUFrame::add_raw_array(const void* value, size_t size) {
  raw_array_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ndm_proto.IMUFrame.raw_array)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
IMUFrame::raw_array() const {
  // @@protoc_insertion_point(field_list:ndm_proto.IMUFrame.raw_array)
  return raw_array_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
IMUFrame::mutable_raw_array() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.IMUFrame.raw_array)
  return &raw_array_;
}

// optional .ndm_proto.UNPACK_IMU_ALG unpack_imu_alg = 25;
inline bool IMUFrame::has_unpack_imu_alg() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void IMUFrame::set_has_unpack_imu_alg() {
  _has_bits_[0] |= 0x00000200u;
}
inline void IMUFrame::clear_has_unpack_imu_alg() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void IMUFrame::clear_unpack_imu_alg() {
  if (unpack_imu_alg_ != NULL) unpack_imu_alg_->Clear();
  clear_has_unpack_imu_alg();
}
inline const ::ndm_proto::UNPACK_IMU_ALG& IMUFrame::unpack_imu_alg() const {
  const ::ndm_proto::UNPACK_IMU_ALG* p = unpack_imu_alg_;
  // @@protoc_insertion_point(field_get:ndm_proto.IMUFrame.unpack_imu_alg)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::UNPACK_IMU_ALG*>(
      &::ndm_proto::_UNPACK_IMU_ALG_default_instance_);
}
inline ::ndm_proto::UNPACK_IMU_ALG* IMUFrame::release_unpack_imu_alg() {
  // @@protoc_insertion_point(field_release:ndm_proto.IMUFrame.unpack_imu_alg)
  clear_has_unpack_imu_alg();
  ::ndm_proto::UNPACK_IMU_ALG* temp = unpack_imu_alg_;
  unpack_imu_alg_ = NULL;
  return temp;
}
inline ::ndm_proto::UNPACK_IMU_ALG* IMUFrame::mutable_unpack_imu_alg() {
  set_has_unpack_imu_alg();
  if (unpack_imu_alg_ == NULL) {
    unpack_imu_alg_ = new ::ndm_proto::UNPACK_IMU_ALG;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.IMUFrame.unpack_imu_alg)
  return unpack_imu_alg_;
}
inline void IMUFrame::set_allocated_unpack_imu_alg(::ndm_proto::UNPACK_IMU_ALG* unpack_imu_alg) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete unpack_imu_alg_;
  }
  if (unpack_imu_alg) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      unpack_imu_alg = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, unpack_imu_alg, submessage_arena);
    }
    set_has_unpack_imu_alg();
  } else {
    clear_has_unpack_imu_alg();
  }
  unpack_imu_alg_ = unpack_imu_alg;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.IMUFrame.unpack_imu_alg)
}

// optional bool flag_imu_alg = 26;
inline bool IMUFrame::has_flag_imu_alg() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void IMUFrame::set_has_flag_imu_alg() {
  _has_bits_[0] |= 0x01000000u;
}
inline void IMUFrame::clear_has_flag_imu_alg() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void IMUFrame::clear_flag_imu_alg() {
  flag_imu_alg_ = false;
  clear_has_flag_imu_alg();
}
inline bool IMUFrame::flag_imu_alg() const {
  // @@protoc_insertion_point(field_get:ndm_proto.IMUFrame.flag_imu_alg)
  return flag_imu_alg_;
}
inline void IMUFrame::set_flag_imu_alg(bool value) {
  set_has_flag_imu_alg();
  flag_imu_alg_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.IMUFrame.flag_imu_alg)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ndm_proto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_sense_2eproto__INCLUDED
