// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: base.proto

#ifndef PROTOBUF_base_2eproto__INCLUDED
#define PROTOBUF_base_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_base_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[43];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsIdImpl();
void InitDefaultsId();
void InitDefaultsIndexImpl();
void InitDefaultsIndex();
void InitDefaultsLinkImpl();
void InitDefaultsLink();
void InitDefaultsNumberImpl();
void InitDefaultsNumber();
void InitDefaultsStringImpl();
void InitDefaultsString();
void InitDefaultsPointImpl();
void InitDefaultsPoint();
void InitDefaultsQuaternion4dImpl();
void InitDefaultsQuaternion4d();
void InitDefaultsOdometryImpl();
void InitDefaultsOdometry();
void InitDefaultsWGS84Impl();
void InitDefaultsWGS84();
void InitDefaultsTrajectoryImpl();
void InitDefaultsTrajectory();
void InitDefaultsCylinderImpl();
void InitDefaultsCylinder();
void InitDefaultsCircleImpl();
void InitDefaultsCircle();
void InitDefaultsCurveLineImpl();
void InitDefaultsCurveLine();
void InitDefaultsPolygonImpl();
void InitDefaultsPolygon();
void InitDefaultsTrafficLightTypeImpl();
void InitDefaultsTrafficLightType();
void InitDefaultsTrafficLightStateImpl();
void InitDefaultsTrafficLightState();
void InitDefaultsTrafficLightBulbColorImpl();
void InitDefaultsTrafficLightBulbColor();
void InitDefaultsTrafficLightBulbShapeImpl();
void InitDefaultsTrafficLightBulbShape();
void InitDefaultsLaneMarkingTypeImpl();
void InitDefaultsLaneMarkingType();
void InitDefaultsLaneFunctionImpl();
void InitDefaultsLaneFunction();
void InitDefaultsLaneDirectionImpl();
void InitDefaultsLaneDirection();
void InitDefaultsLaneAttrImpl();
void InitDefaultsLaneAttr();
void InitDefaultsVehicleTypeImpl();
void InitDefaultsVehicleType();
void InitDefaultsSpeedLimitImpl();
void InitDefaultsSpeedLimit();
void InitDefaultsTimeLimitImpl();
void InitDefaultsTimeLimit();
void InitDefaultsLaneRestrictionImpl();
void InitDefaultsLaneRestriction();
void InitDefaultsLanePriorityImpl();
void InitDefaultsLanePriority();
void InitDefaultsLaneLineColorImpl();
void InitDefaultsLaneLineColor();
void InitDefaultsLaneLineTypeImpl();
void InitDefaultsLaneLineType();
void InitDefaultsLaneLineRestrictionImpl();
void InitDefaultsLaneLineRestriction();
void InitDefaultsTrafficSignTypeImpl();
void InitDefaultsTrafficSignType();
void InitDefaultsConditionNumericImpl();
void InitDefaultsConditionNumeric();
void InitDefaultsConditionVehicleTypeImpl();
void InitDefaultsConditionVehicleType();
void InitDefaultsConditionLoadImpl();
void InitDefaultsConditionLoad();
void InitDefaultsConditionTimeOfDayImpl();
void InitDefaultsConditionTimeOfDay();
void InitDefaultsConditionWeatherImpl();
void InitDefaultsConditionWeather();
void InitDefaultsConditionFuzzyTimeImpl();
void InitDefaultsConditionFuzzyTime();
void InitDefaultsConditionTurnDirectionImpl();
void InitDefaultsConditionTurnDirection();
void InitDefaultsConditionImpl();
void InitDefaultsCondition();
void InitDefaultsParkingSpaceRestrictionImpl();
void InitDefaultsParkingSpaceRestriction();
void InitDefaultsZoneTypeImpl();
void InitDefaultsZoneType();
void InitDefaultsAreaTypeImpl();
void InitDefaultsAreaType();
void InitDefaultsPoleTypeImpl();
void InitDefaultsPoleType();
inline void InitDefaults() {
  InitDefaultsId();
  InitDefaultsIndex();
  InitDefaultsLink();
  InitDefaultsNumber();
  InitDefaultsString();
  InitDefaultsPoint();
  InitDefaultsQuaternion4d();
  InitDefaultsOdometry();
  InitDefaultsWGS84();
  InitDefaultsTrajectory();
  InitDefaultsCylinder();
  InitDefaultsCircle();
  InitDefaultsCurveLine();
  InitDefaultsPolygon();
  InitDefaultsTrafficLightType();
  InitDefaultsTrafficLightState();
  InitDefaultsTrafficLightBulbColor();
  InitDefaultsTrafficLightBulbShape();
  InitDefaultsLaneMarkingType();
  InitDefaultsLaneFunction();
  InitDefaultsLaneDirection();
  InitDefaultsLaneAttr();
  InitDefaultsVehicleType();
  InitDefaultsSpeedLimit();
  InitDefaultsTimeLimit();
  InitDefaultsLaneRestriction();
  InitDefaultsLanePriority();
  InitDefaultsLaneLineColor();
  InitDefaultsLaneLineType();
  InitDefaultsLaneLineRestriction();
  InitDefaultsTrafficSignType();
  InitDefaultsConditionNumeric();
  InitDefaultsConditionVehicleType();
  InitDefaultsConditionLoad();
  InitDefaultsConditionTimeOfDay();
  InitDefaultsConditionWeather();
  InitDefaultsConditionFuzzyTime();
  InitDefaultsConditionTurnDirection();
  InitDefaultsCondition();
  InitDefaultsParkingSpaceRestriction();
  InitDefaultsZoneType();
  InitDefaultsAreaType();
  InitDefaultsPoleType();
}
}  // namespace protobuf_base_2eproto
namespace ndm_proto {
class AreaType;
class AreaTypeDefaultTypeInternal;
extern AreaTypeDefaultTypeInternal _AreaType_default_instance_;
class Circle;
class CircleDefaultTypeInternal;
extern CircleDefaultTypeInternal _Circle_default_instance_;
class Condition;
class ConditionDefaultTypeInternal;
extern ConditionDefaultTypeInternal _Condition_default_instance_;
class ConditionFuzzyTime;
class ConditionFuzzyTimeDefaultTypeInternal;
extern ConditionFuzzyTimeDefaultTypeInternal _ConditionFuzzyTime_default_instance_;
class ConditionLoad;
class ConditionLoadDefaultTypeInternal;
extern ConditionLoadDefaultTypeInternal _ConditionLoad_default_instance_;
class ConditionNumeric;
class ConditionNumericDefaultTypeInternal;
extern ConditionNumericDefaultTypeInternal _ConditionNumeric_default_instance_;
class ConditionTimeOfDay;
class ConditionTimeOfDayDefaultTypeInternal;
extern ConditionTimeOfDayDefaultTypeInternal _ConditionTimeOfDay_default_instance_;
class ConditionTurnDirection;
class ConditionTurnDirectionDefaultTypeInternal;
extern ConditionTurnDirectionDefaultTypeInternal _ConditionTurnDirection_default_instance_;
class ConditionVehicleType;
class ConditionVehicleTypeDefaultTypeInternal;
extern ConditionVehicleTypeDefaultTypeInternal _ConditionVehicleType_default_instance_;
class ConditionWeather;
class ConditionWeatherDefaultTypeInternal;
extern ConditionWeatherDefaultTypeInternal _ConditionWeather_default_instance_;
class CurveLine;
class CurveLineDefaultTypeInternal;
extern CurveLineDefaultTypeInternal _CurveLine_default_instance_;
class Cylinder;
class CylinderDefaultTypeInternal;
extern CylinderDefaultTypeInternal _Cylinder_default_instance_;
class Id;
class IdDefaultTypeInternal;
extern IdDefaultTypeInternal _Id_default_instance_;
class Index;
class IndexDefaultTypeInternal;
extern IndexDefaultTypeInternal _Index_default_instance_;
class LaneAttr;
class LaneAttrDefaultTypeInternal;
extern LaneAttrDefaultTypeInternal _LaneAttr_default_instance_;
class LaneDirection;
class LaneDirectionDefaultTypeInternal;
extern LaneDirectionDefaultTypeInternal _LaneDirection_default_instance_;
class LaneFunction;
class LaneFunctionDefaultTypeInternal;
extern LaneFunctionDefaultTypeInternal _LaneFunction_default_instance_;
class LaneLineColor;
class LaneLineColorDefaultTypeInternal;
extern LaneLineColorDefaultTypeInternal _LaneLineColor_default_instance_;
class LaneLineRestriction;
class LaneLineRestrictionDefaultTypeInternal;
extern LaneLineRestrictionDefaultTypeInternal _LaneLineRestriction_default_instance_;
class LaneLineType;
class LaneLineTypeDefaultTypeInternal;
extern LaneLineTypeDefaultTypeInternal _LaneLineType_default_instance_;
class LaneMarkingType;
class LaneMarkingTypeDefaultTypeInternal;
extern LaneMarkingTypeDefaultTypeInternal _LaneMarkingType_default_instance_;
class LanePriority;
class LanePriorityDefaultTypeInternal;
extern LanePriorityDefaultTypeInternal _LanePriority_default_instance_;
class LaneRestriction;
class LaneRestrictionDefaultTypeInternal;
extern LaneRestrictionDefaultTypeInternal _LaneRestriction_default_instance_;
class Link;
class LinkDefaultTypeInternal;
extern LinkDefaultTypeInternal _Link_default_instance_;
class Number;
class NumberDefaultTypeInternal;
extern NumberDefaultTypeInternal _Number_default_instance_;
class Odometry;
class OdometryDefaultTypeInternal;
extern OdometryDefaultTypeInternal _Odometry_default_instance_;
class ParkingSpaceRestriction;
class ParkingSpaceRestrictionDefaultTypeInternal;
extern ParkingSpaceRestrictionDefaultTypeInternal _ParkingSpaceRestriction_default_instance_;
class Point;
class PointDefaultTypeInternal;
extern PointDefaultTypeInternal _Point_default_instance_;
class PoleType;
class PoleTypeDefaultTypeInternal;
extern PoleTypeDefaultTypeInternal _PoleType_default_instance_;
class Polygon;
class PolygonDefaultTypeInternal;
extern PolygonDefaultTypeInternal _Polygon_default_instance_;
class Quaternion4d;
class Quaternion4dDefaultTypeInternal;
extern Quaternion4dDefaultTypeInternal _Quaternion4d_default_instance_;
class SpeedLimit;
class SpeedLimitDefaultTypeInternal;
extern SpeedLimitDefaultTypeInternal _SpeedLimit_default_instance_;
class String;
class StringDefaultTypeInternal;
extern StringDefaultTypeInternal _String_default_instance_;
class TimeLimit;
class TimeLimitDefaultTypeInternal;
extern TimeLimitDefaultTypeInternal _TimeLimit_default_instance_;
class TrafficLightBulbColor;
class TrafficLightBulbColorDefaultTypeInternal;
extern TrafficLightBulbColorDefaultTypeInternal _TrafficLightBulbColor_default_instance_;
class TrafficLightBulbShape;
class TrafficLightBulbShapeDefaultTypeInternal;
extern TrafficLightBulbShapeDefaultTypeInternal _TrafficLightBulbShape_default_instance_;
class TrafficLightState;
class TrafficLightStateDefaultTypeInternal;
extern TrafficLightStateDefaultTypeInternal _TrafficLightState_default_instance_;
class TrafficLightType;
class TrafficLightTypeDefaultTypeInternal;
extern TrafficLightTypeDefaultTypeInternal _TrafficLightType_default_instance_;
class TrafficSignType;
class TrafficSignTypeDefaultTypeInternal;
extern TrafficSignTypeDefaultTypeInternal _TrafficSignType_default_instance_;
class Trajectory;
class TrajectoryDefaultTypeInternal;
extern TrajectoryDefaultTypeInternal _Trajectory_default_instance_;
class VehicleType;
class VehicleTypeDefaultTypeInternal;
extern VehicleTypeDefaultTypeInternal _VehicleType_default_instance_;
class WGS84;
class WGS84DefaultTypeInternal;
extern WGS84DefaultTypeInternal _WGS84_default_instance_;
class ZoneType;
class ZoneTypeDefaultTypeInternal;
extern ZoneTypeDefaultTypeInternal _ZoneType_default_instance_;
}  // namespace ndm_proto
namespace ndm_proto {

enum TrafficLightType_Type {
  TrafficLightType_Type_NONE = 0,
  TrafficLightType_Type_CIRCLE = 1,
  TrafficLightType_Type_CROSS = 2,
  TrafficLightType_Type_PEDESTRIAN = 3,
  TrafficLightType_Type_BICYCLE = 4,
  TrafficLightType_Type_ARROW = 5,
  TrafficLightType_Type_TIME = 6
};
bool TrafficLightType_Type_IsValid(int value);
const TrafficLightType_Type TrafficLightType_Type_Type_MIN = TrafficLightType_Type_NONE;
const TrafficLightType_Type TrafficLightType_Type_Type_MAX = TrafficLightType_Type_TIME;
const int TrafficLightType_Type_Type_ARRAYSIZE = TrafficLightType_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* TrafficLightType_Type_descriptor();
inline const ::std::string& TrafficLightType_Type_Name(TrafficLightType_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    TrafficLightType_Type_descriptor(), value);
}
inline bool TrafficLightType_Type_Parse(
    const ::std::string& name, TrafficLightType_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrafficLightType_Type>(
    TrafficLightType_Type_descriptor(), name, value);
}
enum TrafficLightState_State {
  TrafficLightState_State_UNKNOWN = 0,
  TrafficLightState_State_RED = 1,
  TrafficLightState_State_GREEN = 2,
  TrafficLightState_State_BLUE = 3,
  TrafficLightState_State_YELLOW = 4
};
bool TrafficLightState_State_IsValid(int value);
const TrafficLightState_State TrafficLightState_State_State_MIN = TrafficLightState_State_UNKNOWN;
const TrafficLightState_State TrafficLightState_State_State_MAX = TrafficLightState_State_YELLOW;
const int TrafficLightState_State_State_ARRAYSIZE = TrafficLightState_State_State_MAX + 1;

const ::google::protobuf::EnumDescriptor* TrafficLightState_State_descriptor();
inline const ::std::string& TrafficLightState_State_Name(TrafficLightState_State value) {
  return ::google::protobuf::internal::NameOfEnum(
    TrafficLightState_State_descriptor(), value);
}
inline bool TrafficLightState_State_Parse(
    const ::std::string& name, TrafficLightState_State* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrafficLightState_State>(
    TrafficLightState_State_descriptor(), name, value);
}
enum TrafficLightBulbColor_Color {
  TrafficLightBulbColor_Color_UNKNOWN = 0,
  TrafficLightBulbColor_Color_RED = 1,
  TrafficLightBulbColor_Color_YELLOW = 2,
  TrafficLightBulbColor_Color_GREEN = 3,
  TrafficLightBulbColor_Color_WHITE = 4
};
bool TrafficLightBulbColor_Color_IsValid(int value);
const TrafficLightBulbColor_Color TrafficLightBulbColor_Color_Color_MIN = TrafficLightBulbColor_Color_UNKNOWN;
const TrafficLightBulbColor_Color TrafficLightBulbColor_Color_Color_MAX = TrafficLightBulbColor_Color_WHITE;
const int TrafficLightBulbColor_Color_Color_ARRAYSIZE = TrafficLightBulbColor_Color_Color_MAX + 1;

const ::google::protobuf::EnumDescriptor* TrafficLightBulbColor_Color_descriptor();
inline const ::std::string& TrafficLightBulbColor_Color_Name(TrafficLightBulbColor_Color value) {
  return ::google::protobuf::internal::NameOfEnum(
    TrafficLightBulbColor_Color_descriptor(), value);
}
inline bool TrafficLightBulbColor_Color_Parse(
    const ::std::string& name, TrafficLightBulbColor_Color* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrafficLightBulbColor_Color>(
    TrafficLightBulbColor_Color_descriptor(), name, value);
}
enum TrafficLightBulbShape_Type {
  TrafficLightBulbShape_Type_UNKNOWN = 0,
  TrafficLightBulbShape_Type_CIRCLE = 1,
  TrafficLightBulbShape_Type_LEFT_ARROW = 2,
  TrafficLightBulbShape_Type_RIGHT_ARROW = 3,
  TrafficLightBulbShape_Type_UP_ARROW = 4,
  TrafficLightBulbShape_Type_DOWN_ARROW = 5,
  TrafficLightBulbShape_Type_UTURN = 6,
  TrafficLightBulbShape_Type_FORWARD_AND_LEFT = 7,
  TrafficLightBulbShape_Type_FORWARD_AND_RIGHT = 8
};
bool TrafficLightBulbShape_Type_IsValid(int value);
const TrafficLightBulbShape_Type TrafficLightBulbShape_Type_Type_MIN = TrafficLightBulbShape_Type_UNKNOWN;
const TrafficLightBulbShape_Type TrafficLightBulbShape_Type_Type_MAX = TrafficLightBulbShape_Type_FORWARD_AND_RIGHT;
const int TrafficLightBulbShape_Type_Type_ARRAYSIZE = TrafficLightBulbShape_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* TrafficLightBulbShape_Type_descriptor();
inline const ::std::string& TrafficLightBulbShape_Type_Name(TrafficLightBulbShape_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    TrafficLightBulbShape_Type_descriptor(), value);
}
inline bool TrafficLightBulbShape_Type_Parse(
    const ::std::string& name, TrafficLightBulbShape_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrafficLightBulbShape_Type>(
    TrafficLightBulbShape_Type_descriptor(), name, value);
}
enum LaneMarkingType_Type {
  LaneMarkingType_Type_UNKNOWN = 0,
  LaneMarkingType_Type_ARROW_LEFT = 1,
  LaneMarkingType_Type_ARROW_FORWARD = 2,
  LaneMarkingType_Type_ARROW_RIGHT = 3,
  LaneMarkingType_Type_ARROW_LEFT_AND_FORWARD = 4,
  LaneMarkingType_Type_ARROW_RIGHT_AND_FORWARD = 5,
  LaneMarkingType_Type_ARROW_LEFT_AND_RIGHT = 6,
  LaneMarkingType_Type_ARROW_U_TURN = 7,
  LaneMarkingType_Type_ARROW_U_TURN_AND_FORWARD = 8,
  LaneMarkingType_Type_ARROW_U_TURN_AND_LEFT = 9,
  LaneMarkingType_Type_ARROW_MERGE_LEFT = 10,
  LaneMarkingType_Type_ARROW_MERGE_RIGHT = 11,
  LaneMarkingType_Type_CROSSWALK_NOTICE = 12,
  LaneMarkingType_Type_SPEED_LIMIT_LOW = 13,
  LaneMarkingType_Type_SPEED_LIMIT_HIGH = 14,
  LaneMarkingType_Type_ARROW_NO_LEFT_TURN = 15,
  LaneMarkingType_Type_ARROW_NO_RIGHT_TURN = 16,
  LaneMarkingType_Type_ARROW_NO_U_TURN = 17,
  LaneMarkingType_Type_ARROW_FORWARD_AND_LEFT_AND_RIGHT = 18,
  LaneMarkingType_Type_ARROW_FORWARD_AND_U_TURN_AND_LEFT = 19,
  LaneMarkingType_Type_ARROW_RIGHT_AND_U_TURN = 20,
  LaneMarkingType_Type_TEXT = 21,
  LaneMarkingType_Type_TIME = 22,
  LaneMarkingType_Type_CHECK_FOLLOWING_DISTANCE = 23,
  LaneMarkingType_Type_STOP_TO_GIVE_WAY = 24,
  LaneMarkingType_Type_SLOWDOWN_TO_GIVE_WAY = 25,
  LaneMarkingType_Type_STOP_MARK = 26,
  LaneMarkingType_Type_NETS = 27
};
bool LaneMarkingType_Type_IsValid(int value);
const LaneMarkingType_Type LaneMarkingType_Type_Type_MIN = LaneMarkingType_Type_UNKNOWN;
const LaneMarkingType_Type LaneMarkingType_Type_Type_MAX = LaneMarkingType_Type_NETS;
const int LaneMarkingType_Type_Type_ARRAYSIZE = LaneMarkingType_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* LaneMarkingType_Type_descriptor();
inline const ::std::string& LaneMarkingType_Type_Name(LaneMarkingType_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    LaneMarkingType_Type_descriptor(), value);
}
inline bool LaneMarkingType_Type_Parse(
    const ::std::string& name, LaneMarkingType_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LaneMarkingType_Type>(
    LaneMarkingType_Type_descriptor(), name, value);
}
enum LaneFunction_Function {
  LaneFunction_Function_NONE = 0,
  LaneFunction_Function_CITY_DRIVING = 1,
  LaneFunction_Function_HIGH_DRIVING = 2,
  LaneFunction_Function_BIKING = 3,
  LaneFunction_Function_SIDEWALK = 4,
  LaneFunction_Function_PARKING = 5,
  LaneFunction_Function_RAMP = 6,
  LaneFunction_Function_EMERGENCY = 7,
  LaneFunction_Function_ACCELERATION = 8
};
bool LaneFunction_Function_IsValid(int value);
const LaneFunction_Function LaneFunction_Function_Function_MIN = LaneFunction_Function_NONE;
const LaneFunction_Function LaneFunction_Function_Function_MAX = LaneFunction_Function_ACCELERATION;
const int LaneFunction_Function_Function_ARRAYSIZE = LaneFunction_Function_Function_MAX + 1;

const ::google::protobuf::EnumDescriptor* LaneFunction_Function_descriptor();
inline const ::std::string& LaneFunction_Function_Name(LaneFunction_Function value) {
  return ::google::protobuf::internal::NameOfEnum(
    LaneFunction_Function_descriptor(), value);
}
inline bool LaneFunction_Function_Parse(
    const ::std::string& name, LaneFunction_Function* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LaneFunction_Function>(
    LaneFunction_Function_descriptor(), name, value);
}
enum LaneDirection_Direction {
  LaneDirection_Direction_FORWARD = 1,
  LaneDirection_Direction_BACKWARD = 2,
  LaneDirection_Direction_BIDIRECTION = 3,
  LaneDirection_Direction_TIDAL = 4,
  LaneDirection_Direction_NONE = 5
};
bool LaneDirection_Direction_IsValid(int value);
const LaneDirection_Direction LaneDirection_Direction_Direction_MIN = LaneDirection_Direction_FORWARD;
const LaneDirection_Direction LaneDirection_Direction_Direction_MAX = LaneDirection_Direction_NONE;
const int LaneDirection_Direction_Direction_ARRAYSIZE = LaneDirection_Direction_Direction_MAX + 1;

const ::google::protobuf::EnumDescriptor* LaneDirection_Direction_descriptor();
inline const ::std::string& LaneDirection_Direction_Name(LaneDirection_Direction value) {
  return ::google::protobuf::internal::NameOfEnum(
    LaneDirection_Direction_descriptor(), value);
}
inline bool LaneDirection_Direction_Parse(
    const ::std::string& name, LaneDirection_Direction* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LaneDirection_Direction>(
    LaneDirection_Direction_descriptor(), name, value);
}
enum VehicleType_Type {
  VehicleType_Type_VEHICLE_TYPE_UNKNOWN = 0,
  VehicleType_Type_CAR = 1,
  VehicleType_Type_MOTORCYCLE = 2,
  VehicleType_Type_BICYCLE = 3,
  VehicleType_Type_TRUCK = 4,
  VehicleType_Type_TAXI = 5,
  VehicleType_Type_BUS = 6,
  VehicleType_Type_PEDESTRAIN = 7,
  VehicleType_Type_CABLE_CAR = 8
};
bool VehicleType_Type_IsValid(int value);
const VehicleType_Type VehicleType_Type_Type_MIN = VehicleType_Type_VEHICLE_TYPE_UNKNOWN;
const VehicleType_Type VehicleType_Type_Type_MAX = VehicleType_Type_CABLE_CAR;
const int VehicleType_Type_Type_ARRAYSIZE = VehicleType_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* VehicleType_Type_descriptor();
inline const ::std::string& VehicleType_Type_Name(VehicleType_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    VehicleType_Type_descriptor(), value);
}
inline bool VehicleType_Type_Parse(
    const ::std::string& name, VehicleType_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VehicleType_Type>(
    VehicleType_Type_descriptor(), name, value);
}
enum LanePriority_Priority {
  LanePriority_Priority_LANE_PRIORITY_UNKNOWN = 0,
  LanePriority_Priority_LANE_PRIORITY_HIGHER = 1,
  LanePriority_Priority_LANE_PRIORITY_EQUAL = 2,
  LanePriority_Priority_LANE_PRIORITY_LOWER = 3,
  LanePriority_Priority_LANE_PRIORITY_CONTROLLED_BY_SIGNAL = 4,
  LanePriority_Priority_LANE_PRIORITY_CONTROLLED_BY_STOPLINE = 5
};
bool LanePriority_Priority_IsValid(int value);
const LanePriority_Priority LanePriority_Priority_Priority_MIN = LanePriority_Priority_LANE_PRIORITY_UNKNOWN;
const LanePriority_Priority LanePriority_Priority_Priority_MAX = LanePriority_Priority_LANE_PRIORITY_CONTROLLED_BY_STOPLINE;
const int LanePriority_Priority_Priority_ARRAYSIZE = LanePriority_Priority_Priority_MAX + 1;

const ::google::protobuf::EnumDescriptor* LanePriority_Priority_descriptor();
inline const ::std::string& LanePriority_Priority_Name(LanePriority_Priority value) {
  return ::google::protobuf::internal::NameOfEnum(
    LanePriority_Priority_descriptor(), value);
}
inline bool LanePriority_Priority_Parse(
    const ::std::string& name, LanePriority_Priority* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LanePriority_Priority>(
    LanePriority_Priority_descriptor(), name, value);
}
enum LaneLineColor_Color {
  LaneLineColor_Color_UNKNOWN_LINE_COLOR = 0,
  LaneLineColor_Color_WHITE = 1,
  LaneLineColor_Color_YELLOW = 2,
  LaneLineColor_Color_ORANGE = 3,
  LaneLineColor_Color_BLUE = 4,
  LaneLineColor_Color_GREEN = 5,
  LaneLineColor_Color_GRAY = 6,
  LaneLineColor_Color_LETF_GRAY_RIGHT_YELLOW = 7,
  LaneLineColor_Color_LETF_YELLOW_RIGHT_WHITE = 8
};
bool LaneLineColor_Color_IsValid(int value);
const LaneLineColor_Color LaneLineColor_Color_Color_MIN = LaneLineColor_Color_UNKNOWN_LINE_COLOR;
const LaneLineColor_Color LaneLineColor_Color_Color_MAX = LaneLineColor_Color_LETF_YELLOW_RIGHT_WHITE;
const int LaneLineColor_Color_Color_ARRAYSIZE = LaneLineColor_Color_Color_MAX + 1;

const ::google::protobuf::EnumDescriptor* LaneLineColor_Color_descriptor();
inline const ::std::string& LaneLineColor_Color_Name(LaneLineColor_Color value) {
  return ::google::protobuf::internal::NameOfEnum(
    LaneLineColor_Color_descriptor(), value);
}
inline bool LaneLineColor_Color_Parse(
    const ::std::string& name, LaneLineColor_Color* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LaneLineColor_Color>(
    LaneLineColor_Color_descriptor(), name, value);
}
enum LaneLineType_Type {
  LaneLineType_Type_UNKNOWN = 0,
  LaneLineType_Type_LANELINE = 1,
  LaneLineType_Type_CURB = 2,
  LaneLineType_Type_CENTER = 3,
  LaneLineType_Type_GUARDRAIL = 4,
  LaneLineType_Type_CONCRETE_BARRIER = 5,
  LaneLineType_Type_FENCE = 6,
  LaneLineType_Type_WALL = 7,
  LaneLineType_Type_CANOPY = 8
};
bool LaneLineType_Type_IsValid(int value);
const LaneLineType_Type LaneLineType_Type_Type_MIN = LaneLineType_Type_UNKNOWN;
const LaneLineType_Type LaneLineType_Type_Type_MAX = LaneLineType_Type_CANOPY;
const int LaneLineType_Type_Type_ARRAYSIZE = LaneLineType_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* LaneLineType_Type_descriptor();
inline const ::std::string& LaneLineType_Type_Name(LaneLineType_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    LaneLineType_Type_descriptor(), value);
}
inline bool LaneLineType_Type_Parse(
    const ::std::string& name, LaneLineType_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LaneLineType_Type>(
    LaneLineType_Type_descriptor(), name, value);
}
enum LaneLineRestriction_LaneLineRestrictionType {
  LaneLineRestriction_LaneLineRestrictionType_UNKNOWN_LINE_RESTRICTION_TYPE = 0,
  LaneLineRestriction_LaneLineRestrictionType_BUS_LANE_LEFT_EDGE = 1,
  LaneLineRestriction_LaneLineRestrictionType_BUS_LANE_RIGHT_EDGE = 2,
  LaneLineRestriction_LaneLineRestrictionType_BIKE_LANE_LEFT_EDGE = 3,
  LaneLineRestriction_LaneLineRestrictionType_BIKE_LANE_RIGHT_EDGE = 4,
  LaneLineRestriction_LaneLineRestrictionType_OPPOSITE_NO_PASS = 5,
  LaneLineRestriction_LaneLineRestrictionType_OPPOSITE_CAN_PASS = 6,
  LaneLineRestriction_LaneLineRestrictionType_PEDESTRAIN_LANE_LEFT_EDGE = 7,
  LaneLineRestriction_LaneLineRestrictionType_PEDESTRAIN_LANE_RIGHT_EDGE = 8,
  LaneLineRestriction_LaneLineRestrictionType_WHITE_STRIP_ZONE_ON_LEFT = 9,
  LaneLineRestriction_LaneLineRestrictionType_WHITE_STRIP_ZONE_ON_RIGHT = 10,
  LaneLineRestriction_LaneLineRestrictionType_YELLOW_STRIP_ZONE_ON_LEFT = 11,
  LaneLineRestriction_LaneLineRestrictionType_YELLOW_STRIP_ZONE_ON_RIGHT = 12,
  LaneLineRestriction_LaneLineRestrictionType_CABLE_CAR_ON_LEFT = 13,
  LaneLineRestriction_LaneLineRestrictionType_CABLE_CAR_ON_RIGHT = 14,
  LaneLineRestriction_LaneLineRestrictionType_NO_CAR_ON_LEFT = 15,
  LaneLineRestriction_LaneLineRestrictionType_NO_CAR_ON_RIGHT = 16,
  LaneLineRestriction_LaneLineRestrictionType_EXIT_LANE_LEFT_EDGE = 17,
  LaneLineRestriction_LaneLineRestrictionType_EXIT_LANE_RIGHT_EDGE = 18,
  LaneLineRestriction_LaneLineRestrictionType_ENTRY_LANE_LEFT_EDGE = 19,
  LaneLineRestriction_LaneLineRestrictionType_ENTRY_LANE_RIGHT_EDGE = 20,
  LaneLineRestriction_LaneLineRestrictionType_HOV_LANE_LEFT_EDGE = 21,
  LaneLineRestriction_LaneLineRestrictionType_HOV_LANE_RIGHT_EDGE = 22,
  LaneLineRestriction_LaneLineRestrictionType_SIDEWALK_LEFT_EDGE = 23,
  LaneLineRestriction_LaneLineRestrictionType_SIDEWALK_RIGHT_EDGE = 24,
  LaneLineRestriction_LaneLineRestrictionType_PARKING_LANE_LEFT_EDGE = 25,
  LaneLineRestriction_LaneLineRestrictionType_PARKING_LANE_RIGHT_EDGE = 26,
  LaneLineRestriction_LaneLineRestrictionType_SHOULDER_LANE_LEFT_EDGE = 27,
  LaneLineRestriction_LaneLineRestrictionType_SHOULDER_LANE_RIGHT_EDGE = 28
};
bool LaneLineRestriction_LaneLineRestrictionType_IsValid(int value);
const LaneLineRestriction_LaneLineRestrictionType LaneLineRestriction_LaneLineRestrictionType_LaneLineRestrictionType_MIN = LaneLineRestriction_LaneLineRestrictionType_UNKNOWN_LINE_RESTRICTION_TYPE;
const LaneLineRestriction_LaneLineRestrictionType LaneLineRestriction_LaneLineRestrictionType_LaneLineRestrictionType_MAX = LaneLineRestriction_LaneLineRestrictionType_SHOULDER_LANE_RIGHT_EDGE;
const int LaneLineRestriction_LaneLineRestrictionType_LaneLineRestrictionType_ARRAYSIZE = LaneLineRestriction_LaneLineRestrictionType_LaneLineRestrictionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* LaneLineRestriction_LaneLineRestrictionType_descriptor();
inline const ::std::string& LaneLineRestriction_LaneLineRestrictionType_Name(LaneLineRestriction_LaneLineRestrictionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    LaneLineRestriction_LaneLineRestrictionType_descriptor(), value);
}
inline bool LaneLineRestriction_LaneLineRestrictionType_Parse(
    const ::std::string& name, LaneLineRestriction_LaneLineRestrictionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LaneLineRestriction_LaneLineRestrictionType>(
    LaneLineRestriction_LaneLineRestrictionType_descriptor(), name, value);
}
enum TrafficSignType_Type {
  TrafficSignType_Type_UNKNOWN = 0,
  TrafficSignType_Type_P_Stop_For = 1,
  TrafficSignType_Type_P_Slow_For = 2,
  TrafficSignType_Type_P_Give_Way = 3,
  TrafficSignType_Type_P_Noway = 4,
  TrafficSignType_Type_P_No_Entry = 5,
  TrafficSignType_Type_P_No_Parking = 6,
  TrafficSignType_Type_P_No_Long_Parking = 7,
  TrafficSignType_Type_P_Parking_Check = 8,
  TrafficSignType_Type_P_No_Motor = 9,
  TrafficSignType_Type_P_No_Motorcycle = 10,
  TrafficSignType_Type_P_No_Truck = 11,
  TrafficSignType_Type_P_No_Moto_Tricycle = 12,
  TrafficSignType_Type_P_No_Bus = 13,
  TrafficSignType_Type_P_No_Car = 14,
  TrafficSignType_Type_P_No_Trailer = 15,
  TrafficSignType_Type_P_No_Tractor = 16,
  TrafficSignType_Type_P_No_Cargo_Tricycle = 17,
  TrafficSignType_Type_P_No_Non_Motor = 18,
  TrafficSignType_Type_P_No_Animal_Vehicle = 19,
  TrafficSignType_Type_P_No_Human_Vehicle = 20,
  TrafficSignType_Type_P_No_Human_Cargo_Triangle = 21,
  TrafficSignType_Type_P_No_Human_Passenger_Triangle = 22,
  TrafficSignType_Type_P_No_Human = 23,
  TrafficSignType_Type_P_No_Left_Turn = 24,
  TrafficSignType_Type_P_No_Right_Turn = 25,
  TrafficSignType_Type_P_No_Left_Right_Turn = 26,
  TrafficSignType_Type_P_No_Foward = 27,
  TrafficSignType_Type_P_No_Forward_Left = 28,
  TrafficSignType_Type_P_No_Forward_Right = 29,
  TrafficSignType_Type_P_No_Return = 30,
  TrafficSignType_Type_P_No_Horning = 31,
  TrafficSignType_Type_P_Height_Lim = 32,
  TrafficSignType_Type_P_Width_Lim = 33,
  TrafficSignType_Type_P_Weight_Lim = 34,
  TrafficSignType_Type_P_Weight_Lim_wheel = 35,
  TrafficSignType_Type_P_Speed_Lim = 36,
  TrafficSignType_Type_P_Speed_Lim_Rev = 37,
  TrafficSignType_Type_P_No_Passing = 38,
  TrafficSignType_Type_P_No_Dangerous = 39,
  TrafficSignType_Type_P_Custom = 40,
  TrafficSignType_Type_P_Other = 41,
  TrafficSignType_Type_W_T_Shap = 42,
  TrafficSignType_Type_W_T_Shap_Left = 43,
  TrafficSignType_Type_W_T_Shap_Right = 44,
  TrafficSignType_Type_W_T_Shaps = 45,
  TrafficSignType_Type_W_Cross = 46,
  TrafficSignType_Type_W_Circle = 47,
  TrafficSignType_Type_W_Y_Left = 48,
  TrafficSignType_Type_W_Y_Right = 49,
  TrafficSignType_Type_W_YB_Left = 50,
  TrafficSignType_Type_W_YB_Right = 51,
  TrafficSignType_Type_W_Left_Turn = 52,
  TrafficSignType_Type_W_Right_Turn = 53,
  TrafficSignType_Type_W_RL_Turn = 54,
  TrafficSignType_Type_W_LR_Turn = 55,
  TrafficSignType_Type_W_Continuous_Turn = 56,
  TrafficSignType_Type_W_Up = 57,
  TrafficSignType_Type_W_Down = 58,
  TrafficSignType_Type_W_Continuous_Down = 59,
  TrafficSignType_Type_W_Accident_Prone = 60,
  TrafficSignType_Type_W_Danger = 61,
  TrafficSignType_Type_W_Left_Narrow = 62,
  TrafficSignType_Type_W_Right_Narrow = 63,
  TrafficSignType_Type_W_LR_Narrow = 64,
  TrafficSignType_Type_W_Narrow_Bridge = 65,
  TrafficSignType_Type_W_Slip = 66,
  TrafficSignType_Type_W_Pedestrain = 67,
  TrafficSignType_Type_W_Children = 68,
  TrafficSignType_Type_W_Cycle = 69,
  TrafficSignType_Type_W_Disabled = 70,
  TrafficSignType_Type_W_Side_Wind = 71,
  TrafficSignType_Type_W_Domestic = 72,
  TrafficSignType_Type_W_Animal = 73,
  TrafficSignType_Type_W_Tunnel = 74,
  TrafficSignType_Type_W_Tunnel_Headlight = 75,
  TrafficSignType_Type_W_Traffic_Light = 76,
  TrafficSignType_Type_W_Left_Falling = 77,
  TrafficSignType_Type_W_Right_Falling = 78,
  TrafficSignType_Type_W_Mount_Left = 79,
  TrafficSignType_Type_W_Mount_Right = 80,
  TrafficSignType_Type_W_Village = 81,
  TrafficSignType_Type_W_Dam_Right = 82,
  TrafficSignType_Type_W_Dam_Left = 83,
  TrafficSignType_Type_W_Ferry = 84,
  TrafficSignType_Type_W_Ford = 85,
  TrafficSignType_Type_W_Slow = 86,
  TrafficSignType_Type_W_Hump_Bridge = 87,
  TrafficSignType_Type_W_Bumpy = 88,
  TrafficSignType_Type_W_Bump = 89,
  TrafficSignType_Type_W_Low_Lying = 90,
  TrafficSignType_Type_W_Working = 91,
  TrafficSignType_Type_W_Guarded_Railway = 92,
  TrafficSignType_Type_W_Railway = 93,
  TrafficSignType_Type_W_Detour_Around = 94,
  TrafficSignType_Type_W_Detour_Left = 95,
  TrafficSignType_Type_W_Detour_Right = 96,
  TrafficSignType_Type_W_Merge_Left = 97,
  TrafficSignType_Type_W_Merge_Right = 98,
  TrafficSignType_Type_W_Two_Way = 99,
  TrafficSignType_Type_W_Tidal = 100,
  TrafficSignType_Type_W_Keep_Distance = 101,
  TrafficSignType_Type_W_Cross_Intersection = 102,
  TrafficSignType_Type_W_T_Intersection = 103,
  TrafficSignType_Type_W_Vehicle_Queue = 104,
  TrafficSignType_Type_W_Ice = 105,
  TrafficSignType_Type_W_Rain = 106,
  TrafficSignType_Type_W_Fog = 107,
  TrafficSignType_Type_W_Bad_Weather = 108,
  TrafficSignType_Type_W_Other = 109,
  TrafficSignType_Type_I_Forward = 110,
  TrafficSignType_Type_I_Left_Turn = 111,
  TrafficSignType_Type_I_Right_Turn = 112,
  TrafficSignType_Type_I_Forward_Left = 113,
  TrafficSignType_Type_I_Forward_Right = 114,
  TrafficSignType_Type_I_Left_Right = 115,
  TrafficSignType_Type_I_Right = 116,
  TrafficSignType_Type_I_Left = 117,
  TrafficSignType_Type_I_Forward_Left_Stereo = 118,
  TrafficSignType_Type_I_Forward_Right_Stereo = 119,
  TrafficSignType_Type_I_Circle = 120,
  TrafficSignType_Type_I_Walk = 121,
  TrafficSignType_Type_I_Honk = 122,
  TrafficSignType_Type_I_Min_Speed_Lim = 123,
  TrafficSignType_Type_I_Motors = 124,
  TrafficSignType_Type_I_Non_Motors = 125,
  TrafficSignType_Type_I_Pedestrian_Cross = 126,
  TrafficSignType_Type_I_Other = 127,
  TrafficSignType_Type_P_No_Passing_Rev = 128,
  TrafficSignType_Type_P_All_Speed_Limit_Cancel = 129,
  TrafficSignType_Type_W_Tripod = 130
};
bool TrafficSignType_Type_IsValid(int value);
const TrafficSignType_Type TrafficSignType_Type_Type_MIN = TrafficSignType_Type_UNKNOWN;
const TrafficSignType_Type TrafficSignType_Type_Type_MAX = TrafficSignType_Type_W_Tripod;
const int TrafficSignType_Type_Type_ARRAYSIZE = TrafficSignType_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* TrafficSignType_Type_descriptor();
inline const ::std::string& TrafficSignType_Type_Name(TrafficSignType_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    TrafficSignType_Type_descriptor(), value);
}
inline bool TrafficSignType_Type_Parse(
    const ::std::string& name, TrafficSignType_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrafficSignType_Type>(
    TrafficSignType_Type_descriptor(), name, value);
}
enum ZoneType_Type {
  ZoneType_Type_UNKNOWN = 0,
  ZoneType_Type_CIRCLE = 1,
  ZoneType_Type_CIRCLE_CUL_DE_SAC = 2,
  ZoneType_Type_POLYGON = 3,
  ZoneType_Type_KEEP_CLEAR = 4,
  ZoneType_Type_DRIVEWAY = 5,
  ZoneType_Type_PARKING_LOT = 6,
  ZoneType_Type_RAILWAY_CROSSING = 7,
  ZoneType_Type_INTERSECTION = 8,
  ZoneType_Type_PARKING_AREA = 9,
  ZoneType_Type_PICK_UP_ZONE = 10,
  ZoneType_Type_DROP_OFF_ZONE = 11,
  ZoneType_Type_ROADWORK_ZONE = 12,
  ZoneType_Type_CROSS_WALK = 13
};
bool ZoneType_Type_IsValid(int value);
const ZoneType_Type ZoneType_Type_Type_MIN = ZoneType_Type_UNKNOWN;
const ZoneType_Type ZoneType_Type_Type_MAX = ZoneType_Type_CROSS_WALK;
const int ZoneType_Type_Type_ARRAYSIZE = ZoneType_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* ZoneType_Type_descriptor();
inline const ::std::string& ZoneType_Type_Name(ZoneType_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    ZoneType_Type_descriptor(), value);
}
inline bool ZoneType_Type_Parse(
    const ::std::string& name, ZoneType_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ZoneType_Type>(
    ZoneType_Type_descriptor(), name, value);
}
enum AreaType_Type {
  AreaType_Type_UNKNOWN = 0,
  AreaType_Type_COMMUNITY = 1
};
bool AreaType_Type_IsValid(int value);
const AreaType_Type AreaType_Type_Type_MIN = AreaType_Type_UNKNOWN;
const AreaType_Type AreaType_Type_Type_MAX = AreaType_Type_COMMUNITY;
const int AreaType_Type_Type_ARRAYSIZE = AreaType_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* AreaType_Type_descriptor();
inline const ::std::string& AreaType_Type_Name(AreaType_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    AreaType_Type_descriptor(), value);
}
inline bool AreaType_Type_Parse(
    const ::std::string& name, AreaType_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AreaType_Type>(
    AreaType_Type_descriptor(), name, value);
}
enum PoleType_Type {
  PoleType_Type_UNKNOWN = 0,
  PoleType_Type_GANTRY = 1,
  PoleType_Type_SIGNPOST = 2,
  PoleType_Type_SIGNAL = 3
};
bool PoleType_Type_IsValid(int value);
const PoleType_Type PoleType_Type_Type_MIN = PoleType_Type_UNKNOWN;
const PoleType_Type PoleType_Type_Type_MAX = PoleType_Type_SIGNAL;
const int PoleType_Type_Type_ARRAYSIZE = PoleType_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* PoleType_Type_descriptor();
inline const ::std::string& PoleType_Type_Name(PoleType_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    PoleType_Type_descriptor(), value);
}
inline bool PoleType_Type_Parse(
    const ::std::string& name, PoleType_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PoleType_Type>(
    PoleType_Type_descriptor(), name, value);
}
enum LaneTransition {
  LaneTransition_Unknown = 0,
  LaneTransition_Continue = 1,
  LaneTransition_Merging = 2,
  LaneTransition_Splitting = 3,
  LaneTransition_Other = 99
};
bool LaneTransition_IsValid(int value);
const LaneTransition LaneTransition_MIN = LaneTransition_Unknown;
const LaneTransition LaneTransition_MAX = LaneTransition_Other;
const int LaneTransition_ARRAYSIZE = LaneTransition_MAX + 1;

const ::google::protobuf::EnumDescriptor* LaneTransition_descriptor();
inline const ::std::string& LaneTransition_Name(LaneTransition value) {
  return ::google::protobuf::internal::NameOfEnum(
    LaneTransition_descriptor(), value);
}
inline bool LaneTransition_Parse(
    const ::std::string& name, LaneTransition* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LaneTransition>(
    LaneTransition_descriptor(), name, value);
}
enum SpeedLimitSource {
  SpeedLimitSource_Unknown = 0,
  SpeedLimitSource_Implicit = 1,
  SpeedLimitSource_Explicit = 2
};
bool SpeedLimitSource_IsValid(int value);
const SpeedLimitSource SpeedLimitSource_MIN = SpeedLimitSource_Unknown;
const SpeedLimitSource SpeedLimitSource_MAX = SpeedLimitSource_Explicit;
const int SpeedLimitSource_ARRAYSIZE = SpeedLimitSource_MAX + 1;

const ::google::protobuf::EnumDescriptor* SpeedLimitSource_descriptor();
inline const ::std::string& SpeedLimitSource_Name(SpeedLimitSource value) {
  return ::google::protobuf::internal::NameOfEnum(
    SpeedLimitSource_descriptor(), value);
}
inline bool SpeedLimitSource_Parse(
    const ::std::string& name, SpeedLimitSource* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SpeedLimitSource>(
    SpeedLimitSource_descriptor(), name, value);
}
enum LaneLineConfidence {
  LaneLineConfidence_Unknown = 0,
  LaneLineConfidence_Normal = 1,
  LaneLineConfidence_Obscured = 2,
  LaneLineConfidence_NotClear = 3,
  LaneLineConfidence_NotAligned = 4,
  LaneLineConfidence_InterferenceLine = 5,
  LaneLineConfidence_OverlapLine = 6,
  LaneLineConfidence_MeanWhile = 7,
  LaneLineConfidence_Other = 99
};
bool LaneLineConfidence_IsValid(int value);
const LaneLineConfidence LaneLineConfidence_MIN = LaneLineConfidence_Unknown;
const LaneLineConfidence LaneLineConfidence_MAX = LaneLineConfidence_Other;
const int LaneLineConfidence_ARRAYSIZE = LaneLineConfidence_MAX + 1;

const ::google::protobuf::EnumDescriptor* LaneLineConfidence_descriptor();
inline const ::std::string& LaneLineConfidence_Name(LaneLineConfidence value) {
  return ::google::protobuf::internal::NameOfEnum(
    LaneLineConfidence_descriptor(), value);
}
inline bool LaneLineConfidence_Parse(
    const ::std::string& name, LaneLineConfidence* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LaneLineConfidence>(
    LaneLineConfidence_descriptor(), name, value);
}
enum LineMarking {
  LineMarking_Unknown = 0,
  LineMarking_SolidLine = 1,
  LineMarking_DashedLine = 2,
  LineMarking_ShortDashedLine = 3,
  LineMarking_DoubleSolidLine = 4,
  LineMarking_DoubleDashedLine = 5,
  LineMarking_LeftSolidRightDashed = 6,
  LineMarking_RightSolidLeftDashed = 7,
  LineMarking_ShadedArea = 8,
  LineMarking_LaneVirtualMarking = 9,
  LineMarking_IntersectionVirualMarking = 10,
  LineMarking_CurbVirtualMarking = 11,
  LineMarking_UnclosedRoad = 12,
  LineMarking_RoadVirtualLine = 13,
  LineMarking_Other = 99
};
bool LineMarking_IsValid(int value);
const LineMarking LineMarking_MIN = LineMarking_Unknown;
const LineMarking LineMarking_MAX = LineMarking_Other;
const int LineMarking_ARRAYSIZE = LineMarking_MAX + 1;

const ::google::protobuf::EnumDescriptor* LineMarking_descriptor();
inline const ::std::string& LineMarking_Name(LineMarking value) {
  return ::google::protobuf::internal::NameOfEnum(
    LineMarking_descriptor(), value);
}
inline bool LineMarking_Parse(
    const ::std::string& name, LineMarking* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LineMarking>(
    LineMarking_descriptor(), name, value);
}
enum SignShape {
  SignShape_Unknown = 0,
  SignShape_Rectangle = 1,
  SignShape_Triangle = 2,
  SignShape_Round = 3,
  SignShape_Diamond = 4,
  SignShape_Hexagon = 5,
  SignShape_Octagon = 6,
  SignShape_Furcation = 7,
  SignShape_Combination = 8,
  SignShape_Other = 99
};
bool SignShape_IsValid(int value);
const SignShape SignShape_MIN = SignShape_Unknown;
const SignShape SignShape_MAX = SignShape_Other;
const int SignShape_ARRAYSIZE = SignShape_MAX + 1;

const ::google::protobuf::EnumDescriptor* SignShape_descriptor();
inline const ::std::string& SignShape_Name(SignShape value) {
  return ::google::protobuf::internal::NameOfEnum(
    SignShape_descriptor(), value);
}
inline bool SignShape_Parse(
    const ::std::string& name, SignShape* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SignShape>(
    SignShape_descriptor(), name, value);
}
enum YesNoUnknown {
  YesNoUnknown_Unknown = 0,
  YesNoUnknown_Yes = 1,
  YesNoUnknown_No = 2
};
bool YesNoUnknown_IsValid(int value);
const YesNoUnknown YesNoUnknown_MIN = YesNoUnknown_Unknown;
const YesNoUnknown YesNoUnknown_MAX = YesNoUnknown_No;
const int YesNoUnknown_ARRAYSIZE = YesNoUnknown_MAX + 1;

const ::google::protobuf::EnumDescriptor* YesNoUnknown_descriptor();
inline const ::std::string& YesNoUnknown_Name(YesNoUnknown value) {
  return ::google::protobuf::internal::NameOfEnum(
    YesNoUnknown_descriptor(), value);
}
inline bool YesNoUnknown_Parse(
    const ::std::string& name, YesNoUnknown* value) {
  return ::google::protobuf::internal::ParseNamedEnum<YesNoUnknown>(
    YesNoUnknown_descriptor(), name, value);
}
enum ConditionType {
  ConditionType_conditionTypeNumeric = 0,
  ConditionType_conditionTypeVehicle = 1,
  ConditionType_conditionTypeLoad = 2,
  ConditionType_conditionTypeTimeOfDay = 3,
  ConditionType_conditionTypeWeather = 4,
  ConditionType_conditionTypeFuzzyTime = 5,
  ConditionType_conditionTypeTurnDirection = 6
};
bool ConditionType_IsValid(int value);
const ConditionType ConditionType_MIN = ConditionType_conditionTypeNumeric;
const ConditionType ConditionType_MAX = ConditionType_conditionTypeTurnDirection;
const int ConditionType_ARRAYSIZE = ConditionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ConditionType_descriptor();
inline const ::std::string& ConditionType_Name(ConditionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ConditionType_descriptor(), value);
}
inline bool ConditionType_Parse(
    const ::std::string& name, ConditionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ConditionType>(
    ConditionType_descriptor(), name, value);
}
enum Load {
  Load_loadWaterPolluting = 1,
  Load_loadExplosive = 2,
  Load_loadOtherDangerous = 3,
  Load_loadEmpty = 4,
  Load_loadSpecial = 5,
  Load_loadGasses = 6,
  Load_loadFlammableLiquids = 7,
  Load_loadFlammableSolids = 8,
  Load_loadOxidizing = 9,
  Load_loadToxicInfectious = 10,
  Load_loadRadioactive = 11,
  Load_loadCorrosive = 12
};
bool Load_IsValid(int value);
const Load Load_MIN = Load_loadWaterPolluting;
const Load Load_MAX = Load_loadCorrosive;
const int Load_ARRAYSIZE = Load_MAX + 1;

const ::google::protobuf::EnumDescriptor* Load_descriptor();
inline const ::std::string& Load_Name(Load value) {
  return ::google::protobuf::internal::NameOfEnum(
    Load_descriptor(), value);
}
inline bool Load_Parse(
    const ::std::string& name, Load* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Load>(
    Load_descriptor(), name, value);
}
enum Weather {
  Weather_Unknown = 0,
  Weather_NoSpecial = 1,
  Weather_Sunshine = 2,
  Weather_Rain = 3,
  Weather_Fog = 4,
  Weather_Snow = 5,
  Weather_Ice = 6,
  Weather_StrongWind = 7
};
bool Weather_IsValid(int value);
const Weather Weather_MIN = Weather_Unknown;
const Weather Weather_MAX = Weather_StrongWind;
const int Weather_ARRAYSIZE = Weather_MAX + 1;

const ::google::protobuf::EnumDescriptor* Weather_descriptor();
inline const ::std::string& Weather_Name(Weather value) {
  return ::google::protobuf::internal::NameOfEnum(
    Weather_descriptor(), value);
}
inline bool Weather_Parse(
    const ::std::string& name, Weather* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Weather>(
    Weather_descriptor(), name, value);
}
enum FuzzyTime {
  FuzzyTime_Unknown = 1,
  FuzzyTime_Day = 2,
  FuzzyTime_Night = 3
};
bool FuzzyTime_IsValid(int value);
const FuzzyTime FuzzyTime_MIN = FuzzyTime_Unknown;
const FuzzyTime FuzzyTime_MAX = FuzzyTime_Night;
const int FuzzyTime_ARRAYSIZE = FuzzyTime_MAX + 1;

const ::google::protobuf::EnumDescriptor* FuzzyTime_descriptor();
inline const ::std::string& FuzzyTime_Name(FuzzyTime value) {
  return ::google::protobuf::internal::NameOfEnum(
    FuzzyTime_descriptor(), value);
}
inline bool FuzzyTime_Parse(
    const ::std::string& name, FuzzyTime* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FuzzyTime>(
    FuzzyTime_descriptor(), name, value);
}
enum LaneArrowMarking {
  LaneArrowMarking_None = 0,
  LaneArrowMarking_Straight = 1,
  LaneArrowMarking_SlightRight = 2,
  LaneArrowMarking_Right = 4,
  LaneArrowMarking_HardRight = 8,
  LaneArrowMarking_UTurn = 16,
  LaneArrowMarking_HardLeft = 32,
  LaneArrowMarking_Left = 64,
  LaneArrowMarking_SlightLeft = 128,
  LaneArrowMarking_NA = -1
};
bool LaneArrowMarking_IsValid(int value);
const LaneArrowMarking LaneArrowMarking_MIN = LaneArrowMarking_NA;
const LaneArrowMarking LaneArrowMarking_MAX = LaneArrowMarking_SlightLeft;
const int LaneArrowMarking_ARRAYSIZE = LaneArrowMarking_MAX + 1;

const ::google::protobuf::EnumDescriptor* LaneArrowMarking_descriptor();
inline const ::std::string& LaneArrowMarking_Name(LaneArrowMarking value) {
  return ::google::protobuf::internal::NameOfEnum(
    LaneArrowMarking_descriptor(), value);
}
inline bool LaneArrowMarking_Parse(
    const ::std::string& name, LaneArrowMarking* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LaneArrowMarking>(
    LaneArrowMarking_descriptor(), name, value);
}
enum SpecialSituationType {
  SpecialSituationType_DeadEnd = 248,
  SpecialSituationType_FerryTerminal = 249,
  SpecialSituationType_TollBooth = 250,
  SpecialSituationType_RailroadCrossing = 251,
  SpecialSituationType_PedestrianCrossing = 252,
  SpecialSituationType_SpeedBump = 253,
  SpecialSituationType_CertifiedRoad = 254,
  SpecialSituationType_TollBooth_CertifiedRoad = 255
};
bool SpecialSituationType_IsValid(int value);
const SpecialSituationType SpecialSituationType_MIN = SpecialSituationType_DeadEnd;
const SpecialSituationType SpecialSituationType_MAX = SpecialSituationType_TollBooth_CertifiedRoad;
const int SpecialSituationType_ARRAYSIZE = SpecialSituationType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SpecialSituationType_descriptor();
inline const ::std::string& SpecialSituationType_Name(SpecialSituationType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SpecialSituationType_descriptor(), value);
}
inline bool SpecialSituationType_Parse(
    const ::std::string& name, SpecialSituationType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SpecialSituationType>(
    SpecialSituationType_descriptor(), name, value);
}
enum TrafficEventType {
  TrafficEventType_Unknown = 0,
  TrafficEventType_GeneralTrafficAccident = 7,
  TrafficEventType_SeriousTrafficAccident = 8,
  TrafficEventType_FaultyCar = 9,
  TrafficEventType_SuspectedAccident = 10,
  TrafficEventType_RoadConstruction = 11,
  TrafficEventType_ConstructionImpactTravel = 12,
  TrafficEventType_ConstructionAndPassThroughNotRecommended = 13,
  TrafficEventType_TrafficControl = 14,
  TrafficEventType_RoadClosed = 15,
  TrafficEventType_ExitRampClosed = 16,
  TrafficEventType_EntranceRampClosed = 17,
  TrafficEventType_OneLaneClosed = 18,
  TrafficEventType_TwoLanesClosed = 19,
  TrafficEventType_ThreeLanesClosed = 20,
  TrafficEventType_FourLanesClosed = 21,
  TrafficEventType_ProhibitLeftTurn = 22,
  TrafficEventType_ProhibitRightTurn = 24,
  TrafficEventType_ProhibitLeftAndRightTurn = 26,
  TrafficEventType_ProhibitStraight = 28,
  TrafficEventType_ProhibitUTurn = 30,
  TrafficEventType_RoadHeightOrWeightOrWidthLimited = 32,
  TrafficEventType_OtherVehicleRestrictions = 33,
  TrafficEventType_NoParking = 34,
  TrafficEventType_Gale = 35,
  TrafficEventType_Hurricane = 36,
  TrafficEventType_Fog = 37,
  TrafficEventType_HeavyFog = 38,
  TrafficEventType_Rain = 39,
  TrafficEventType_HeavyRain = 40,
  TrafficEventType_Sleet = 41,
  TrafficEventType_Snow = 42,
  TrafficEventType_HeavySnow = 43,
  TrafficEventType_Hail = 44,
  TrafficEventType_DestructiveHail = 45,
  TrafficEventType_ColdWave = 46,
  TrafficEventType_Sandstorm = 47,
  TrafficEventType_HighTemperature = 48,
  TrafficEventType_Drought = 49,
  TrafficEventType_Thunder = 50,
  TrafficEventType_Frost = 51,
  TrafficEventType_Haze = 52,
  TrafficEventType_Typhoon = 53,
  TrafficEventType_Thunderstorm = 54,
  TrafficEventType_ForestFire = 55,
  TrafficEventType_RoadSurfaceWater = 56,
  TrafficEventType_RoadSurfaceSnow = 57,
  TrafficEventType_RoadSurfaceThinIce = 58,
  TrafficEventType_RoadSurfaceSubsidence = 59,
  TrafficEventType_RoadSurfaceObstacle = 60,
  TrafficEventType_RoadSurfaceFire = 61,
  TrafficEventType_RoadSurfaceSlip = 62,
  TrafficEventType_RoadSurfaceOil = 63,
  TrafficEventType_RoadSurfaceGasoline = 64,
  TrafficEventType_PoorRoadConditions = 65,
  TrafficEventType_DangerousDrivingConditions = 66,
  TrafficEventType_ExtremelyDangerousDrivingConditions = 67,
  TrafficEventType_Expo = 68,
  TrafficEventType_MajorNationalEvents = 69,
  TrafficEventType_Assembly = 70,
  TrafficEventType_LargeConference = 71,
  TrafficEventType_SportsActivity = 72,
  TrafficEventType_CulturalActivity = 73,
  TrafficEventType_Holiday = 74,
  TrafficEventType_Flood = 75,
  TrafficEventType_Earthquake = 76,
  TrafficEventType_RockFall = 77,
  TrafficEventType_Collapse = 78,
  TrafficEventType_DebrisFlow = 79,
  TrafficEventType_GraspTheViolation = 80,
  TrafficEventType_CheckDrunkDriving = 81,
  TrafficEventType_PoliceEnforcement = 82,
  TrafficEventType_Announcement = 83,
  TrafficEventType_OpenToTraffic = 84,
  TrafficEventType_CompleteTheReconstruction = 85,
  TrafficEventType_RealRoadCondition = 86,
  TrafficEventType_Emergency = 87,
  TrafficEventType_SubwayEvent = 88,
  TrafficEventType_CustomBroadcast = 89,
  TrafficEventType_GeneralTrafficAccidentAndRoadClosed = 90,
  TrafficEventType_SeriousTrafficAccidentAndRoadClosed = 91,
  TrafficEventType_RoadConstructionAndRoadClosed = 92,
  TrafficEventType_HeavyFogAndRoadClosed = 93,
  TrafficEventType_HeavyRainAndRoadClosed = 94,
  TrafficEventType_HeavySnowAndRoadClosed = 95,
  TrafficEventType_HailAndRoadClosed = 96,
  TrafficEventType_RoadSurfaceWaterAndRoadClosed = 97,
  TrafficEventType_RoadSurfaceSnowAndRoadClosed = 98,
  TrafficEventType_RoadSurfaceThinIceAndRoadClosed = 99,
  TrafficEventType_RoadSurfaceSubsidenceAndRoadClosed = 100,
  TrafficEventType_RoadSurfaceObstacleAndRoadClosed = 101,
  TrafficEventType_SeriousFireAndRoadClosed = 102,
  TrafficEventType_ExpoAndRoadClosed = 103,
  TrafficEventType_MajorNationalEventsAndRoadClosed = 104,
  TrafficEventType_AssemblyAndRoadClosed = 105,
  TrafficEventType_LargeConferenceAndRoadClosed = 106,
  TrafficEventType_SportsActivityAndRoadClosed = 107,
  TrafficEventType_CulturalActivityAndRoadClosed = 108,
  TrafficEventType_HolidayAndRoadClosed = 109,
  TrafficEventType_FloodAndRoadClosed = 110,
  TrafficEventType_EarthquakeAndRoadClosed = 111,
  TrafficEventType_RockFallAndRoadClosed = 112,
  TrafficEventType_CollapseAndRoadClosed = 113,
  TrafficEventType_DebrisFlowAndRoadClosed = 114,
  TrafficEventType_Other = 999
};
bool TrafficEventType_IsValid(int value);
const TrafficEventType TrafficEventType_MIN = TrafficEventType_Unknown;
const TrafficEventType TrafficEventType_MAX = TrafficEventType_Other;
const int TrafficEventType_ARRAYSIZE = TrafficEventType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TrafficEventType_descriptor();
inline const ::std::string& TrafficEventType_Name(TrafficEventType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TrafficEventType_descriptor(), value);
}
inline bool TrafficEventType_Parse(
    const ::std::string& name, TrafficEventType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrafficEventType>(
    TrafficEventType_descriptor(), name, value);
}
enum TrafficFlowStatus {
  TrafficFlowStatus_Unknown = 0,
  TrafficFlowStatus_Smooth = 1,
  TrafficFlowStatus_Amble = 2,
  TrafficFlowStatus_Congestion = 3,
  TrafficFlowStatus_Blockage = 4,
  TrafficFlowStatus_NoTrafficFlow = 5,
  TrafficFlowStatus_Other = 99
};
bool TrafficFlowStatus_IsValid(int value);
const TrafficFlowStatus TrafficFlowStatus_MIN = TrafficFlowStatus_Unknown;
const TrafficFlowStatus TrafficFlowStatus_MAX = TrafficFlowStatus_Other;
const int TrafficFlowStatus_ARRAYSIZE = TrafficFlowStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* TrafficFlowStatus_descriptor();
inline const ::std::string& TrafficFlowStatus_Name(TrafficFlowStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    TrafficFlowStatus_descriptor(), value);
}
inline bool TrafficFlowStatus_Parse(
    const ::std::string& name, TrafficFlowStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrafficFlowStatus>(
    TrafficFlowStatus_descriptor(), name, value);
}
enum TrafficConeType {
  TrafficConeType_Unknown = 0,
  TrafficConeType_TrafficCone = 1,
  TrafficConeType_TrafficBollard = 2,
  TrafficConeType_IsolationBollard = 3,
  TrafficConeType_OtherBollard = 4,
  TrafficConeType_CrashBarrel = 5
};
bool TrafficConeType_IsValid(int value);
const TrafficConeType TrafficConeType_MIN = TrafficConeType_Unknown;
const TrafficConeType TrafficConeType_MAX = TrafficConeType_CrashBarrel;
const int TrafficConeType_ARRAYSIZE = TrafficConeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TrafficConeType_descriptor();
inline const ::std::string& TrafficConeType_Name(TrafficConeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TrafficConeType_descriptor(), value);
}
inline bool TrafficConeType_Parse(
    const ::std::string& name, TrafficConeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrafficConeType>(
    TrafficConeType_descriptor(), name, value);
}
// ===================================================================

class Id : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.Id) */ {
 public:
  Id();
  virtual ~Id();

  Id(const Id& from);

  inline Id& operator=(const Id& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Id(Id&& from) noexcept
    : Id() {
    *this = ::std::move(from);
  }

  inline Id& operator=(Id&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Id& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Id* internal_default_instance() {
    return reinterpret_cast<const Id*>(
               &_Id_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Id* other);
  friend void swap(Id& a, Id& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Id* New() const PROTOBUF_FINAL { return New(NULL); }

  Id* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Id& from);
  void MergeFrom(const Id& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Id* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required uint64 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint64 id() const;
  void set_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:ndm_proto.Id)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_name();
  void clear_has_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint64 id_;
  friend struct ::protobuf_base_2eproto::TableStruct;
  friend void ::protobuf_base_2eproto::InitDefaultsIdImpl();
};
// -------------------------------------------------------------------

class Index : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.Index) */ {
 public:
  Index();
  virtual ~Index();

  Index(const Index& from);

  inline Index& operator=(const Index& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Index(Index&& from) noexcept
    : Index() {
    *this = ::std::move(from);
  }

  inline Index& operator=(Index&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Index& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Index* internal_default_instance() {
    return reinterpret_cast<const Index*>(
               &_Index_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Index* other);
  friend void swap(Index& a, Index& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Index* New() const PROTOBUF_FINAL { return New(NULL); }

  Index* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Index& from);
  void MergeFrom(const Index& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Index* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  ::google::protobuf::uint64 x() const;
  void set_x(::google::protobuf::uint64 value);

  // required uint64 y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  ::google::protobuf::uint64 y() const;
  void set_y(::google::protobuf::uint64 value);

  // required uint64 z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  ::google::protobuf::uint64 z() const;
  void set_z(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:ndm_proto.Index)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_z();
  void clear_has_z();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint64 x_;
  ::google::protobuf::uint64 y_;
  ::google::protobuf::uint64 z_;
  friend struct ::protobuf_base_2eproto::TableStruct;
  friend void ::protobuf_base_2eproto::InitDefaultsIndexImpl();
};
// -------------------------------------------------------------------

class Link : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.Link) */ {
 public:
  Link();
  virtual ~Link();

  Link(const Link& from);

  inline Link& operator=(const Link& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Link(Link&& from) noexcept
    : Link() {
    *this = ::std::move(from);
  }

  inline Link& operator=(Link&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Link& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Link* internal_default_instance() {
    return reinterpret_cast<const Link*>(
               &_Link_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(Link* other);
  friend void swap(Link& a, Link& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Link* New() const PROTOBUF_FINAL { return New(NULL); }

  Link* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Link& from);
  void MergeFrom(const Link& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Link* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // optional float offset = 2;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 2;
  float offset() const;
  void set_offset(float value);

  // optional float end_offset = 3;
  bool has_end_offset() const;
  void clear_end_offset();
  static const int kEndOffsetFieldNumber = 3;
  float end_offset() const;
  void set_end_offset(float value);

  // @@protoc_insertion_point(class_scope:ndm_proto.Link)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_offset();
  void clear_has_offset();
  void set_has_end_offset();
  void clear_has_end_offset();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  float offset_;
  float end_offset_;
  friend struct ::protobuf_base_2eproto::TableStruct;
  friend void ::protobuf_base_2eproto::InitDefaultsLinkImpl();
};
// -------------------------------------------------------------------

class Number : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.Number) */ {
 public:
  Number();
  virtual ~Number();

  Number(const Number& from);

  inline Number& operator=(const Number& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Number(Number&& from) noexcept
    : Number() {
    *this = ::std::move(from);
  }

  inline Number& operator=(Number&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Number& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Number* internal_default_instance() {
    return reinterpret_cast<const Number*>(
               &_Number_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(Number* other);
  friend void swap(Number& a, Number& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Number* New() const PROTOBUF_FINAL { return New(NULL); }

  Number* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Number& from);
  void MergeFrom(const Number& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Number* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  float value() const;
  void set_value(float value);

  // optional float cov = 2;
  bool has_cov() const;
  void clear_cov();
  static const int kCovFieldNumber = 2;
  float cov() const;
  void set_cov(float value);

  // @@protoc_insertion_point(class_scope:ndm_proto.Number)
 private:
  void set_has_value();
  void clear_has_value();
  void set_has_cov();
  void clear_has_cov();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float value_;
  float cov_;
  friend struct ::protobuf_base_2eproto::TableStruct;
  friend void ::protobuf_base_2eproto::InitDefaultsNumberImpl();
};
// -------------------------------------------------------------------

class String : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.String) */ {
 public:
  String();
  virtual ~String();

  String(const String& from);

  inline String& operator=(const String& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  String(String&& from) noexcept
    : String() {
    *this = ::std::move(from);
  }

  inline String& operator=(String&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const String& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const String* internal_default_instance() {
    return reinterpret_cast<const String*>(
               &_String_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(String* other);
  friend void swap(String& a, String& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline String* New() const PROTOBUF_FINAL { return New(NULL); }

  String* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const String& from);
  void MergeFrom(const String& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(String* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string str = 1;
  bool has_str() const;
  void clear_str();
  static const int kStrFieldNumber = 1;
  const ::std::string& str() const;
  void set_str(const ::std::string& value);
  #if LANG_CXX11
  void set_str(::std::string&& value);
  #endif
  void set_str(const char* value);
  void set_str(const char* value, size_t size);
  ::std::string* mutable_str();
  ::std::string* release_str();
  void set_allocated_str(::std::string* str);

  // optional float cov = 2;
  bool has_cov() const;
  void clear_cov();
  static const int kCovFieldNumber = 2;
  float cov() const;
  void set_cov(float value);

  // @@protoc_insertion_point(class_scope:ndm_proto.String)
 private:
  void set_has_str();
  void clear_has_str();
  void set_has_cov();
  void clear_has_cov();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr str_;
  float cov_;
  friend struct ::protobuf_base_2eproto::TableStruct;
  friend void ::protobuf_base_2eproto::InitDefaultsStringImpl();
};
// -------------------------------------------------------------------

class Point : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.Point) */ {
 public:
  Point();
  virtual ~Point();

  Point(const Point& from);

  inline Point& operator=(const Point& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Point(Point&& from) noexcept
    : Point() {
    *this = ::std::move(from);
  }

  inline Point& operator=(Point&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Point& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Point* internal_default_instance() {
    return reinterpret_cast<const Point*>(
               &_Point_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(Point* other);
  friend void swap(Point& a, Point& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Point* New() const PROTOBUF_FINAL { return New(NULL); }

  Point* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Point& from);
  void MergeFrom(const Point& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Point* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double cov = 4;
  int cov_size() const;
  void clear_cov();
  static const int kCovFieldNumber = 4;
  double cov(int index) const;
  void set_cov(int index, double value);
  void add_cov(double value);
  const ::google::protobuf::RepeatedField< double >&
      cov() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_cov();

  // required double x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // required double y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // required double z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  double z() const;
  void set_z(double value);

  // @@protoc_insertion_point(class_scope:ndm_proto.Point)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_z();
  void clear_has_z();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< double > cov_;
  double x_;
  double y_;
  double z_;
  friend struct ::protobuf_base_2eproto::TableStruct;
  friend void ::protobuf_base_2eproto::InitDefaultsPointImpl();
};
// -------------------------------------------------------------------

class Quaternion4d : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.Quaternion4d) */ {
 public:
  Quaternion4d();
  virtual ~Quaternion4d();

  Quaternion4d(const Quaternion4d& from);

  inline Quaternion4d& operator=(const Quaternion4d& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Quaternion4d(Quaternion4d&& from) noexcept
    : Quaternion4d() {
    *this = ::std::move(from);
  }

  inline Quaternion4d& operator=(Quaternion4d&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Quaternion4d& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Quaternion4d* internal_default_instance() {
    return reinterpret_cast<const Quaternion4d*>(
               &_Quaternion4d_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(Quaternion4d* other);
  friend void swap(Quaternion4d& a, Quaternion4d& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Quaternion4d* New() const PROTOBUF_FINAL { return New(NULL); }

  Quaternion4d* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Quaternion4d& from);
  void MergeFrom(const Quaternion4d& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Quaternion4d* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double cov = 5;
  int cov_size() const;
  void clear_cov();
  static const int kCovFieldNumber = 5;
  double cov(int index) const;
  void set_cov(int index, double value);
  void add_cov(double value);
  const ::google::protobuf::RepeatedField< double >&
      cov() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_cov();

  // required double x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // required double y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // required double z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  double z() const;
  void set_z(double value);

  // required double w = 4;
  bool has_w() const;
  void clear_w();
  static const int kWFieldNumber = 4;
  double w() const;
  void set_w(double value);

  // @@protoc_insertion_point(class_scope:ndm_proto.Quaternion4d)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_z();
  void clear_has_z();
  void set_has_w();
  void clear_has_w();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< double > cov_;
  double x_;
  double y_;
  double z_;
  double w_;
  friend struct ::protobuf_base_2eproto::TableStruct;
  friend void ::protobuf_base_2eproto::InitDefaultsQuaternion4dImpl();
};
// -------------------------------------------------------------------

class Odometry : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.Odometry) */ {
 public:
  Odometry();
  virtual ~Odometry();

  Odometry(const Odometry& from);

  inline Odometry& operator=(const Odometry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Odometry(Odometry&& from) noexcept
    : Odometry() {
    *this = ::std::move(from);
  }

  inline Odometry& operator=(Odometry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Odometry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Odometry* internal_default_instance() {
    return reinterpret_cast<const Odometry*>(
               &_Odometry_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(Odometry* other);
  friend void swap(Odometry& a, Odometry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Odometry* New() const PROTOBUF_FINAL { return New(NULL); }

  Odometry* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Odometry& from);
  void MergeFrom(const Odometry& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Odometry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double pose_cov = 7;
  int pose_cov_size() const;
  void clear_pose_cov();
  static const int kPoseCovFieldNumber = 7;
  double pose_cov(int index) const;
  void set_pose_cov(int index, double value);
  void add_pose_cov(double value);
  const ::google::protobuf::RepeatedField< double >&
      pose_cov() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_pose_cov();

  // repeated double twist_cov = 10;
  int twist_cov_size() const;
  void clear_twist_cov();
  static const int kTwistCovFieldNumber = 10;
  double twist_cov(int index) const;
  void set_twist_cov(int index, double value);
  void add_twist_cov(double value);
  const ::google::protobuf::RepeatedField< double >&
      twist_cov() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_twist_cov();

  // required string frame_id = 2;
  bool has_frame_id() const;
  void clear_frame_id();
  static const int kFrameIdFieldNumber = 2;
  const ::std::string& frame_id() const;
  void set_frame_id(const ::std::string& value);
  #if LANG_CXX11
  void set_frame_id(::std::string&& value);
  #endif
  void set_frame_id(const char* value);
  void set_frame_id(const char* value, size_t size);
  ::std::string* mutable_frame_id();
  ::std::string* release_frame_id();
  void set_allocated_frame_id(::std::string* frame_id);

  // required string child_frame_id = 3;
  bool has_child_frame_id() const;
  void clear_child_frame_id();
  static const int kChildFrameIdFieldNumber = 3;
  const ::std::string& child_frame_id() const;
  void set_child_frame_id(const ::std::string& value);
  #if LANG_CXX11
  void set_child_frame_id(::std::string&& value);
  #endif
  void set_child_frame_id(const char* value);
  void set_child_frame_id(const char* value, size_t size);
  ::std::string* mutable_child_frame_id();
  ::std::string* release_child_frame_id();
  void set_allocated_child_frame_id(::std::string* child_frame_id);

  // optional string utm_zone = 11;
  bool has_utm_zone() const;
  void clear_utm_zone();
  static const int kUtmZoneFieldNumber = 11;
  const ::std::string& utm_zone() const;
  void set_utm_zone(const ::std::string& value);
  #if LANG_CXX11
  void set_utm_zone(::std::string&& value);
  #endif
  void set_utm_zone(const char* value);
  void set_utm_zone(const char* value, size_t size);
  ::std::string* mutable_utm_zone();
  ::std::string* release_utm_zone();
  void set_allocated_utm_zone(::std::string* utm_zone);

  // required .ndm_proto.Quaternion4d quaternion = 5;
  bool has_quaternion() const;
  void clear_quaternion();
  static const int kQuaternionFieldNumber = 5;
  const ::ndm_proto::Quaternion4d& quaternion() const;
  ::ndm_proto::Quaternion4d* release_quaternion();
  ::ndm_proto::Quaternion4d* mutable_quaternion();
  void set_allocated_quaternion(::ndm_proto::Quaternion4d* quaternion);

  // required .ndm_proto.Point position = 6;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 6;
  const ::ndm_proto::Point& position() const;
  ::ndm_proto::Point* release_position();
  ::ndm_proto::Point* mutable_position();
  void set_allocated_position(::ndm_proto::Point* position);

  // required .ndm_proto.Point linear_velocity = 8;
  bool has_linear_velocity() const;
  void clear_linear_velocity();
  static const int kLinearVelocityFieldNumber = 8;
  const ::ndm_proto::Point& linear_velocity() const;
  ::ndm_proto::Point* release_linear_velocity();
  ::ndm_proto::Point* mutable_linear_velocity();
  void set_allocated_linear_velocity(::ndm_proto::Point* linear_velocity);

  // required .ndm_proto.Point angular_velocity = 9;
  bool has_angular_velocity() const;
  void clear_angular_velocity();
  static const int kAngularVelocityFieldNumber = 9;
  const ::ndm_proto::Point& angular_velocity() const;
  ::ndm_proto::Point* release_angular_velocity();
  ::ndm_proto::Point* mutable_angular_velocity();
  void set_allocated_angular_velocity(::ndm_proto::Point* angular_velocity);

  // optional .ndm_proto.Point map_offset = 12;
  bool has_map_offset() const;
  void clear_map_offset();
  static const int kMapOffsetFieldNumber = 12;
  const ::ndm_proto::Point& map_offset() const;
  ::ndm_proto::Point* release_map_offset();
  ::ndm_proto::Point* mutable_map_offset();
  void set_allocated_map_offset(::ndm_proto::Point* map_offset);

  // required uint64 stamp = 1;
  bool has_stamp() const;
  void clear_stamp();
  static const int kStampFieldNumber = 1;
  ::google::protobuf::uint64 stamp() const;
  void set_stamp(::google::protobuf::uint64 value);

  // optional uint32 seq_id = 4;
  bool has_seq_id() const;
  void clear_seq_id();
  static const int kSeqIdFieldNumber = 4;
  ::google::protobuf::uint32 seq_id() const;
  void set_seq_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ndm_proto.Odometry)
 private:
  void set_has_stamp();
  void clear_has_stamp();
  void set_has_frame_id();
  void clear_has_frame_id();
  void set_has_child_frame_id();
  void clear_has_child_frame_id();
  void set_has_seq_id();
  void clear_has_seq_id();
  void set_has_quaternion();
  void clear_has_quaternion();
  void set_has_position();
  void clear_has_position();
  void set_has_linear_velocity();
  void clear_has_linear_velocity();
  void set_has_angular_velocity();
  void clear_has_angular_velocity();
  void set_has_utm_zone();
  void clear_has_utm_zone();
  void set_has_map_offset();
  void clear_has_map_offset();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< double > pose_cov_;
  ::google::protobuf::RepeatedField< double > twist_cov_;
  ::google::protobuf::internal::ArenaStringPtr frame_id_;
  ::google::protobuf::internal::ArenaStringPtr child_frame_id_;
  ::google::protobuf::internal::ArenaStringPtr utm_zone_;
  ::ndm_proto::Quaternion4d* quaternion_;
  ::ndm_proto::Point* position_;
  ::ndm_proto::Point* linear_velocity_;
  ::ndm_proto::Point* angular_velocity_;
  ::ndm_proto::Point* map_offset_;
  ::google::protobuf::uint64 stamp_;
  ::google::protobuf::uint32 seq_id_;
  friend struct ::protobuf_base_2eproto::TableStruct;
  friend void ::protobuf_base_2eproto::InitDefaultsOdometryImpl();
};
// -------------------------------------------------------------------

class WGS84 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.WGS84) */ {
 public:
  WGS84();
  virtual ~WGS84();

  WGS84(const WGS84& from);

  inline WGS84& operator=(const WGS84& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WGS84(WGS84&& from) noexcept
    : WGS84() {
    *this = ::std::move(from);
  }

  inline WGS84& operator=(WGS84&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WGS84& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WGS84* internal_default_instance() {
    return reinterpret_cast<const WGS84*>(
               &_WGS84_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(WGS84* other);
  friend void swap(WGS84& a, WGS84& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WGS84* New() const PROTOBUF_FINAL { return New(NULL); }

  WGS84* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const WGS84& from);
  void MergeFrom(const WGS84& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(WGS84* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 stamp = 1;
  bool has_stamp() const;
  void clear_stamp();
  static const int kStampFieldNumber = 1;
  ::google::protobuf::uint64 stamp() const;
  void set_stamp(::google::protobuf::uint64 value);

  // required double lat = 2;
  bool has_lat() const;
  void clear_lat();
  static const int kLatFieldNumber = 2;
  double lat() const;
  void set_lat(double value);

  // required double lon = 3;
  bool has_lon() const;
  void clear_lon();
  static const int kLonFieldNumber = 3;
  double lon() const;
  void set_lon(double value);

  // required uint64 height = 4;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 4;
  ::google::protobuf::uint64 height() const;
  void set_height(::google::protobuf::uint64 value);

  // required double yaw = 5;
  bool has_yaw() const;
  void clear_yaw();
  static const int kYawFieldNumber = 5;
  double yaw() const;
  void set_yaw(double value);

  // @@protoc_insertion_point(class_scope:ndm_proto.WGS84)
 private:
  void set_has_stamp();
  void clear_has_stamp();
  void set_has_lat();
  void clear_has_lat();
  void set_has_lon();
  void clear_has_lon();
  void set_has_height();
  void clear_has_height();
  void set_has_yaw();
  void clear_has_yaw();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint64 stamp_;
  double lat_;
  double lon_;
  ::google::protobuf::uint64 height_;
  double yaw_;
  friend struct ::protobuf_base_2eproto::TableStruct;
  friend void ::protobuf_base_2eproto::InitDefaultsWGS84Impl();
};
// -------------------------------------------------------------------

class Trajectory : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.Trajectory) */ {
 public:
  Trajectory();
  virtual ~Trajectory();

  Trajectory(const Trajectory& from);

  inline Trajectory& operator=(const Trajectory& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Trajectory(Trajectory&& from) noexcept
    : Trajectory() {
    *this = ::std::move(from);
  }

  inline Trajectory& operator=(Trajectory&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Trajectory& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Trajectory* internal_default_instance() {
    return reinterpret_cast<const Trajectory*>(
               &_Trajectory_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(Trajectory* other);
  friend void swap(Trajectory& a, Trajectory& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Trajectory* New() const PROTOBUF_FINAL { return New(NULL); }

  Trajectory* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Trajectory& from);
  void MergeFrom(const Trajectory& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Trajectory* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ndm_proto.Odometry odoms = 3;
  int odoms_size() const;
  void clear_odoms();
  static const int kOdomsFieldNumber = 3;
  const ::ndm_proto::Odometry& odoms(int index) const;
  ::ndm_proto::Odometry* mutable_odoms(int index);
  ::ndm_proto::Odometry* add_odoms();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Odometry >*
      mutable_odoms();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Odometry >&
      odoms() const;

  // repeated string road_ids = 4;
  int road_ids_size() const;
  void clear_road_ids();
  static const int kRoadIdsFieldNumber = 4;
  const ::std::string& road_ids(int index) const;
  ::std::string* mutable_road_ids(int index);
  void set_road_ids(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_road_ids(int index, ::std::string&& value);
  #endif
  void set_road_ids(int index, const char* value);
  void set_road_ids(int index, const char* value, size_t size);
  ::std::string* add_road_ids();
  void add_road_ids(const ::std::string& value);
  #if LANG_CXX11
  void add_road_ids(::std::string&& value);
  #endif
  void add_road_ids(const char* value);
  void add_road_ids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& road_ids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_road_ids();

  // repeated string lane_ids = 5;
  int lane_ids_size() const;
  void clear_lane_ids();
  static const int kLaneIdsFieldNumber = 5;
  const ::std::string& lane_ids(int index) const;
  ::std::string* mutable_lane_ids(int index);
  void set_lane_ids(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_lane_ids(int index, ::std::string&& value);
  #endif
  void set_lane_ids(int index, const char* value);
  void set_lane_ids(int index, const char* value, size_t size);
  ::std::string* add_lane_ids();
  void add_lane_ids(const ::std::string& value);
  #if LANG_CXX11
  void add_lane_ids(::std::string&& value);
  #endif
  void add_lane_ids(const char* value);
  void add_lane_ids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& lane_ids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_lane_ids();

  // required uint64 stamp = 1;
  bool has_stamp() const;
  void clear_stamp();
  static const int kStampFieldNumber = 1;
  ::google::protobuf::uint64 stamp() const;
  void set_stamp(::google::protobuf::uint64 value);

  // optional uint32 seq_id = 2;
  bool has_seq_id() const;
  void clear_seq_id();
  static const int kSeqIdFieldNumber = 2;
  ::google::protobuf::uint32 seq_id() const;
  void set_seq_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ndm_proto.Trajectory)
 private:
  void set_has_stamp();
  void clear_has_stamp();
  void set_has_seq_id();
  void clear_has_seq_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Odometry > odoms_;
  ::google::protobuf::RepeatedPtrField< ::std::string> road_ids_;
  ::google::protobuf::RepeatedPtrField< ::std::string> lane_ids_;
  ::google::protobuf::uint64 stamp_;
  ::google::protobuf::uint32 seq_id_;
  friend struct ::protobuf_base_2eproto::TableStruct;
  friend void ::protobuf_base_2eproto::InitDefaultsTrajectoryImpl();
};
// -------------------------------------------------------------------

class Cylinder : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.Cylinder) */ {
 public:
  Cylinder();
  virtual ~Cylinder();

  Cylinder(const Cylinder& from);

  inline Cylinder& operator=(const Cylinder& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Cylinder(Cylinder&& from) noexcept
    : Cylinder() {
    *this = ::std::move(from);
  }

  inline Cylinder& operator=(Cylinder&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Cylinder& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Cylinder* internal_default_instance() {
    return reinterpret_cast<const Cylinder*>(
               &_Cylinder_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(Cylinder* other);
  friend void swap(Cylinder& a, Cylinder& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Cylinder* New() const PROTOBUF_FINAL { return New(NULL); }

  Cylinder* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Cylinder& from);
  void MergeFrom(const Cylinder& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Cylinder* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ndm_proto.Point points = 1;
  int points_size() const;
  void clear_points();
  static const int kPointsFieldNumber = 1;
  const ::ndm_proto::Point& points(int index) const;
  ::ndm_proto::Point* mutable_points(int index);
  ::ndm_proto::Point* add_points();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point >*
      mutable_points();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point >&
      points() const;

  // repeated .ndm_proto.Point pred_points = 2;
  int pred_points_size() const;
  void clear_pred_points();
  static const int kPredPointsFieldNumber = 2;
  const ::ndm_proto::Point& pred_points(int index) const;
  ::ndm_proto::Point* mutable_pred_points(int index);
  ::ndm_proto::Point* add_pred_points();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point >*
      mutable_pred_points();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point >&
      pred_points() const;

  // repeated .ndm_proto.Point succ_points = 3;
  int succ_points_size() const;
  void clear_succ_points();
  static const int kSuccPointsFieldNumber = 3;
  const ::ndm_proto::Point& succ_points(int index) const;
  ::ndm_proto::Point* mutable_succ_points(int index);
  ::ndm_proto::Point* add_succ_points();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point >*
      mutable_succ_points();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point >&
      succ_points() const;

  // optional .ndm_proto.Number radius = 4;
  bool has_radius() const;
  void clear_radius();
  static const int kRadiusFieldNumber = 4;
  const ::ndm_proto::Number& radius() const;
  ::ndm_proto::Number* release_radius();
  ::ndm_proto::Number* mutable_radius();
  void set_allocated_radius(::ndm_proto::Number* radius);

  // @@protoc_insertion_point(class_scope:ndm_proto.Cylinder)
 private:
  void set_has_radius();
  void clear_has_radius();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point > points_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point > pred_points_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point > succ_points_;
  ::ndm_proto::Number* radius_;
  friend struct ::protobuf_base_2eproto::TableStruct;
  friend void ::protobuf_base_2eproto::InitDefaultsCylinderImpl();
};
// -------------------------------------------------------------------

class Circle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.Circle) */ {
 public:
  Circle();
  virtual ~Circle();

  Circle(const Circle& from);

  inline Circle& operator=(const Circle& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Circle(Circle&& from) noexcept
    : Circle() {
    *this = ::std::move(from);
  }

  inline Circle& operator=(Circle&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Circle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Circle* internal_default_instance() {
    return reinterpret_cast<const Circle*>(
               &_Circle_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(Circle* other);
  friend void swap(Circle& a, Circle& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Circle* New() const PROTOBUF_FINAL { return New(NULL); }

  Circle* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Circle& from);
  void MergeFrom(const Circle& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Circle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ndm_proto.Point center = 1;
  bool has_center() const;
  void clear_center();
  static const int kCenterFieldNumber = 1;
  const ::ndm_proto::Point& center() const;
  ::ndm_proto::Point* release_center();
  ::ndm_proto::Point* mutable_center();
  void set_allocated_center(::ndm_proto::Point* center);

  // required .ndm_proto.Point normal = 2;
  bool has_normal() const;
  void clear_normal();
  static const int kNormalFieldNumber = 2;
  const ::ndm_proto::Point& normal() const;
  ::ndm_proto::Point* release_normal();
  ::ndm_proto::Point* mutable_normal();
  void set_allocated_normal(::ndm_proto::Point* normal);

  // required .ndm_proto.Number radius = 3;
  bool has_radius() const;
  void clear_radius();
  static const int kRadiusFieldNumber = 3;
  const ::ndm_proto::Number& radius() const;
  ::ndm_proto::Number* release_radius();
  ::ndm_proto::Number* mutable_radius();
  void set_allocated_radius(::ndm_proto::Number* radius);

  // optional float edgeline_width = 5;
  bool has_edgeline_width() const;
  void clear_edgeline_width();
  static const int kEdgelineWidthFieldNumber = 5;
  float edgeline_width() const;
  void set_edgeline_width(float value);

  // @@protoc_insertion_point(class_scope:ndm_proto.Circle)
 private:
  void set_has_center();
  void clear_has_center();
  void set_has_normal();
  void clear_has_normal();
  void set_has_radius();
  void clear_has_radius();
  void set_has_edgeline_width();
  void clear_has_edgeline_width();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::ndm_proto::Point* center_;
  ::ndm_proto::Point* normal_;
  ::ndm_proto::Number* radius_;
  float edgeline_width_;
  friend struct ::protobuf_base_2eproto::TableStruct;
  friend void ::protobuf_base_2eproto::InitDefaultsCircleImpl();
};
// -------------------------------------------------------------------

class CurveLine : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.CurveLine) */ {
 public:
  CurveLine();
  virtual ~CurveLine();

  CurveLine(const CurveLine& from);

  inline CurveLine& operator=(const CurveLine& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CurveLine(CurveLine&& from) noexcept
    : CurveLine() {
    *this = ::std::move(from);
  }

  inline CurveLine& operator=(CurveLine&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CurveLine& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CurveLine* internal_default_instance() {
    return reinterpret_cast<const CurveLine*>(
               &_CurveLine_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(CurveLine* other);
  friend void swap(CurveLine& a, CurveLine& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CurveLine* New() const PROTOBUF_FINAL { return New(NULL); }

  CurveLine* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CurveLine& from);
  void MergeFrom(const CurveLine& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CurveLine* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ndm_proto.Point points = 1;
  int points_size() const;
  void clear_points();
  static const int kPointsFieldNumber = 1;
  const ::ndm_proto::Point& points(int index) const;
  ::ndm_proto::Point* mutable_points(int index);
  ::ndm_proto::Point* add_points();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point >*
      mutable_points();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point >&
      points() const;

  // repeated .ndm_proto.Point pred_points = 2;
  int pred_points_size() const;
  void clear_pred_points();
  static const int kPredPointsFieldNumber = 2;
  const ::ndm_proto::Point& pred_points(int index) const;
  ::ndm_proto::Point* mutable_pred_points(int index);
  ::ndm_proto::Point* add_pred_points();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point >*
      mutable_pred_points();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point >&
      pred_points() const;

  // repeated .ndm_proto.Point succ_points = 3;
  int succ_points_size() const;
  void clear_succ_points();
  static const int kSuccPointsFieldNumber = 3;
  const ::ndm_proto::Point& succ_points(int index) const;
  ::ndm_proto::Point* mutable_succ_points(int index);
  ::ndm_proto::Point* add_succ_points();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point >*
      mutable_succ_points();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point >&
      succ_points() const;

  // repeated uint64 index = 5;
  int index_size() const;
  void clear_index();
  static const int kIndexFieldNumber = 5;
  ::google::protobuf::uint64 index(int index) const;
  void set_index(int index, ::google::protobuf::uint64 value);
  void add_index(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      index() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_index();

  // repeated double t = 6;
  int t_size() const;
  void clear_t();
  static const int kTFieldNumber = 6;
  double t(int index) const;
  void set_t(int index, double value);
  void add_t(double value);
  const ::google::protobuf::RepeatedField< double >&
      t() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_t();

  // repeated .ndm_proto.Point x_coeff = 7;
  int x_coeff_size() const;
  void clear_x_coeff();
  static const int kXCoeffFieldNumber = 7;
  const ::ndm_proto::Point& x_coeff(int index) const;
  ::ndm_proto::Point* mutable_x_coeff(int index);
  ::ndm_proto::Point* add_x_coeff();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point >*
      mutable_x_coeff();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point >&
      x_coeff() const;

  // repeated .ndm_proto.Point y_coeff = 8;
  int y_coeff_size() const;
  void clear_y_coeff();
  static const int kYCoeffFieldNumber = 8;
  const ::ndm_proto::Point& y_coeff(int index) const;
  ::ndm_proto::Point* mutable_y_coeff(int index);
  ::ndm_proto::Point* add_y_coeff();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point >*
      mutable_y_coeff();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point >&
      y_coeff() const;

  // repeated .ndm_proto.Point z_coeff = 9;
  int z_coeff_size() const;
  void clear_z_coeff();
  static const int kZCoeffFieldNumber = 9;
  const ::ndm_proto::Point& z_coeff(int index) const;
  ::ndm_proto::Point* mutable_z_coeff(int index);
  ::ndm_proto::Point* add_z_coeff();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point >*
      mutable_z_coeff();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point >&
      z_coeff() const;

  // repeated double t_max = 10;
  int t_max_size() const;
  void clear_t_max();
  static const int kTMaxFieldNumber = 10;
  double t_max(int index) const;
  void set_t_max(int index, double value);
  void add_t_max(double value);
  const ::google::protobuf::RepeatedField< double >&
      t_max() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_t_max();

  // repeated .ndm_proto.Point up_points = 11;
  int up_points_size() const;
  void clear_up_points();
  static const int kUpPointsFieldNumber = 11;
  const ::ndm_proto::Point& up_points(int index) const;
  ::ndm_proto::Point* mutable_up_points(int index);
  ::ndm_proto::Point* add_up_points();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point >*
      mutable_up_points();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point >&
      up_points() const;

  // repeated .ndm_proto.Point h_coeff = 12;
  int h_coeff_size() const;
  void clear_h_coeff();
  static const int kHCoeffFieldNumber = 12;
  const ::ndm_proto::Point& h_coeff(int index) const;
  ::ndm_proto::Point* mutable_h_coeff(int index);
  ::ndm_proto::Point* add_h_coeff();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point >*
      mutable_h_coeff();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point >&
      h_coeff() const;

  // repeated .ndm_proto.Number pred_points_height = 13;
  int pred_points_height_size() const;
  void clear_pred_points_height();
  static const int kPredPointsHeightFieldNumber = 13;
  const ::ndm_proto::Number& pred_points_height(int index) const;
  ::ndm_proto::Number* mutable_pred_points_height(int index);
  ::ndm_proto::Number* add_pred_points_height();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Number >*
      mutable_pred_points_height();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Number >&
      pred_points_height() const;

  // optional .ndm_proto.Number width = 4;
  bool has_width() const;
  void clear_width();
  static const int kWidthFieldNumber = 4;
  const ::ndm_proto::Number& width() const;
  ::ndm_proto::Number* release_width();
  ::ndm_proto::Number* mutable_width();
  void set_allocated_width(::ndm_proto::Number* width);

  // @@protoc_insertion_point(class_scope:ndm_proto.CurveLine)
 private:
  void set_has_width();
  void clear_has_width();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point > points_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point > pred_points_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point > succ_points_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > index_;
  ::google::protobuf::RepeatedField< double > t_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point > x_coeff_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point > y_coeff_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point > z_coeff_;
  ::google::protobuf::RepeatedField< double > t_max_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point > up_points_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point > h_coeff_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Number > pred_points_height_;
  ::ndm_proto::Number* width_;
  friend struct ::protobuf_base_2eproto::TableStruct;
  friend void ::protobuf_base_2eproto::InitDefaultsCurveLineImpl();
};
// -------------------------------------------------------------------

class Polygon : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.Polygon) */ {
 public:
  Polygon();
  virtual ~Polygon();

  Polygon(const Polygon& from);

  inline Polygon& operator=(const Polygon& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Polygon(Polygon&& from) noexcept
    : Polygon() {
    *this = ::std::move(from);
  }

  inline Polygon& operator=(Polygon&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Polygon& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Polygon* internal_default_instance() {
    return reinterpret_cast<const Polygon*>(
               &_Polygon_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(Polygon* other);
  friend void swap(Polygon& a, Polygon& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Polygon* New() const PROTOBUF_FINAL { return New(NULL); }

  Polygon* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Polygon& from);
  void MergeFrom(const Polygon& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Polygon* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ndm_proto.Point points = 1;
  int points_size() const;
  void clear_points();
  static const int kPointsFieldNumber = 1;
  const ::ndm_proto::Point& points(int index) const;
  ::ndm_proto::Point* mutable_points(int index);
  ::ndm_proto::Point* add_points();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point >*
      mutable_points();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point >&
      points() const;

  // optional .ndm_proto.Point normal = 2;
  bool has_normal() const;
  void clear_normal();
  static const int kNormalFieldNumber = 2;
  const ::ndm_proto::Point& normal() const;
  ::ndm_proto::Point* release_normal();
  ::ndm_proto::Point* mutable_normal();
  void set_allocated_normal(::ndm_proto::Point* normal);

  // optional .ndm_proto.Point orientation = 4;
  bool has_orientation() const;
  void clear_orientation();
  static const int kOrientationFieldNumber = 4;
  const ::ndm_proto::Point& orientation() const;
  ::ndm_proto::Point* release_orientation();
  ::ndm_proto::Point* mutable_orientation();
  void set_allocated_orientation(::ndm_proto::Point* orientation);

  // optional float edgeline_width = 3;
  bool has_edgeline_width() const;
  void clear_edgeline_width();
  static const int kEdgelineWidthFieldNumber = 3;
  float edgeline_width() const;
  void set_edgeline_width(float value);

  // @@protoc_insertion_point(class_scope:ndm_proto.Polygon)
 private:
  void set_has_normal();
  void clear_has_normal();
  void set_has_edgeline_width();
  void clear_has_edgeline_width();
  void set_has_orientation();
  void clear_has_orientation();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point > points_;
  ::ndm_proto::Point* normal_;
  ::ndm_proto::Point* orientation_;
  float edgeline_width_;
  friend struct ::protobuf_base_2eproto::TableStruct;
  friend void ::protobuf_base_2eproto::InitDefaultsPolygonImpl();
};
// -------------------------------------------------------------------

class TrafficLightType : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.TrafficLightType) */ {
 public:
  TrafficLightType();
  virtual ~TrafficLightType();

  TrafficLightType(const TrafficLightType& from);

  inline TrafficLightType& operator=(const TrafficLightType& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TrafficLightType(TrafficLightType&& from) noexcept
    : TrafficLightType() {
    *this = ::std::move(from);
  }

  inline TrafficLightType& operator=(TrafficLightType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TrafficLightType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrafficLightType* internal_default_instance() {
    return reinterpret_cast<const TrafficLightType*>(
               &_TrafficLightType_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(TrafficLightType* other);
  friend void swap(TrafficLightType& a, TrafficLightType& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrafficLightType* New() const PROTOBUF_FINAL { return New(NULL); }

  TrafficLightType* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TrafficLightType& from);
  void MergeFrom(const TrafficLightType& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TrafficLightType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef TrafficLightType_Type Type;
  static const Type NONE =
    TrafficLightType_Type_NONE;
  static const Type CIRCLE =
    TrafficLightType_Type_CIRCLE;
  static const Type CROSS =
    TrafficLightType_Type_CROSS;
  static const Type PEDESTRIAN =
    TrafficLightType_Type_PEDESTRIAN;
  static const Type BICYCLE =
    TrafficLightType_Type_BICYCLE;
  static const Type ARROW =
    TrafficLightType_Type_ARROW;
  static const Type TIME =
    TrafficLightType_Type_TIME;
  static inline bool Type_IsValid(int value) {
    return TrafficLightType_Type_IsValid(value);
  }
  static const Type Type_MIN =
    TrafficLightType_Type_Type_MIN;
  static const Type Type_MAX =
    TrafficLightType_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    TrafficLightType_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return TrafficLightType_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return TrafficLightType_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return TrafficLightType_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .ndm_proto.TrafficLightType.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::ndm_proto::TrafficLightType_Type type() const;
  void set_type(::ndm_proto::TrafficLightType_Type value);

  // optional float conf = 2;
  bool has_conf() const;
  void clear_conf();
  static const int kConfFieldNumber = 2;
  float conf() const;
  void set_conf(float value);

  // @@protoc_insertion_point(class_scope:ndm_proto.TrafficLightType)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_conf();
  void clear_has_conf();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int type_;
  float conf_;
  friend struct ::protobuf_base_2eproto::TableStruct;
  friend void ::protobuf_base_2eproto::InitDefaultsTrafficLightTypeImpl();
};
// -------------------------------------------------------------------

class TrafficLightState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.TrafficLightState) */ {
 public:
  TrafficLightState();
  virtual ~TrafficLightState();

  TrafficLightState(const TrafficLightState& from);

  inline TrafficLightState& operator=(const TrafficLightState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TrafficLightState(TrafficLightState&& from) noexcept
    : TrafficLightState() {
    *this = ::std::move(from);
  }

  inline TrafficLightState& operator=(TrafficLightState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TrafficLightState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrafficLightState* internal_default_instance() {
    return reinterpret_cast<const TrafficLightState*>(
               &_TrafficLightState_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(TrafficLightState* other);
  friend void swap(TrafficLightState& a, TrafficLightState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrafficLightState* New() const PROTOBUF_FINAL { return New(NULL); }

  TrafficLightState* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TrafficLightState& from);
  void MergeFrom(const TrafficLightState& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TrafficLightState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef TrafficLightState_State State;
  static const State UNKNOWN =
    TrafficLightState_State_UNKNOWN;
  static const State RED =
    TrafficLightState_State_RED;
  static const State GREEN =
    TrafficLightState_State_GREEN;
  static const State BLUE =
    TrafficLightState_State_BLUE;
  static const State YELLOW =
    TrafficLightState_State_YELLOW;
  static inline bool State_IsValid(int value) {
    return TrafficLightState_State_IsValid(value);
  }
  static const State State_MIN =
    TrafficLightState_State_State_MIN;
  static const State State_MAX =
    TrafficLightState_State_State_MAX;
  static const int State_ARRAYSIZE =
    TrafficLightState_State_State_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  State_descriptor() {
    return TrafficLightState_State_descriptor();
  }
  static inline const ::std::string& State_Name(State value) {
    return TrafficLightState_State_Name(value);
  }
  static inline bool State_Parse(const ::std::string& name,
      State* value) {
    return TrafficLightState_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .ndm_proto.TrafficLightState.State state = 1;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 1;
  ::ndm_proto::TrafficLightState_State state() const;
  void set_state(::ndm_proto::TrafficLightState_State value);

  // optional float conf = 2;
  bool has_conf() const;
  void clear_conf();
  static const int kConfFieldNumber = 2;
  float conf() const;
  void set_conf(float value);

  // @@protoc_insertion_point(class_scope:ndm_proto.TrafficLightState)
 private:
  void set_has_state();
  void clear_has_state();
  void set_has_conf();
  void clear_has_conf();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int state_;
  float conf_;
  friend struct ::protobuf_base_2eproto::TableStruct;
  friend void ::protobuf_base_2eproto::InitDefaultsTrafficLightStateImpl();
};
// -------------------------------------------------------------------

class TrafficLightBulbColor : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.TrafficLightBulbColor) */ {
 public:
  TrafficLightBulbColor();
  virtual ~TrafficLightBulbColor();

  TrafficLightBulbColor(const TrafficLightBulbColor& from);

  inline TrafficLightBulbColor& operator=(const TrafficLightBulbColor& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TrafficLightBulbColor(TrafficLightBulbColor&& from) noexcept
    : TrafficLightBulbColor() {
    *this = ::std::move(from);
  }

  inline TrafficLightBulbColor& operator=(TrafficLightBulbColor&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TrafficLightBulbColor& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrafficLightBulbColor* internal_default_instance() {
    return reinterpret_cast<const TrafficLightBulbColor*>(
               &_TrafficLightBulbColor_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(TrafficLightBulbColor* other);
  friend void swap(TrafficLightBulbColor& a, TrafficLightBulbColor& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrafficLightBulbColor* New() const PROTOBUF_FINAL { return New(NULL); }

  TrafficLightBulbColor* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TrafficLightBulbColor& from);
  void MergeFrom(const TrafficLightBulbColor& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TrafficLightBulbColor* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef TrafficLightBulbColor_Color Color;
  static const Color UNKNOWN =
    TrafficLightBulbColor_Color_UNKNOWN;
  static const Color RED =
    TrafficLightBulbColor_Color_RED;
  static const Color YELLOW =
    TrafficLightBulbColor_Color_YELLOW;
  static const Color GREEN =
    TrafficLightBulbColor_Color_GREEN;
  static const Color WHITE =
    TrafficLightBulbColor_Color_WHITE;
  static inline bool Color_IsValid(int value) {
    return TrafficLightBulbColor_Color_IsValid(value);
  }
  static const Color Color_MIN =
    TrafficLightBulbColor_Color_Color_MIN;
  static const Color Color_MAX =
    TrafficLightBulbColor_Color_Color_MAX;
  static const int Color_ARRAYSIZE =
    TrafficLightBulbColor_Color_Color_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Color_descriptor() {
    return TrafficLightBulbColor_Color_descriptor();
  }
  static inline const ::std::string& Color_Name(Color value) {
    return TrafficLightBulbColor_Color_Name(value);
  }
  static inline bool Color_Parse(const ::std::string& name,
      Color* value) {
    return TrafficLightBulbColor_Color_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .ndm_proto.TrafficLightBulbColor.Color color = 1;
  bool has_color() const;
  void clear_color();
  static const int kColorFieldNumber = 1;
  ::ndm_proto::TrafficLightBulbColor_Color color() const;
  void set_color(::ndm_proto::TrafficLightBulbColor_Color value);

  // optional float conf = 2;
  bool has_conf() const;
  void clear_conf();
  static const int kConfFieldNumber = 2;
  float conf() const;
  void set_conf(float value);

  // @@protoc_insertion_point(class_scope:ndm_proto.TrafficLightBulbColor)
 private:
  void set_has_color();
  void clear_has_color();
  void set_has_conf();
  void clear_has_conf();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int color_;
  float conf_;
  friend struct ::protobuf_base_2eproto::TableStruct;
  friend void ::protobuf_base_2eproto::InitDefaultsTrafficLightBulbColorImpl();
};
// -------------------------------------------------------------------

class TrafficLightBulbShape : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.TrafficLightBulbShape) */ {
 public:
  TrafficLightBulbShape();
  virtual ~TrafficLightBulbShape();

  TrafficLightBulbShape(const TrafficLightBulbShape& from);

  inline TrafficLightBulbShape& operator=(const TrafficLightBulbShape& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TrafficLightBulbShape(TrafficLightBulbShape&& from) noexcept
    : TrafficLightBulbShape() {
    *this = ::std::move(from);
  }

  inline TrafficLightBulbShape& operator=(TrafficLightBulbShape&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TrafficLightBulbShape& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrafficLightBulbShape* internal_default_instance() {
    return reinterpret_cast<const TrafficLightBulbShape*>(
               &_TrafficLightBulbShape_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(TrafficLightBulbShape* other);
  friend void swap(TrafficLightBulbShape& a, TrafficLightBulbShape& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrafficLightBulbShape* New() const PROTOBUF_FINAL { return New(NULL); }

  TrafficLightBulbShape* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TrafficLightBulbShape& from);
  void MergeFrom(const TrafficLightBulbShape& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TrafficLightBulbShape* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef TrafficLightBulbShape_Type Type;
  static const Type UNKNOWN =
    TrafficLightBulbShape_Type_UNKNOWN;
  static const Type CIRCLE =
    TrafficLightBulbShape_Type_CIRCLE;
  static const Type LEFT_ARROW =
    TrafficLightBulbShape_Type_LEFT_ARROW;
  static const Type RIGHT_ARROW =
    TrafficLightBulbShape_Type_RIGHT_ARROW;
  static const Type UP_ARROW =
    TrafficLightBulbShape_Type_UP_ARROW;
  static const Type DOWN_ARROW =
    TrafficLightBulbShape_Type_DOWN_ARROW;
  static const Type UTURN =
    TrafficLightBulbShape_Type_UTURN;
  static const Type FORWARD_AND_LEFT =
    TrafficLightBulbShape_Type_FORWARD_AND_LEFT;
  static const Type FORWARD_AND_RIGHT =
    TrafficLightBulbShape_Type_FORWARD_AND_RIGHT;
  static inline bool Type_IsValid(int value) {
    return TrafficLightBulbShape_Type_IsValid(value);
  }
  static const Type Type_MIN =
    TrafficLightBulbShape_Type_Type_MIN;
  static const Type Type_MAX =
    TrafficLightBulbShape_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    TrafficLightBulbShape_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return TrafficLightBulbShape_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return TrafficLightBulbShape_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return TrafficLightBulbShape_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .ndm_proto.TrafficLightBulbShape.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::ndm_proto::TrafficLightBulbShape_Type type() const;
  void set_type(::ndm_proto::TrafficLightBulbShape_Type value);

  // optional float conf = 2;
  bool has_conf() const;
  void clear_conf();
  static const int kConfFieldNumber = 2;
  float conf() const;
  void set_conf(float value);

  // @@protoc_insertion_point(class_scope:ndm_proto.TrafficLightBulbShape)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_conf();
  void clear_has_conf();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int type_;
  float conf_;
  friend struct ::protobuf_base_2eproto::TableStruct;
  friend void ::protobuf_base_2eproto::InitDefaultsTrafficLightBulbShapeImpl();
};
// -------------------------------------------------------------------

class LaneMarkingType : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.LaneMarkingType) */ {
 public:
  LaneMarkingType();
  virtual ~LaneMarkingType();

  LaneMarkingType(const LaneMarkingType& from);

  inline LaneMarkingType& operator=(const LaneMarkingType& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LaneMarkingType(LaneMarkingType&& from) noexcept
    : LaneMarkingType() {
    *this = ::std::move(from);
  }

  inline LaneMarkingType& operator=(LaneMarkingType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LaneMarkingType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LaneMarkingType* internal_default_instance() {
    return reinterpret_cast<const LaneMarkingType*>(
               &_LaneMarkingType_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(LaneMarkingType* other);
  friend void swap(LaneMarkingType& a, LaneMarkingType& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LaneMarkingType* New() const PROTOBUF_FINAL { return New(NULL); }

  LaneMarkingType* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LaneMarkingType& from);
  void MergeFrom(const LaneMarkingType& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LaneMarkingType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef LaneMarkingType_Type Type;
  static const Type UNKNOWN =
    LaneMarkingType_Type_UNKNOWN;
  static const Type ARROW_LEFT =
    LaneMarkingType_Type_ARROW_LEFT;
  static const Type ARROW_FORWARD =
    LaneMarkingType_Type_ARROW_FORWARD;
  static const Type ARROW_RIGHT =
    LaneMarkingType_Type_ARROW_RIGHT;
  static const Type ARROW_LEFT_AND_FORWARD =
    LaneMarkingType_Type_ARROW_LEFT_AND_FORWARD;
  static const Type ARROW_RIGHT_AND_FORWARD =
    LaneMarkingType_Type_ARROW_RIGHT_AND_FORWARD;
  static const Type ARROW_LEFT_AND_RIGHT =
    LaneMarkingType_Type_ARROW_LEFT_AND_RIGHT;
  static const Type ARROW_U_TURN =
    LaneMarkingType_Type_ARROW_U_TURN;
  static const Type ARROW_U_TURN_AND_FORWARD =
    LaneMarkingType_Type_ARROW_U_TURN_AND_FORWARD;
  static const Type ARROW_U_TURN_AND_LEFT =
    LaneMarkingType_Type_ARROW_U_TURN_AND_LEFT;
  static const Type ARROW_MERGE_LEFT =
    LaneMarkingType_Type_ARROW_MERGE_LEFT;
  static const Type ARROW_MERGE_RIGHT =
    LaneMarkingType_Type_ARROW_MERGE_RIGHT;
  static const Type CROSSWALK_NOTICE =
    LaneMarkingType_Type_CROSSWALK_NOTICE;
  static const Type SPEED_LIMIT_LOW =
    LaneMarkingType_Type_SPEED_LIMIT_LOW;
  static const Type SPEED_LIMIT_HIGH =
    LaneMarkingType_Type_SPEED_LIMIT_HIGH;
  static const Type ARROW_NO_LEFT_TURN =
    LaneMarkingType_Type_ARROW_NO_LEFT_TURN;
  static const Type ARROW_NO_RIGHT_TURN =
    LaneMarkingType_Type_ARROW_NO_RIGHT_TURN;
  static const Type ARROW_NO_U_TURN =
    LaneMarkingType_Type_ARROW_NO_U_TURN;
  static const Type ARROW_FORWARD_AND_LEFT_AND_RIGHT =
    LaneMarkingType_Type_ARROW_FORWARD_AND_LEFT_AND_RIGHT;
  static const Type ARROW_FORWARD_AND_U_TURN_AND_LEFT =
    LaneMarkingType_Type_ARROW_FORWARD_AND_U_TURN_AND_LEFT;
  static const Type ARROW_RIGHT_AND_U_TURN =
    LaneMarkingType_Type_ARROW_RIGHT_AND_U_TURN;
  static const Type TEXT =
    LaneMarkingType_Type_TEXT;
  static const Type TIME =
    LaneMarkingType_Type_TIME;
  static const Type CHECK_FOLLOWING_DISTANCE =
    LaneMarkingType_Type_CHECK_FOLLOWING_DISTANCE;
  static const Type STOP_TO_GIVE_WAY =
    LaneMarkingType_Type_STOP_TO_GIVE_WAY;
  static const Type SLOWDOWN_TO_GIVE_WAY =
    LaneMarkingType_Type_SLOWDOWN_TO_GIVE_WAY;
  static const Type STOP_MARK =
    LaneMarkingType_Type_STOP_MARK;
  static const Type NETS =
    LaneMarkingType_Type_NETS;
  static inline bool Type_IsValid(int value) {
    return LaneMarkingType_Type_IsValid(value);
  }
  static const Type Type_MIN =
    LaneMarkingType_Type_Type_MIN;
  static const Type Type_MAX =
    LaneMarkingType_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    LaneMarkingType_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return LaneMarkingType_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return LaneMarkingType_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return LaneMarkingType_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .ndm_proto.LaneMarkingType.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::ndm_proto::LaneMarkingType_Type type() const;
  void set_type(::ndm_proto::LaneMarkingType_Type value);

  // optional float conf = 2;
  bool has_conf() const;
  void clear_conf();
  static const int kConfFieldNumber = 2;
  float conf() const;
  void set_conf(float value);

  // @@protoc_insertion_point(class_scope:ndm_proto.LaneMarkingType)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_conf();
  void clear_has_conf();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int type_;
  float conf_;
  friend struct ::protobuf_base_2eproto::TableStruct;
  friend void ::protobuf_base_2eproto::InitDefaultsLaneMarkingTypeImpl();
};
// -------------------------------------------------------------------

class LaneFunction : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.LaneFunction) */ {
 public:
  LaneFunction();
  virtual ~LaneFunction();

  LaneFunction(const LaneFunction& from);

  inline LaneFunction& operator=(const LaneFunction& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LaneFunction(LaneFunction&& from) noexcept
    : LaneFunction() {
    *this = ::std::move(from);
  }

  inline LaneFunction& operator=(LaneFunction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LaneFunction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LaneFunction* internal_default_instance() {
    return reinterpret_cast<const LaneFunction*>(
               &_LaneFunction_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void Swap(LaneFunction* other);
  friend void swap(LaneFunction& a, LaneFunction& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LaneFunction* New() const PROTOBUF_FINAL { return New(NULL); }

  LaneFunction* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LaneFunction& from);
  void MergeFrom(const LaneFunction& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LaneFunction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef LaneFunction_Function Function;
  static const Function NONE =
    LaneFunction_Function_NONE;
  static const Function CITY_DRIVING =
    LaneFunction_Function_CITY_DRIVING;
  static const Function HIGH_DRIVING =
    LaneFunction_Function_HIGH_DRIVING;
  static const Function BIKING =
    LaneFunction_Function_BIKING;
  static const Function SIDEWALK =
    LaneFunction_Function_SIDEWALK;
  static const Function PARKING =
    LaneFunction_Function_PARKING;
  static const Function RAMP =
    LaneFunction_Function_RAMP;
  static const Function EMERGENCY =
    LaneFunction_Function_EMERGENCY;
  static const Function ACCELERATION =
    LaneFunction_Function_ACCELERATION;
  static inline bool Function_IsValid(int value) {
    return LaneFunction_Function_IsValid(value);
  }
  static const Function Function_MIN =
    LaneFunction_Function_Function_MIN;
  static const Function Function_MAX =
    LaneFunction_Function_Function_MAX;
  static const int Function_ARRAYSIZE =
    LaneFunction_Function_Function_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Function_descriptor() {
    return LaneFunction_Function_descriptor();
  }
  static inline const ::std::string& Function_Name(Function value) {
    return LaneFunction_Function_Name(value);
  }
  static inline bool Function_Parse(const ::std::string& name,
      Function* value) {
    return LaneFunction_Function_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .ndm_proto.LaneFunction.Function function = 1;
  bool has_function() const;
  void clear_function();
  static const int kFunctionFieldNumber = 1;
  ::ndm_proto::LaneFunction_Function function() const;
  void set_function(::ndm_proto::LaneFunction_Function value);

  // optional float conf = 2;
  bool has_conf() const;
  void clear_conf();
  static const int kConfFieldNumber = 2;
  float conf() const;
  void set_conf(float value);

  // @@protoc_insertion_point(class_scope:ndm_proto.LaneFunction)
 private:
  void set_has_function();
  void clear_has_function();
  void set_has_conf();
  void clear_has_conf();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int function_;
  float conf_;
  friend struct ::protobuf_base_2eproto::TableStruct;
  friend void ::protobuf_base_2eproto::InitDefaultsLaneFunctionImpl();
};
// -------------------------------------------------------------------

class LaneDirection : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.LaneDirection) */ {
 public:
  LaneDirection();
  virtual ~LaneDirection();

  LaneDirection(const LaneDirection& from);

  inline LaneDirection& operator=(const LaneDirection& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LaneDirection(LaneDirection&& from) noexcept
    : LaneDirection() {
    *this = ::std::move(from);
  }

  inline LaneDirection& operator=(LaneDirection&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LaneDirection& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LaneDirection* internal_default_instance() {
    return reinterpret_cast<const LaneDirection*>(
               &_LaneDirection_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  void Swap(LaneDirection* other);
  friend void swap(LaneDirection& a, LaneDirection& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LaneDirection* New() const PROTOBUF_FINAL { return New(NULL); }

  LaneDirection* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LaneDirection& from);
  void MergeFrom(const LaneDirection& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LaneDirection* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef LaneDirection_Direction Direction;
  static const Direction FORWARD =
    LaneDirection_Direction_FORWARD;
  static const Direction BACKWARD =
    LaneDirection_Direction_BACKWARD;
  static const Direction BIDIRECTION =
    LaneDirection_Direction_BIDIRECTION;
  static const Direction TIDAL =
    LaneDirection_Direction_TIDAL;
  static const Direction NONE =
    LaneDirection_Direction_NONE;
  static inline bool Direction_IsValid(int value) {
    return LaneDirection_Direction_IsValid(value);
  }
  static const Direction Direction_MIN =
    LaneDirection_Direction_Direction_MIN;
  static const Direction Direction_MAX =
    LaneDirection_Direction_Direction_MAX;
  static const int Direction_ARRAYSIZE =
    LaneDirection_Direction_Direction_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Direction_descriptor() {
    return LaneDirection_Direction_descriptor();
  }
  static inline const ::std::string& Direction_Name(Direction value) {
    return LaneDirection_Direction_Name(value);
  }
  static inline bool Direction_Parse(const ::std::string& name,
      Direction* value) {
    return LaneDirection_Direction_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional float conf = 2;
  bool has_conf() const;
  void clear_conf();
  static const int kConfFieldNumber = 2;
  float conf() const;
  void set_conf(float value);

  // required .ndm_proto.LaneDirection.Direction direction = 1;
  bool has_direction() const;
  void clear_direction();
  static const int kDirectionFieldNumber = 1;
  ::ndm_proto::LaneDirection_Direction direction() const;
  void set_direction(::ndm_proto::LaneDirection_Direction value);

  // @@protoc_insertion_point(class_scope:ndm_proto.LaneDirection)
 private:
  void set_has_direction();
  void clear_has_direction();
  void set_has_conf();
  void clear_has_conf();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float conf_;
  int direction_;
  friend struct ::protobuf_base_2eproto::TableStruct;
  friend void ::protobuf_base_2eproto::InitDefaultsLaneDirectionImpl();
};
// -------------------------------------------------------------------

class LaneAttr : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.LaneAttr) */ {
 public:
  LaneAttr();
  virtual ~LaneAttr();

  LaneAttr(const LaneAttr& from);

  inline LaneAttr& operator=(const LaneAttr& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LaneAttr(LaneAttr&& from) noexcept
    : LaneAttr() {
    *this = ::std::move(from);
  }

  inline LaneAttr& operator=(LaneAttr&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LaneAttr& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LaneAttr* internal_default_instance() {
    return reinterpret_cast<const LaneAttr*>(
               &_LaneAttr_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    21;

  void Swap(LaneAttr* other);
  friend void swap(LaneAttr& a, LaneAttr& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LaneAttr* New() const PROTOBUF_FINAL { return New(NULL); }

  LaneAttr* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LaneAttr& from);
  void MergeFrom(const LaneAttr& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LaneAttr* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float curvature = 1;
  bool has_curvature() const;
  void clear_curvature();
  static const int kCurvatureFieldNumber = 1;
  float curvature() const;
  void set_curvature(float value);

  // required float slope = 2;
  bool has_slope() const;
  void clear_slope();
  static const int kSlopeFieldNumber = 2;
  float slope() const;
  void set_slope(float value);

  // required float banking = 3;
  bool has_banking() const;
  void clear_banking();
  static const int kBankingFieldNumber = 3;
  float banking() const;
  void set_banking(float value);

  // required float headingAngle = 4;
  bool has_headingangle() const;
  void clear_headingangle();
  static const int kHeadingAngleFieldNumber = 4;
  float headingangle() const;
  void set_headingangle(float value);

  // required float offset = 5;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 5;
  float offset() const;
  void set_offset(float value);

  // @@protoc_insertion_point(class_scope:ndm_proto.LaneAttr)
 private:
  void set_has_curvature();
  void clear_has_curvature();
  void set_has_slope();
  void clear_has_slope();
  void set_has_banking();
  void clear_has_banking();
  void set_has_headingangle();
  void clear_has_headingangle();
  void set_has_offset();
  void clear_has_offset();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float curvature_;
  float slope_;
  float banking_;
  float headingangle_;
  float offset_;
  friend struct ::protobuf_base_2eproto::TableStruct;
  friend void ::protobuf_base_2eproto::InitDefaultsLaneAttrImpl();
};
// -------------------------------------------------------------------

class VehicleType : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.VehicleType) */ {
 public:
  VehicleType();
  virtual ~VehicleType();

  VehicleType(const VehicleType& from);

  inline VehicleType& operator=(const VehicleType& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VehicleType(VehicleType&& from) noexcept
    : VehicleType() {
    *this = ::std::move(from);
  }

  inline VehicleType& operator=(VehicleType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VehicleType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VehicleType* internal_default_instance() {
    return reinterpret_cast<const VehicleType*>(
               &_VehicleType_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    22;

  void Swap(VehicleType* other);
  friend void swap(VehicleType& a, VehicleType& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VehicleType* New() const PROTOBUF_FINAL { return New(NULL); }

  VehicleType* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const VehicleType& from);
  void MergeFrom(const VehicleType& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(VehicleType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef VehicleType_Type Type;
  static const Type VEHICLE_TYPE_UNKNOWN =
    VehicleType_Type_VEHICLE_TYPE_UNKNOWN;
  static const Type CAR =
    VehicleType_Type_CAR;
  static const Type MOTORCYCLE =
    VehicleType_Type_MOTORCYCLE;
  static const Type BICYCLE =
    VehicleType_Type_BICYCLE;
  static const Type TRUCK =
    VehicleType_Type_TRUCK;
  static const Type TAXI =
    VehicleType_Type_TAXI;
  static const Type BUS =
    VehicleType_Type_BUS;
  static const Type PEDESTRAIN =
    VehicleType_Type_PEDESTRAIN;
  static const Type CABLE_CAR =
    VehicleType_Type_CABLE_CAR;
  static inline bool Type_IsValid(int value) {
    return VehicleType_Type_IsValid(value);
  }
  static const Type Type_MIN =
    VehicleType_Type_Type_MIN;
  static const Type Type_MAX =
    VehicleType_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    VehicleType_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return VehicleType_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return VehicleType_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return VehicleType_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .ndm_proto.VehicleType.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::ndm_proto::VehicleType_Type type() const;
  void set_type(::ndm_proto::VehicleType_Type value);

  // optional float conf = 2;
  bool has_conf() const;
  void clear_conf();
  static const int kConfFieldNumber = 2;
  float conf() const;
  void set_conf(float value);

  // @@protoc_insertion_point(class_scope:ndm_proto.VehicleType)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_conf();
  void clear_has_conf();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int type_;
  float conf_;
  friend struct ::protobuf_base_2eproto::TableStruct;
  friend void ::protobuf_base_2eproto::InitDefaultsVehicleTypeImpl();
};
// -------------------------------------------------------------------

class SpeedLimit : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.SpeedLimit) */ {
 public:
  SpeedLimit();
  virtual ~SpeedLimit();

  SpeedLimit(const SpeedLimit& from);

  inline SpeedLimit& operator=(const SpeedLimit& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SpeedLimit(SpeedLimit&& from) noexcept
    : SpeedLimit() {
    *this = ::std::move(from);
  }

  inline SpeedLimit& operator=(SpeedLimit&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SpeedLimit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SpeedLimit* internal_default_instance() {
    return reinterpret_cast<const SpeedLimit*>(
               &_SpeedLimit_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    23;

  void Swap(SpeedLimit* other);
  friend void swap(SpeedLimit& a, SpeedLimit& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SpeedLimit* New() const PROTOBUF_FINAL { return New(NULL); }

  SpeedLimit* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SpeedLimit& from);
  void MergeFrom(const SpeedLimit& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SpeedLimit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ndm_proto.LaneMarkingType limit_type = 1;
  bool has_limit_type() const;
  void clear_limit_type();
  static const int kLimitTypeFieldNumber = 1;
  const ::ndm_proto::LaneMarkingType& limit_type() const;
  ::ndm_proto::LaneMarkingType* release_limit_type();
  ::ndm_proto::LaneMarkingType* mutable_limit_type();
  void set_allocated_limit_type(::ndm_proto::LaneMarkingType* limit_type);

  // required .ndm_proto.Number speed_value = 2;
  bool has_speed_value() const;
  void clear_speed_value();
  static const int kSpeedValueFieldNumber = 2;
  const ::ndm_proto::Number& speed_value() const;
  ::ndm_proto::Number* release_speed_value();
  ::ndm_proto::Number* mutable_speed_value();
  void set_allocated_speed_value(::ndm_proto::Number* speed_value);

  // optional .ndm_proto.SpeedLimitSource source = 3;
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 3;
  ::ndm_proto::SpeedLimitSource source() const;
  void set_source(::ndm_proto::SpeedLimitSource value);

  // optional float offset = 4;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 4;
  float offset() const;
  void set_offset(float value);

  // optional float end_offset = 5;
  bool has_end_offset() const;
  void clear_end_offset();
  static const int kEndOffsetFieldNumber = 5;
  float end_offset() const;
  void set_end_offset(float value);

  // @@protoc_insertion_point(class_scope:ndm_proto.SpeedLimit)
 private:
  void set_has_limit_type();
  void clear_has_limit_type();
  void set_has_speed_value();
  void clear_has_speed_value();
  void set_has_source();
  void clear_has_source();
  void set_has_offset();
  void clear_has_offset();
  void set_has_end_offset();
  void clear_has_end_offset();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::ndm_proto::LaneMarkingType* limit_type_;
  ::ndm_proto::Number* speed_value_;
  int source_;
  float offset_;
  float end_offset_;
  friend struct ::protobuf_base_2eproto::TableStruct;
  friend void ::protobuf_base_2eproto::InitDefaultsSpeedLimitImpl();
};
// -------------------------------------------------------------------

class TimeLimit : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.TimeLimit) */ {
 public:
  TimeLimit();
  virtual ~TimeLimit();

  TimeLimit(const TimeLimit& from);

  inline TimeLimit& operator=(const TimeLimit& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TimeLimit(TimeLimit&& from) noexcept
    : TimeLimit() {
    *this = ::std::move(from);
  }

  inline TimeLimit& operator=(TimeLimit&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TimeLimit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TimeLimit* internal_default_instance() {
    return reinterpret_cast<const TimeLimit*>(
               &_TimeLimit_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    24;

  void Swap(TimeLimit* other);
  friend void swap(TimeLimit& a, TimeLimit& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TimeLimit* New() const PROTOBUF_FINAL { return New(NULL); }

  TimeLimit* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TimeLimit& from);
  void MergeFrom(const TimeLimit& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TimeLimit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ndm_proto.Number time_begin = 1;
  bool has_time_begin() const;
  void clear_time_begin();
  static const int kTimeBeginFieldNumber = 1;
  const ::ndm_proto::Number& time_begin() const;
  ::ndm_proto::Number* release_time_begin();
  ::ndm_proto::Number* mutable_time_begin();
  void set_allocated_time_begin(::ndm_proto::Number* time_begin);

  // required .ndm_proto.Number time_end = 2;
  bool has_time_end() const;
  void clear_time_end();
  static const int kTimeEndFieldNumber = 2;
  const ::ndm_proto::Number& time_end() const;
  ::ndm_proto::Number* release_time_end();
  ::ndm_proto::Number* mutable_time_end();
  void set_allocated_time_end(::ndm_proto::Number* time_end);

  // @@protoc_insertion_point(class_scope:ndm_proto.TimeLimit)
 private:
  void set_has_time_begin();
  void clear_has_time_begin();
  void set_has_time_end();
  void clear_has_time_end();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::ndm_proto::Number* time_begin_;
  ::ndm_proto::Number* time_end_;
  friend struct ::protobuf_base_2eproto::TableStruct;
  friend void ::protobuf_base_2eproto::InitDefaultsTimeLimitImpl();
};
// -------------------------------------------------------------------

class LaneRestriction : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.LaneRestriction) */ {
 public:
  LaneRestriction();
  virtual ~LaneRestriction();

  LaneRestriction(const LaneRestriction& from);

  inline LaneRestriction& operator=(const LaneRestriction& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LaneRestriction(LaneRestriction&& from) noexcept
    : LaneRestriction() {
    *this = ::std::move(from);
  }

  inline LaneRestriction& operator=(LaneRestriction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LaneRestriction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LaneRestriction* internal_default_instance() {
    return reinterpret_cast<const LaneRestriction*>(
               &_LaneRestriction_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    25;

  void Swap(LaneRestriction* other);
  friend void swap(LaneRestriction& a, LaneRestriction& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LaneRestriction* New() const PROTOBUF_FINAL { return New(NULL); }

  LaneRestriction* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LaneRestriction& from);
  void MergeFrom(const LaneRestriction& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LaneRestriction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ndm_proto.VehicleType vehicle_types = 1;
  int vehicle_types_size() const;
  void clear_vehicle_types();
  static const int kVehicleTypesFieldNumber = 1;
  const ::ndm_proto::VehicleType& vehicle_types(int index) const;
  ::ndm_proto::VehicleType* mutable_vehicle_types(int index);
  ::ndm_proto::VehicleType* add_vehicle_types();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::VehicleType >*
      mutable_vehicle_types();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::VehicleType >&
      vehicle_types() const;

  // repeated .ndm_proto.SpeedLimit speed_limits = 2;
  int speed_limits_size() const;
  void clear_speed_limits();
  static const int kSpeedLimitsFieldNumber = 2;
  const ::ndm_proto::SpeedLimit& speed_limits(int index) const;
  ::ndm_proto::SpeedLimit* mutable_speed_limits(int index);
  ::ndm_proto::SpeedLimit* add_speed_limits();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::SpeedLimit >*
      mutable_speed_limits();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::SpeedLimit >&
      speed_limits() const;

  // repeated .ndm_proto.TimeLimit time_limits = 3;
  int time_limits_size() const;
  void clear_time_limits();
  static const int kTimeLimitsFieldNumber = 3;
  const ::ndm_proto::TimeLimit& time_limits(int index) const;
  ::ndm_proto::TimeLimit* mutable_time_limits(int index);
  ::ndm_proto::TimeLimit* add_time_limits();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::TimeLimit >*
      mutable_time_limits();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::TimeLimit >&
      time_limits() const;

  // repeated .ndm_proto.LaneMarkingType lanemarking_types = 4;
  int lanemarking_types_size() const;
  void clear_lanemarking_types();
  static const int kLanemarkingTypesFieldNumber = 4;
  const ::ndm_proto::LaneMarkingType& lanemarking_types(int index) const;
  ::ndm_proto::LaneMarkingType* mutable_lanemarking_types(int index);
  ::ndm_proto::LaneMarkingType* add_lanemarking_types();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::LaneMarkingType >*
      mutable_lanemarking_types();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::LaneMarkingType >&
      lanemarking_types() const;

  // repeated .ndm_proto.TrafficSignType trafficsign_types = 5;
  int trafficsign_types_size() const;
  void clear_trafficsign_types();
  static const int kTrafficsignTypesFieldNumber = 5;
  const ::ndm_proto::TrafficSignType& trafficsign_types(int index) const;
  ::ndm_proto::TrafficSignType* mutable_trafficsign_types(int index);
  ::ndm_proto::TrafficSignType* add_trafficsign_types();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::TrafficSignType >*
      mutable_trafficsign_types();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::TrafficSignType >&
      trafficsign_types() const;

  // optional .ndm_proto.Number weight_limit = 10;
  bool has_weight_limit() const;
  void clear_weight_limit();
  static const int kWeightLimitFieldNumber = 10;
  const ::ndm_proto::Number& weight_limit() const;
  ::ndm_proto::Number* release_weight_limit();
  ::ndm_proto::Number* mutable_weight_limit();
  void set_allocated_weight_limit(::ndm_proto::Number* weight_limit);

  // optional .ndm_proto.Number height_limit = 11;
  bool has_height_limit() const;
  void clear_height_limit();
  static const int kHeightLimitFieldNumber = 11;
  const ::ndm_proto::Number& height_limit() const;
  ::ndm_proto::Number* release_height_limit();
  ::ndm_proto::Number* mutable_height_limit();
  void set_allocated_height_limit(::ndm_proto::Number* height_limit);

  // @@protoc_insertion_point(class_scope:ndm_proto.LaneRestriction)
 private:
  void set_has_weight_limit();
  void clear_has_weight_limit();
  void set_has_height_limit();
  void clear_has_height_limit();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::VehicleType > vehicle_types_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::SpeedLimit > speed_limits_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::TimeLimit > time_limits_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::LaneMarkingType > lanemarking_types_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::TrafficSignType > trafficsign_types_;
  ::ndm_proto::Number* weight_limit_;
  ::ndm_proto::Number* height_limit_;
  friend struct ::protobuf_base_2eproto::TableStruct;
  friend void ::protobuf_base_2eproto::InitDefaultsLaneRestrictionImpl();
};
// -------------------------------------------------------------------

class LanePriority : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.LanePriority) */ {
 public:
  LanePriority();
  virtual ~LanePriority();

  LanePriority(const LanePriority& from);

  inline LanePriority& operator=(const LanePriority& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LanePriority(LanePriority&& from) noexcept
    : LanePriority() {
    *this = ::std::move(from);
  }

  inline LanePriority& operator=(LanePriority&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LanePriority& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LanePriority* internal_default_instance() {
    return reinterpret_cast<const LanePriority*>(
               &_LanePriority_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    26;

  void Swap(LanePriority* other);
  friend void swap(LanePriority& a, LanePriority& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LanePriority* New() const PROTOBUF_FINAL { return New(NULL); }

  LanePriority* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LanePriority& from);
  void MergeFrom(const LanePriority& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LanePriority* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef LanePriority_Priority Priority;
  static const Priority LANE_PRIORITY_UNKNOWN =
    LanePriority_Priority_LANE_PRIORITY_UNKNOWN;
  static const Priority LANE_PRIORITY_HIGHER =
    LanePriority_Priority_LANE_PRIORITY_HIGHER;
  static const Priority LANE_PRIORITY_EQUAL =
    LanePriority_Priority_LANE_PRIORITY_EQUAL;
  static const Priority LANE_PRIORITY_LOWER =
    LanePriority_Priority_LANE_PRIORITY_LOWER;
  static const Priority LANE_PRIORITY_CONTROLLED_BY_SIGNAL =
    LanePriority_Priority_LANE_PRIORITY_CONTROLLED_BY_SIGNAL;
  static const Priority LANE_PRIORITY_CONTROLLED_BY_STOPLINE =
    LanePriority_Priority_LANE_PRIORITY_CONTROLLED_BY_STOPLINE;
  static inline bool Priority_IsValid(int value) {
    return LanePriority_Priority_IsValid(value);
  }
  static const Priority Priority_MIN =
    LanePriority_Priority_Priority_MIN;
  static const Priority Priority_MAX =
    LanePriority_Priority_Priority_MAX;
  static const int Priority_ARRAYSIZE =
    LanePriority_Priority_Priority_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Priority_descriptor() {
    return LanePriority_Priority_descriptor();
  }
  static inline const ::std::string& Priority_Name(Priority value) {
    return LanePriority_Priority_Name(value);
  }
  static inline bool Priority_Parse(const ::std::string& name,
      Priority* value) {
    return LanePriority_Priority_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .ndm_proto.LanePriority.Priority priority = 1;
  bool has_priority() const;
  void clear_priority();
  static const int kPriorityFieldNumber = 1;
  ::ndm_proto::LanePriority_Priority priority() const;
  void set_priority(::ndm_proto::LanePriority_Priority value);

  // optional float conf = 2;
  bool has_conf() const;
  void clear_conf();
  static const int kConfFieldNumber = 2;
  float conf() const;
  void set_conf(float value);

  // @@protoc_insertion_point(class_scope:ndm_proto.LanePriority)
 private:
  void set_has_priority();
  void clear_has_priority();
  void set_has_conf();
  void clear_has_conf();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int priority_;
  float conf_;
  friend struct ::protobuf_base_2eproto::TableStruct;
  friend void ::protobuf_base_2eproto::InitDefaultsLanePriorityImpl();
};
// -------------------------------------------------------------------

class LaneLineColor : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.LaneLineColor) */ {
 public:
  LaneLineColor();
  virtual ~LaneLineColor();

  LaneLineColor(const LaneLineColor& from);

  inline LaneLineColor& operator=(const LaneLineColor& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LaneLineColor(LaneLineColor&& from) noexcept
    : LaneLineColor() {
    *this = ::std::move(from);
  }

  inline LaneLineColor& operator=(LaneLineColor&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LaneLineColor& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LaneLineColor* internal_default_instance() {
    return reinterpret_cast<const LaneLineColor*>(
               &_LaneLineColor_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    27;

  void Swap(LaneLineColor* other);
  friend void swap(LaneLineColor& a, LaneLineColor& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LaneLineColor* New() const PROTOBUF_FINAL { return New(NULL); }

  LaneLineColor* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LaneLineColor& from);
  void MergeFrom(const LaneLineColor& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LaneLineColor* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef LaneLineColor_Color Color;
  static const Color UNKNOWN_LINE_COLOR =
    LaneLineColor_Color_UNKNOWN_LINE_COLOR;
  static const Color WHITE =
    LaneLineColor_Color_WHITE;
  static const Color YELLOW =
    LaneLineColor_Color_YELLOW;
  static const Color ORANGE =
    LaneLineColor_Color_ORANGE;
  static const Color BLUE =
    LaneLineColor_Color_BLUE;
  static const Color GREEN =
    LaneLineColor_Color_GREEN;
  static const Color GRAY =
    LaneLineColor_Color_GRAY;
  static const Color LETF_GRAY_RIGHT_YELLOW =
    LaneLineColor_Color_LETF_GRAY_RIGHT_YELLOW;
  static const Color LETF_YELLOW_RIGHT_WHITE =
    LaneLineColor_Color_LETF_YELLOW_RIGHT_WHITE;
  static inline bool Color_IsValid(int value) {
    return LaneLineColor_Color_IsValid(value);
  }
  static const Color Color_MIN =
    LaneLineColor_Color_Color_MIN;
  static const Color Color_MAX =
    LaneLineColor_Color_Color_MAX;
  static const int Color_ARRAYSIZE =
    LaneLineColor_Color_Color_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Color_descriptor() {
    return LaneLineColor_Color_descriptor();
  }
  static inline const ::std::string& Color_Name(Color value) {
    return LaneLineColor_Color_Name(value);
  }
  static inline bool Color_Parse(const ::std::string& name,
      Color* value) {
    return LaneLineColor_Color_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .ndm_proto.LaneLineColor.Color color = 1;
  bool has_color() const;
  void clear_color();
  static const int kColorFieldNumber = 1;
  ::ndm_proto::LaneLineColor_Color color() const;
  void set_color(::ndm_proto::LaneLineColor_Color value);

  // optional float conf = 2;
  bool has_conf() const;
  void clear_conf();
  static const int kConfFieldNumber = 2;
  float conf() const;
  void set_conf(float value);

  // @@protoc_insertion_point(class_scope:ndm_proto.LaneLineColor)
 private:
  void set_has_color();
  void clear_has_color();
  void set_has_conf();
  void clear_has_conf();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int color_;
  float conf_;
  friend struct ::protobuf_base_2eproto::TableStruct;
  friend void ::protobuf_base_2eproto::InitDefaultsLaneLineColorImpl();
};
// -------------------------------------------------------------------

class LaneLineType : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.LaneLineType) */ {
 public:
  LaneLineType();
  virtual ~LaneLineType();

  LaneLineType(const LaneLineType& from);

  inline LaneLineType& operator=(const LaneLineType& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LaneLineType(LaneLineType&& from) noexcept
    : LaneLineType() {
    *this = ::std::move(from);
  }

  inline LaneLineType& operator=(LaneLineType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LaneLineType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LaneLineType* internal_default_instance() {
    return reinterpret_cast<const LaneLineType*>(
               &_LaneLineType_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    28;

  void Swap(LaneLineType* other);
  friend void swap(LaneLineType& a, LaneLineType& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LaneLineType* New() const PROTOBUF_FINAL { return New(NULL); }

  LaneLineType* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LaneLineType& from);
  void MergeFrom(const LaneLineType& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LaneLineType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef LaneLineType_Type Type;
  static const Type UNKNOWN =
    LaneLineType_Type_UNKNOWN;
  static const Type LANELINE =
    LaneLineType_Type_LANELINE;
  static const Type CURB =
    LaneLineType_Type_CURB;
  static const Type CENTER =
    LaneLineType_Type_CENTER;
  static const Type GUARDRAIL =
    LaneLineType_Type_GUARDRAIL;
  static const Type CONCRETE_BARRIER =
    LaneLineType_Type_CONCRETE_BARRIER;
  static const Type FENCE =
    LaneLineType_Type_FENCE;
  static const Type WALL =
    LaneLineType_Type_WALL;
  static const Type CANOPY =
    LaneLineType_Type_CANOPY;
  static inline bool Type_IsValid(int value) {
    return LaneLineType_Type_IsValid(value);
  }
  static const Type Type_MIN =
    LaneLineType_Type_Type_MIN;
  static const Type Type_MAX =
    LaneLineType_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    LaneLineType_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return LaneLineType_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return LaneLineType_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return LaneLineType_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .ndm_proto.LaneLineType.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::ndm_proto::LaneLineType_Type type() const;
  void set_type(::ndm_proto::LaneLineType_Type value);

  // optional float conf = 2;
  bool has_conf() const;
  void clear_conf();
  static const int kConfFieldNumber = 2;
  float conf() const;
  void set_conf(float value);

  // @@protoc_insertion_point(class_scope:ndm_proto.LaneLineType)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_conf();
  void clear_has_conf();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int type_;
  float conf_;
  friend struct ::protobuf_base_2eproto::TableStruct;
  friend void ::protobuf_base_2eproto::InitDefaultsLaneLineTypeImpl();
};
// -------------------------------------------------------------------

class LaneLineRestriction : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.LaneLineRestriction) */ {
 public:
  LaneLineRestriction();
  virtual ~LaneLineRestriction();

  LaneLineRestriction(const LaneLineRestriction& from);

  inline LaneLineRestriction& operator=(const LaneLineRestriction& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LaneLineRestriction(LaneLineRestriction&& from) noexcept
    : LaneLineRestriction() {
    *this = ::std::move(from);
  }

  inline LaneLineRestriction& operator=(LaneLineRestriction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LaneLineRestriction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LaneLineRestriction* internal_default_instance() {
    return reinterpret_cast<const LaneLineRestriction*>(
               &_LaneLineRestriction_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    29;

  void Swap(LaneLineRestriction* other);
  friend void swap(LaneLineRestriction& a, LaneLineRestriction& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LaneLineRestriction* New() const PROTOBUF_FINAL { return New(NULL); }

  LaneLineRestriction* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LaneLineRestriction& from);
  void MergeFrom(const LaneLineRestriction& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LaneLineRestriction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef LaneLineRestriction_LaneLineRestrictionType LaneLineRestrictionType;
  static const LaneLineRestrictionType UNKNOWN_LINE_RESTRICTION_TYPE =
    LaneLineRestriction_LaneLineRestrictionType_UNKNOWN_LINE_RESTRICTION_TYPE;
  static const LaneLineRestrictionType BUS_LANE_LEFT_EDGE =
    LaneLineRestriction_LaneLineRestrictionType_BUS_LANE_LEFT_EDGE;
  static const LaneLineRestrictionType BUS_LANE_RIGHT_EDGE =
    LaneLineRestriction_LaneLineRestrictionType_BUS_LANE_RIGHT_EDGE;
  static const LaneLineRestrictionType BIKE_LANE_LEFT_EDGE =
    LaneLineRestriction_LaneLineRestrictionType_BIKE_LANE_LEFT_EDGE;
  static const LaneLineRestrictionType BIKE_LANE_RIGHT_EDGE =
    LaneLineRestriction_LaneLineRestrictionType_BIKE_LANE_RIGHT_EDGE;
  static const LaneLineRestrictionType OPPOSITE_NO_PASS =
    LaneLineRestriction_LaneLineRestrictionType_OPPOSITE_NO_PASS;
  static const LaneLineRestrictionType OPPOSITE_CAN_PASS =
    LaneLineRestriction_LaneLineRestrictionType_OPPOSITE_CAN_PASS;
  static const LaneLineRestrictionType PEDESTRAIN_LANE_LEFT_EDGE =
    LaneLineRestriction_LaneLineRestrictionType_PEDESTRAIN_LANE_LEFT_EDGE;
  static const LaneLineRestrictionType PEDESTRAIN_LANE_RIGHT_EDGE =
    LaneLineRestriction_LaneLineRestrictionType_PEDESTRAIN_LANE_RIGHT_EDGE;
  static const LaneLineRestrictionType WHITE_STRIP_ZONE_ON_LEFT =
    LaneLineRestriction_LaneLineRestrictionType_WHITE_STRIP_ZONE_ON_LEFT;
  static const LaneLineRestrictionType WHITE_STRIP_ZONE_ON_RIGHT =
    LaneLineRestriction_LaneLineRestrictionType_WHITE_STRIP_ZONE_ON_RIGHT;
  static const LaneLineRestrictionType YELLOW_STRIP_ZONE_ON_LEFT =
    LaneLineRestriction_LaneLineRestrictionType_YELLOW_STRIP_ZONE_ON_LEFT;
  static const LaneLineRestrictionType YELLOW_STRIP_ZONE_ON_RIGHT =
    LaneLineRestriction_LaneLineRestrictionType_YELLOW_STRIP_ZONE_ON_RIGHT;
  static const LaneLineRestrictionType CABLE_CAR_ON_LEFT =
    LaneLineRestriction_LaneLineRestrictionType_CABLE_CAR_ON_LEFT;
  static const LaneLineRestrictionType CABLE_CAR_ON_RIGHT =
    LaneLineRestriction_LaneLineRestrictionType_CABLE_CAR_ON_RIGHT;
  static const LaneLineRestrictionType NO_CAR_ON_LEFT =
    LaneLineRestriction_LaneLineRestrictionType_NO_CAR_ON_LEFT;
  static const LaneLineRestrictionType NO_CAR_ON_RIGHT =
    LaneLineRestriction_LaneLineRestrictionType_NO_CAR_ON_RIGHT;
  static const LaneLineRestrictionType EXIT_LANE_LEFT_EDGE =
    LaneLineRestriction_LaneLineRestrictionType_EXIT_LANE_LEFT_EDGE;
  static const LaneLineRestrictionType EXIT_LANE_RIGHT_EDGE =
    LaneLineRestriction_LaneLineRestrictionType_EXIT_LANE_RIGHT_EDGE;
  static const LaneLineRestrictionType ENTRY_LANE_LEFT_EDGE =
    LaneLineRestriction_LaneLineRestrictionType_ENTRY_LANE_LEFT_EDGE;
  static const LaneLineRestrictionType ENTRY_LANE_RIGHT_EDGE =
    LaneLineRestriction_LaneLineRestrictionType_ENTRY_LANE_RIGHT_EDGE;
  static const LaneLineRestrictionType HOV_LANE_LEFT_EDGE =
    LaneLineRestriction_LaneLineRestrictionType_HOV_LANE_LEFT_EDGE;
  static const LaneLineRestrictionType HOV_LANE_RIGHT_EDGE =
    LaneLineRestriction_LaneLineRestrictionType_HOV_LANE_RIGHT_EDGE;
  static const LaneLineRestrictionType SIDEWALK_LEFT_EDGE =
    LaneLineRestriction_LaneLineRestrictionType_SIDEWALK_LEFT_EDGE;
  static const LaneLineRestrictionType SIDEWALK_RIGHT_EDGE =
    LaneLineRestriction_LaneLineRestrictionType_SIDEWALK_RIGHT_EDGE;
  static const LaneLineRestrictionType PARKING_LANE_LEFT_EDGE =
    LaneLineRestriction_LaneLineRestrictionType_PARKING_LANE_LEFT_EDGE;
  static const LaneLineRestrictionType PARKING_LANE_RIGHT_EDGE =
    LaneLineRestriction_LaneLineRestrictionType_PARKING_LANE_RIGHT_EDGE;
  static const LaneLineRestrictionType SHOULDER_LANE_LEFT_EDGE =
    LaneLineRestriction_LaneLineRestrictionType_SHOULDER_LANE_LEFT_EDGE;
  static const LaneLineRestrictionType SHOULDER_LANE_RIGHT_EDGE =
    LaneLineRestriction_LaneLineRestrictionType_SHOULDER_LANE_RIGHT_EDGE;
  static inline bool LaneLineRestrictionType_IsValid(int value) {
    return LaneLineRestriction_LaneLineRestrictionType_IsValid(value);
  }
  static const LaneLineRestrictionType LaneLineRestrictionType_MIN =
    LaneLineRestriction_LaneLineRestrictionType_LaneLineRestrictionType_MIN;
  static const LaneLineRestrictionType LaneLineRestrictionType_MAX =
    LaneLineRestriction_LaneLineRestrictionType_LaneLineRestrictionType_MAX;
  static const int LaneLineRestrictionType_ARRAYSIZE =
    LaneLineRestriction_LaneLineRestrictionType_LaneLineRestrictionType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LaneLineRestrictionType_descriptor() {
    return LaneLineRestriction_LaneLineRestrictionType_descriptor();
  }
  static inline const ::std::string& LaneLineRestrictionType_Name(LaneLineRestrictionType value) {
    return LaneLineRestriction_LaneLineRestrictionType_Name(value);
  }
  static inline bool LaneLineRestrictionType_Parse(const ::std::string& name,
      LaneLineRestrictionType* value) {
    return LaneLineRestriction_LaneLineRestrictionType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .ndm_proto.LaneLineRestriction.LaneLineRestrictionType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::ndm_proto::LaneLineRestriction_LaneLineRestrictionType type() const;
  void set_type(::ndm_proto::LaneLineRestriction_LaneLineRestrictionType value);

  // optional float conf = 2;
  bool has_conf() const;
  void clear_conf();
  static const int kConfFieldNumber = 2;
  float conf() const;
  void set_conf(float value);

  // @@protoc_insertion_point(class_scope:ndm_proto.LaneLineRestriction)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_conf();
  void clear_has_conf();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int type_;
  float conf_;
  friend struct ::protobuf_base_2eproto::TableStruct;
  friend void ::protobuf_base_2eproto::InitDefaultsLaneLineRestrictionImpl();
};
// -------------------------------------------------------------------

class TrafficSignType : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.TrafficSignType) */ {
 public:
  TrafficSignType();
  virtual ~TrafficSignType();

  TrafficSignType(const TrafficSignType& from);

  inline TrafficSignType& operator=(const TrafficSignType& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TrafficSignType(TrafficSignType&& from) noexcept
    : TrafficSignType() {
    *this = ::std::move(from);
  }

  inline TrafficSignType& operator=(TrafficSignType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TrafficSignType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrafficSignType* internal_default_instance() {
    return reinterpret_cast<const TrafficSignType*>(
               &_TrafficSignType_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    30;

  void Swap(TrafficSignType* other);
  friend void swap(TrafficSignType& a, TrafficSignType& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrafficSignType* New() const PROTOBUF_FINAL { return New(NULL); }

  TrafficSignType* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TrafficSignType& from);
  void MergeFrom(const TrafficSignType& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TrafficSignType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef TrafficSignType_Type Type;
  static const Type UNKNOWN =
    TrafficSignType_Type_UNKNOWN;
  static const Type P_Stop_For =
    TrafficSignType_Type_P_Stop_For;
  static const Type P_Slow_For =
    TrafficSignType_Type_P_Slow_For;
  static const Type P_Give_Way =
    TrafficSignType_Type_P_Give_Way;
  static const Type P_Noway =
    TrafficSignType_Type_P_Noway;
  static const Type P_No_Entry =
    TrafficSignType_Type_P_No_Entry;
  static const Type P_No_Parking =
    TrafficSignType_Type_P_No_Parking;
  static const Type P_No_Long_Parking =
    TrafficSignType_Type_P_No_Long_Parking;
  static const Type P_Parking_Check =
    TrafficSignType_Type_P_Parking_Check;
  static const Type P_No_Motor =
    TrafficSignType_Type_P_No_Motor;
  static const Type P_No_Motorcycle =
    TrafficSignType_Type_P_No_Motorcycle;
  static const Type P_No_Truck =
    TrafficSignType_Type_P_No_Truck;
  static const Type P_No_Moto_Tricycle =
    TrafficSignType_Type_P_No_Moto_Tricycle;
  static const Type P_No_Bus =
    TrafficSignType_Type_P_No_Bus;
  static const Type P_No_Car =
    TrafficSignType_Type_P_No_Car;
  static const Type P_No_Trailer =
    TrafficSignType_Type_P_No_Trailer;
  static const Type P_No_Tractor =
    TrafficSignType_Type_P_No_Tractor;
  static const Type P_No_Cargo_Tricycle =
    TrafficSignType_Type_P_No_Cargo_Tricycle;
  static const Type P_No_Non_Motor =
    TrafficSignType_Type_P_No_Non_Motor;
  static const Type P_No_Animal_Vehicle =
    TrafficSignType_Type_P_No_Animal_Vehicle;
  static const Type P_No_Human_Vehicle =
    TrafficSignType_Type_P_No_Human_Vehicle;
  static const Type P_No_Human_Cargo_Triangle =
    TrafficSignType_Type_P_No_Human_Cargo_Triangle;
  static const Type P_No_Human_Passenger_Triangle =
    TrafficSignType_Type_P_No_Human_Passenger_Triangle;
  static const Type P_No_Human =
    TrafficSignType_Type_P_No_Human;
  static const Type P_No_Left_Turn =
    TrafficSignType_Type_P_No_Left_Turn;
  static const Type P_No_Right_Turn =
    TrafficSignType_Type_P_No_Right_Turn;
  static const Type P_No_Left_Right_Turn =
    TrafficSignType_Type_P_No_Left_Right_Turn;
  static const Type P_No_Foward =
    TrafficSignType_Type_P_No_Foward;
  static const Type P_No_Forward_Left =
    TrafficSignType_Type_P_No_Forward_Left;
  static const Type P_No_Forward_Right =
    TrafficSignType_Type_P_No_Forward_Right;
  static const Type P_No_Return =
    TrafficSignType_Type_P_No_Return;
  static const Type P_No_Horning =
    TrafficSignType_Type_P_No_Horning;
  static const Type P_Height_Lim =
    TrafficSignType_Type_P_Height_Lim;
  static const Type P_Width_Lim =
    TrafficSignType_Type_P_Width_Lim;
  static const Type P_Weight_Lim =
    TrafficSignType_Type_P_Weight_Lim;
  static const Type P_Weight_Lim_wheel =
    TrafficSignType_Type_P_Weight_Lim_wheel;
  static const Type P_Speed_Lim =
    TrafficSignType_Type_P_Speed_Lim;
  static const Type P_Speed_Lim_Rev =
    TrafficSignType_Type_P_Speed_Lim_Rev;
  static const Type P_No_Passing =
    TrafficSignType_Type_P_No_Passing;
  static const Type P_No_Dangerous =
    TrafficSignType_Type_P_No_Dangerous;
  static const Type P_Custom =
    TrafficSignType_Type_P_Custom;
  static const Type P_Other =
    TrafficSignType_Type_P_Other;
  static const Type W_T_Shap =
    TrafficSignType_Type_W_T_Shap;
  static const Type W_T_Shap_Left =
    TrafficSignType_Type_W_T_Shap_Left;
  static const Type W_T_Shap_Right =
    TrafficSignType_Type_W_T_Shap_Right;
  static const Type W_T_Shaps =
    TrafficSignType_Type_W_T_Shaps;
  static const Type W_Cross =
    TrafficSignType_Type_W_Cross;
  static const Type W_Circle =
    TrafficSignType_Type_W_Circle;
  static const Type W_Y_Left =
    TrafficSignType_Type_W_Y_Left;
  static const Type W_Y_Right =
    TrafficSignType_Type_W_Y_Right;
  static const Type W_YB_Left =
    TrafficSignType_Type_W_YB_Left;
  static const Type W_YB_Right =
    TrafficSignType_Type_W_YB_Right;
  static const Type W_Left_Turn =
    TrafficSignType_Type_W_Left_Turn;
  static const Type W_Right_Turn =
    TrafficSignType_Type_W_Right_Turn;
  static const Type W_RL_Turn =
    TrafficSignType_Type_W_RL_Turn;
  static const Type W_LR_Turn =
    TrafficSignType_Type_W_LR_Turn;
  static const Type W_Continuous_Turn =
    TrafficSignType_Type_W_Continuous_Turn;
  static const Type W_Up =
    TrafficSignType_Type_W_Up;
  static const Type W_Down =
    TrafficSignType_Type_W_Down;
  static const Type W_Continuous_Down =
    TrafficSignType_Type_W_Continuous_Down;
  static const Type W_Accident_Prone =
    TrafficSignType_Type_W_Accident_Prone;
  static const Type W_Danger =
    TrafficSignType_Type_W_Danger;
  static const Type W_Left_Narrow =
    TrafficSignType_Type_W_Left_Narrow;
  static const Type W_Right_Narrow =
    TrafficSignType_Type_W_Right_Narrow;
  static const Type W_LR_Narrow =
    TrafficSignType_Type_W_LR_Narrow;
  static const Type W_Narrow_Bridge =
    TrafficSignType_Type_W_Narrow_Bridge;
  static const Type W_Slip =
    TrafficSignType_Type_W_Slip;
  static const Type W_Pedestrain =
    TrafficSignType_Type_W_Pedestrain;
  static const Type W_Children =
    TrafficSignType_Type_W_Children;
  static const Type W_Cycle =
    TrafficSignType_Type_W_Cycle;
  static const Type W_Disabled =
    TrafficSignType_Type_W_Disabled;
  static const Type W_Side_Wind =
    TrafficSignType_Type_W_Side_Wind;
  static const Type W_Domestic =
    TrafficSignType_Type_W_Domestic;
  static const Type W_Animal =
    TrafficSignType_Type_W_Animal;
  static const Type W_Tunnel =
    TrafficSignType_Type_W_Tunnel;
  static const Type W_Tunnel_Headlight =
    TrafficSignType_Type_W_Tunnel_Headlight;
  static const Type W_Traffic_Light =
    TrafficSignType_Type_W_Traffic_Light;
  static const Type W_Left_Falling =
    TrafficSignType_Type_W_Left_Falling;
  static const Type W_Right_Falling =
    TrafficSignType_Type_W_Right_Falling;
  static const Type W_Mount_Left =
    TrafficSignType_Type_W_Mount_Left;
  static const Type W_Mount_Right =
    TrafficSignType_Type_W_Mount_Right;
  static const Type W_Village =
    TrafficSignType_Type_W_Village;
  static const Type W_Dam_Right =
    TrafficSignType_Type_W_Dam_Right;
  static const Type W_Dam_Left =
    TrafficSignType_Type_W_Dam_Left;
  static const Type W_Ferry =
    TrafficSignType_Type_W_Ferry;
  static const Type W_Ford =
    TrafficSignType_Type_W_Ford;
  static const Type W_Slow =
    TrafficSignType_Type_W_Slow;
  static const Type W_Hump_Bridge =
    TrafficSignType_Type_W_Hump_Bridge;
  static const Type W_Bumpy =
    TrafficSignType_Type_W_Bumpy;
  static const Type W_Bump =
    TrafficSignType_Type_W_Bump;
  static const Type W_Low_Lying =
    TrafficSignType_Type_W_Low_Lying;
  static const Type W_Working =
    TrafficSignType_Type_W_Working;
  static const Type W_Guarded_Railway =
    TrafficSignType_Type_W_Guarded_Railway;
  static const Type W_Railway =
    TrafficSignType_Type_W_Railway;
  static const Type W_Detour_Around =
    TrafficSignType_Type_W_Detour_Around;
  static const Type W_Detour_Left =
    TrafficSignType_Type_W_Detour_Left;
  static const Type W_Detour_Right =
    TrafficSignType_Type_W_Detour_Right;
  static const Type W_Merge_Left =
    TrafficSignType_Type_W_Merge_Left;
  static const Type W_Merge_Right =
    TrafficSignType_Type_W_Merge_Right;
  static const Type W_Two_Way =
    TrafficSignType_Type_W_Two_Way;
  static const Type W_Tidal =
    TrafficSignType_Type_W_Tidal;
  static const Type W_Keep_Distance =
    TrafficSignType_Type_W_Keep_Distance;
  static const Type W_Cross_Intersection =
    TrafficSignType_Type_W_Cross_Intersection;
  static const Type W_T_Intersection =
    TrafficSignType_Type_W_T_Intersection;
  static const Type W_Vehicle_Queue =
    TrafficSignType_Type_W_Vehicle_Queue;
  static const Type W_Ice =
    TrafficSignType_Type_W_Ice;
  static const Type W_Rain =
    TrafficSignType_Type_W_Rain;
  static const Type W_Fog =
    TrafficSignType_Type_W_Fog;
  static const Type W_Bad_Weather =
    TrafficSignType_Type_W_Bad_Weather;
  static const Type W_Other =
    TrafficSignType_Type_W_Other;
  static const Type I_Forward =
    TrafficSignType_Type_I_Forward;
  static const Type I_Left_Turn =
    TrafficSignType_Type_I_Left_Turn;
  static const Type I_Right_Turn =
    TrafficSignType_Type_I_Right_Turn;
  static const Type I_Forward_Left =
    TrafficSignType_Type_I_Forward_Left;
  static const Type I_Forward_Right =
    TrafficSignType_Type_I_Forward_Right;
  static const Type I_Left_Right =
    TrafficSignType_Type_I_Left_Right;
  static const Type I_Right =
    TrafficSignType_Type_I_Right;
  static const Type I_Left =
    TrafficSignType_Type_I_Left;
  static const Type I_Forward_Left_Stereo =
    TrafficSignType_Type_I_Forward_Left_Stereo;
  static const Type I_Forward_Right_Stereo =
    TrafficSignType_Type_I_Forward_Right_Stereo;
  static const Type I_Circle =
    TrafficSignType_Type_I_Circle;
  static const Type I_Walk =
    TrafficSignType_Type_I_Walk;
  static const Type I_Honk =
    TrafficSignType_Type_I_Honk;
  static const Type I_Min_Speed_Lim =
    TrafficSignType_Type_I_Min_Speed_Lim;
  static const Type I_Motors =
    TrafficSignType_Type_I_Motors;
  static const Type I_Non_Motors =
    TrafficSignType_Type_I_Non_Motors;
  static const Type I_Pedestrian_Cross =
    TrafficSignType_Type_I_Pedestrian_Cross;
  static const Type I_Other =
    TrafficSignType_Type_I_Other;
  static const Type P_No_Passing_Rev =
    TrafficSignType_Type_P_No_Passing_Rev;
  static const Type P_All_Speed_Limit_Cancel =
    TrafficSignType_Type_P_All_Speed_Limit_Cancel;
  static const Type W_Tripod =
    TrafficSignType_Type_W_Tripod;
  static inline bool Type_IsValid(int value) {
    return TrafficSignType_Type_IsValid(value);
  }
  static const Type Type_MIN =
    TrafficSignType_Type_Type_MIN;
  static const Type Type_MAX =
    TrafficSignType_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    TrafficSignType_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return TrafficSignType_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return TrafficSignType_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return TrafficSignType_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .ndm_proto.TrafficSignType.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::ndm_proto::TrafficSignType_Type type() const;
  void set_type(::ndm_proto::TrafficSignType_Type value);

  // optional float conf = 2;
  bool has_conf() const;
  void clear_conf();
  static const int kConfFieldNumber = 2;
  float conf() const;
  void set_conf(float value);

  // @@protoc_insertion_point(class_scope:ndm_proto.TrafficSignType)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_conf();
  void clear_has_conf();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int type_;
  float conf_;
  friend struct ::protobuf_base_2eproto::TableStruct;
  friend void ::protobuf_base_2eproto::InitDefaultsTrafficSignTypeImpl();
};
// -------------------------------------------------------------------

class ConditionNumeric : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.ConditionNumeric) */ {
 public:
  ConditionNumeric();
  virtual ~ConditionNumeric();

  ConditionNumeric(const ConditionNumeric& from);

  inline ConditionNumeric& operator=(const ConditionNumeric& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConditionNumeric(ConditionNumeric&& from) noexcept
    : ConditionNumeric() {
    *this = ::std::move(from);
  }

  inline ConditionNumeric& operator=(ConditionNumeric&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConditionNumeric& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConditionNumeric* internal_default_instance() {
    return reinterpret_cast<const ConditionNumeric*>(
               &_ConditionNumeric_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    31;

  void Swap(ConditionNumeric* other);
  friend void swap(ConditionNumeric& a, ConditionNumeric& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConditionNumeric* New() const PROTOBUF_FINAL { return New(NULL); }

  ConditionNumeric* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ConditionNumeric& from);
  void MergeFrom(const ConditionNumeric& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ConditionNumeric* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::google::protobuf::uint32 value() const;
  void set_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ndm_proto.ConditionNumeric)
 private:
  void set_has_value();
  void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 value_;
  friend struct ::protobuf_base_2eproto::TableStruct;
  friend void ::protobuf_base_2eproto::InitDefaultsConditionNumericImpl();
};
// -------------------------------------------------------------------

class ConditionVehicleType : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.ConditionVehicleType) */ {
 public:
  ConditionVehicleType();
  virtual ~ConditionVehicleType();

  ConditionVehicleType(const ConditionVehicleType& from);

  inline ConditionVehicleType& operator=(const ConditionVehicleType& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConditionVehicleType(ConditionVehicleType&& from) noexcept
    : ConditionVehicleType() {
    *this = ::std::move(from);
  }

  inline ConditionVehicleType& operator=(ConditionVehicleType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConditionVehicleType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConditionVehicleType* internal_default_instance() {
    return reinterpret_cast<const ConditionVehicleType*>(
               &_ConditionVehicleType_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    32;

  void Swap(ConditionVehicleType* other);
  friend void swap(ConditionVehicleType& a, ConditionVehicleType& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConditionVehicleType* New() const PROTOBUF_FINAL { return New(NULL); }

  ConditionVehicleType* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ConditionVehicleType& from);
  void MergeFrom(const ConditionVehicleType& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ConditionVehicleType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 vehicleTypeMask = 1;
  bool has_vehicletypemask() const;
  void clear_vehicletypemask();
  static const int kVehicleTypeMaskFieldNumber = 1;
  ::google::protobuf::uint32 vehicletypemask() const;
  void set_vehicletypemask(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ndm_proto.ConditionVehicleType)
 private:
  void set_has_vehicletypemask();
  void clear_has_vehicletypemask();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 vehicletypemask_;
  friend struct ::protobuf_base_2eproto::TableStruct;
  friend void ::protobuf_base_2eproto::InitDefaultsConditionVehicleTypeImpl();
};
// -------------------------------------------------------------------

class ConditionLoad : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.ConditionLoad) */ {
 public:
  ConditionLoad();
  virtual ~ConditionLoad();

  ConditionLoad(const ConditionLoad& from);

  inline ConditionLoad& operator=(const ConditionLoad& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConditionLoad(ConditionLoad&& from) noexcept
    : ConditionLoad() {
    *this = ::std::move(from);
  }

  inline ConditionLoad& operator=(ConditionLoad&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConditionLoad& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConditionLoad* internal_default_instance() {
    return reinterpret_cast<const ConditionLoad*>(
               &_ConditionLoad_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    33;

  void Swap(ConditionLoad* other);
  friend void swap(ConditionLoad& a, ConditionLoad& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConditionLoad* New() const PROTOBUF_FINAL { return New(NULL); }

  ConditionLoad* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ConditionLoad& from);
  void MergeFrom(const ConditionLoad& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ConditionLoad* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ndm_proto.Load value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::ndm_proto::Load value() const;
  void set_value(::ndm_proto::Load value);

  // @@protoc_insertion_point(class_scope:ndm_proto.ConditionLoad)
 private:
  void set_has_value();
  void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int value_;
  friend struct ::protobuf_base_2eproto::TableStruct;
  friend void ::protobuf_base_2eproto::InitDefaultsConditionLoadImpl();
};
// -------------------------------------------------------------------

class ConditionTimeOfDay : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.ConditionTimeOfDay) */ {
 public:
  ConditionTimeOfDay();
  virtual ~ConditionTimeOfDay();

  ConditionTimeOfDay(const ConditionTimeOfDay& from);

  inline ConditionTimeOfDay& operator=(const ConditionTimeOfDay& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConditionTimeOfDay(ConditionTimeOfDay&& from) noexcept
    : ConditionTimeOfDay() {
    *this = ::std::move(from);
  }

  inline ConditionTimeOfDay& operator=(ConditionTimeOfDay&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConditionTimeOfDay& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConditionTimeOfDay* internal_default_instance() {
    return reinterpret_cast<const ConditionTimeOfDay*>(
               &_ConditionTimeOfDay_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    34;

  void Swap(ConditionTimeOfDay* other);
  friend void swap(ConditionTimeOfDay& a, ConditionTimeOfDay& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConditionTimeOfDay* New() const PROTOBUF_FINAL { return New(NULL); }

  ConditionTimeOfDay* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ConditionTimeOfDay& from);
  void MergeFrom(const ConditionTimeOfDay& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ConditionTimeOfDay* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 startMinutes = 1;
  bool has_startminutes() const;
  void clear_startminutes();
  static const int kStartMinutesFieldNumber = 1;
  ::google::protobuf::uint32 startminutes() const;
  void set_startminutes(::google::protobuf::uint32 value);

  // required uint32 endMinutes = 2;
  bool has_endminutes() const;
  void clear_endminutes();
  static const int kEndMinutesFieldNumber = 2;
  ::google::protobuf::uint32 endminutes() const;
  void set_endminutes(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ndm_proto.ConditionTimeOfDay)
 private:
  void set_has_startminutes();
  void clear_has_startminutes();
  void set_has_endminutes();
  void clear_has_endminutes();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 startminutes_;
  ::google::protobuf::uint32 endminutes_;
  friend struct ::protobuf_base_2eproto::TableStruct;
  friend void ::protobuf_base_2eproto::InitDefaultsConditionTimeOfDayImpl();
};
// -------------------------------------------------------------------

class ConditionWeather : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.ConditionWeather) */ {
 public:
  ConditionWeather();
  virtual ~ConditionWeather();

  ConditionWeather(const ConditionWeather& from);

  inline ConditionWeather& operator=(const ConditionWeather& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConditionWeather(ConditionWeather&& from) noexcept
    : ConditionWeather() {
    *this = ::std::move(from);
  }

  inline ConditionWeather& operator=(ConditionWeather&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConditionWeather& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConditionWeather* internal_default_instance() {
    return reinterpret_cast<const ConditionWeather*>(
               &_ConditionWeather_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    35;

  void Swap(ConditionWeather* other);
  friend void swap(ConditionWeather& a, ConditionWeather& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConditionWeather* New() const PROTOBUF_FINAL { return New(NULL); }

  ConditionWeather* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ConditionWeather& from);
  void MergeFrom(const ConditionWeather& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ConditionWeather* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ndm_proto.Weather weather = 1;
  bool has_weather() const;
  void clear_weather();
  static const int kWeatherFieldNumber = 1;
  ::ndm_proto::Weather weather() const;
  void set_weather(::ndm_proto::Weather value);

  // @@protoc_insertion_point(class_scope:ndm_proto.ConditionWeather)
 private:
  void set_has_weather();
  void clear_has_weather();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int weather_;
  friend struct ::protobuf_base_2eproto::TableStruct;
  friend void ::protobuf_base_2eproto::InitDefaultsConditionWeatherImpl();
};
// -------------------------------------------------------------------

class ConditionFuzzyTime : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.ConditionFuzzyTime) */ {
 public:
  ConditionFuzzyTime();
  virtual ~ConditionFuzzyTime();

  ConditionFuzzyTime(const ConditionFuzzyTime& from);

  inline ConditionFuzzyTime& operator=(const ConditionFuzzyTime& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConditionFuzzyTime(ConditionFuzzyTime&& from) noexcept
    : ConditionFuzzyTime() {
    *this = ::std::move(from);
  }

  inline ConditionFuzzyTime& operator=(ConditionFuzzyTime&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConditionFuzzyTime& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConditionFuzzyTime* internal_default_instance() {
    return reinterpret_cast<const ConditionFuzzyTime*>(
               &_ConditionFuzzyTime_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    36;

  void Swap(ConditionFuzzyTime* other);
  friend void swap(ConditionFuzzyTime& a, ConditionFuzzyTime& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConditionFuzzyTime* New() const PROTOBUF_FINAL { return New(NULL); }

  ConditionFuzzyTime* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ConditionFuzzyTime& from);
  void MergeFrom(const ConditionFuzzyTime& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ConditionFuzzyTime* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ndm_proto.FuzzyTime fuzzyTime = 1;
  bool has_fuzzytime() const;
  void clear_fuzzytime();
  static const int kFuzzyTimeFieldNumber = 1;
  ::ndm_proto::FuzzyTime fuzzytime() const;
  void set_fuzzytime(::ndm_proto::FuzzyTime value);

  // @@protoc_insertion_point(class_scope:ndm_proto.ConditionFuzzyTime)
 private:
  void set_has_fuzzytime();
  void clear_has_fuzzytime();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int fuzzytime_;
  friend struct ::protobuf_base_2eproto::TableStruct;
  friend void ::protobuf_base_2eproto::InitDefaultsConditionFuzzyTimeImpl();
};
// -------------------------------------------------------------------

class ConditionTurnDirection : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.ConditionTurnDirection) */ {
 public:
  ConditionTurnDirection();
  virtual ~ConditionTurnDirection();

  ConditionTurnDirection(const ConditionTurnDirection& from);

  inline ConditionTurnDirection& operator=(const ConditionTurnDirection& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConditionTurnDirection(ConditionTurnDirection&& from) noexcept
    : ConditionTurnDirection() {
    *this = ::std::move(from);
  }

  inline ConditionTurnDirection& operator=(ConditionTurnDirection&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConditionTurnDirection& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConditionTurnDirection* internal_default_instance() {
    return reinterpret_cast<const ConditionTurnDirection*>(
               &_ConditionTurnDirection_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    37;

  void Swap(ConditionTurnDirection* other);
  friend void swap(ConditionTurnDirection& a, ConditionTurnDirection& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConditionTurnDirection* New() const PROTOBUF_FINAL { return New(NULL); }

  ConditionTurnDirection* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ConditionTurnDirection& from);
  void MergeFrom(const ConditionTurnDirection& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ConditionTurnDirection* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ndm_proto.LaneArrowMarking direction = 1;
  bool has_direction() const;
  void clear_direction();
  static const int kDirectionFieldNumber = 1;
  ::ndm_proto::LaneArrowMarking direction() const;
  void set_direction(::ndm_proto::LaneArrowMarking value);

  // @@protoc_insertion_point(class_scope:ndm_proto.ConditionTurnDirection)
 private:
  void set_has_direction();
  void clear_has_direction();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int direction_;
  friend struct ::protobuf_base_2eproto::TableStruct;
  friend void ::protobuf_base_2eproto::InitDefaultsConditionTurnDirectionImpl();
};
// -------------------------------------------------------------------

class Condition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.Condition) */ {
 public:
  Condition();
  virtual ~Condition();

  Condition(const Condition& from);

  inline Condition& operator=(const Condition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Condition(Condition&& from) noexcept
    : Condition() {
    *this = ::std::move(from);
  }

  inline Condition& operator=(Condition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Condition& default_instance();

  enum ConditionCase {
    kConditionNumeric = 3,
    kConditionVehicleType = 4,
    kConditionLoad = 5,
    kConditionTimeOfDay = 6,
    kConditionWeather = 7,
    kConditionFuzzyTime = 8,
    kConditionTurnDirection = 9,
    CONDITION_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Condition* internal_default_instance() {
    return reinterpret_cast<const Condition*>(
               &_Condition_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    38;

  void Swap(Condition* other);
  friend void swap(Condition& a, Condition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Condition* New() const PROTOBUF_FINAL { return New(NULL); }

  Condition* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Condition& from);
  void MergeFrom(const Condition& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Condition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ndm_proto.ConditionType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::ndm_proto::ConditionType type() const;
  void set_type(::ndm_proto::ConditionType value);

  // required .ndm_proto.YesNoUnknown appliesToEgoVehicle = 2;
  bool has_appliestoegovehicle() const;
  void clear_appliestoegovehicle();
  static const int kAppliesToEgoVehicleFieldNumber = 2;
  ::ndm_proto::YesNoUnknown appliestoegovehicle() const;
  void set_appliestoegovehicle(::ndm_proto::YesNoUnknown value);

  // optional .ndm_proto.ConditionNumeric condition_numeric = 3;
  bool has_condition_numeric() const;
  void clear_condition_numeric();
  static const int kConditionNumericFieldNumber = 3;
  const ::ndm_proto::ConditionNumeric& condition_numeric() const;
  ::ndm_proto::ConditionNumeric* release_condition_numeric();
  ::ndm_proto::ConditionNumeric* mutable_condition_numeric();
  void set_allocated_condition_numeric(::ndm_proto::ConditionNumeric* condition_numeric);

  // optional .ndm_proto.ConditionVehicleType condition_vehicleType = 4;
  bool has_condition_vehicletype() const;
  void clear_condition_vehicletype();
  static const int kConditionVehicleTypeFieldNumber = 4;
  const ::ndm_proto::ConditionVehicleType& condition_vehicletype() const;
  ::ndm_proto::ConditionVehicleType* release_condition_vehicletype();
  ::ndm_proto::ConditionVehicleType* mutable_condition_vehicletype();
  void set_allocated_condition_vehicletype(::ndm_proto::ConditionVehicleType* condition_vehicletype);

  // optional .ndm_proto.ConditionLoad condition_load = 5;
  bool has_condition_load() const;
  void clear_condition_load();
  static const int kConditionLoadFieldNumber = 5;
  const ::ndm_proto::ConditionLoad& condition_load() const;
  ::ndm_proto::ConditionLoad* release_condition_load();
  ::ndm_proto::ConditionLoad* mutable_condition_load();
  void set_allocated_condition_load(::ndm_proto::ConditionLoad* condition_load);

  // optional .ndm_proto.ConditionTimeOfDay condition_timeOfDay = 6;
  bool has_condition_timeofday() const;
  void clear_condition_timeofday();
  static const int kConditionTimeOfDayFieldNumber = 6;
  const ::ndm_proto::ConditionTimeOfDay& condition_timeofday() const;
  ::ndm_proto::ConditionTimeOfDay* release_condition_timeofday();
  ::ndm_proto::ConditionTimeOfDay* mutable_condition_timeofday();
  void set_allocated_condition_timeofday(::ndm_proto::ConditionTimeOfDay* condition_timeofday);

  // optional .ndm_proto.ConditionWeather condition_weather = 7;
  bool has_condition_weather() const;
  void clear_condition_weather();
  static const int kConditionWeatherFieldNumber = 7;
  const ::ndm_proto::ConditionWeather& condition_weather() const;
  ::ndm_proto::ConditionWeather* release_condition_weather();
  ::ndm_proto::ConditionWeather* mutable_condition_weather();
  void set_allocated_condition_weather(::ndm_proto::ConditionWeather* condition_weather);

  // optional .ndm_proto.ConditionFuzzyTime condition_fuzzyTime = 8;
  bool has_condition_fuzzytime() const;
  void clear_condition_fuzzytime();
  static const int kConditionFuzzyTimeFieldNumber = 8;
  const ::ndm_proto::ConditionFuzzyTime& condition_fuzzytime() const;
  ::ndm_proto::ConditionFuzzyTime* release_condition_fuzzytime();
  ::ndm_proto::ConditionFuzzyTime* mutable_condition_fuzzytime();
  void set_allocated_condition_fuzzytime(::ndm_proto::ConditionFuzzyTime* condition_fuzzytime);

  // optional .ndm_proto.ConditionTurnDirection condition_turnDirection = 9;
  bool has_condition_turndirection() const;
  void clear_condition_turndirection();
  static const int kConditionTurnDirectionFieldNumber = 9;
  const ::ndm_proto::ConditionTurnDirection& condition_turndirection() const;
  ::ndm_proto::ConditionTurnDirection* release_condition_turndirection();
  ::ndm_proto::ConditionTurnDirection* mutable_condition_turndirection();
  void set_allocated_condition_turndirection(::ndm_proto::ConditionTurnDirection* condition_turndirection);

  ConditionCase condition_case() const;
  // @@protoc_insertion_point(class_scope:ndm_proto.Condition)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_appliestoegovehicle();
  void clear_has_appliestoegovehicle();
  void set_has_condition_numeric();
  void set_has_condition_vehicletype();
  void set_has_condition_load();
  void set_has_condition_timeofday();
  void set_has_condition_weather();
  void set_has_condition_fuzzytime();
  void set_has_condition_turndirection();

  inline bool has_condition() const;
  void clear_condition();
  inline void clear_has_condition();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int type_;
  int appliestoegovehicle_;
  union ConditionUnion {
    ConditionUnion() {}
    ::ndm_proto::ConditionNumeric* condition_numeric_;
    ::ndm_proto::ConditionVehicleType* condition_vehicletype_;
    ::ndm_proto::ConditionLoad* condition_load_;
    ::ndm_proto::ConditionTimeOfDay* condition_timeofday_;
    ::ndm_proto::ConditionWeather* condition_weather_;
    ::ndm_proto::ConditionFuzzyTime* condition_fuzzytime_;
    ::ndm_proto::ConditionTurnDirection* condition_turndirection_;
  } condition_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_base_2eproto::TableStruct;
  friend void ::protobuf_base_2eproto::InitDefaultsConditionImpl();
};
// -------------------------------------------------------------------

class ParkingSpaceRestriction : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.ParkingSpaceRestriction) */ {
 public:
  ParkingSpaceRestriction();
  virtual ~ParkingSpaceRestriction();

  ParkingSpaceRestriction(const ParkingSpaceRestriction& from);

  inline ParkingSpaceRestriction& operator=(const ParkingSpaceRestriction& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ParkingSpaceRestriction(ParkingSpaceRestriction&& from) noexcept
    : ParkingSpaceRestriction() {
    *this = ::std::move(from);
  }

  inline ParkingSpaceRestriction& operator=(ParkingSpaceRestriction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ParkingSpaceRestriction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ParkingSpaceRestriction* internal_default_instance() {
    return reinterpret_cast<const ParkingSpaceRestriction*>(
               &_ParkingSpaceRestriction_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    39;

  void Swap(ParkingSpaceRestriction* other);
  friend void swap(ParkingSpaceRestriction& a, ParkingSpaceRestriction& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ParkingSpaceRestriction* New() const PROTOBUF_FINAL { return New(NULL); }

  ParkingSpaceRestriction* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ParkingSpaceRestriction& from);
  void MergeFrom(const ParkingSpaceRestriction& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ParkingSpaceRestriction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ndm_proto.TimeLimit time_limits = 2;
  int time_limits_size() const;
  void clear_time_limits();
  static const int kTimeLimitsFieldNumber = 2;
  const ::ndm_proto::TimeLimit& time_limits(int index) const;
  ::ndm_proto::TimeLimit* mutable_time_limits(int index);
  ::ndm_proto::TimeLimit* add_time_limits();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::TimeLimit >*
      mutable_time_limits();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::TimeLimit >&
      time_limits() const;

  // repeated .ndm_proto.VehicleType vehicle_types = 3;
  int vehicle_types_size() const;
  void clear_vehicle_types();
  static const int kVehicleTypesFieldNumber = 3;
  const ::ndm_proto::VehicleType& vehicle_types(int index) const;
  ::ndm_proto::VehicleType* mutable_vehicle_types(int index);
  ::ndm_proto::VehicleType* add_vehicle_types();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::VehicleType >*
      mutable_vehicle_types();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::VehicleType >&
      vehicle_types() const;

  // optional .ndm_proto.Number number_limit = 1;
  bool has_number_limit() const;
  void clear_number_limit();
  static const int kNumberLimitFieldNumber = 1;
  const ::ndm_proto::Number& number_limit() const;
  ::ndm_proto::Number* release_number_limit();
  ::ndm_proto::Number* mutable_number_limit();
  void set_allocated_number_limit(::ndm_proto::Number* number_limit);

  // @@protoc_insertion_point(class_scope:ndm_proto.ParkingSpaceRestriction)
 private:
  void set_has_number_limit();
  void clear_has_number_limit();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::TimeLimit > time_limits_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::VehicleType > vehicle_types_;
  ::ndm_proto::Number* number_limit_;
  friend struct ::protobuf_base_2eproto::TableStruct;
  friend void ::protobuf_base_2eproto::InitDefaultsParkingSpaceRestrictionImpl();
};
// -------------------------------------------------------------------

class ZoneType : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.ZoneType) */ {
 public:
  ZoneType();
  virtual ~ZoneType();

  ZoneType(const ZoneType& from);

  inline ZoneType& operator=(const ZoneType& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ZoneType(ZoneType&& from) noexcept
    : ZoneType() {
    *this = ::std::move(from);
  }

  inline ZoneType& operator=(ZoneType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ZoneType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ZoneType* internal_default_instance() {
    return reinterpret_cast<const ZoneType*>(
               &_ZoneType_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    40;

  void Swap(ZoneType* other);
  friend void swap(ZoneType& a, ZoneType& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ZoneType* New() const PROTOBUF_FINAL { return New(NULL); }

  ZoneType* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ZoneType& from);
  void MergeFrom(const ZoneType& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ZoneType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ZoneType_Type Type;
  static const Type UNKNOWN =
    ZoneType_Type_UNKNOWN;
  static const Type CIRCLE =
    ZoneType_Type_CIRCLE;
  static const Type CIRCLE_CUL_DE_SAC =
    ZoneType_Type_CIRCLE_CUL_DE_SAC;
  static const Type POLYGON =
    ZoneType_Type_POLYGON;
  static const Type KEEP_CLEAR =
    ZoneType_Type_KEEP_CLEAR;
  static const Type DRIVEWAY =
    ZoneType_Type_DRIVEWAY;
  static const Type PARKING_LOT =
    ZoneType_Type_PARKING_LOT;
  static const Type RAILWAY_CROSSING =
    ZoneType_Type_RAILWAY_CROSSING;
  static const Type INTERSECTION =
    ZoneType_Type_INTERSECTION;
  static const Type PARKING_AREA =
    ZoneType_Type_PARKING_AREA;
  static const Type PICK_UP_ZONE =
    ZoneType_Type_PICK_UP_ZONE;
  static const Type DROP_OFF_ZONE =
    ZoneType_Type_DROP_OFF_ZONE;
  static const Type ROADWORK_ZONE =
    ZoneType_Type_ROADWORK_ZONE;
  static const Type CROSS_WALK =
    ZoneType_Type_CROSS_WALK;
  static inline bool Type_IsValid(int value) {
    return ZoneType_Type_IsValid(value);
  }
  static const Type Type_MIN =
    ZoneType_Type_Type_MIN;
  static const Type Type_MAX =
    ZoneType_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    ZoneType_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return ZoneType_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return ZoneType_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return ZoneType_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .ndm_proto.ZoneType.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::ndm_proto::ZoneType_Type type() const;
  void set_type(::ndm_proto::ZoneType_Type value);

  // optional float conf = 2;
  bool has_conf() const;
  void clear_conf();
  static const int kConfFieldNumber = 2;
  float conf() const;
  void set_conf(float value);

  // @@protoc_insertion_point(class_scope:ndm_proto.ZoneType)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_conf();
  void clear_has_conf();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int type_;
  float conf_;
  friend struct ::protobuf_base_2eproto::TableStruct;
  friend void ::protobuf_base_2eproto::InitDefaultsZoneTypeImpl();
};
// -------------------------------------------------------------------

class AreaType : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.AreaType) */ {
 public:
  AreaType();
  virtual ~AreaType();

  AreaType(const AreaType& from);

  inline AreaType& operator=(const AreaType& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AreaType(AreaType&& from) noexcept
    : AreaType() {
    *this = ::std::move(from);
  }

  inline AreaType& operator=(AreaType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AreaType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AreaType* internal_default_instance() {
    return reinterpret_cast<const AreaType*>(
               &_AreaType_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    41;

  void Swap(AreaType* other);
  friend void swap(AreaType& a, AreaType& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AreaType* New() const PROTOBUF_FINAL { return New(NULL); }

  AreaType* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AreaType& from);
  void MergeFrom(const AreaType& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AreaType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef AreaType_Type Type;
  static const Type UNKNOWN =
    AreaType_Type_UNKNOWN;
  static const Type COMMUNITY =
    AreaType_Type_COMMUNITY;
  static inline bool Type_IsValid(int value) {
    return AreaType_Type_IsValid(value);
  }
  static const Type Type_MIN =
    AreaType_Type_Type_MIN;
  static const Type Type_MAX =
    AreaType_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    AreaType_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return AreaType_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return AreaType_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return AreaType_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .ndm_proto.AreaType.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::ndm_proto::AreaType_Type type() const;
  void set_type(::ndm_proto::AreaType_Type value);

  // optional float conf = 2;
  bool has_conf() const;
  void clear_conf();
  static const int kConfFieldNumber = 2;
  float conf() const;
  void set_conf(float value);

  // @@protoc_insertion_point(class_scope:ndm_proto.AreaType)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_conf();
  void clear_has_conf();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int type_;
  float conf_;
  friend struct ::protobuf_base_2eproto::TableStruct;
  friend void ::protobuf_base_2eproto::InitDefaultsAreaTypeImpl();
};
// -------------------------------------------------------------------

class PoleType : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.PoleType) */ {
 public:
  PoleType();
  virtual ~PoleType();

  PoleType(const PoleType& from);

  inline PoleType& operator=(const PoleType& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PoleType(PoleType&& from) noexcept
    : PoleType() {
    *this = ::std::move(from);
  }

  inline PoleType& operator=(PoleType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PoleType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PoleType* internal_default_instance() {
    return reinterpret_cast<const PoleType*>(
               &_PoleType_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    42;

  void Swap(PoleType* other);
  friend void swap(PoleType& a, PoleType& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PoleType* New() const PROTOBUF_FINAL { return New(NULL); }

  PoleType* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PoleType& from);
  void MergeFrom(const PoleType& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PoleType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef PoleType_Type Type;
  static const Type UNKNOWN =
    PoleType_Type_UNKNOWN;
  static const Type GANTRY =
    PoleType_Type_GANTRY;
  static const Type SIGNPOST =
    PoleType_Type_SIGNPOST;
  static const Type SIGNAL =
    PoleType_Type_SIGNAL;
  static inline bool Type_IsValid(int value) {
    return PoleType_Type_IsValid(value);
  }
  static const Type Type_MIN =
    PoleType_Type_Type_MIN;
  static const Type Type_MAX =
    PoleType_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    PoleType_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return PoleType_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return PoleType_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return PoleType_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .ndm_proto.PoleType.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::ndm_proto::PoleType_Type type() const;
  void set_type(::ndm_proto::PoleType_Type value);

  // optional float conf = 2;
  bool has_conf() const;
  void clear_conf();
  static const int kConfFieldNumber = 2;
  float conf() const;
  void set_conf(float value);

  // @@protoc_insertion_point(class_scope:ndm_proto.PoleType)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_conf();
  void clear_has_conf();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int type_;
  float conf_;
  friend struct ::protobuf_base_2eproto::TableStruct;
  friend void ::protobuf_base_2eproto::InitDefaultsPoleTypeImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Id

// required uint64 id = 1;
inline bool Id::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Id::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Id::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Id::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 Id::id() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Id.id)
  return id_;
}
inline void Id::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.Id.id)
}

// optional string name = 2;
inline bool Id::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Id::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Id::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Id::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Id::name() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Id.name)
  return name_.GetNoArena();
}
inline void Id::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ndm_proto.Id.name)
}
#if LANG_CXX11
inline void Id::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ndm_proto.Id.name)
}
#endif
inline void Id::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ndm_proto.Id.name)
}
inline void Id::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.Id.name)
}
inline ::std::string* Id::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:ndm_proto.Id.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Id::release_name() {
  // @@protoc_insertion_point(field_release:ndm_proto.Id.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Id::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.Id.name)
}

// -------------------------------------------------------------------

// Index

// required uint64 x = 1;
inline bool Index::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Index::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Index::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Index::clear_x() {
  x_ = GOOGLE_ULONGLONG(0);
  clear_has_x();
}
inline ::google::protobuf::uint64 Index::x() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Index.x)
  return x_;
}
inline void Index::set_x(::google::protobuf::uint64 value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.Index.x)
}

// required uint64 y = 2;
inline bool Index::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Index::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Index::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Index::clear_y() {
  y_ = GOOGLE_ULONGLONG(0);
  clear_has_y();
}
inline ::google::protobuf::uint64 Index::y() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Index.y)
  return y_;
}
inline void Index::set_y(::google::protobuf::uint64 value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.Index.y)
}

// required uint64 z = 3;
inline bool Index::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Index::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Index::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Index::clear_z() {
  z_ = GOOGLE_ULONGLONG(0);
  clear_has_z();
}
inline ::google::protobuf::uint64 Index::z() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Index.z)
  return z_;
}
inline void Index::set_z(::google::protobuf::uint64 value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.Index.z)
}

// -------------------------------------------------------------------

// Link

// required string id = 1;
inline bool Link::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Link::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Link::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Link::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& Link::id() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Link.id)
  return id_.GetNoArena();
}
inline void Link::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ndm_proto.Link.id)
}
#if LANG_CXX11
inline void Link::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ndm_proto.Link.id)
}
#endif
inline void Link::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ndm_proto.Link.id)
}
inline void Link::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.Link.id)
}
inline ::std::string* Link::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:ndm_proto.Link.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Link::release_id() {
  // @@protoc_insertion_point(field_release:ndm_proto.Link.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Link::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.Link.id)
}

// optional float offset = 2;
inline bool Link::has_offset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Link::set_has_offset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Link::clear_has_offset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Link::clear_offset() {
  offset_ = 0;
  clear_has_offset();
}
inline float Link::offset() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Link.offset)
  return offset_;
}
inline void Link::set_offset(float value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.Link.offset)
}

// optional float end_offset = 3;
inline bool Link::has_end_offset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Link::set_has_end_offset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Link::clear_has_end_offset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Link::clear_end_offset() {
  end_offset_ = 0;
  clear_has_end_offset();
}
inline float Link::end_offset() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Link.end_offset)
  return end_offset_;
}
inline void Link::set_end_offset(float value) {
  set_has_end_offset();
  end_offset_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.Link.end_offset)
}

// -------------------------------------------------------------------

// Number

// required float value = 1;
inline bool Number::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Number::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Number::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Number::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline float Number::value() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Number.value)
  return value_;
}
inline void Number::set_value(float value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.Number.value)
}

// optional float cov = 2;
inline bool Number::has_cov() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Number::set_has_cov() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Number::clear_has_cov() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Number::clear_cov() {
  cov_ = 0;
  clear_has_cov();
}
inline float Number::cov() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Number.cov)
  return cov_;
}
inline void Number::set_cov(float value) {
  set_has_cov();
  cov_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.Number.cov)
}

// -------------------------------------------------------------------

// String

// required string str = 1;
inline bool String::has_str() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void String::set_has_str() {
  _has_bits_[0] |= 0x00000001u;
}
inline void String::clear_has_str() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void String::clear_str() {
  str_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_str();
}
inline const ::std::string& String::str() const {
  // @@protoc_insertion_point(field_get:ndm_proto.String.str)
  return str_.GetNoArena();
}
inline void String::set_str(const ::std::string& value) {
  set_has_str();
  str_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ndm_proto.String.str)
}
#if LANG_CXX11
inline void String::set_str(::std::string&& value) {
  set_has_str();
  str_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ndm_proto.String.str)
}
#endif
inline void String::set_str(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_str();
  str_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ndm_proto.String.str)
}
inline void String::set_str(const char* value, size_t size) {
  set_has_str();
  str_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.String.str)
}
inline ::std::string* String::mutable_str() {
  set_has_str();
  // @@protoc_insertion_point(field_mutable:ndm_proto.String.str)
  return str_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* String::release_str() {
  // @@protoc_insertion_point(field_release:ndm_proto.String.str)
  clear_has_str();
  return str_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void String::set_allocated_str(::std::string* str) {
  if (str != NULL) {
    set_has_str();
  } else {
    clear_has_str();
  }
  str_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), str);
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.String.str)
}

// optional float cov = 2;
inline bool String::has_cov() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void String::set_has_cov() {
  _has_bits_[0] |= 0x00000002u;
}
inline void String::clear_has_cov() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void String::clear_cov() {
  cov_ = 0;
  clear_has_cov();
}
inline float String::cov() const {
  // @@protoc_insertion_point(field_get:ndm_proto.String.cov)
  return cov_;
}
inline void String::set_cov(float value) {
  set_has_cov();
  cov_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.String.cov)
}

// -------------------------------------------------------------------

// Point

// required double x = 1;
inline bool Point::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Point::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Point::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Point::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double Point::x() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Point.x)
  return x_;
}
inline void Point::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.Point.x)
}

// required double y = 2;
inline bool Point::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Point::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Point::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Point::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double Point::y() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Point.y)
  return y_;
}
inline void Point::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.Point.y)
}

// required double z = 3;
inline bool Point::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Point::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Point::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Point::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double Point::z() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Point.z)
  return z_;
}
inline void Point::set_z(double value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.Point.z)
}

// repeated double cov = 4;
inline int Point::cov_size() const {
  return cov_.size();
}
inline void Point::clear_cov() {
  cov_.Clear();
}
inline double Point::cov(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.Point.cov)
  return cov_.Get(index);
}
inline void Point::set_cov(int index, double value) {
  cov_.Set(index, value);
  // @@protoc_insertion_point(field_set:ndm_proto.Point.cov)
}
inline void Point::add_cov(double value) {
  cov_.Add(value);
  // @@protoc_insertion_point(field_add:ndm_proto.Point.cov)
}
inline const ::google::protobuf::RepeatedField< double >&
Point::cov() const {
  // @@protoc_insertion_point(field_list:ndm_proto.Point.cov)
  return cov_;
}
inline ::google::protobuf::RepeatedField< double >*
Point::mutable_cov() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.Point.cov)
  return &cov_;
}

// -------------------------------------------------------------------

// Quaternion4d

// required double x = 1;
inline bool Quaternion4d::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Quaternion4d::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Quaternion4d::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Quaternion4d::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double Quaternion4d::x() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Quaternion4d.x)
  return x_;
}
inline void Quaternion4d::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.Quaternion4d.x)
}

// required double y = 2;
inline bool Quaternion4d::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Quaternion4d::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Quaternion4d::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Quaternion4d::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double Quaternion4d::y() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Quaternion4d.y)
  return y_;
}
inline void Quaternion4d::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.Quaternion4d.y)
}

// required double z = 3;
inline bool Quaternion4d::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Quaternion4d::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Quaternion4d::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Quaternion4d::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double Quaternion4d::z() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Quaternion4d.z)
  return z_;
}
inline void Quaternion4d::set_z(double value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.Quaternion4d.z)
}

// required double w = 4;
inline bool Quaternion4d::has_w() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Quaternion4d::set_has_w() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Quaternion4d::clear_has_w() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Quaternion4d::clear_w() {
  w_ = 0;
  clear_has_w();
}
inline double Quaternion4d::w() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Quaternion4d.w)
  return w_;
}
inline void Quaternion4d::set_w(double value) {
  set_has_w();
  w_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.Quaternion4d.w)
}

// repeated double cov = 5;
inline int Quaternion4d::cov_size() const {
  return cov_.size();
}
inline void Quaternion4d::clear_cov() {
  cov_.Clear();
}
inline double Quaternion4d::cov(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.Quaternion4d.cov)
  return cov_.Get(index);
}
inline void Quaternion4d::set_cov(int index, double value) {
  cov_.Set(index, value);
  // @@protoc_insertion_point(field_set:ndm_proto.Quaternion4d.cov)
}
inline void Quaternion4d::add_cov(double value) {
  cov_.Add(value);
  // @@protoc_insertion_point(field_add:ndm_proto.Quaternion4d.cov)
}
inline const ::google::protobuf::RepeatedField< double >&
Quaternion4d::cov() const {
  // @@protoc_insertion_point(field_list:ndm_proto.Quaternion4d.cov)
  return cov_;
}
inline ::google::protobuf::RepeatedField< double >*
Quaternion4d::mutable_cov() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.Quaternion4d.cov)
  return &cov_;
}

// -------------------------------------------------------------------

// Odometry

// required uint64 stamp = 1;
inline bool Odometry::has_stamp() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Odometry::set_has_stamp() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Odometry::clear_has_stamp() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Odometry::clear_stamp() {
  stamp_ = GOOGLE_ULONGLONG(0);
  clear_has_stamp();
}
inline ::google::protobuf::uint64 Odometry::stamp() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Odometry.stamp)
  return stamp_;
}
inline void Odometry::set_stamp(::google::protobuf::uint64 value) {
  set_has_stamp();
  stamp_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.Odometry.stamp)
}

// required string frame_id = 2;
inline bool Odometry::has_frame_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Odometry::set_has_frame_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Odometry::clear_has_frame_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Odometry::clear_frame_id() {
  frame_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_frame_id();
}
inline const ::std::string& Odometry::frame_id() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Odometry.frame_id)
  return frame_id_.GetNoArena();
}
inline void Odometry::set_frame_id(const ::std::string& value) {
  set_has_frame_id();
  frame_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ndm_proto.Odometry.frame_id)
}
#if LANG_CXX11
inline void Odometry::set_frame_id(::std::string&& value) {
  set_has_frame_id();
  frame_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ndm_proto.Odometry.frame_id)
}
#endif
inline void Odometry::set_frame_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_frame_id();
  frame_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ndm_proto.Odometry.frame_id)
}
inline void Odometry::set_frame_id(const char* value, size_t size) {
  set_has_frame_id();
  frame_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.Odometry.frame_id)
}
inline ::std::string* Odometry::mutable_frame_id() {
  set_has_frame_id();
  // @@protoc_insertion_point(field_mutable:ndm_proto.Odometry.frame_id)
  return frame_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Odometry::release_frame_id() {
  // @@protoc_insertion_point(field_release:ndm_proto.Odometry.frame_id)
  clear_has_frame_id();
  return frame_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Odometry::set_allocated_frame_id(::std::string* frame_id) {
  if (frame_id != NULL) {
    set_has_frame_id();
  } else {
    clear_has_frame_id();
  }
  frame_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), frame_id);
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.Odometry.frame_id)
}

// required string child_frame_id = 3;
inline bool Odometry::has_child_frame_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Odometry::set_has_child_frame_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Odometry::clear_has_child_frame_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Odometry::clear_child_frame_id() {
  child_frame_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_child_frame_id();
}
inline const ::std::string& Odometry::child_frame_id() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Odometry.child_frame_id)
  return child_frame_id_.GetNoArena();
}
inline void Odometry::set_child_frame_id(const ::std::string& value) {
  set_has_child_frame_id();
  child_frame_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ndm_proto.Odometry.child_frame_id)
}
#if LANG_CXX11
inline void Odometry::set_child_frame_id(::std::string&& value) {
  set_has_child_frame_id();
  child_frame_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ndm_proto.Odometry.child_frame_id)
}
#endif
inline void Odometry::set_child_frame_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_child_frame_id();
  child_frame_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ndm_proto.Odometry.child_frame_id)
}
inline void Odometry::set_child_frame_id(const char* value, size_t size) {
  set_has_child_frame_id();
  child_frame_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.Odometry.child_frame_id)
}
inline ::std::string* Odometry::mutable_child_frame_id() {
  set_has_child_frame_id();
  // @@protoc_insertion_point(field_mutable:ndm_proto.Odometry.child_frame_id)
  return child_frame_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Odometry::release_child_frame_id() {
  // @@protoc_insertion_point(field_release:ndm_proto.Odometry.child_frame_id)
  clear_has_child_frame_id();
  return child_frame_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Odometry::set_allocated_child_frame_id(::std::string* child_frame_id) {
  if (child_frame_id != NULL) {
    set_has_child_frame_id();
  } else {
    clear_has_child_frame_id();
  }
  child_frame_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), child_frame_id);
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.Odometry.child_frame_id)
}

// optional uint32 seq_id = 4;
inline bool Odometry::has_seq_id() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Odometry::set_has_seq_id() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Odometry::clear_has_seq_id() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Odometry::clear_seq_id() {
  seq_id_ = 0u;
  clear_has_seq_id();
}
inline ::google::protobuf::uint32 Odometry::seq_id() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Odometry.seq_id)
  return seq_id_;
}
inline void Odometry::set_seq_id(::google::protobuf::uint32 value) {
  set_has_seq_id();
  seq_id_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.Odometry.seq_id)
}

// required .ndm_proto.Quaternion4d quaternion = 5;
inline bool Odometry::has_quaternion() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Odometry::set_has_quaternion() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Odometry::clear_has_quaternion() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Odometry::clear_quaternion() {
  if (quaternion_ != NULL) quaternion_->Clear();
  clear_has_quaternion();
}
inline const ::ndm_proto::Quaternion4d& Odometry::quaternion() const {
  const ::ndm_proto::Quaternion4d* p = quaternion_;
  // @@protoc_insertion_point(field_get:ndm_proto.Odometry.quaternion)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Quaternion4d*>(
      &::ndm_proto::_Quaternion4d_default_instance_);
}
inline ::ndm_proto::Quaternion4d* Odometry::release_quaternion() {
  // @@protoc_insertion_point(field_release:ndm_proto.Odometry.quaternion)
  clear_has_quaternion();
  ::ndm_proto::Quaternion4d* temp = quaternion_;
  quaternion_ = NULL;
  return temp;
}
inline ::ndm_proto::Quaternion4d* Odometry::mutable_quaternion() {
  set_has_quaternion();
  if (quaternion_ == NULL) {
    quaternion_ = new ::ndm_proto::Quaternion4d;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.Odometry.quaternion)
  return quaternion_;
}
inline void Odometry::set_allocated_quaternion(::ndm_proto::Quaternion4d* quaternion) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete quaternion_;
  }
  if (quaternion) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      quaternion = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, quaternion, submessage_arena);
    }
    set_has_quaternion();
  } else {
    clear_has_quaternion();
  }
  quaternion_ = quaternion;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.Odometry.quaternion)
}

// required .ndm_proto.Point position = 6;
inline bool Odometry::has_position() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Odometry::set_has_position() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Odometry::clear_has_position() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Odometry::clear_position() {
  if (position_ != NULL) position_->Clear();
  clear_has_position();
}
inline const ::ndm_proto::Point& Odometry::position() const {
  const ::ndm_proto::Point* p = position_;
  // @@protoc_insertion_point(field_get:ndm_proto.Odometry.position)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Point*>(
      &::ndm_proto::_Point_default_instance_);
}
inline ::ndm_proto::Point* Odometry::release_position() {
  // @@protoc_insertion_point(field_release:ndm_proto.Odometry.position)
  clear_has_position();
  ::ndm_proto::Point* temp = position_;
  position_ = NULL;
  return temp;
}
inline ::ndm_proto::Point* Odometry::mutable_position() {
  set_has_position();
  if (position_ == NULL) {
    position_ = new ::ndm_proto::Point;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.Odometry.position)
  return position_;
}
inline void Odometry::set_allocated_position(::ndm_proto::Point* position) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete position_;
  }
  if (position) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      position = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    set_has_position();
  } else {
    clear_has_position();
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.Odometry.position)
}

// repeated double pose_cov = 7;
inline int Odometry::pose_cov_size() const {
  return pose_cov_.size();
}
inline void Odometry::clear_pose_cov() {
  pose_cov_.Clear();
}
inline double Odometry::pose_cov(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.Odometry.pose_cov)
  return pose_cov_.Get(index);
}
inline void Odometry::set_pose_cov(int index, double value) {
  pose_cov_.Set(index, value);
  // @@protoc_insertion_point(field_set:ndm_proto.Odometry.pose_cov)
}
inline void Odometry::add_pose_cov(double value) {
  pose_cov_.Add(value);
  // @@protoc_insertion_point(field_add:ndm_proto.Odometry.pose_cov)
}
inline const ::google::protobuf::RepeatedField< double >&
Odometry::pose_cov() const {
  // @@protoc_insertion_point(field_list:ndm_proto.Odometry.pose_cov)
  return pose_cov_;
}
inline ::google::protobuf::RepeatedField< double >*
Odometry::mutable_pose_cov() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.Odometry.pose_cov)
  return &pose_cov_;
}

// required .ndm_proto.Point linear_velocity = 8;
inline bool Odometry::has_linear_velocity() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Odometry::set_has_linear_velocity() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Odometry::clear_has_linear_velocity() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Odometry::clear_linear_velocity() {
  if (linear_velocity_ != NULL) linear_velocity_->Clear();
  clear_has_linear_velocity();
}
inline const ::ndm_proto::Point& Odometry::linear_velocity() const {
  const ::ndm_proto::Point* p = linear_velocity_;
  // @@protoc_insertion_point(field_get:ndm_proto.Odometry.linear_velocity)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Point*>(
      &::ndm_proto::_Point_default_instance_);
}
inline ::ndm_proto::Point* Odometry::release_linear_velocity() {
  // @@protoc_insertion_point(field_release:ndm_proto.Odometry.linear_velocity)
  clear_has_linear_velocity();
  ::ndm_proto::Point* temp = linear_velocity_;
  linear_velocity_ = NULL;
  return temp;
}
inline ::ndm_proto::Point* Odometry::mutable_linear_velocity() {
  set_has_linear_velocity();
  if (linear_velocity_ == NULL) {
    linear_velocity_ = new ::ndm_proto::Point;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.Odometry.linear_velocity)
  return linear_velocity_;
}
inline void Odometry::set_allocated_linear_velocity(::ndm_proto::Point* linear_velocity) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete linear_velocity_;
  }
  if (linear_velocity) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      linear_velocity = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, linear_velocity, submessage_arena);
    }
    set_has_linear_velocity();
  } else {
    clear_has_linear_velocity();
  }
  linear_velocity_ = linear_velocity;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.Odometry.linear_velocity)
}

// required .ndm_proto.Point angular_velocity = 9;
inline bool Odometry::has_angular_velocity() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Odometry::set_has_angular_velocity() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Odometry::clear_has_angular_velocity() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Odometry::clear_angular_velocity() {
  if (angular_velocity_ != NULL) angular_velocity_->Clear();
  clear_has_angular_velocity();
}
inline const ::ndm_proto::Point& Odometry::angular_velocity() const {
  const ::ndm_proto::Point* p = angular_velocity_;
  // @@protoc_insertion_point(field_get:ndm_proto.Odometry.angular_velocity)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Point*>(
      &::ndm_proto::_Point_default_instance_);
}
inline ::ndm_proto::Point* Odometry::release_angular_velocity() {
  // @@protoc_insertion_point(field_release:ndm_proto.Odometry.angular_velocity)
  clear_has_angular_velocity();
  ::ndm_proto::Point* temp = angular_velocity_;
  angular_velocity_ = NULL;
  return temp;
}
inline ::ndm_proto::Point* Odometry::mutable_angular_velocity() {
  set_has_angular_velocity();
  if (angular_velocity_ == NULL) {
    angular_velocity_ = new ::ndm_proto::Point;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.Odometry.angular_velocity)
  return angular_velocity_;
}
inline void Odometry::set_allocated_angular_velocity(::ndm_proto::Point* angular_velocity) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete angular_velocity_;
  }
  if (angular_velocity) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      angular_velocity = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, angular_velocity, submessage_arena);
    }
    set_has_angular_velocity();
  } else {
    clear_has_angular_velocity();
  }
  angular_velocity_ = angular_velocity;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.Odometry.angular_velocity)
}

// repeated double twist_cov = 10;
inline int Odometry::twist_cov_size() const {
  return twist_cov_.size();
}
inline void Odometry::clear_twist_cov() {
  twist_cov_.Clear();
}
inline double Odometry::twist_cov(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.Odometry.twist_cov)
  return twist_cov_.Get(index);
}
inline void Odometry::set_twist_cov(int index, double value) {
  twist_cov_.Set(index, value);
  // @@protoc_insertion_point(field_set:ndm_proto.Odometry.twist_cov)
}
inline void Odometry::add_twist_cov(double value) {
  twist_cov_.Add(value);
  // @@protoc_insertion_point(field_add:ndm_proto.Odometry.twist_cov)
}
inline const ::google::protobuf::RepeatedField< double >&
Odometry::twist_cov() const {
  // @@protoc_insertion_point(field_list:ndm_proto.Odometry.twist_cov)
  return twist_cov_;
}
inline ::google::protobuf::RepeatedField< double >*
Odometry::mutable_twist_cov() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.Odometry.twist_cov)
  return &twist_cov_;
}

// optional string utm_zone = 11;
inline bool Odometry::has_utm_zone() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Odometry::set_has_utm_zone() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Odometry::clear_has_utm_zone() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Odometry::clear_utm_zone() {
  utm_zone_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_utm_zone();
}
inline const ::std::string& Odometry::utm_zone() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Odometry.utm_zone)
  return utm_zone_.GetNoArena();
}
inline void Odometry::set_utm_zone(const ::std::string& value) {
  set_has_utm_zone();
  utm_zone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ndm_proto.Odometry.utm_zone)
}
#if LANG_CXX11
inline void Odometry::set_utm_zone(::std::string&& value) {
  set_has_utm_zone();
  utm_zone_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ndm_proto.Odometry.utm_zone)
}
#endif
inline void Odometry::set_utm_zone(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_utm_zone();
  utm_zone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ndm_proto.Odometry.utm_zone)
}
inline void Odometry::set_utm_zone(const char* value, size_t size) {
  set_has_utm_zone();
  utm_zone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.Odometry.utm_zone)
}
inline ::std::string* Odometry::mutable_utm_zone() {
  set_has_utm_zone();
  // @@protoc_insertion_point(field_mutable:ndm_proto.Odometry.utm_zone)
  return utm_zone_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Odometry::release_utm_zone() {
  // @@protoc_insertion_point(field_release:ndm_proto.Odometry.utm_zone)
  clear_has_utm_zone();
  return utm_zone_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Odometry::set_allocated_utm_zone(::std::string* utm_zone) {
  if (utm_zone != NULL) {
    set_has_utm_zone();
  } else {
    clear_has_utm_zone();
  }
  utm_zone_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), utm_zone);
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.Odometry.utm_zone)
}

// optional .ndm_proto.Point map_offset = 12;
inline bool Odometry::has_map_offset() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Odometry::set_has_map_offset() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Odometry::clear_has_map_offset() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Odometry::clear_map_offset() {
  if (map_offset_ != NULL) map_offset_->Clear();
  clear_has_map_offset();
}
inline const ::ndm_proto::Point& Odometry::map_offset() const {
  const ::ndm_proto::Point* p = map_offset_;
  // @@protoc_insertion_point(field_get:ndm_proto.Odometry.map_offset)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Point*>(
      &::ndm_proto::_Point_default_instance_);
}
inline ::ndm_proto::Point* Odometry::release_map_offset() {
  // @@protoc_insertion_point(field_release:ndm_proto.Odometry.map_offset)
  clear_has_map_offset();
  ::ndm_proto::Point* temp = map_offset_;
  map_offset_ = NULL;
  return temp;
}
inline ::ndm_proto::Point* Odometry::mutable_map_offset() {
  set_has_map_offset();
  if (map_offset_ == NULL) {
    map_offset_ = new ::ndm_proto::Point;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.Odometry.map_offset)
  return map_offset_;
}
inline void Odometry::set_allocated_map_offset(::ndm_proto::Point* map_offset) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete map_offset_;
  }
  if (map_offset) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      map_offset = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, map_offset, submessage_arena);
    }
    set_has_map_offset();
  } else {
    clear_has_map_offset();
  }
  map_offset_ = map_offset;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.Odometry.map_offset)
}

// -------------------------------------------------------------------

// WGS84

// required uint64 stamp = 1;
inline bool WGS84::has_stamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WGS84::set_has_stamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WGS84::clear_has_stamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WGS84::clear_stamp() {
  stamp_ = GOOGLE_ULONGLONG(0);
  clear_has_stamp();
}
inline ::google::protobuf::uint64 WGS84::stamp() const {
  // @@protoc_insertion_point(field_get:ndm_proto.WGS84.stamp)
  return stamp_;
}
inline void WGS84::set_stamp(::google::protobuf::uint64 value) {
  set_has_stamp();
  stamp_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.WGS84.stamp)
}

// required double lat = 2;
inline bool WGS84::has_lat() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WGS84::set_has_lat() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WGS84::clear_has_lat() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WGS84::clear_lat() {
  lat_ = 0;
  clear_has_lat();
}
inline double WGS84::lat() const {
  // @@protoc_insertion_point(field_get:ndm_proto.WGS84.lat)
  return lat_;
}
inline void WGS84::set_lat(double value) {
  set_has_lat();
  lat_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.WGS84.lat)
}

// required double lon = 3;
inline bool WGS84::has_lon() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WGS84::set_has_lon() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WGS84::clear_has_lon() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WGS84::clear_lon() {
  lon_ = 0;
  clear_has_lon();
}
inline double WGS84::lon() const {
  // @@protoc_insertion_point(field_get:ndm_proto.WGS84.lon)
  return lon_;
}
inline void WGS84::set_lon(double value) {
  set_has_lon();
  lon_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.WGS84.lon)
}

// required uint64 height = 4;
inline bool WGS84::has_height() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WGS84::set_has_height() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WGS84::clear_has_height() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WGS84::clear_height() {
  height_ = GOOGLE_ULONGLONG(0);
  clear_has_height();
}
inline ::google::protobuf::uint64 WGS84::height() const {
  // @@protoc_insertion_point(field_get:ndm_proto.WGS84.height)
  return height_;
}
inline void WGS84::set_height(::google::protobuf::uint64 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.WGS84.height)
}

// required double yaw = 5;
inline bool WGS84::has_yaw() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void WGS84::set_has_yaw() {
  _has_bits_[0] |= 0x00000010u;
}
inline void WGS84::clear_has_yaw() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void WGS84::clear_yaw() {
  yaw_ = 0;
  clear_has_yaw();
}
inline double WGS84::yaw() const {
  // @@protoc_insertion_point(field_get:ndm_proto.WGS84.yaw)
  return yaw_;
}
inline void WGS84::set_yaw(double value) {
  set_has_yaw();
  yaw_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.WGS84.yaw)
}

// -------------------------------------------------------------------

// Trajectory

// required uint64 stamp = 1;
inline bool Trajectory::has_stamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Trajectory::set_has_stamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Trajectory::clear_has_stamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Trajectory::clear_stamp() {
  stamp_ = GOOGLE_ULONGLONG(0);
  clear_has_stamp();
}
inline ::google::protobuf::uint64 Trajectory::stamp() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Trajectory.stamp)
  return stamp_;
}
inline void Trajectory::set_stamp(::google::protobuf::uint64 value) {
  set_has_stamp();
  stamp_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.Trajectory.stamp)
}

// optional uint32 seq_id = 2;
inline bool Trajectory::has_seq_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Trajectory::set_has_seq_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Trajectory::clear_has_seq_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Trajectory::clear_seq_id() {
  seq_id_ = 0u;
  clear_has_seq_id();
}
inline ::google::protobuf::uint32 Trajectory::seq_id() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Trajectory.seq_id)
  return seq_id_;
}
inline void Trajectory::set_seq_id(::google::protobuf::uint32 value) {
  set_has_seq_id();
  seq_id_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.Trajectory.seq_id)
}

// repeated .ndm_proto.Odometry odoms = 3;
inline int Trajectory::odoms_size() const {
  return odoms_.size();
}
inline void Trajectory::clear_odoms() {
  odoms_.Clear();
}
inline const ::ndm_proto::Odometry& Trajectory::odoms(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.Trajectory.odoms)
  return odoms_.Get(index);
}
inline ::ndm_proto::Odometry* Trajectory::mutable_odoms(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.Trajectory.odoms)
  return odoms_.Mutable(index);
}
inline ::ndm_proto::Odometry* Trajectory::add_odoms() {
  // @@protoc_insertion_point(field_add:ndm_proto.Trajectory.odoms)
  return odoms_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::Odometry >*
Trajectory::mutable_odoms() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.Trajectory.odoms)
  return &odoms_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Odometry >&
Trajectory::odoms() const {
  // @@protoc_insertion_point(field_list:ndm_proto.Trajectory.odoms)
  return odoms_;
}

// repeated string road_ids = 4;
inline int Trajectory::road_ids_size() const {
  return road_ids_.size();
}
inline void Trajectory::clear_road_ids() {
  road_ids_.Clear();
}
inline const ::std::string& Trajectory::road_ids(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.Trajectory.road_ids)
  return road_ids_.Get(index);
}
inline ::std::string* Trajectory::mutable_road_ids(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.Trajectory.road_ids)
  return road_ids_.Mutable(index);
}
inline void Trajectory::set_road_ids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ndm_proto.Trajectory.road_ids)
  road_ids_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Trajectory::set_road_ids(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:ndm_proto.Trajectory.road_ids)
  road_ids_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Trajectory::set_road_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  road_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ndm_proto.Trajectory.road_ids)
}
inline void Trajectory::set_road_ids(int index, const char* value, size_t size) {
  road_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.Trajectory.road_ids)
}
inline ::std::string* Trajectory::add_road_ids() {
  // @@protoc_insertion_point(field_add_mutable:ndm_proto.Trajectory.road_ids)
  return road_ids_.Add();
}
inline void Trajectory::add_road_ids(const ::std::string& value) {
  road_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ndm_proto.Trajectory.road_ids)
}
#if LANG_CXX11
inline void Trajectory::add_road_ids(::std::string&& value) {
  road_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ndm_proto.Trajectory.road_ids)
}
#endif
inline void Trajectory::add_road_ids(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  road_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ndm_proto.Trajectory.road_ids)
}
inline void Trajectory::add_road_ids(const char* value, size_t size) {
  road_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ndm_proto.Trajectory.road_ids)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Trajectory::road_ids() const {
  // @@protoc_insertion_point(field_list:ndm_proto.Trajectory.road_ids)
  return road_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Trajectory::mutable_road_ids() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.Trajectory.road_ids)
  return &road_ids_;
}

// repeated string lane_ids = 5;
inline int Trajectory::lane_ids_size() const {
  return lane_ids_.size();
}
inline void Trajectory::clear_lane_ids() {
  lane_ids_.Clear();
}
inline const ::std::string& Trajectory::lane_ids(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.Trajectory.lane_ids)
  return lane_ids_.Get(index);
}
inline ::std::string* Trajectory::mutable_lane_ids(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.Trajectory.lane_ids)
  return lane_ids_.Mutable(index);
}
inline void Trajectory::set_lane_ids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ndm_proto.Trajectory.lane_ids)
  lane_ids_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Trajectory::set_lane_ids(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:ndm_proto.Trajectory.lane_ids)
  lane_ids_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Trajectory::set_lane_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  lane_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ndm_proto.Trajectory.lane_ids)
}
inline void Trajectory::set_lane_ids(int index, const char* value, size_t size) {
  lane_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.Trajectory.lane_ids)
}
inline ::std::string* Trajectory::add_lane_ids() {
  // @@protoc_insertion_point(field_add_mutable:ndm_proto.Trajectory.lane_ids)
  return lane_ids_.Add();
}
inline void Trajectory::add_lane_ids(const ::std::string& value) {
  lane_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ndm_proto.Trajectory.lane_ids)
}
#if LANG_CXX11
inline void Trajectory::add_lane_ids(::std::string&& value) {
  lane_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ndm_proto.Trajectory.lane_ids)
}
#endif
inline void Trajectory::add_lane_ids(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  lane_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ndm_proto.Trajectory.lane_ids)
}
inline void Trajectory::add_lane_ids(const char* value, size_t size) {
  lane_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ndm_proto.Trajectory.lane_ids)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Trajectory::lane_ids() const {
  // @@protoc_insertion_point(field_list:ndm_proto.Trajectory.lane_ids)
  return lane_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Trajectory::mutable_lane_ids() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.Trajectory.lane_ids)
  return &lane_ids_;
}

// -------------------------------------------------------------------

// Cylinder

// repeated .ndm_proto.Point points = 1;
inline int Cylinder::points_size() const {
  return points_.size();
}
inline void Cylinder::clear_points() {
  points_.Clear();
}
inline const ::ndm_proto::Point& Cylinder::points(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.Cylinder.points)
  return points_.Get(index);
}
inline ::ndm_proto::Point* Cylinder::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.Cylinder.points)
  return points_.Mutable(index);
}
inline ::ndm_proto::Point* Cylinder::add_points() {
  // @@protoc_insertion_point(field_add:ndm_proto.Cylinder.points)
  return points_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point >*
Cylinder::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.Cylinder.points)
  return &points_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point >&
Cylinder::points() const {
  // @@protoc_insertion_point(field_list:ndm_proto.Cylinder.points)
  return points_;
}

// repeated .ndm_proto.Point pred_points = 2;
inline int Cylinder::pred_points_size() const {
  return pred_points_.size();
}
inline void Cylinder::clear_pred_points() {
  pred_points_.Clear();
}
inline const ::ndm_proto::Point& Cylinder::pred_points(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.Cylinder.pred_points)
  return pred_points_.Get(index);
}
inline ::ndm_proto::Point* Cylinder::mutable_pred_points(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.Cylinder.pred_points)
  return pred_points_.Mutable(index);
}
inline ::ndm_proto::Point* Cylinder::add_pred_points() {
  // @@protoc_insertion_point(field_add:ndm_proto.Cylinder.pred_points)
  return pred_points_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point >*
Cylinder::mutable_pred_points() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.Cylinder.pred_points)
  return &pred_points_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point >&
Cylinder::pred_points() const {
  // @@protoc_insertion_point(field_list:ndm_proto.Cylinder.pred_points)
  return pred_points_;
}

// repeated .ndm_proto.Point succ_points = 3;
inline int Cylinder::succ_points_size() const {
  return succ_points_.size();
}
inline void Cylinder::clear_succ_points() {
  succ_points_.Clear();
}
inline const ::ndm_proto::Point& Cylinder::succ_points(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.Cylinder.succ_points)
  return succ_points_.Get(index);
}
inline ::ndm_proto::Point* Cylinder::mutable_succ_points(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.Cylinder.succ_points)
  return succ_points_.Mutable(index);
}
inline ::ndm_proto::Point* Cylinder::add_succ_points() {
  // @@protoc_insertion_point(field_add:ndm_proto.Cylinder.succ_points)
  return succ_points_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point >*
Cylinder::mutable_succ_points() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.Cylinder.succ_points)
  return &succ_points_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point >&
Cylinder::succ_points() const {
  // @@protoc_insertion_point(field_list:ndm_proto.Cylinder.succ_points)
  return succ_points_;
}

// optional .ndm_proto.Number radius = 4;
inline bool Cylinder::has_radius() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Cylinder::set_has_radius() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Cylinder::clear_has_radius() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Cylinder::clear_radius() {
  if (radius_ != NULL) radius_->Clear();
  clear_has_radius();
}
inline const ::ndm_proto::Number& Cylinder::radius() const {
  const ::ndm_proto::Number* p = radius_;
  // @@protoc_insertion_point(field_get:ndm_proto.Cylinder.radius)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Number*>(
      &::ndm_proto::_Number_default_instance_);
}
inline ::ndm_proto::Number* Cylinder::release_radius() {
  // @@protoc_insertion_point(field_release:ndm_proto.Cylinder.radius)
  clear_has_radius();
  ::ndm_proto::Number* temp = radius_;
  radius_ = NULL;
  return temp;
}
inline ::ndm_proto::Number* Cylinder::mutable_radius() {
  set_has_radius();
  if (radius_ == NULL) {
    radius_ = new ::ndm_proto::Number;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.Cylinder.radius)
  return radius_;
}
inline void Cylinder::set_allocated_radius(::ndm_proto::Number* radius) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete radius_;
  }
  if (radius) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      radius = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, radius, submessage_arena);
    }
    set_has_radius();
  } else {
    clear_has_radius();
  }
  radius_ = radius;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.Cylinder.radius)
}

// -------------------------------------------------------------------

// Circle

// required .ndm_proto.Point center = 1;
inline bool Circle::has_center() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Circle::set_has_center() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Circle::clear_has_center() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Circle::clear_center() {
  if (center_ != NULL) center_->Clear();
  clear_has_center();
}
inline const ::ndm_proto::Point& Circle::center() const {
  const ::ndm_proto::Point* p = center_;
  // @@protoc_insertion_point(field_get:ndm_proto.Circle.center)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Point*>(
      &::ndm_proto::_Point_default_instance_);
}
inline ::ndm_proto::Point* Circle::release_center() {
  // @@protoc_insertion_point(field_release:ndm_proto.Circle.center)
  clear_has_center();
  ::ndm_proto::Point* temp = center_;
  center_ = NULL;
  return temp;
}
inline ::ndm_proto::Point* Circle::mutable_center() {
  set_has_center();
  if (center_ == NULL) {
    center_ = new ::ndm_proto::Point;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.Circle.center)
  return center_;
}
inline void Circle::set_allocated_center(::ndm_proto::Point* center) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete center_;
  }
  if (center) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      center = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, center, submessage_arena);
    }
    set_has_center();
  } else {
    clear_has_center();
  }
  center_ = center;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.Circle.center)
}

// required .ndm_proto.Point normal = 2;
inline bool Circle::has_normal() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Circle::set_has_normal() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Circle::clear_has_normal() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Circle::clear_normal() {
  if (normal_ != NULL) normal_->Clear();
  clear_has_normal();
}
inline const ::ndm_proto::Point& Circle::normal() const {
  const ::ndm_proto::Point* p = normal_;
  // @@protoc_insertion_point(field_get:ndm_proto.Circle.normal)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Point*>(
      &::ndm_proto::_Point_default_instance_);
}
inline ::ndm_proto::Point* Circle::release_normal() {
  // @@protoc_insertion_point(field_release:ndm_proto.Circle.normal)
  clear_has_normal();
  ::ndm_proto::Point* temp = normal_;
  normal_ = NULL;
  return temp;
}
inline ::ndm_proto::Point* Circle::mutable_normal() {
  set_has_normal();
  if (normal_ == NULL) {
    normal_ = new ::ndm_proto::Point;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.Circle.normal)
  return normal_;
}
inline void Circle::set_allocated_normal(::ndm_proto::Point* normal) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete normal_;
  }
  if (normal) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      normal = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, normal, submessage_arena);
    }
    set_has_normal();
  } else {
    clear_has_normal();
  }
  normal_ = normal;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.Circle.normal)
}

// required .ndm_proto.Number radius = 3;
inline bool Circle::has_radius() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Circle::set_has_radius() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Circle::clear_has_radius() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Circle::clear_radius() {
  if (radius_ != NULL) radius_->Clear();
  clear_has_radius();
}
inline const ::ndm_proto::Number& Circle::radius() const {
  const ::ndm_proto::Number* p = radius_;
  // @@protoc_insertion_point(field_get:ndm_proto.Circle.radius)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Number*>(
      &::ndm_proto::_Number_default_instance_);
}
inline ::ndm_proto::Number* Circle::release_radius() {
  // @@protoc_insertion_point(field_release:ndm_proto.Circle.radius)
  clear_has_radius();
  ::ndm_proto::Number* temp = radius_;
  radius_ = NULL;
  return temp;
}
inline ::ndm_proto::Number* Circle::mutable_radius() {
  set_has_radius();
  if (radius_ == NULL) {
    radius_ = new ::ndm_proto::Number;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.Circle.radius)
  return radius_;
}
inline void Circle::set_allocated_radius(::ndm_proto::Number* radius) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete radius_;
  }
  if (radius) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      radius = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, radius, submessage_arena);
    }
    set_has_radius();
  } else {
    clear_has_radius();
  }
  radius_ = radius;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.Circle.radius)
}

// optional float edgeline_width = 5;
inline bool Circle::has_edgeline_width() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Circle::set_has_edgeline_width() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Circle::clear_has_edgeline_width() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Circle::clear_edgeline_width() {
  edgeline_width_ = 0;
  clear_has_edgeline_width();
}
inline float Circle::edgeline_width() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Circle.edgeline_width)
  return edgeline_width_;
}
inline void Circle::set_edgeline_width(float value) {
  set_has_edgeline_width();
  edgeline_width_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.Circle.edgeline_width)
}

// -------------------------------------------------------------------

// CurveLine

// repeated .ndm_proto.Point points = 1;
inline int CurveLine::points_size() const {
  return points_.size();
}
inline void CurveLine::clear_points() {
  points_.Clear();
}
inline const ::ndm_proto::Point& CurveLine::points(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.CurveLine.points)
  return points_.Get(index);
}
inline ::ndm_proto::Point* CurveLine::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.CurveLine.points)
  return points_.Mutable(index);
}
inline ::ndm_proto::Point* CurveLine::add_points() {
  // @@protoc_insertion_point(field_add:ndm_proto.CurveLine.points)
  return points_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point >*
CurveLine::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.CurveLine.points)
  return &points_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point >&
CurveLine::points() const {
  // @@protoc_insertion_point(field_list:ndm_proto.CurveLine.points)
  return points_;
}

// repeated .ndm_proto.Point pred_points = 2;
inline int CurveLine::pred_points_size() const {
  return pred_points_.size();
}
inline void CurveLine::clear_pred_points() {
  pred_points_.Clear();
}
inline const ::ndm_proto::Point& CurveLine::pred_points(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.CurveLine.pred_points)
  return pred_points_.Get(index);
}
inline ::ndm_proto::Point* CurveLine::mutable_pred_points(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.CurveLine.pred_points)
  return pred_points_.Mutable(index);
}
inline ::ndm_proto::Point* CurveLine::add_pred_points() {
  // @@protoc_insertion_point(field_add:ndm_proto.CurveLine.pred_points)
  return pred_points_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point >*
CurveLine::mutable_pred_points() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.CurveLine.pred_points)
  return &pred_points_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point >&
CurveLine::pred_points() const {
  // @@protoc_insertion_point(field_list:ndm_proto.CurveLine.pred_points)
  return pred_points_;
}

// repeated .ndm_proto.Point succ_points = 3;
inline int CurveLine::succ_points_size() const {
  return succ_points_.size();
}
inline void CurveLine::clear_succ_points() {
  succ_points_.Clear();
}
inline const ::ndm_proto::Point& CurveLine::succ_points(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.CurveLine.succ_points)
  return succ_points_.Get(index);
}
inline ::ndm_proto::Point* CurveLine::mutable_succ_points(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.CurveLine.succ_points)
  return succ_points_.Mutable(index);
}
inline ::ndm_proto::Point* CurveLine::add_succ_points() {
  // @@protoc_insertion_point(field_add:ndm_proto.CurveLine.succ_points)
  return succ_points_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point >*
CurveLine::mutable_succ_points() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.CurveLine.succ_points)
  return &succ_points_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point >&
CurveLine::succ_points() const {
  // @@protoc_insertion_point(field_list:ndm_proto.CurveLine.succ_points)
  return succ_points_;
}

// optional .ndm_proto.Number width = 4;
inline bool CurveLine::has_width() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CurveLine::set_has_width() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CurveLine::clear_has_width() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CurveLine::clear_width() {
  if (width_ != NULL) width_->Clear();
  clear_has_width();
}
inline const ::ndm_proto::Number& CurveLine::width() const {
  const ::ndm_proto::Number* p = width_;
  // @@protoc_insertion_point(field_get:ndm_proto.CurveLine.width)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Number*>(
      &::ndm_proto::_Number_default_instance_);
}
inline ::ndm_proto::Number* CurveLine::release_width() {
  // @@protoc_insertion_point(field_release:ndm_proto.CurveLine.width)
  clear_has_width();
  ::ndm_proto::Number* temp = width_;
  width_ = NULL;
  return temp;
}
inline ::ndm_proto::Number* CurveLine::mutable_width() {
  set_has_width();
  if (width_ == NULL) {
    width_ = new ::ndm_proto::Number;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.CurveLine.width)
  return width_;
}
inline void CurveLine::set_allocated_width(::ndm_proto::Number* width) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete width_;
  }
  if (width) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      width = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, width, submessage_arena);
    }
    set_has_width();
  } else {
    clear_has_width();
  }
  width_ = width;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.CurveLine.width)
}

// repeated uint64 index = 5;
inline int CurveLine::index_size() const {
  return index_.size();
}
inline void CurveLine::clear_index() {
  index_.Clear();
}
inline ::google::protobuf::uint64 CurveLine::index(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.CurveLine.index)
  return index_.Get(index);
}
inline void CurveLine::set_index(int index, ::google::protobuf::uint64 value) {
  index_.Set(index, value);
  // @@protoc_insertion_point(field_set:ndm_proto.CurveLine.index)
}
inline void CurveLine::add_index(::google::protobuf::uint64 value) {
  index_.Add(value);
  // @@protoc_insertion_point(field_add:ndm_proto.CurveLine.index)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
CurveLine::index() const {
  // @@protoc_insertion_point(field_list:ndm_proto.CurveLine.index)
  return index_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
CurveLine::mutable_index() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.CurveLine.index)
  return &index_;
}

// repeated double t = 6;
inline int CurveLine::t_size() const {
  return t_.size();
}
inline void CurveLine::clear_t() {
  t_.Clear();
}
inline double CurveLine::t(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.CurveLine.t)
  return t_.Get(index);
}
inline void CurveLine::set_t(int index, double value) {
  t_.Set(index, value);
  // @@protoc_insertion_point(field_set:ndm_proto.CurveLine.t)
}
inline void CurveLine::add_t(double value) {
  t_.Add(value);
  // @@protoc_insertion_point(field_add:ndm_proto.CurveLine.t)
}
inline const ::google::protobuf::RepeatedField< double >&
CurveLine::t() const {
  // @@protoc_insertion_point(field_list:ndm_proto.CurveLine.t)
  return t_;
}
inline ::google::protobuf::RepeatedField< double >*
CurveLine::mutable_t() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.CurveLine.t)
  return &t_;
}

// repeated .ndm_proto.Point x_coeff = 7;
inline int CurveLine::x_coeff_size() const {
  return x_coeff_.size();
}
inline void CurveLine::clear_x_coeff() {
  x_coeff_.Clear();
}
inline const ::ndm_proto::Point& CurveLine::x_coeff(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.CurveLine.x_coeff)
  return x_coeff_.Get(index);
}
inline ::ndm_proto::Point* CurveLine::mutable_x_coeff(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.CurveLine.x_coeff)
  return x_coeff_.Mutable(index);
}
inline ::ndm_proto::Point* CurveLine::add_x_coeff() {
  // @@protoc_insertion_point(field_add:ndm_proto.CurveLine.x_coeff)
  return x_coeff_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point >*
CurveLine::mutable_x_coeff() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.CurveLine.x_coeff)
  return &x_coeff_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point >&
CurveLine::x_coeff() const {
  // @@protoc_insertion_point(field_list:ndm_proto.CurveLine.x_coeff)
  return x_coeff_;
}

// repeated .ndm_proto.Point y_coeff = 8;
inline int CurveLine::y_coeff_size() const {
  return y_coeff_.size();
}
inline void CurveLine::clear_y_coeff() {
  y_coeff_.Clear();
}
inline const ::ndm_proto::Point& CurveLine::y_coeff(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.CurveLine.y_coeff)
  return y_coeff_.Get(index);
}
inline ::ndm_proto::Point* CurveLine::mutable_y_coeff(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.CurveLine.y_coeff)
  return y_coeff_.Mutable(index);
}
inline ::ndm_proto::Point* CurveLine::add_y_coeff() {
  // @@protoc_insertion_point(field_add:ndm_proto.CurveLine.y_coeff)
  return y_coeff_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point >*
CurveLine::mutable_y_coeff() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.CurveLine.y_coeff)
  return &y_coeff_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point >&
CurveLine::y_coeff() const {
  // @@protoc_insertion_point(field_list:ndm_proto.CurveLine.y_coeff)
  return y_coeff_;
}

// repeated .ndm_proto.Point z_coeff = 9;
inline int CurveLine::z_coeff_size() const {
  return z_coeff_.size();
}
inline void CurveLine::clear_z_coeff() {
  z_coeff_.Clear();
}
inline const ::ndm_proto::Point& CurveLine::z_coeff(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.CurveLine.z_coeff)
  return z_coeff_.Get(index);
}
inline ::ndm_proto::Point* CurveLine::mutable_z_coeff(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.CurveLine.z_coeff)
  return z_coeff_.Mutable(index);
}
inline ::ndm_proto::Point* CurveLine::add_z_coeff() {
  // @@protoc_insertion_point(field_add:ndm_proto.CurveLine.z_coeff)
  return z_coeff_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point >*
CurveLine::mutable_z_coeff() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.CurveLine.z_coeff)
  return &z_coeff_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point >&
CurveLine::z_coeff() const {
  // @@protoc_insertion_point(field_list:ndm_proto.CurveLine.z_coeff)
  return z_coeff_;
}

// repeated double t_max = 10;
inline int CurveLine::t_max_size() const {
  return t_max_.size();
}
inline void CurveLine::clear_t_max() {
  t_max_.Clear();
}
inline double CurveLine::t_max(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.CurveLine.t_max)
  return t_max_.Get(index);
}
inline void CurveLine::set_t_max(int index, double value) {
  t_max_.Set(index, value);
  // @@protoc_insertion_point(field_set:ndm_proto.CurveLine.t_max)
}
inline void CurveLine::add_t_max(double value) {
  t_max_.Add(value);
  // @@protoc_insertion_point(field_add:ndm_proto.CurveLine.t_max)
}
inline const ::google::protobuf::RepeatedField< double >&
CurveLine::t_max() const {
  // @@protoc_insertion_point(field_list:ndm_proto.CurveLine.t_max)
  return t_max_;
}
inline ::google::protobuf::RepeatedField< double >*
CurveLine::mutable_t_max() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.CurveLine.t_max)
  return &t_max_;
}

// repeated .ndm_proto.Point up_points = 11;
inline int CurveLine::up_points_size() const {
  return up_points_.size();
}
inline void CurveLine::clear_up_points() {
  up_points_.Clear();
}
inline const ::ndm_proto::Point& CurveLine::up_points(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.CurveLine.up_points)
  return up_points_.Get(index);
}
inline ::ndm_proto::Point* CurveLine::mutable_up_points(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.CurveLine.up_points)
  return up_points_.Mutable(index);
}
inline ::ndm_proto::Point* CurveLine::add_up_points() {
  // @@protoc_insertion_point(field_add:ndm_proto.CurveLine.up_points)
  return up_points_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point >*
CurveLine::mutable_up_points() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.CurveLine.up_points)
  return &up_points_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point >&
CurveLine::up_points() const {
  // @@protoc_insertion_point(field_list:ndm_proto.CurveLine.up_points)
  return up_points_;
}

// repeated .ndm_proto.Point h_coeff = 12;
inline int CurveLine::h_coeff_size() const {
  return h_coeff_.size();
}
inline void CurveLine::clear_h_coeff() {
  h_coeff_.Clear();
}
inline const ::ndm_proto::Point& CurveLine::h_coeff(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.CurveLine.h_coeff)
  return h_coeff_.Get(index);
}
inline ::ndm_proto::Point* CurveLine::mutable_h_coeff(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.CurveLine.h_coeff)
  return h_coeff_.Mutable(index);
}
inline ::ndm_proto::Point* CurveLine::add_h_coeff() {
  // @@protoc_insertion_point(field_add:ndm_proto.CurveLine.h_coeff)
  return h_coeff_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point >*
CurveLine::mutable_h_coeff() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.CurveLine.h_coeff)
  return &h_coeff_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point >&
CurveLine::h_coeff() const {
  // @@protoc_insertion_point(field_list:ndm_proto.CurveLine.h_coeff)
  return h_coeff_;
}

// repeated .ndm_proto.Number pred_points_height = 13;
inline int CurveLine::pred_points_height_size() const {
  return pred_points_height_.size();
}
inline void CurveLine::clear_pred_points_height() {
  pred_points_height_.Clear();
}
inline const ::ndm_proto::Number& CurveLine::pred_points_height(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.CurveLine.pred_points_height)
  return pred_points_height_.Get(index);
}
inline ::ndm_proto::Number* CurveLine::mutable_pred_points_height(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.CurveLine.pred_points_height)
  return pred_points_height_.Mutable(index);
}
inline ::ndm_proto::Number* CurveLine::add_pred_points_height() {
  // @@protoc_insertion_point(field_add:ndm_proto.CurveLine.pred_points_height)
  return pred_points_height_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::Number >*
CurveLine::mutable_pred_points_height() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.CurveLine.pred_points_height)
  return &pred_points_height_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Number >&
CurveLine::pred_points_height() const {
  // @@protoc_insertion_point(field_list:ndm_proto.CurveLine.pred_points_height)
  return pred_points_height_;
}

// -------------------------------------------------------------------

// Polygon

// repeated .ndm_proto.Point points = 1;
inline int Polygon::points_size() const {
  return points_.size();
}
inline void Polygon::clear_points() {
  points_.Clear();
}
inline const ::ndm_proto::Point& Polygon::points(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.Polygon.points)
  return points_.Get(index);
}
inline ::ndm_proto::Point* Polygon::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.Polygon.points)
  return points_.Mutable(index);
}
inline ::ndm_proto::Point* Polygon::add_points() {
  // @@protoc_insertion_point(field_add:ndm_proto.Polygon.points)
  return points_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point >*
Polygon::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.Polygon.points)
  return &points_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Point >&
Polygon::points() const {
  // @@protoc_insertion_point(field_list:ndm_proto.Polygon.points)
  return points_;
}

// optional .ndm_proto.Point normal = 2;
inline bool Polygon::has_normal() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Polygon::set_has_normal() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Polygon::clear_has_normal() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Polygon::clear_normal() {
  if (normal_ != NULL) normal_->Clear();
  clear_has_normal();
}
inline const ::ndm_proto::Point& Polygon::normal() const {
  const ::ndm_proto::Point* p = normal_;
  // @@protoc_insertion_point(field_get:ndm_proto.Polygon.normal)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Point*>(
      &::ndm_proto::_Point_default_instance_);
}
inline ::ndm_proto::Point* Polygon::release_normal() {
  // @@protoc_insertion_point(field_release:ndm_proto.Polygon.normal)
  clear_has_normal();
  ::ndm_proto::Point* temp = normal_;
  normal_ = NULL;
  return temp;
}
inline ::ndm_proto::Point* Polygon::mutable_normal() {
  set_has_normal();
  if (normal_ == NULL) {
    normal_ = new ::ndm_proto::Point;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.Polygon.normal)
  return normal_;
}
inline void Polygon::set_allocated_normal(::ndm_proto::Point* normal) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete normal_;
  }
  if (normal) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      normal = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, normal, submessage_arena);
    }
    set_has_normal();
  } else {
    clear_has_normal();
  }
  normal_ = normal;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.Polygon.normal)
}

// optional float edgeline_width = 3;
inline bool Polygon::has_edgeline_width() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Polygon::set_has_edgeline_width() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Polygon::clear_has_edgeline_width() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Polygon::clear_edgeline_width() {
  edgeline_width_ = 0;
  clear_has_edgeline_width();
}
inline float Polygon::edgeline_width() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Polygon.edgeline_width)
  return edgeline_width_;
}
inline void Polygon::set_edgeline_width(float value) {
  set_has_edgeline_width();
  edgeline_width_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.Polygon.edgeline_width)
}

// optional .ndm_proto.Point orientation = 4;
inline bool Polygon::has_orientation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Polygon::set_has_orientation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Polygon::clear_has_orientation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Polygon::clear_orientation() {
  if (orientation_ != NULL) orientation_->Clear();
  clear_has_orientation();
}
inline const ::ndm_proto::Point& Polygon::orientation() const {
  const ::ndm_proto::Point* p = orientation_;
  // @@protoc_insertion_point(field_get:ndm_proto.Polygon.orientation)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Point*>(
      &::ndm_proto::_Point_default_instance_);
}
inline ::ndm_proto::Point* Polygon::release_orientation() {
  // @@protoc_insertion_point(field_release:ndm_proto.Polygon.orientation)
  clear_has_orientation();
  ::ndm_proto::Point* temp = orientation_;
  orientation_ = NULL;
  return temp;
}
inline ::ndm_proto::Point* Polygon::mutable_orientation() {
  set_has_orientation();
  if (orientation_ == NULL) {
    orientation_ = new ::ndm_proto::Point;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.Polygon.orientation)
  return orientation_;
}
inline void Polygon::set_allocated_orientation(::ndm_proto::Point* orientation) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete orientation_;
  }
  if (orientation) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      orientation = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, orientation, submessage_arena);
    }
    set_has_orientation();
  } else {
    clear_has_orientation();
  }
  orientation_ = orientation;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.Polygon.orientation)
}

// -------------------------------------------------------------------

// TrafficLightType

// required .ndm_proto.TrafficLightType.Type type = 1;
inline bool TrafficLightType::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrafficLightType::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrafficLightType::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrafficLightType::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::ndm_proto::TrafficLightType_Type TrafficLightType::type() const {
  // @@protoc_insertion_point(field_get:ndm_proto.TrafficLightType.type)
  return static_cast< ::ndm_proto::TrafficLightType_Type >(type_);
}
inline void TrafficLightType::set_type(::ndm_proto::TrafficLightType_Type value) {
  assert(::ndm_proto::TrafficLightType_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.TrafficLightType.type)
}

// optional float conf = 2;
inline bool TrafficLightType::has_conf() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrafficLightType::set_has_conf() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrafficLightType::clear_has_conf() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrafficLightType::clear_conf() {
  conf_ = 0;
  clear_has_conf();
}
inline float TrafficLightType::conf() const {
  // @@protoc_insertion_point(field_get:ndm_proto.TrafficLightType.conf)
  return conf_;
}
inline void TrafficLightType::set_conf(float value) {
  set_has_conf();
  conf_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.TrafficLightType.conf)
}

// -------------------------------------------------------------------

// TrafficLightState

// required .ndm_proto.TrafficLightState.State state = 1;
inline bool TrafficLightState::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrafficLightState::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrafficLightState::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrafficLightState::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::ndm_proto::TrafficLightState_State TrafficLightState::state() const {
  // @@protoc_insertion_point(field_get:ndm_proto.TrafficLightState.state)
  return static_cast< ::ndm_proto::TrafficLightState_State >(state_);
}
inline void TrafficLightState::set_state(::ndm_proto::TrafficLightState_State value) {
  assert(::ndm_proto::TrafficLightState_State_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.TrafficLightState.state)
}

// optional float conf = 2;
inline bool TrafficLightState::has_conf() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrafficLightState::set_has_conf() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrafficLightState::clear_has_conf() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrafficLightState::clear_conf() {
  conf_ = 0;
  clear_has_conf();
}
inline float TrafficLightState::conf() const {
  // @@protoc_insertion_point(field_get:ndm_proto.TrafficLightState.conf)
  return conf_;
}
inline void TrafficLightState::set_conf(float value) {
  set_has_conf();
  conf_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.TrafficLightState.conf)
}

// -------------------------------------------------------------------

// TrafficLightBulbColor

// required .ndm_proto.TrafficLightBulbColor.Color color = 1;
inline bool TrafficLightBulbColor::has_color() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrafficLightBulbColor::set_has_color() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrafficLightBulbColor::clear_has_color() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrafficLightBulbColor::clear_color() {
  color_ = 0;
  clear_has_color();
}
inline ::ndm_proto::TrafficLightBulbColor_Color TrafficLightBulbColor::color() const {
  // @@protoc_insertion_point(field_get:ndm_proto.TrafficLightBulbColor.color)
  return static_cast< ::ndm_proto::TrafficLightBulbColor_Color >(color_);
}
inline void TrafficLightBulbColor::set_color(::ndm_proto::TrafficLightBulbColor_Color value) {
  assert(::ndm_proto::TrafficLightBulbColor_Color_IsValid(value));
  set_has_color();
  color_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.TrafficLightBulbColor.color)
}

// optional float conf = 2;
inline bool TrafficLightBulbColor::has_conf() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrafficLightBulbColor::set_has_conf() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrafficLightBulbColor::clear_has_conf() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrafficLightBulbColor::clear_conf() {
  conf_ = 0;
  clear_has_conf();
}
inline float TrafficLightBulbColor::conf() const {
  // @@protoc_insertion_point(field_get:ndm_proto.TrafficLightBulbColor.conf)
  return conf_;
}
inline void TrafficLightBulbColor::set_conf(float value) {
  set_has_conf();
  conf_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.TrafficLightBulbColor.conf)
}

// -------------------------------------------------------------------

// TrafficLightBulbShape

// required .ndm_proto.TrafficLightBulbShape.Type type = 1;
inline bool TrafficLightBulbShape::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrafficLightBulbShape::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrafficLightBulbShape::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrafficLightBulbShape::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::ndm_proto::TrafficLightBulbShape_Type TrafficLightBulbShape::type() const {
  // @@protoc_insertion_point(field_get:ndm_proto.TrafficLightBulbShape.type)
  return static_cast< ::ndm_proto::TrafficLightBulbShape_Type >(type_);
}
inline void TrafficLightBulbShape::set_type(::ndm_proto::TrafficLightBulbShape_Type value) {
  assert(::ndm_proto::TrafficLightBulbShape_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.TrafficLightBulbShape.type)
}

// optional float conf = 2;
inline bool TrafficLightBulbShape::has_conf() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrafficLightBulbShape::set_has_conf() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrafficLightBulbShape::clear_has_conf() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrafficLightBulbShape::clear_conf() {
  conf_ = 0;
  clear_has_conf();
}
inline float TrafficLightBulbShape::conf() const {
  // @@protoc_insertion_point(field_get:ndm_proto.TrafficLightBulbShape.conf)
  return conf_;
}
inline void TrafficLightBulbShape::set_conf(float value) {
  set_has_conf();
  conf_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.TrafficLightBulbShape.conf)
}

// -------------------------------------------------------------------

// LaneMarkingType

// required .ndm_proto.LaneMarkingType.Type type = 1;
inline bool LaneMarkingType::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LaneMarkingType::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LaneMarkingType::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LaneMarkingType::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::ndm_proto::LaneMarkingType_Type LaneMarkingType::type() const {
  // @@protoc_insertion_point(field_get:ndm_proto.LaneMarkingType.type)
  return static_cast< ::ndm_proto::LaneMarkingType_Type >(type_);
}
inline void LaneMarkingType::set_type(::ndm_proto::LaneMarkingType_Type value) {
  assert(::ndm_proto::LaneMarkingType_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.LaneMarkingType.type)
}

// optional float conf = 2;
inline bool LaneMarkingType::has_conf() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LaneMarkingType::set_has_conf() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LaneMarkingType::clear_has_conf() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LaneMarkingType::clear_conf() {
  conf_ = 0;
  clear_has_conf();
}
inline float LaneMarkingType::conf() const {
  // @@protoc_insertion_point(field_get:ndm_proto.LaneMarkingType.conf)
  return conf_;
}
inline void LaneMarkingType::set_conf(float value) {
  set_has_conf();
  conf_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.LaneMarkingType.conf)
}

// -------------------------------------------------------------------

// LaneFunction

// required .ndm_proto.LaneFunction.Function function = 1;
inline bool LaneFunction::has_function() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LaneFunction::set_has_function() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LaneFunction::clear_has_function() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LaneFunction::clear_function() {
  function_ = 0;
  clear_has_function();
}
inline ::ndm_proto::LaneFunction_Function LaneFunction::function() const {
  // @@protoc_insertion_point(field_get:ndm_proto.LaneFunction.function)
  return static_cast< ::ndm_proto::LaneFunction_Function >(function_);
}
inline void LaneFunction::set_function(::ndm_proto::LaneFunction_Function value) {
  assert(::ndm_proto::LaneFunction_Function_IsValid(value));
  set_has_function();
  function_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.LaneFunction.function)
}

// optional float conf = 2;
inline bool LaneFunction::has_conf() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LaneFunction::set_has_conf() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LaneFunction::clear_has_conf() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LaneFunction::clear_conf() {
  conf_ = 0;
  clear_has_conf();
}
inline float LaneFunction::conf() const {
  // @@protoc_insertion_point(field_get:ndm_proto.LaneFunction.conf)
  return conf_;
}
inline void LaneFunction::set_conf(float value) {
  set_has_conf();
  conf_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.LaneFunction.conf)
}

// -------------------------------------------------------------------

// LaneDirection

// required .ndm_proto.LaneDirection.Direction direction = 1;
inline bool LaneDirection::has_direction() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LaneDirection::set_has_direction() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LaneDirection::clear_has_direction() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LaneDirection::clear_direction() {
  direction_ = 1;
  clear_has_direction();
}
inline ::ndm_proto::LaneDirection_Direction LaneDirection::direction() const {
  // @@protoc_insertion_point(field_get:ndm_proto.LaneDirection.direction)
  return static_cast< ::ndm_proto::LaneDirection_Direction >(direction_);
}
inline void LaneDirection::set_direction(::ndm_proto::LaneDirection_Direction value) {
  assert(::ndm_proto::LaneDirection_Direction_IsValid(value));
  set_has_direction();
  direction_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.LaneDirection.direction)
}

// optional float conf = 2;
inline bool LaneDirection::has_conf() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LaneDirection::set_has_conf() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LaneDirection::clear_has_conf() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LaneDirection::clear_conf() {
  conf_ = 0;
  clear_has_conf();
}
inline float LaneDirection::conf() const {
  // @@protoc_insertion_point(field_get:ndm_proto.LaneDirection.conf)
  return conf_;
}
inline void LaneDirection::set_conf(float value) {
  set_has_conf();
  conf_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.LaneDirection.conf)
}

// -------------------------------------------------------------------

// LaneAttr

// required float curvature = 1;
inline bool LaneAttr::has_curvature() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LaneAttr::set_has_curvature() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LaneAttr::clear_has_curvature() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LaneAttr::clear_curvature() {
  curvature_ = 0;
  clear_has_curvature();
}
inline float LaneAttr::curvature() const {
  // @@protoc_insertion_point(field_get:ndm_proto.LaneAttr.curvature)
  return curvature_;
}
inline void LaneAttr::set_curvature(float value) {
  set_has_curvature();
  curvature_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.LaneAttr.curvature)
}

// required float slope = 2;
inline bool LaneAttr::has_slope() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LaneAttr::set_has_slope() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LaneAttr::clear_has_slope() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LaneAttr::clear_slope() {
  slope_ = 0;
  clear_has_slope();
}
inline float LaneAttr::slope() const {
  // @@protoc_insertion_point(field_get:ndm_proto.LaneAttr.slope)
  return slope_;
}
inline void LaneAttr::set_slope(float value) {
  set_has_slope();
  slope_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.LaneAttr.slope)
}

// required float banking = 3;
inline bool LaneAttr::has_banking() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LaneAttr::set_has_banking() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LaneAttr::clear_has_banking() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LaneAttr::clear_banking() {
  banking_ = 0;
  clear_has_banking();
}
inline float LaneAttr::banking() const {
  // @@protoc_insertion_point(field_get:ndm_proto.LaneAttr.banking)
  return banking_;
}
inline void LaneAttr::set_banking(float value) {
  set_has_banking();
  banking_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.LaneAttr.banking)
}

// required float headingAngle = 4;
inline bool LaneAttr::has_headingangle() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LaneAttr::set_has_headingangle() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LaneAttr::clear_has_headingangle() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LaneAttr::clear_headingangle() {
  headingangle_ = 0;
  clear_has_headingangle();
}
inline float LaneAttr::headingangle() const {
  // @@protoc_insertion_point(field_get:ndm_proto.LaneAttr.headingAngle)
  return headingangle_;
}
inline void LaneAttr::set_headingangle(float value) {
  set_has_headingangle();
  headingangle_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.LaneAttr.headingAngle)
}

// required float offset = 5;
inline bool LaneAttr::has_offset() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LaneAttr::set_has_offset() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LaneAttr::clear_has_offset() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LaneAttr::clear_offset() {
  offset_ = 0;
  clear_has_offset();
}
inline float LaneAttr::offset() const {
  // @@protoc_insertion_point(field_get:ndm_proto.LaneAttr.offset)
  return offset_;
}
inline void LaneAttr::set_offset(float value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.LaneAttr.offset)
}

// -------------------------------------------------------------------

// VehicleType

// required .ndm_proto.VehicleType.Type type = 1;
inline bool VehicleType::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VehicleType::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VehicleType::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VehicleType::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::ndm_proto::VehicleType_Type VehicleType::type() const {
  // @@protoc_insertion_point(field_get:ndm_proto.VehicleType.type)
  return static_cast< ::ndm_proto::VehicleType_Type >(type_);
}
inline void VehicleType::set_type(::ndm_proto::VehicleType_Type value) {
  assert(::ndm_proto::VehicleType_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.VehicleType.type)
}

// optional float conf = 2;
inline bool VehicleType::has_conf() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VehicleType::set_has_conf() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VehicleType::clear_has_conf() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VehicleType::clear_conf() {
  conf_ = 0;
  clear_has_conf();
}
inline float VehicleType::conf() const {
  // @@protoc_insertion_point(field_get:ndm_proto.VehicleType.conf)
  return conf_;
}
inline void VehicleType::set_conf(float value) {
  set_has_conf();
  conf_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.VehicleType.conf)
}

// -------------------------------------------------------------------

// SpeedLimit

// required .ndm_proto.LaneMarkingType limit_type = 1;
inline bool SpeedLimit::has_limit_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SpeedLimit::set_has_limit_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SpeedLimit::clear_has_limit_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SpeedLimit::clear_limit_type() {
  if (limit_type_ != NULL) limit_type_->Clear();
  clear_has_limit_type();
}
inline const ::ndm_proto::LaneMarkingType& SpeedLimit::limit_type() const {
  const ::ndm_proto::LaneMarkingType* p = limit_type_;
  // @@protoc_insertion_point(field_get:ndm_proto.SpeedLimit.limit_type)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::LaneMarkingType*>(
      &::ndm_proto::_LaneMarkingType_default_instance_);
}
inline ::ndm_proto::LaneMarkingType* SpeedLimit::release_limit_type() {
  // @@protoc_insertion_point(field_release:ndm_proto.SpeedLimit.limit_type)
  clear_has_limit_type();
  ::ndm_proto::LaneMarkingType* temp = limit_type_;
  limit_type_ = NULL;
  return temp;
}
inline ::ndm_proto::LaneMarkingType* SpeedLimit::mutable_limit_type() {
  set_has_limit_type();
  if (limit_type_ == NULL) {
    limit_type_ = new ::ndm_proto::LaneMarkingType;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.SpeedLimit.limit_type)
  return limit_type_;
}
inline void SpeedLimit::set_allocated_limit_type(::ndm_proto::LaneMarkingType* limit_type) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete limit_type_;
  }
  if (limit_type) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      limit_type = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, limit_type, submessage_arena);
    }
    set_has_limit_type();
  } else {
    clear_has_limit_type();
  }
  limit_type_ = limit_type;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.SpeedLimit.limit_type)
}

// required .ndm_proto.Number speed_value = 2;
inline bool SpeedLimit::has_speed_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SpeedLimit::set_has_speed_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SpeedLimit::clear_has_speed_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SpeedLimit::clear_speed_value() {
  if (speed_value_ != NULL) speed_value_->Clear();
  clear_has_speed_value();
}
inline const ::ndm_proto::Number& SpeedLimit::speed_value() const {
  const ::ndm_proto::Number* p = speed_value_;
  // @@protoc_insertion_point(field_get:ndm_proto.SpeedLimit.speed_value)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Number*>(
      &::ndm_proto::_Number_default_instance_);
}
inline ::ndm_proto::Number* SpeedLimit::release_speed_value() {
  // @@protoc_insertion_point(field_release:ndm_proto.SpeedLimit.speed_value)
  clear_has_speed_value();
  ::ndm_proto::Number* temp = speed_value_;
  speed_value_ = NULL;
  return temp;
}
inline ::ndm_proto::Number* SpeedLimit::mutable_speed_value() {
  set_has_speed_value();
  if (speed_value_ == NULL) {
    speed_value_ = new ::ndm_proto::Number;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.SpeedLimit.speed_value)
  return speed_value_;
}
inline void SpeedLimit::set_allocated_speed_value(::ndm_proto::Number* speed_value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete speed_value_;
  }
  if (speed_value) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      speed_value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, speed_value, submessage_arena);
    }
    set_has_speed_value();
  } else {
    clear_has_speed_value();
  }
  speed_value_ = speed_value;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.SpeedLimit.speed_value)
}

// optional .ndm_proto.SpeedLimitSource source = 3;
inline bool SpeedLimit::has_source() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SpeedLimit::set_has_source() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SpeedLimit::clear_has_source() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SpeedLimit::clear_source() {
  source_ = 0;
  clear_has_source();
}
inline ::ndm_proto::SpeedLimitSource SpeedLimit::source() const {
  // @@protoc_insertion_point(field_get:ndm_proto.SpeedLimit.source)
  return static_cast< ::ndm_proto::SpeedLimitSource >(source_);
}
inline void SpeedLimit::set_source(::ndm_proto::SpeedLimitSource value) {
  assert(::ndm_proto::SpeedLimitSource_IsValid(value));
  set_has_source();
  source_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.SpeedLimit.source)
}

// optional float offset = 4;
inline bool SpeedLimit::has_offset() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SpeedLimit::set_has_offset() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SpeedLimit::clear_has_offset() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SpeedLimit::clear_offset() {
  offset_ = 0;
  clear_has_offset();
}
inline float SpeedLimit::offset() const {
  // @@protoc_insertion_point(field_get:ndm_proto.SpeedLimit.offset)
  return offset_;
}
inline void SpeedLimit::set_offset(float value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.SpeedLimit.offset)
}

// optional float end_offset = 5;
inline bool SpeedLimit::has_end_offset() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SpeedLimit::set_has_end_offset() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SpeedLimit::clear_has_end_offset() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SpeedLimit::clear_end_offset() {
  end_offset_ = 0;
  clear_has_end_offset();
}
inline float SpeedLimit::end_offset() const {
  // @@protoc_insertion_point(field_get:ndm_proto.SpeedLimit.end_offset)
  return end_offset_;
}
inline void SpeedLimit::set_end_offset(float value) {
  set_has_end_offset();
  end_offset_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.SpeedLimit.end_offset)
}

// -------------------------------------------------------------------

// TimeLimit

// required .ndm_proto.Number time_begin = 1;
inline bool TimeLimit::has_time_begin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TimeLimit::set_has_time_begin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TimeLimit::clear_has_time_begin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TimeLimit::clear_time_begin() {
  if (time_begin_ != NULL) time_begin_->Clear();
  clear_has_time_begin();
}
inline const ::ndm_proto::Number& TimeLimit::time_begin() const {
  const ::ndm_proto::Number* p = time_begin_;
  // @@protoc_insertion_point(field_get:ndm_proto.TimeLimit.time_begin)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Number*>(
      &::ndm_proto::_Number_default_instance_);
}
inline ::ndm_proto::Number* TimeLimit::release_time_begin() {
  // @@protoc_insertion_point(field_release:ndm_proto.TimeLimit.time_begin)
  clear_has_time_begin();
  ::ndm_proto::Number* temp = time_begin_;
  time_begin_ = NULL;
  return temp;
}
inline ::ndm_proto::Number* TimeLimit::mutable_time_begin() {
  set_has_time_begin();
  if (time_begin_ == NULL) {
    time_begin_ = new ::ndm_proto::Number;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.TimeLimit.time_begin)
  return time_begin_;
}
inline void TimeLimit::set_allocated_time_begin(::ndm_proto::Number* time_begin) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete time_begin_;
  }
  if (time_begin) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      time_begin = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, time_begin, submessage_arena);
    }
    set_has_time_begin();
  } else {
    clear_has_time_begin();
  }
  time_begin_ = time_begin;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.TimeLimit.time_begin)
}

// required .ndm_proto.Number time_end = 2;
inline bool TimeLimit::has_time_end() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TimeLimit::set_has_time_end() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TimeLimit::clear_has_time_end() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TimeLimit::clear_time_end() {
  if (time_end_ != NULL) time_end_->Clear();
  clear_has_time_end();
}
inline const ::ndm_proto::Number& TimeLimit::time_end() const {
  const ::ndm_proto::Number* p = time_end_;
  // @@protoc_insertion_point(field_get:ndm_proto.TimeLimit.time_end)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Number*>(
      &::ndm_proto::_Number_default_instance_);
}
inline ::ndm_proto::Number* TimeLimit::release_time_end() {
  // @@protoc_insertion_point(field_release:ndm_proto.TimeLimit.time_end)
  clear_has_time_end();
  ::ndm_proto::Number* temp = time_end_;
  time_end_ = NULL;
  return temp;
}
inline ::ndm_proto::Number* TimeLimit::mutable_time_end() {
  set_has_time_end();
  if (time_end_ == NULL) {
    time_end_ = new ::ndm_proto::Number;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.TimeLimit.time_end)
  return time_end_;
}
inline void TimeLimit::set_allocated_time_end(::ndm_proto::Number* time_end) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete time_end_;
  }
  if (time_end) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      time_end = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, time_end, submessage_arena);
    }
    set_has_time_end();
  } else {
    clear_has_time_end();
  }
  time_end_ = time_end;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.TimeLimit.time_end)
}

// -------------------------------------------------------------------

// LaneRestriction

// repeated .ndm_proto.VehicleType vehicle_types = 1;
inline int LaneRestriction::vehicle_types_size() const {
  return vehicle_types_.size();
}
inline void LaneRestriction::clear_vehicle_types() {
  vehicle_types_.Clear();
}
inline const ::ndm_proto::VehicleType& LaneRestriction::vehicle_types(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.LaneRestriction.vehicle_types)
  return vehicle_types_.Get(index);
}
inline ::ndm_proto::VehicleType* LaneRestriction::mutable_vehicle_types(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.LaneRestriction.vehicle_types)
  return vehicle_types_.Mutable(index);
}
inline ::ndm_proto::VehicleType* LaneRestriction::add_vehicle_types() {
  // @@protoc_insertion_point(field_add:ndm_proto.LaneRestriction.vehicle_types)
  return vehicle_types_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::VehicleType >*
LaneRestriction::mutable_vehicle_types() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.LaneRestriction.vehicle_types)
  return &vehicle_types_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::VehicleType >&
LaneRestriction::vehicle_types() const {
  // @@protoc_insertion_point(field_list:ndm_proto.LaneRestriction.vehicle_types)
  return vehicle_types_;
}

// repeated .ndm_proto.SpeedLimit speed_limits = 2;
inline int LaneRestriction::speed_limits_size() const {
  return speed_limits_.size();
}
inline void LaneRestriction::clear_speed_limits() {
  speed_limits_.Clear();
}
inline const ::ndm_proto::SpeedLimit& LaneRestriction::speed_limits(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.LaneRestriction.speed_limits)
  return speed_limits_.Get(index);
}
inline ::ndm_proto::SpeedLimit* LaneRestriction::mutable_speed_limits(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.LaneRestriction.speed_limits)
  return speed_limits_.Mutable(index);
}
inline ::ndm_proto::SpeedLimit* LaneRestriction::add_speed_limits() {
  // @@protoc_insertion_point(field_add:ndm_proto.LaneRestriction.speed_limits)
  return speed_limits_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::SpeedLimit >*
LaneRestriction::mutable_speed_limits() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.LaneRestriction.speed_limits)
  return &speed_limits_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::SpeedLimit >&
LaneRestriction::speed_limits() const {
  // @@protoc_insertion_point(field_list:ndm_proto.LaneRestriction.speed_limits)
  return speed_limits_;
}

// repeated .ndm_proto.TimeLimit time_limits = 3;
inline int LaneRestriction::time_limits_size() const {
  return time_limits_.size();
}
inline void LaneRestriction::clear_time_limits() {
  time_limits_.Clear();
}
inline const ::ndm_proto::TimeLimit& LaneRestriction::time_limits(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.LaneRestriction.time_limits)
  return time_limits_.Get(index);
}
inline ::ndm_proto::TimeLimit* LaneRestriction::mutable_time_limits(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.LaneRestriction.time_limits)
  return time_limits_.Mutable(index);
}
inline ::ndm_proto::TimeLimit* LaneRestriction::add_time_limits() {
  // @@protoc_insertion_point(field_add:ndm_proto.LaneRestriction.time_limits)
  return time_limits_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::TimeLimit >*
LaneRestriction::mutable_time_limits() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.LaneRestriction.time_limits)
  return &time_limits_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::TimeLimit >&
LaneRestriction::time_limits() const {
  // @@protoc_insertion_point(field_list:ndm_proto.LaneRestriction.time_limits)
  return time_limits_;
}

// repeated .ndm_proto.LaneMarkingType lanemarking_types = 4;
inline int LaneRestriction::lanemarking_types_size() const {
  return lanemarking_types_.size();
}
inline void LaneRestriction::clear_lanemarking_types() {
  lanemarking_types_.Clear();
}
inline const ::ndm_proto::LaneMarkingType& LaneRestriction::lanemarking_types(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.LaneRestriction.lanemarking_types)
  return lanemarking_types_.Get(index);
}
inline ::ndm_proto::LaneMarkingType* LaneRestriction::mutable_lanemarking_types(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.LaneRestriction.lanemarking_types)
  return lanemarking_types_.Mutable(index);
}
inline ::ndm_proto::LaneMarkingType* LaneRestriction::add_lanemarking_types() {
  // @@protoc_insertion_point(field_add:ndm_proto.LaneRestriction.lanemarking_types)
  return lanemarking_types_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::LaneMarkingType >*
LaneRestriction::mutable_lanemarking_types() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.LaneRestriction.lanemarking_types)
  return &lanemarking_types_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::LaneMarkingType >&
LaneRestriction::lanemarking_types() const {
  // @@protoc_insertion_point(field_list:ndm_proto.LaneRestriction.lanemarking_types)
  return lanemarking_types_;
}

// repeated .ndm_proto.TrafficSignType trafficsign_types = 5;
inline int LaneRestriction::trafficsign_types_size() const {
  return trafficsign_types_.size();
}
inline void LaneRestriction::clear_trafficsign_types() {
  trafficsign_types_.Clear();
}
inline const ::ndm_proto::TrafficSignType& LaneRestriction::trafficsign_types(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.LaneRestriction.trafficsign_types)
  return trafficsign_types_.Get(index);
}
inline ::ndm_proto::TrafficSignType* LaneRestriction::mutable_trafficsign_types(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.LaneRestriction.trafficsign_types)
  return trafficsign_types_.Mutable(index);
}
inline ::ndm_proto::TrafficSignType* LaneRestriction::add_trafficsign_types() {
  // @@protoc_insertion_point(field_add:ndm_proto.LaneRestriction.trafficsign_types)
  return trafficsign_types_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::TrafficSignType >*
LaneRestriction::mutable_trafficsign_types() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.LaneRestriction.trafficsign_types)
  return &trafficsign_types_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::TrafficSignType >&
LaneRestriction::trafficsign_types() const {
  // @@protoc_insertion_point(field_list:ndm_proto.LaneRestriction.trafficsign_types)
  return trafficsign_types_;
}

// optional .ndm_proto.Number weight_limit = 10;
inline bool LaneRestriction::has_weight_limit() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LaneRestriction::set_has_weight_limit() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LaneRestriction::clear_has_weight_limit() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LaneRestriction::clear_weight_limit() {
  if (weight_limit_ != NULL) weight_limit_->Clear();
  clear_has_weight_limit();
}
inline const ::ndm_proto::Number& LaneRestriction::weight_limit() const {
  const ::ndm_proto::Number* p = weight_limit_;
  // @@protoc_insertion_point(field_get:ndm_proto.LaneRestriction.weight_limit)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Number*>(
      &::ndm_proto::_Number_default_instance_);
}
inline ::ndm_proto::Number* LaneRestriction::release_weight_limit() {
  // @@protoc_insertion_point(field_release:ndm_proto.LaneRestriction.weight_limit)
  clear_has_weight_limit();
  ::ndm_proto::Number* temp = weight_limit_;
  weight_limit_ = NULL;
  return temp;
}
inline ::ndm_proto::Number* LaneRestriction::mutable_weight_limit() {
  set_has_weight_limit();
  if (weight_limit_ == NULL) {
    weight_limit_ = new ::ndm_proto::Number;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.LaneRestriction.weight_limit)
  return weight_limit_;
}
inline void LaneRestriction::set_allocated_weight_limit(::ndm_proto::Number* weight_limit) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete weight_limit_;
  }
  if (weight_limit) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      weight_limit = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, weight_limit, submessage_arena);
    }
    set_has_weight_limit();
  } else {
    clear_has_weight_limit();
  }
  weight_limit_ = weight_limit;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.LaneRestriction.weight_limit)
}

// optional .ndm_proto.Number height_limit = 11;
inline bool LaneRestriction::has_height_limit() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LaneRestriction::set_has_height_limit() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LaneRestriction::clear_has_height_limit() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LaneRestriction::clear_height_limit() {
  if (height_limit_ != NULL) height_limit_->Clear();
  clear_has_height_limit();
}
inline const ::ndm_proto::Number& LaneRestriction::height_limit() const {
  const ::ndm_proto::Number* p = height_limit_;
  // @@protoc_insertion_point(field_get:ndm_proto.LaneRestriction.height_limit)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Number*>(
      &::ndm_proto::_Number_default_instance_);
}
inline ::ndm_proto::Number* LaneRestriction::release_height_limit() {
  // @@protoc_insertion_point(field_release:ndm_proto.LaneRestriction.height_limit)
  clear_has_height_limit();
  ::ndm_proto::Number* temp = height_limit_;
  height_limit_ = NULL;
  return temp;
}
inline ::ndm_proto::Number* LaneRestriction::mutable_height_limit() {
  set_has_height_limit();
  if (height_limit_ == NULL) {
    height_limit_ = new ::ndm_proto::Number;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.LaneRestriction.height_limit)
  return height_limit_;
}
inline void LaneRestriction::set_allocated_height_limit(::ndm_proto::Number* height_limit) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete height_limit_;
  }
  if (height_limit) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      height_limit = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, height_limit, submessage_arena);
    }
    set_has_height_limit();
  } else {
    clear_has_height_limit();
  }
  height_limit_ = height_limit;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.LaneRestriction.height_limit)
}

// -------------------------------------------------------------------

// LanePriority

// required .ndm_proto.LanePriority.Priority priority = 1;
inline bool LanePriority::has_priority() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LanePriority::set_has_priority() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LanePriority::clear_has_priority() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LanePriority::clear_priority() {
  priority_ = 0;
  clear_has_priority();
}
inline ::ndm_proto::LanePriority_Priority LanePriority::priority() const {
  // @@protoc_insertion_point(field_get:ndm_proto.LanePriority.priority)
  return static_cast< ::ndm_proto::LanePriority_Priority >(priority_);
}
inline void LanePriority::set_priority(::ndm_proto::LanePriority_Priority value) {
  assert(::ndm_proto::LanePriority_Priority_IsValid(value));
  set_has_priority();
  priority_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.LanePriority.priority)
}

// optional float conf = 2;
inline bool LanePriority::has_conf() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LanePriority::set_has_conf() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LanePriority::clear_has_conf() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LanePriority::clear_conf() {
  conf_ = 0;
  clear_has_conf();
}
inline float LanePriority::conf() const {
  // @@protoc_insertion_point(field_get:ndm_proto.LanePriority.conf)
  return conf_;
}
inline void LanePriority::set_conf(float value) {
  set_has_conf();
  conf_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.LanePriority.conf)
}

// -------------------------------------------------------------------

// LaneLineColor

// required .ndm_proto.LaneLineColor.Color color = 1;
inline bool LaneLineColor::has_color() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LaneLineColor::set_has_color() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LaneLineColor::clear_has_color() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LaneLineColor::clear_color() {
  color_ = 0;
  clear_has_color();
}
inline ::ndm_proto::LaneLineColor_Color LaneLineColor::color() const {
  // @@protoc_insertion_point(field_get:ndm_proto.LaneLineColor.color)
  return static_cast< ::ndm_proto::LaneLineColor_Color >(color_);
}
inline void LaneLineColor::set_color(::ndm_proto::LaneLineColor_Color value) {
  assert(::ndm_proto::LaneLineColor_Color_IsValid(value));
  set_has_color();
  color_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.LaneLineColor.color)
}

// optional float conf = 2;
inline bool LaneLineColor::has_conf() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LaneLineColor::set_has_conf() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LaneLineColor::clear_has_conf() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LaneLineColor::clear_conf() {
  conf_ = 0;
  clear_has_conf();
}
inline float LaneLineColor::conf() const {
  // @@protoc_insertion_point(field_get:ndm_proto.LaneLineColor.conf)
  return conf_;
}
inline void LaneLineColor::set_conf(float value) {
  set_has_conf();
  conf_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.LaneLineColor.conf)
}

// -------------------------------------------------------------------

// LaneLineType

// required .ndm_proto.LaneLineType.Type type = 1;
inline bool LaneLineType::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LaneLineType::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LaneLineType::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LaneLineType::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::ndm_proto::LaneLineType_Type LaneLineType::type() const {
  // @@protoc_insertion_point(field_get:ndm_proto.LaneLineType.type)
  return static_cast< ::ndm_proto::LaneLineType_Type >(type_);
}
inline void LaneLineType::set_type(::ndm_proto::LaneLineType_Type value) {
  assert(::ndm_proto::LaneLineType_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.LaneLineType.type)
}

// optional float conf = 2;
inline bool LaneLineType::has_conf() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LaneLineType::set_has_conf() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LaneLineType::clear_has_conf() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LaneLineType::clear_conf() {
  conf_ = 0;
  clear_has_conf();
}
inline float LaneLineType::conf() const {
  // @@protoc_insertion_point(field_get:ndm_proto.LaneLineType.conf)
  return conf_;
}
inline void LaneLineType::set_conf(float value) {
  set_has_conf();
  conf_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.LaneLineType.conf)
}

// -------------------------------------------------------------------

// LaneLineRestriction

// required .ndm_proto.LaneLineRestriction.LaneLineRestrictionType type = 1;
inline bool LaneLineRestriction::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LaneLineRestriction::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LaneLineRestriction::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LaneLineRestriction::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::ndm_proto::LaneLineRestriction_LaneLineRestrictionType LaneLineRestriction::type() const {
  // @@protoc_insertion_point(field_get:ndm_proto.LaneLineRestriction.type)
  return static_cast< ::ndm_proto::LaneLineRestriction_LaneLineRestrictionType >(type_);
}
inline void LaneLineRestriction::set_type(::ndm_proto::LaneLineRestriction_LaneLineRestrictionType value) {
  assert(::ndm_proto::LaneLineRestriction_LaneLineRestrictionType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.LaneLineRestriction.type)
}

// optional float conf = 2;
inline bool LaneLineRestriction::has_conf() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LaneLineRestriction::set_has_conf() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LaneLineRestriction::clear_has_conf() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LaneLineRestriction::clear_conf() {
  conf_ = 0;
  clear_has_conf();
}
inline float LaneLineRestriction::conf() const {
  // @@protoc_insertion_point(field_get:ndm_proto.LaneLineRestriction.conf)
  return conf_;
}
inline void LaneLineRestriction::set_conf(float value) {
  set_has_conf();
  conf_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.LaneLineRestriction.conf)
}

// -------------------------------------------------------------------

// TrafficSignType

// required .ndm_proto.TrafficSignType.Type type = 1;
inline bool TrafficSignType::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrafficSignType::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrafficSignType::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrafficSignType::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::ndm_proto::TrafficSignType_Type TrafficSignType::type() const {
  // @@protoc_insertion_point(field_get:ndm_proto.TrafficSignType.type)
  return static_cast< ::ndm_proto::TrafficSignType_Type >(type_);
}
inline void TrafficSignType::set_type(::ndm_proto::TrafficSignType_Type value) {
  assert(::ndm_proto::TrafficSignType_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.TrafficSignType.type)
}

// optional float conf = 2;
inline bool TrafficSignType::has_conf() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrafficSignType::set_has_conf() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrafficSignType::clear_has_conf() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrafficSignType::clear_conf() {
  conf_ = 0;
  clear_has_conf();
}
inline float TrafficSignType::conf() const {
  // @@protoc_insertion_point(field_get:ndm_proto.TrafficSignType.conf)
  return conf_;
}
inline void TrafficSignType::set_conf(float value) {
  set_has_conf();
  conf_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.TrafficSignType.conf)
}

// -------------------------------------------------------------------

// ConditionNumeric

// required uint32 value = 1;
inline bool ConditionNumeric::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConditionNumeric::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConditionNumeric::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConditionNumeric::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 ConditionNumeric::value() const {
  // @@protoc_insertion_point(field_get:ndm_proto.ConditionNumeric.value)
  return value_;
}
inline void ConditionNumeric::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.ConditionNumeric.value)
}

// -------------------------------------------------------------------

// ConditionVehicleType

// required uint32 vehicleTypeMask = 1;
inline bool ConditionVehicleType::has_vehicletypemask() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConditionVehicleType::set_has_vehicletypemask() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConditionVehicleType::clear_has_vehicletypemask() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConditionVehicleType::clear_vehicletypemask() {
  vehicletypemask_ = 0u;
  clear_has_vehicletypemask();
}
inline ::google::protobuf::uint32 ConditionVehicleType::vehicletypemask() const {
  // @@protoc_insertion_point(field_get:ndm_proto.ConditionVehicleType.vehicleTypeMask)
  return vehicletypemask_;
}
inline void ConditionVehicleType::set_vehicletypemask(::google::protobuf::uint32 value) {
  set_has_vehicletypemask();
  vehicletypemask_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.ConditionVehicleType.vehicleTypeMask)
}

// -------------------------------------------------------------------

// ConditionLoad

// required .ndm_proto.Load value = 1;
inline bool ConditionLoad::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConditionLoad::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConditionLoad::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConditionLoad::clear_value() {
  value_ = 1;
  clear_has_value();
}
inline ::ndm_proto::Load ConditionLoad::value() const {
  // @@protoc_insertion_point(field_get:ndm_proto.ConditionLoad.value)
  return static_cast< ::ndm_proto::Load >(value_);
}
inline void ConditionLoad::set_value(::ndm_proto::Load value) {
  assert(::ndm_proto::Load_IsValid(value));
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.ConditionLoad.value)
}

// -------------------------------------------------------------------

// ConditionTimeOfDay

// required uint32 startMinutes = 1;
inline bool ConditionTimeOfDay::has_startminutes() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConditionTimeOfDay::set_has_startminutes() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConditionTimeOfDay::clear_has_startminutes() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConditionTimeOfDay::clear_startminutes() {
  startminutes_ = 0u;
  clear_has_startminutes();
}
inline ::google::protobuf::uint32 ConditionTimeOfDay::startminutes() const {
  // @@protoc_insertion_point(field_get:ndm_proto.ConditionTimeOfDay.startMinutes)
  return startminutes_;
}
inline void ConditionTimeOfDay::set_startminutes(::google::protobuf::uint32 value) {
  set_has_startminutes();
  startminutes_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.ConditionTimeOfDay.startMinutes)
}

// required uint32 endMinutes = 2;
inline bool ConditionTimeOfDay::has_endminutes() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConditionTimeOfDay::set_has_endminutes() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConditionTimeOfDay::clear_has_endminutes() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConditionTimeOfDay::clear_endminutes() {
  endminutes_ = 0u;
  clear_has_endminutes();
}
inline ::google::protobuf::uint32 ConditionTimeOfDay::endminutes() const {
  // @@protoc_insertion_point(field_get:ndm_proto.ConditionTimeOfDay.endMinutes)
  return endminutes_;
}
inline void ConditionTimeOfDay::set_endminutes(::google::protobuf::uint32 value) {
  set_has_endminutes();
  endminutes_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.ConditionTimeOfDay.endMinutes)
}

// -------------------------------------------------------------------

// ConditionWeather

// required .ndm_proto.Weather weather = 1;
inline bool ConditionWeather::has_weather() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConditionWeather::set_has_weather() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConditionWeather::clear_has_weather() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConditionWeather::clear_weather() {
  weather_ = 0;
  clear_has_weather();
}
inline ::ndm_proto::Weather ConditionWeather::weather() const {
  // @@protoc_insertion_point(field_get:ndm_proto.ConditionWeather.weather)
  return static_cast< ::ndm_proto::Weather >(weather_);
}
inline void ConditionWeather::set_weather(::ndm_proto::Weather value) {
  assert(::ndm_proto::Weather_IsValid(value));
  set_has_weather();
  weather_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.ConditionWeather.weather)
}

// -------------------------------------------------------------------

// ConditionFuzzyTime

// required .ndm_proto.FuzzyTime fuzzyTime = 1;
inline bool ConditionFuzzyTime::has_fuzzytime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConditionFuzzyTime::set_has_fuzzytime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConditionFuzzyTime::clear_has_fuzzytime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConditionFuzzyTime::clear_fuzzytime() {
  fuzzytime_ = 1;
  clear_has_fuzzytime();
}
inline ::ndm_proto::FuzzyTime ConditionFuzzyTime::fuzzytime() const {
  // @@protoc_insertion_point(field_get:ndm_proto.ConditionFuzzyTime.fuzzyTime)
  return static_cast< ::ndm_proto::FuzzyTime >(fuzzytime_);
}
inline void ConditionFuzzyTime::set_fuzzytime(::ndm_proto::FuzzyTime value) {
  assert(::ndm_proto::FuzzyTime_IsValid(value));
  set_has_fuzzytime();
  fuzzytime_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.ConditionFuzzyTime.fuzzyTime)
}

// -------------------------------------------------------------------

// ConditionTurnDirection

// required .ndm_proto.LaneArrowMarking direction = 1;
inline bool ConditionTurnDirection::has_direction() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConditionTurnDirection::set_has_direction() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConditionTurnDirection::clear_has_direction() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConditionTurnDirection::clear_direction() {
  direction_ = 0;
  clear_has_direction();
}
inline ::ndm_proto::LaneArrowMarking ConditionTurnDirection::direction() const {
  // @@protoc_insertion_point(field_get:ndm_proto.ConditionTurnDirection.direction)
  return static_cast< ::ndm_proto::LaneArrowMarking >(direction_);
}
inline void ConditionTurnDirection::set_direction(::ndm_proto::LaneArrowMarking value) {
  assert(::ndm_proto::LaneArrowMarking_IsValid(value));
  set_has_direction();
  direction_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.ConditionTurnDirection.direction)
}

// -------------------------------------------------------------------

// Condition

// required .ndm_proto.ConditionType type = 1;
inline bool Condition::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Condition::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Condition::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Condition::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::ndm_proto::ConditionType Condition::type() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Condition.type)
  return static_cast< ::ndm_proto::ConditionType >(type_);
}
inline void Condition::set_type(::ndm_proto::ConditionType value) {
  assert(::ndm_proto::ConditionType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.Condition.type)
}

// required .ndm_proto.YesNoUnknown appliesToEgoVehicle = 2;
inline bool Condition::has_appliestoegovehicle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Condition::set_has_appliestoegovehicle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Condition::clear_has_appliestoegovehicle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Condition::clear_appliestoegovehicle() {
  appliestoegovehicle_ = 0;
  clear_has_appliestoegovehicle();
}
inline ::ndm_proto::YesNoUnknown Condition::appliestoegovehicle() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Condition.appliesToEgoVehicle)
  return static_cast< ::ndm_proto::YesNoUnknown >(appliestoegovehicle_);
}
inline void Condition::set_appliestoegovehicle(::ndm_proto::YesNoUnknown value) {
  assert(::ndm_proto::YesNoUnknown_IsValid(value));
  set_has_appliestoegovehicle();
  appliestoegovehicle_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.Condition.appliesToEgoVehicle)
}

// optional .ndm_proto.ConditionNumeric condition_numeric = 3;
inline bool Condition::has_condition_numeric() const {
  return condition_case() == kConditionNumeric;
}
inline void Condition::set_has_condition_numeric() {
  _oneof_case_[0] = kConditionNumeric;
}
inline void Condition::clear_condition_numeric() {
  if (has_condition_numeric()) {
    delete condition_.condition_numeric_;
    clear_has_condition();
  }
}
inline ::ndm_proto::ConditionNumeric* Condition::release_condition_numeric() {
  // @@protoc_insertion_point(field_release:ndm_proto.Condition.condition_numeric)
  if (has_condition_numeric()) {
    clear_has_condition();
      ::ndm_proto::ConditionNumeric* temp = condition_.condition_numeric_;
    condition_.condition_numeric_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::ndm_proto::ConditionNumeric& Condition::condition_numeric() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Condition.condition_numeric)
  return has_condition_numeric()
      ? *condition_.condition_numeric_
      : *reinterpret_cast< ::ndm_proto::ConditionNumeric*>(&::ndm_proto::_ConditionNumeric_default_instance_);
}
inline ::ndm_proto::ConditionNumeric* Condition::mutable_condition_numeric() {
  if (!has_condition_numeric()) {
    clear_condition();
    set_has_condition_numeric();
    condition_.condition_numeric_ = new ::ndm_proto::ConditionNumeric;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.Condition.condition_numeric)
  return condition_.condition_numeric_;
}

// optional .ndm_proto.ConditionVehicleType condition_vehicleType = 4;
inline bool Condition::has_condition_vehicletype() const {
  return condition_case() == kConditionVehicleType;
}
inline void Condition::set_has_condition_vehicletype() {
  _oneof_case_[0] = kConditionVehicleType;
}
inline void Condition::clear_condition_vehicletype() {
  if (has_condition_vehicletype()) {
    delete condition_.condition_vehicletype_;
    clear_has_condition();
  }
}
inline ::ndm_proto::ConditionVehicleType* Condition::release_condition_vehicletype() {
  // @@protoc_insertion_point(field_release:ndm_proto.Condition.condition_vehicleType)
  if (has_condition_vehicletype()) {
    clear_has_condition();
      ::ndm_proto::ConditionVehicleType* temp = condition_.condition_vehicletype_;
    condition_.condition_vehicletype_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::ndm_proto::ConditionVehicleType& Condition::condition_vehicletype() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Condition.condition_vehicleType)
  return has_condition_vehicletype()
      ? *condition_.condition_vehicletype_
      : *reinterpret_cast< ::ndm_proto::ConditionVehicleType*>(&::ndm_proto::_ConditionVehicleType_default_instance_);
}
inline ::ndm_proto::ConditionVehicleType* Condition::mutable_condition_vehicletype() {
  if (!has_condition_vehicletype()) {
    clear_condition();
    set_has_condition_vehicletype();
    condition_.condition_vehicletype_ = new ::ndm_proto::ConditionVehicleType;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.Condition.condition_vehicleType)
  return condition_.condition_vehicletype_;
}

// optional .ndm_proto.ConditionLoad condition_load = 5;
inline bool Condition::has_condition_load() const {
  return condition_case() == kConditionLoad;
}
inline void Condition::set_has_condition_load() {
  _oneof_case_[0] = kConditionLoad;
}
inline void Condition::clear_condition_load() {
  if (has_condition_load()) {
    delete condition_.condition_load_;
    clear_has_condition();
  }
}
inline ::ndm_proto::ConditionLoad* Condition::release_condition_load() {
  // @@protoc_insertion_point(field_release:ndm_proto.Condition.condition_load)
  if (has_condition_load()) {
    clear_has_condition();
      ::ndm_proto::ConditionLoad* temp = condition_.condition_load_;
    condition_.condition_load_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::ndm_proto::ConditionLoad& Condition::condition_load() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Condition.condition_load)
  return has_condition_load()
      ? *condition_.condition_load_
      : *reinterpret_cast< ::ndm_proto::ConditionLoad*>(&::ndm_proto::_ConditionLoad_default_instance_);
}
inline ::ndm_proto::ConditionLoad* Condition::mutable_condition_load() {
  if (!has_condition_load()) {
    clear_condition();
    set_has_condition_load();
    condition_.condition_load_ = new ::ndm_proto::ConditionLoad;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.Condition.condition_load)
  return condition_.condition_load_;
}

// optional .ndm_proto.ConditionTimeOfDay condition_timeOfDay = 6;
inline bool Condition::has_condition_timeofday() const {
  return condition_case() == kConditionTimeOfDay;
}
inline void Condition::set_has_condition_timeofday() {
  _oneof_case_[0] = kConditionTimeOfDay;
}
inline void Condition::clear_condition_timeofday() {
  if (has_condition_timeofday()) {
    delete condition_.condition_timeofday_;
    clear_has_condition();
  }
}
inline ::ndm_proto::ConditionTimeOfDay* Condition::release_condition_timeofday() {
  // @@protoc_insertion_point(field_release:ndm_proto.Condition.condition_timeOfDay)
  if (has_condition_timeofday()) {
    clear_has_condition();
      ::ndm_proto::ConditionTimeOfDay* temp = condition_.condition_timeofday_;
    condition_.condition_timeofday_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::ndm_proto::ConditionTimeOfDay& Condition::condition_timeofday() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Condition.condition_timeOfDay)
  return has_condition_timeofday()
      ? *condition_.condition_timeofday_
      : *reinterpret_cast< ::ndm_proto::ConditionTimeOfDay*>(&::ndm_proto::_ConditionTimeOfDay_default_instance_);
}
inline ::ndm_proto::ConditionTimeOfDay* Condition::mutable_condition_timeofday() {
  if (!has_condition_timeofday()) {
    clear_condition();
    set_has_condition_timeofday();
    condition_.condition_timeofday_ = new ::ndm_proto::ConditionTimeOfDay;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.Condition.condition_timeOfDay)
  return condition_.condition_timeofday_;
}

// optional .ndm_proto.ConditionWeather condition_weather = 7;
inline bool Condition::has_condition_weather() const {
  return condition_case() == kConditionWeather;
}
inline void Condition::set_has_condition_weather() {
  _oneof_case_[0] = kConditionWeather;
}
inline void Condition::clear_condition_weather() {
  if (has_condition_weather()) {
    delete condition_.condition_weather_;
    clear_has_condition();
  }
}
inline ::ndm_proto::ConditionWeather* Condition::release_condition_weather() {
  // @@protoc_insertion_point(field_release:ndm_proto.Condition.condition_weather)
  if (has_condition_weather()) {
    clear_has_condition();
      ::ndm_proto::ConditionWeather* temp = condition_.condition_weather_;
    condition_.condition_weather_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::ndm_proto::ConditionWeather& Condition::condition_weather() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Condition.condition_weather)
  return has_condition_weather()
      ? *condition_.condition_weather_
      : *reinterpret_cast< ::ndm_proto::ConditionWeather*>(&::ndm_proto::_ConditionWeather_default_instance_);
}
inline ::ndm_proto::ConditionWeather* Condition::mutable_condition_weather() {
  if (!has_condition_weather()) {
    clear_condition();
    set_has_condition_weather();
    condition_.condition_weather_ = new ::ndm_proto::ConditionWeather;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.Condition.condition_weather)
  return condition_.condition_weather_;
}

// optional .ndm_proto.ConditionFuzzyTime condition_fuzzyTime = 8;
inline bool Condition::has_condition_fuzzytime() const {
  return condition_case() == kConditionFuzzyTime;
}
inline void Condition::set_has_condition_fuzzytime() {
  _oneof_case_[0] = kConditionFuzzyTime;
}
inline void Condition::clear_condition_fuzzytime() {
  if (has_condition_fuzzytime()) {
    delete condition_.condition_fuzzytime_;
    clear_has_condition();
  }
}
inline ::ndm_proto::ConditionFuzzyTime* Condition::release_condition_fuzzytime() {
  // @@protoc_insertion_point(field_release:ndm_proto.Condition.condition_fuzzyTime)
  if (has_condition_fuzzytime()) {
    clear_has_condition();
      ::ndm_proto::ConditionFuzzyTime* temp = condition_.condition_fuzzytime_;
    condition_.condition_fuzzytime_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::ndm_proto::ConditionFuzzyTime& Condition::condition_fuzzytime() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Condition.condition_fuzzyTime)
  return has_condition_fuzzytime()
      ? *condition_.condition_fuzzytime_
      : *reinterpret_cast< ::ndm_proto::ConditionFuzzyTime*>(&::ndm_proto::_ConditionFuzzyTime_default_instance_);
}
inline ::ndm_proto::ConditionFuzzyTime* Condition::mutable_condition_fuzzytime() {
  if (!has_condition_fuzzytime()) {
    clear_condition();
    set_has_condition_fuzzytime();
    condition_.condition_fuzzytime_ = new ::ndm_proto::ConditionFuzzyTime;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.Condition.condition_fuzzyTime)
  return condition_.condition_fuzzytime_;
}

// optional .ndm_proto.ConditionTurnDirection condition_turnDirection = 9;
inline bool Condition::has_condition_turndirection() const {
  return condition_case() == kConditionTurnDirection;
}
inline void Condition::set_has_condition_turndirection() {
  _oneof_case_[0] = kConditionTurnDirection;
}
inline void Condition::clear_condition_turndirection() {
  if (has_condition_turndirection()) {
    delete condition_.condition_turndirection_;
    clear_has_condition();
  }
}
inline ::ndm_proto::ConditionTurnDirection* Condition::release_condition_turndirection() {
  // @@protoc_insertion_point(field_release:ndm_proto.Condition.condition_turnDirection)
  if (has_condition_turndirection()) {
    clear_has_condition();
      ::ndm_proto::ConditionTurnDirection* temp = condition_.condition_turndirection_;
    condition_.condition_turndirection_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::ndm_proto::ConditionTurnDirection& Condition::condition_turndirection() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Condition.condition_turnDirection)
  return has_condition_turndirection()
      ? *condition_.condition_turndirection_
      : *reinterpret_cast< ::ndm_proto::ConditionTurnDirection*>(&::ndm_proto::_ConditionTurnDirection_default_instance_);
}
inline ::ndm_proto::ConditionTurnDirection* Condition::mutable_condition_turndirection() {
  if (!has_condition_turndirection()) {
    clear_condition();
    set_has_condition_turndirection();
    condition_.condition_turndirection_ = new ::ndm_proto::ConditionTurnDirection;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.Condition.condition_turnDirection)
  return condition_.condition_turndirection_;
}

inline bool Condition::has_condition() const {
  return condition_case() != CONDITION_NOT_SET;
}
inline void Condition::clear_has_condition() {
  _oneof_case_[0] = CONDITION_NOT_SET;
}
inline Condition::ConditionCase Condition::condition_case() const {
  return Condition::ConditionCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ParkingSpaceRestriction

// optional .ndm_proto.Number number_limit = 1;
inline bool ParkingSpaceRestriction::has_number_limit() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ParkingSpaceRestriction::set_has_number_limit() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ParkingSpaceRestriction::clear_has_number_limit() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ParkingSpaceRestriction::clear_number_limit() {
  if (number_limit_ != NULL) number_limit_->Clear();
  clear_has_number_limit();
}
inline const ::ndm_proto::Number& ParkingSpaceRestriction::number_limit() const {
  const ::ndm_proto::Number* p = number_limit_;
  // @@protoc_insertion_point(field_get:ndm_proto.ParkingSpaceRestriction.number_limit)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Number*>(
      &::ndm_proto::_Number_default_instance_);
}
inline ::ndm_proto::Number* ParkingSpaceRestriction::release_number_limit() {
  // @@protoc_insertion_point(field_release:ndm_proto.ParkingSpaceRestriction.number_limit)
  clear_has_number_limit();
  ::ndm_proto::Number* temp = number_limit_;
  number_limit_ = NULL;
  return temp;
}
inline ::ndm_proto::Number* ParkingSpaceRestriction::mutable_number_limit() {
  set_has_number_limit();
  if (number_limit_ == NULL) {
    number_limit_ = new ::ndm_proto::Number;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.ParkingSpaceRestriction.number_limit)
  return number_limit_;
}
inline void ParkingSpaceRestriction::set_allocated_number_limit(::ndm_proto::Number* number_limit) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete number_limit_;
  }
  if (number_limit) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      number_limit = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, number_limit, submessage_arena);
    }
    set_has_number_limit();
  } else {
    clear_has_number_limit();
  }
  number_limit_ = number_limit;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.ParkingSpaceRestriction.number_limit)
}

// repeated .ndm_proto.TimeLimit time_limits = 2;
inline int ParkingSpaceRestriction::time_limits_size() const {
  return time_limits_.size();
}
inline void ParkingSpaceRestriction::clear_time_limits() {
  time_limits_.Clear();
}
inline const ::ndm_proto::TimeLimit& ParkingSpaceRestriction::time_limits(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.ParkingSpaceRestriction.time_limits)
  return time_limits_.Get(index);
}
inline ::ndm_proto::TimeLimit* ParkingSpaceRestriction::mutable_time_limits(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.ParkingSpaceRestriction.time_limits)
  return time_limits_.Mutable(index);
}
inline ::ndm_proto::TimeLimit* ParkingSpaceRestriction::add_time_limits() {
  // @@protoc_insertion_point(field_add:ndm_proto.ParkingSpaceRestriction.time_limits)
  return time_limits_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::TimeLimit >*
ParkingSpaceRestriction::mutable_time_limits() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.ParkingSpaceRestriction.time_limits)
  return &time_limits_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::TimeLimit >&
ParkingSpaceRestriction::time_limits() const {
  // @@protoc_insertion_point(field_list:ndm_proto.ParkingSpaceRestriction.time_limits)
  return time_limits_;
}

// repeated .ndm_proto.VehicleType vehicle_types = 3;
inline int ParkingSpaceRestriction::vehicle_types_size() const {
  return vehicle_types_.size();
}
inline void ParkingSpaceRestriction::clear_vehicle_types() {
  vehicle_types_.Clear();
}
inline const ::ndm_proto::VehicleType& ParkingSpaceRestriction::vehicle_types(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.ParkingSpaceRestriction.vehicle_types)
  return vehicle_types_.Get(index);
}
inline ::ndm_proto::VehicleType* ParkingSpaceRestriction::mutable_vehicle_types(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.ParkingSpaceRestriction.vehicle_types)
  return vehicle_types_.Mutable(index);
}
inline ::ndm_proto::VehicleType* ParkingSpaceRestriction::add_vehicle_types() {
  // @@protoc_insertion_point(field_add:ndm_proto.ParkingSpaceRestriction.vehicle_types)
  return vehicle_types_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::VehicleType >*
ParkingSpaceRestriction::mutable_vehicle_types() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.ParkingSpaceRestriction.vehicle_types)
  return &vehicle_types_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::VehicleType >&
ParkingSpaceRestriction::vehicle_types() const {
  // @@protoc_insertion_point(field_list:ndm_proto.ParkingSpaceRestriction.vehicle_types)
  return vehicle_types_;
}

// -------------------------------------------------------------------

// ZoneType

// required .ndm_proto.ZoneType.Type type = 1;
inline bool ZoneType::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ZoneType::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ZoneType::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ZoneType::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::ndm_proto::ZoneType_Type ZoneType::type() const {
  // @@protoc_insertion_point(field_get:ndm_proto.ZoneType.type)
  return static_cast< ::ndm_proto::ZoneType_Type >(type_);
}
inline void ZoneType::set_type(::ndm_proto::ZoneType_Type value) {
  assert(::ndm_proto::ZoneType_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.ZoneType.type)
}

// optional float conf = 2;
inline bool ZoneType::has_conf() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ZoneType::set_has_conf() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ZoneType::clear_has_conf() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ZoneType::clear_conf() {
  conf_ = 0;
  clear_has_conf();
}
inline float ZoneType::conf() const {
  // @@protoc_insertion_point(field_get:ndm_proto.ZoneType.conf)
  return conf_;
}
inline void ZoneType::set_conf(float value) {
  set_has_conf();
  conf_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.ZoneType.conf)
}

// -------------------------------------------------------------------

// AreaType

// required .ndm_proto.AreaType.Type type = 1;
inline bool AreaType::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AreaType::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AreaType::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AreaType::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::ndm_proto::AreaType_Type AreaType::type() const {
  // @@protoc_insertion_point(field_get:ndm_proto.AreaType.type)
  return static_cast< ::ndm_proto::AreaType_Type >(type_);
}
inline void AreaType::set_type(::ndm_proto::AreaType_Type value) {
  assert(::ndm_proto::AreaType_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.AreaType.type)
}

// optional float conf = 2;
inline bool AreaType::has_conf() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AreaType::set_has_conf() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AreaType::clear_has_conf() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AreaType::clear_conf() {
  conf_ = 0;
  clear_has_conf();
}
inline float AreaType::conf() const {
  // @@protoc_insertion_point(field_get:ndm_proto.AreaType.conf)
  return conf_;
}
inline void AreaType::set_conf(float value) {
  set_has_conf();
  conf_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.AreaType.conf)
}

// -------------------------------------------------------------------

// PoleType

// required .ndm_proto.PoleType.Type type = 1;
inline bool PoleType::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PoleType::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PoleType::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PoleType::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::ndm_proto::PoleType_Type PoleType::type() const {
  // @@protoc_insertion_point(field_get:ndm_proto.PoleType.type)
  return static_cast< ::ndm_proto::PoleType_Type >(type_);
}
inline void PoleType::set_type(::ndm_proto::PoleType_Type value) {
  assert(::ndm_proto::PoleType_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.PoleType.type)
}

// optional float conf = 2;
inline bool PoleType::has_conf() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PoleType::set_has_conf() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PoleType::clear_has_conf() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PoleType::clear_conf() {
  conf_ = 0;
  clear_has_conf();
}
inline float PoleType::conf() const {
  // @@protoc_insertion_point(field_get:ndm_proto.PoleType.conf)
  return conf_;
}
inline void PoleType::set_conf(float value) {
  set_has_conf();
  conf_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.PoleType.conf)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ndm_proto

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::ndm_proto::TrafficLightType_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ndm_proto::TrafficLightType_Type>() {
  return ::ndm_proto::TrafficLightType_Type_descriptor();
}
template <> struct is_proto_enum< ::ndm_proto::TrafficLightState_State> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ndm_proto::TrafficLightState_State>() {
  return ::ndm_proto::TrafficLightState_State_descriptor();
}
template <> struct is_proto_enum< ::ndm_proto::TrafficLightBulbColor_Color> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ndm_proto::TrafficLightBulbColor_Color>() {
  return ::ndm_proto::TrafficLightBulbColor_Color_descriptor();
}
template <> struct is_proto_enum< ::ndm_proto::TrafficLightBulbShape_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ndm_proto::TrafficLightBulbShape_Type>() {
  return ::ndm_proto::TrafficLightBulbShape_Type_descriptor();
}
template <> struct is_proto_enum< ::ndm_proto::LaneMarkingType_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ndm_proto::LaneMarkingType_Type>() {
  return ::ndm_proto::LaneMarkingType_Type_descriptor();
}
template <> struct is_proto_enum< ::ndm_proto::LaneFunction_Function> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ndm_proto::LaneFunction_Function>() {
  return ::ndm_proto::LaneFunction_Function_descriptor();
}
template <> struct is_proto_enum< ::ndm_proto::LaneDirection_Direction> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ndm_proto::LaneDirection_Direction>() {
  return ::ndm_proto::LaneDirection_Direction_descriptor();
}
template <> struct is_proto_enum< ::ndm_proto::VehicleType_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ndm_proto::VehicleType_Type>() {
  return ::ndm_proto::VehicleType_Type_descriptor();
}
template <> struct is_proto_enum< ::ndm_proto::LanePriority_Priority> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ndm_proto::LanePriority_Priority>() {
  return ::ndm_proto::LanePriority_Priority_descriptor();
}
template <> struct is_proto_enum< ::ndm_proto::LaneLineColor_Color> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ndm_proto::LaneLineColor_Color>() {
  return ::ndm_proto::LaneLineColor_Color_descriptor();
}
template <> struct is_proto_enum< ::ndm_proto::LaneLineType_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ndm_proto::LaneLineType_Type>() {
  return ::ndm_proto::LaneLineType_Type_descriptor();
}
template <> struct is_proto_enum< ::ndm_proto::LaneLineRestriction_LaneLineRestrictionType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ndm_proto::LaneLineRestriction_LaneLineRestrictionType>() {
  return ::ndm_proto::LaneLineRestriction_LaneLineRestrictionType_descriptor();
}
template <> struct is_proto_enum< ::ndm_proto::TrafficSignType_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ndm_proto::TrafficSignType_Type>() {
  return ::ndm_proto::TrafficSignType_Type_descriptor();
}
template <> struct is_proto_enum< ::ndm_proto::ZoneType_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ndm_proto::ZoneType_Type>() {
  return ::ndm_proto::ZoneType_Type_descriptor();
}
template <> struct is_proto_enum< ::ndm_proto::AreaType_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ndm_proto::AreaType_Type>() {
  return ::ndm_proto::AreaType_Type_descriptor();
}
template <> struct is_proto_enum< ::ndm_proto::PoleType_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ndm_proto::PoleType_Type>() {
  return ::ndm_proto::PoleType_Type_descriptor();
}
template <> struct is_proto_enum< ::ndm_proto::LaneTransition> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ndm_proto::LaneTransition>() {
  return ::ndm_proto::LaneTransition_descriptor();
}
template <> struct is_proto_enum< ::ndm_proto::SpeedLimitSource> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ndm_proto::SpeedLimitSource>() {
  return ::ndm_proto::SpeedLimitSource_descriptor();
}
template <> struct is_proto_enum< ::ndm_proto::LaneLineConfidence> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ndm_proto::LaneLineConfidence>() {
  return ::ndm_proto::LaneLineConfidence_descriptor();
}
template <> struct is_proto_enum< ::ndm_proto::LineMarking> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ndm_proto::LineMarking>() {
  return ::ndm_proto::LineMarking_descriptor();
}
template <> struct is_proto_enum< ::ndm_proto::SignShape> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ndm_proto::SignShape>() {
  return ::ndm_proto::SignShape_descriptor();
}
template <> struct is_proto_enum< ::ndm_proto::YesNoUnknown> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ndm_proto::YesNoUnknown>() {
  return ::ndm_proto::YesNoUnknown_descriptor();
}
template <> struct is_proto_enum< ::ndm_proto::ConditionType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ndm_proto::ConditionType>() {
  return ::ndm_proto::ConditionType_descriptor();
}
template <> struct is_proto_enum< ::ndm_proto::Load> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ndm_proto::Load>() {
  return ::ndm_proto::Load_descriptor();
}
template <> struct is_proto_enum< ::ndm_proto::Weather> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ndm_proto::Weather>() {
  return ::ndm_proto::Weather_descriptor();
}
template <> struct is_proto_enum< ::ndm_proto::FuzzyTime> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ndm_proto::FuzzyTime>() {
  return ::ndm_proto::FuzzyTime_descriptor();
}
template <> struct is_proto_enum< ::ndm_proto::LaneArrowMarking> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ndm_proto::LaneArrowMarking>() {
  return ::ndm_proto::LaneArrowMarking_descriptor();
}
template <> struct is_proto_enum< ::ndm_proto::SpecialSituationType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ndm_proto::SpecialSituationType>() {
  return ::ndm_proto::SpecialSituationType_descriptor();
}
template <> struct is_proto_enum< ::ndm_proto::TrafficEventType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ndm_proto::TrafficEventType>() {
  return ::ndm_proto::TrafficEventType_descriptor();
}
template <> struct is_proto_enum< ::ndm_proto::TrafficFlowStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ndm_proto::TrafficFlowStatus>() {
  return ::ndm_proto::TrafficFlowStatus_descriptor();
}
template <> struct is_proto_enum< ::ndm_proto::TrafficConeType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ndm_proto::TrafficConeType>() {
  return ::ndm_proto::TrafficConeType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_base_2eproto__INCLUDED
