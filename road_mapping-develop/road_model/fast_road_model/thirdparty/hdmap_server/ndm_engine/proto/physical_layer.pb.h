// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: physical_layer.proto

#ifndef PROTOBUF_physical_5flayer_2eproto__INCLUDED
#define PROTOBUF_physical_5flayer_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "base.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_physical_5flayer_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[17];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsTrafficLightImpl();
void InitDefaultsTrafficLight();
void InitDefaultsTrafficLightBulbImpl();
void InitDefaultsTrafficLightBulb();
void InitDefaultsLaneMarkingImpl();
void InitDefaultsLaneMarking();
void InitDefaultsLaneLineImpl();
void InitDefaultsLaneLine();
void InitDefaultsStopLineImpl();
void InitDefaultsStopLine();
void InitDefaultsSpeedBumpImpl();
void InitDefaultsSpeedBump();
void InitDefaultsPoleImpl();
void InitDefaultsPole();
void InitDefaultsBoardImpl();
void InitDefaultsBoard();
void InitDefaultsCrossWalkImpl();
void InitDefaultsCrossWalk();
void InitDefaultsZoneImpl();
void InitDefaultsZone();
void InitDefaultsTrafficSignImpl();
void InitDefaultsTrafficSign();
void InitDefaultsParkingSlotImpl();
void InitDefaultsParkingSlot();
void InitDefaultsElevationPlaneImpl();
void InitDefaultsElevationPlane();
void InitDefaultsAreaPolygonImpl();
void InitDefaultsAreaPolygon();
void InitDefaultsGeneralPolygonImpl();
void InitDefaultsGeneralPolygon();
void InitDefaultsGeneralLineImpl();
void InitDefaultsGeneralLine();
void InitDefaultsPhysicalLayerImpl();
void InitDefaultsPhysicalLayer();
inline void InitDefaults() {
  InitDefaultsTrafficLight();
  InitDefaultsTrafficLightBulb();
  InitDefaultsLaneMarking();
  InitDefaultsLaneLine();
  InitDefaultsStopLine();
  InitDefaultsSpeedBump();
  InitDefaultsPole();
  InitDefaultsBoard();
  InitDefaultsCrossWalk();
  InitDefaultsZone();
  InitDefaultsTrafficSign();
  InitDefaultsParkingSlot();
  InitDefaultsElevationPlane();
  InitDefaultsAreaPolygon();
  InitDefaultsGeneralPolygon();
  InitDefaultsGeneralLine();
  InitDefaultsPhysicalLayer();
}
}  // namespace protobuf_physical_5flayer_2eproto
namespace ndm_proto {
class AreaPolygon;
class AreaPolygonDefaultTypeInternal;
extern AreaPolygonDefaultTypeInternal _AreaPolygon_default_instance_;
class Board;
class BoardDefaultTypeInternal;
extern BoardDefaultTypeInternal _Board_default_instance_;
class CrossWalk;
class CrossWalkDefaultTypeInternal;
extern CrossWalkDefaultTypeInternal _CrossWalk_default_instance_;
class ElevationPlane;
class ElevationPlaneDefaultTypeInternal;
extern ElevationPlaneDefaultTypeInternal _ElevationPlane_default_instance_;
class GeneralLine;
class GeneralLineDefaultTypeInternal;
extern GeneralLineDefaultTypeInternal _GeneralLine_default_instance_;
class GeneralPolygon;
class GeneralPolygonDefaultTypeInternal;
extern GeneralPolygonDefaultTypeInternal _GeneralPolygon_default_instance_;
class LaneLine;
class LaneLineDefaultTypeInternal;
extern LaneLineDefaultTypeInternal _LaneLine_default_instance_;
class LaneMarking;
class LaneMarkingDefaultTypeInternal;
extern LaneMarkingDefaultTypeInternal _LaneMarking_default_instance_;
class ParkingSlot;
class ParkingSlotDefaultTypeInternal;
extern ParkingSlotDefaultTypeInternal _ParkingSlot_default_instance_;
class PhysicalLayer;
class PhysicalLayerDefaultTypeInternal;
extern PhysicalLayerDefaultTypeInternal _PhysicalLayer_default_instance_;
class Pole;
class PoleDefaultTypeInternal;
extern PoleDefaultTypeInternal _Pole_default_instance_;
class SpeedBump;
class SpeedBumpDefaultTypeInternal;
extern SpeedBumpDefaultTypeInternal _SpeedBump_default_instance_;
class StopLine;
class StopLineDefaultTypeInternal;
extern StopLineDefaultTypeInternal _StopLine_default_instance_;
class TrafficLight;
class TrafficLightDefaultTypeInternal;
extern TrafficLightDefaultTypeInternal _TrafficLight_default_instance_;
class TrafficLightBulb;
class TrafficLightBulbDefaultTypeInternal;
extern TrafficLightBulbDefaultTypeInternal _TrafficLightBulb_default_instance_;
class TrafficSign;
class TrafficSignDefaultTypeInternal;
extern TrafficSignDefaultTypeInternal _TrafficSign_default_instance_;
class Zone;
class ZoneDefaultTypeInternal;
extern ZoneDefaultTypeInternal _Zone_default_instance_;
}  // namespace ndm_proto
namespace ndm_proto {

// ===================================================================

class TrafficLight : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.TrafficLight) */ {
 public:
  TrafficLight();
  virtual ~TrafficLight();

  TrafficLight(const TrafficLight& from);

  inline TrafficLight& operator=(const TrafficLight& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TrafficLight(TrafficLight&& from) noexcept
    : TrafficLight() {
    *this = ::std::move(from);
  }

  inline TrafficLight& operator=(TrafficLight&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TrafficLight& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrafficLight* internal_default_instance() {
    return reinterpret_cast<const TrafficLight*>(
               &_TrafficLight_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(TrafficLight* other);
  friend void swap(TrafficLight& a, TrafficLight& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrafficLight* New() const PROTOBUF_FINAL { return New(NULL); }

  TrafficLight* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TrafficLight& from);
  void MergeFrom(const TrafficLight& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TrafficLight* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ndm_proto.TrafficLightBulb bulbs = 10;
  int bulbs_size() const;
  void clear_bulbs();
  static const int kBulbsFieldNumber = 10;
  const ::ndm_proto::TrafficLightBulb& bulbs(int index) const;
  ::ndm_proto::TrafficLightBulb* mutable_bulbs(int index);
  ::ndm_proto::TrafficLightBulb* add_bulbs();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::TrafficLightBulb >*
      mutable_bulbs();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::TrafficLightBulb >&
      bulbs() const;

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // required .ndm_proto.Polygon border = 2;
  bool has_border() const;
  void clear_border();
  static const int kBorderFieldNumber = 2;
  const ::ndm_proto::Polygon& border() const;
  ::ndm_proto::Polygon* release_border();
  ::ndm_proto::Polygon* mutable_border();
  void set_allocated_border(::ndm_proto::Polygon* border);

  // optional .ndm_proto.TrafficLightType type = 3;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  const ::ndm_proto::TrafficLightType& type() const;
  ::ndm_proto::TrafficLightType* release_type();
  ::ndm_proto::TrafficLightType* mutable_type();
  void set_allocated_type(::ndm_proto::TrafficLightType* type);

  // optional .ndm_proto.TrafficLightState state = 4;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 4;
  const ::ndm_proto::TrafficLightState& state() const;
  ::ndm_proto::TrafficLightState* release_state();
  ::ndm_proto::TrafficLightState* mutable_state();
  void set_allocated_state(::ndm_proto::TrafficLightState* state);

  // optional float exist_conf = 5;
  bool has_exist_conf() const;
  void clear_exist_conf();
  static const int kExistConfFieldNumber = 5;
  float exist_conf() const;
  void set_exist_conf(float value);

  // @@protoc_insertion_point(class_scope:ndm_proto.TrafficLight)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_border();
  void clear_has_border();
  void set_has_type();
  void clear_has_type();
  void set_has_state();
  void clear_has_state();
  void set_has_exist_conf();
  void clear_has_exist_conf();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::TrafficLightBulb > bulbs_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::ndm_proto::Polygon* border_;
  ::ndm_proto::TrafficLightType* type_;
  ::ndm_proto::TrafficLightState* state_;
  float exist_conf_;
  friend struct ::protobuf_physical_5flayer_2eproto::TableStruct;
  friend void ::protobuf_physical_5flayer_2eproto::InitDefaultsTrafficLightImpl();
};
// -------------------------------------------------------------------

class TrafficLightBulb : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.TrafficLightBulb) */ {
 public:
  TrafficLightBulb();
  virtual ~TrafficLightBulb();

  TrafficLightBulb(const TrafficLightBulb& from);

  inline TrafficLightBulb& operator=(const TrafficLightBulb& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TrafficLightBulb(TrafficLightBulb&& from) noexcept
    : TrafficLightBulb() {
    *this = ::std::move(from);
  }

  inline TrafficLightBulb& operator=(TrafficLightBulb&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TrafficLightBulb& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrafficLightBulb* internal_default_instance() {
    return reinterpret_cast<const TrafficLightBulb*>(
               &_TrafficLightBulb_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(TrafficLightBulb* other);
  friend void swap(TrafficLightBulb& a, TrafficLightBulb& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrafficLightBulb* New() const PROTOBUF_FINAL { return New(NULL); }

  TrafficLightBulb* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TrafficLightBulb& from);
  void MergeFrom(const TrafficLightBulb& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TrafficLightBulb* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // required .ndm_proto.Circle cborder = 2;
  bool has_cborder() const;
  void clear_cborder();
  static const int kCborderFieldNumber = 2;
  const ::ndm_proto::Circle& cborder() const;
  ::ndm_proto::Circle* release_cborder();
  ::ndm_proto::Circle* mutable_cborder();
  void set_allocated_cborder(::ndm_proto::Circle* cborder);

  // optional .ndm_proto.Polygon border = 3;
  bool has_border() const;
  void clear_border();
  static const int kBorderFieldNumber = 3;
  const ::ndm_proto::Polygon& border() const;
  ::ndm_proto::Polygon* release_border();
  ::ndm_proto::Polygon* mutable_border();
  void set_allocated_border(::ndm_proto::Polygon* border);

  // optional .ndm_proto.TrafficLightBulbShape shape = 4;
  bool has_shape() const;
  void clear_shape();
  static const int kShapeFieldNumber = 4;
  const ::ndm_proto::TrafficLightBulbShape& shape() const;
  ::ndm_proto::TrafficLightBulbShape* release_shape();
  ::ndm_proto::TrafficLightBulbShape* mutable_shape();
  void set_allocated_shape(::ndm_proto::TrafficLightBulbShape* shape);

  // optional uint64 time_cycle = 5;
  bool has_time_cycle() const;
  void clear_time_cycle();
  static const int kTimeCycleFieldNumber = 5;
  ::google::protobuf::uint64 time_cycle() const;
  void set_time_cycle(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:ndm_proto.TrafficLightBulb)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_cborder();
  void clear_has_cborder();
  void set_has_border();
  void clear_has_border();
  void set_has_shape();
  void clear_has_shape();
  void set_has_time_cycle();
  void clear_has_time_cycle();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::ndm_proto::Circle* cborder_;
  ::ndm_proto::Polygon* border_;
  ::ndm_proto::TrafficLightBulbShape* shape_;
  ::google::protobuf::uint64 time_cycle_;
  friend struct ::protobuf_physical_5flayer_2eproto::TableStruct;
  friend void ::protobuf_physical_5flayer_2eproto::InitDefaultsTrafficLightBulbImpl();
};
// -------------------------------------------------------------------

class LaneMarking : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.LaneMarking) */ {
 public:
  LaneMarking();
  virtual ~LaneMarking();

  LaneMarking(const LaneMarking& from);

  inline LaneMarking& operator=(const LaneMarking& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LaneMarking(LaneMarking&& from) noexcept
    : LaneMarking() {
    *this = ::std::move(from);
  }

  inline LaneMarking& operator=(LaneMarking&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LaneMarking& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LaneMarking* internal_default_instance() {
    return reinterpret_cast<const LaneMarking*>(
               &_LaneMarking_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(LaneMarking* other);
  friend void swap(LaneMarking& a, LaneMarking& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LaneMarking* New() const PROTOBUF_FINAL { return New(NULL); }

  LaneMarking* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LaneMarking& from);
  void MergeFrom(const LaneMarking& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LaneMarking* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // required .ndm_proto.Polygon border = 2;
  bool has_border() const;
  void clear_border();
  static const int kBorderFieldNumber = 2;
  const ::ndm_proto::Polygon& border() const;
  ::ndm_proto::Polygon* release_border();
  ::ndm_proto::Polygon* mutable_border();
  void set_allocated_border(::ndm_proto::Polygon* border);

  // optional .ndm_proto.LaneMarkingType type = 3;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  const ::ndm_proto::LaneMarkingType& type() const;
  ::ndm_proto::LaneMarkingType* release_type();
  ::ndm_proto::LaneMarkingType* mutable_type();
  void set_allocated_type(::ndm_proto::LaneMarkingType* type);

  // optional .ndm_proto.Number number = 4;
  bool has_number() const;
  void clear_number();
  static const int kNumberFieldNumber = 4;
  const ::ndm_proto::Number& number() const;
  ::ndm_proto::Number* release_number();
  ::ndm_proto::Number* mutable_number();
  void set_allocated_number(::ndm_proto::Number* number);

  // optional .ndm_proto.String str = 6;
  bool has_str() const;
  void clear_str();
  static const int kStrFieldNumber = 6;
  const ::ndm_proto::String& str() const;
  ::ndm_proto::String* release_str();
  ::ndm_proto::String* mutable_str();
  void set_allocated_str(::ndm_proto::String* str);

  // optional float exist_conf = 5;
  bool has_exist_conf() const;
  void clear_exist_conf();
  static const int kExistConfFieldNumber = 5;
  float exist_conf() const;
  void set_exist_conf(float value);

  // @@protoc_insertion_point(class_scope:ndm_proto.LaneMarking)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_border();
  void clear_has_border();
  void set_has_type();
  void clear_has_type();
  void set_has_number();
  void clear_has_number();
  void set_has_exist_conf();
  void clear_has_exist_conf();
  void set_has_str();
  void clear_has_str();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::ndm_proto::Polygon* border_;
  ::ndm_proto::LaneMarkingType* type_;
  ::ndm_proto::Number* number_;
  ::ndm_proto::String* str_;
  float exist_conf_;
  friend struct ::protobuf_physical_5flayer_2eproto::TableStruct;
  friend void ::protobuf_physical_5flayer_2eproto::InitDefaultsLaneMarkingImpl();
};
// -------------------------------------------------------------------

class LaneLine : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.LaneLine) */ {
 public:
  LaneLine();
  virtual ~LaneLine();

  LaneLine(const LaneLine& from);

  inline LaneLine& operator=(const LaneLine& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LaneLine(LaneLine&& from) noexcept
    : LaneLine() {
    *this = ::std::move(from);
  }

  inline LaneLine& operator=(LaneLine&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LaneLine& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LaneLine* internal_default_instance() {
    return reinterpret_cast<const LaneLine*>(
               &_LaneLine_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(LaneLine* other);
  friend void swap(LaneLine& a, LaneLine& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LaneLine* New() const PROTOBUF_FINAL { return New(NULL); }

  LaneLine* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LaneLine& from);
  void MergeFrom(const LaneLine& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LaneLine* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ndm_proto.CurveLine lines = 2;
  int lines_size() const;
  void clear_lines();
  static const int kLinesFieldNumber = 2;
  const ::ndm_proto::CurveLine& lines(int index) const;
  ::ndm_proto::CurveLine* mutable_lines(int index);
  ::ndm_proto::CurveLine* add_lines();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::CurveLine >*
      mutable_lines();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::CurveLine >&
      lines() const;

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // optional .ndm_proto.LaneLineType type = 3;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  const ::ndm_proto::LaneLineType& type() const;
  ::ndm_proto::LaneLineType* release_type();
  ::ndm_proto::LaneLineType* mutable_type();
  void set_allocated_type(::ndm_proto::LaneLineType* type);

  // optional .ndm_proto.LaneLineColor color = 4;
  bool has_color() const;
  void clear_color();
  static const int kColorFieldNumber = 4;
  const ::ndm_proto::LaneLineColor& color() const;
  ::ndm_proto::LaneLineColor* release_color();
  ::ndm_proto::LaneLineColor* mutable_color();
  void set_allocated_color(::ndm_proto::LaneLineColor* color);

  // optional float exist_conf = 6;
  bool has_exist_conf() const;
  void clear_exist_conf();
  static const int kExistConfFieldNumber = 6;
  float exist_conf() const;
  void set_exist_conf(float value);

  // optional .ndm_proto.LaneLineConfidence confidence = 7;
  bool has_confidence() const;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 7;
  ::ndm_proto::LaneLineConfidence confidence() const;
  void set_confidence(::ndm_proto::LaneLineConfidence value);

  // optional bool virtual = 5 [default = false];
  bool has_virtual_() const;
  void clear_virtual_();
  static const int kVirtualFieldNumber = 5;
  bool virtual_() const;
  void set_virtual_(bool value);

  // optional bool ldm = 9;
  bool has_ldm() const;
  void clear_ldm();
  static const int kLdmFieldNumber = 9;
  bool ldm() const;
  void set_ldm(bool value);

  // optional .ndm_proto.LineMarking marking = 8;
  bool has_marking() const;
  void clear_marking();
  static const int kMarkingFieldNumber = 8;
  ::ndm_proto::LineMarking marking() const;
  void set_marking(::ndm_proto::LineMarking value);

  // @@protoc_insertion_point(class_scope:ndm_proto.LaneLine)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_type();
  void clear_has_type();
  void set_has_color();
  void clear_has_color();
  void set_has_virtual_();
  void clear_has_virtual_();
  void set_has_exist_conf();
  void clear_has_exist_conf();
  void set_has_confidence();
  void clear_has_confidence();
  void set_has_marking();
  void clear_has_marking();
  void set_has_ldm();
  void clear_has_ldm();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::CurveLine > lines_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::ndm_proto::LaneLineType* type_;
  ::ndm_proto::LaneLineColor* color_;
  float exist_conf_;
  int confidence_;
  bool virtual__;
  bool ldm_;
  int marking_;
  friend struct ::protobuf_physical_5flayer_2eproto::TableStruct;
  friend void ::protobuf_physical_5flayer_2eproto::InitDefaultsLaneLineImpl();
};
// -------------------------------------------------------------------

class StopLine : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.StopLine) */ {
 public:
  StopLine();
  virtual ~StopLine();

  StopLine(const StopLine& from);

  inline StopLine& operator=(const StopLine& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StopLine(StopLine&& from) noexcept
    : StopLine() {
    *this = ::std::move(from);
  }

  inline StopLine& operator=(StopLine&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StopLine& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StopLine* internal_default_instance() {
    return reinterpret_cast<const StopLine*>(
               &_StopLine_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(StopLine* other);
  friend void swap(StopLine& a, StopLine& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StopLine* New() const PROTOBUF_FINAL { return New(NULL); }

  StopLine* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const StopLine& from);
  void MergeFrom(const StopLine& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(StopLine* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // required .ndm_proto.Polygon border = 2;
  bool has_border() const;
  void clear_border();
  static const int kBorderFieldNumber = 2;
  const ::ndm_proto::Polygon& border() const;
  ::ndm_proto::Polygon* release_border();
  ::ndm_proto::Polygon* mutable_border();
  void set_allocated_border(::ndm_proto::Polygon* border);

  // optional float exist_conf = 3;
  bool has_exist_conf() const;
  void clear_exist_conf();
  static const int kExistConfFieldNumber = 3;
  float exist_conf() const;
  void set_exist_conf(float value);

  // @@protoc_insertion_point(class_scope:ndm_proto.StopLine)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_border();
  void clear_has_border();
  void set_has_exist_conf();
  void clear_has_exist_conf();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::ndm_proto::Polygon* border_;
  float exist_conf_;
  friend struct ::protobuf_physical_5flayer_2eproto::TableStruct;
  friend void ::protobuf_physical_5flayer_2eproto::InitDefaultsStopLineImpl();
};
// -------------------------------------------------------------------

class SpeedBump : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.SpeedBump) */ {
 public:
  SpeedBump();
  virtual ~SpeedBump();

  SpeedBump(const SpeedBump& from);

  inline SpeedBump& operator=(const SpeedBump& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SpeedBump(SpeedBump&& from) noexcept
    : SpeedBump() {
    *this = ::std::move(from);
  }

  inline SpeedBump& operator=(SpeedBump&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SpeedBump& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SpeedBump* internal_default_instance() {
    return reinterpret_cast<const SpeedBump*>(
               &_SpeedBump_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(SpeedBump* other);
  friend void swap(SpeedBump& a, SpeedBump& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SpeedBump* New() const PROTOBUF_FINAL { return New(NULL); }

  SpeedBump* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SpeedBump& from);
  void MergeFrom(const SpeedBump& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SpeedBump* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // required .ndm_proto.Polygon border = 2;
  bool has_border() const;
  void clear_border();
  static const int kBorderFieldNumber = 2;
  const ::ndm_proto::Polygon& border() const;
  ::ndm_proto::Polygon* release_border();
  ::ndm_proto::Polygon* mutable_border();
  void set_allocated_border(::ndm_proto::Polygon* border);

  // optional .ndm_proto.Number height = 3;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 3;
  const ::ndm_proto::Number& height() const;
  ::ndm_proto::Number* release_height();
  ::ndm_proto::Number* mutable_height();
  void set_allocated_height(::ndm_proto::Number* height);

  // optional .ndm_proto.Number speedlimit = 4;
  bool has_speedlimit() const;
  void clear_speedlimit();
  static const int kSpeedlimitFieldNumber = 4;
  const ::ndm_proto::Number& speedlimit() const;
  ::ndm_proto::Number* release_speedlimit();
  ::ndm_proto::Number* mutable_speedlimit();
  void set_allocated_speedlimit(::ndm_proto::Number* speedlimit);

  // optional float exist_conf = 5;
  bool has_exist_conf() const;
  void clear_exist_conf();
  static const int kExistConfFieldNumber = 5;
  float exist_conf() const;
  void set_exist_conf(float value);

  // @@protoc_insertion_point(class_scope:ndm_proto.SpeedBump)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_border();
  void clear_has_border();
  void set_has_height();
  void clear_has_height();
  void set_has_speedlimit();
  void clear_has_speedlimit();
  void set_has_exist_conf();
  void clear_has_exist_conf();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::ndm_proto::Polygon* border_;
  ::ndm_proto::Number* height_;
  ::ndm_proto::Number* speedlimit_;
  float exist_conf_;
  friend struct ::protobuf_physical_5flayer_2eproto::TableStruct;
  friend void ::protobuf_physical_5flayer_2eproto::InitDefaultsSpeedBumpImpl();
};
// -------------------------------------------------------------------

class Pole : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.Pole) */ {
 public:
  Pole();
  virtual ~Pole();

  Pole(const Pole& from);

  inline Pole& operator=(const Pole& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Pole(Pole&& from) noexcept
    : Pole() {
    *this = ::std::move(from);
  }

  inline Pole& operator=(Pole&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Pole& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Pole* internal_default_instance() {
    return reinterpret_cast<const Pole*>(
               &_Pole_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(Pole* other);
  friend void swap(Pole& a, Pole& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Pole* New() const PROTOBUF_FINAL { return New(NULL); }

  Pole* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Pole& from);
  void MergeFrom(const Pole& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Pole* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // required .ndm_proto.Cylinder body = 2;
  bool has_body() const;
  void clear_body();
  static const int kBodyFieldNumber = 2;
  const ::ndm_proto::Cylinder& body() const;
  ::ndm_proto::Cylinder* release_body();
  ::ndm_proto::Cylinder* mutable_body();
  void set_allocated_body(::ndm_proto::Cylinder* body);

  // optional .ndm_proto.PoleType type = 4;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 4;
  const ::ndm_proto::PoleType& type() const;
  ::ndm_proto::PoleType* release_type();
  ::ndm_proto::PoleType* mutable_type();
  void set_allocated_type(::ndm_proto::PoleType* type);

  // optional float exist_conf = 3;
  bool has_exist_conf() const;
  void clear_exist_conf();
  static const int kExistConfFieldNumber = 3;
  float exist_conf() const;
  void set_exist_conf(float value);

  // @@protoc_insertion_point(class_scope:ndm_proto.Pole)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_body();
  void clear_has_body();
  void set_has_exist_conf();
  void clear_has_exist_conf();
  void set_has_type();
  void clear_has_type();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::ndm_proto::Cylinder* body_;
  ::ndm_proto::PoleType* type_;
  float exist_conf_;
  friend struct ::protobuf_physical_5flayer_2eproto::TableStruct;
  friend void ::protobuf_physical_5flayer_2eproto::InitDefaultsPoleImpl();
};
// -------------------------------------------------------------------

class Board : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.Board) */ {
 public:
  Board();
  virtual ~Board();

  Board(const Board& from);

  inline Board& operator=(const Board& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Board(Board&& from) noexcept
    : Board() {
    *this = ::std::move(from);
  }

  inline Board& operator=(Board&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Board& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Board* internal_default_instance() {
    return reinterpret_cast<const Board*>(
               &_Board_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(Board* other);
  friend void swap(Board& a, Board& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Board* New() const PROTOBUF_FINAL { return New(NULL); }

  Board* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Board& from);
  void MergeFrom(const Board& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Board* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // required .ndm_proto.Polygon border = 2;
  bool has_border() const;
  void clear_border();
  static const int kBorderFieldNumber = 2;
  const ::ndm_proto::Polygon& border() const;
  ::ndm_proto::Polygon* release_border();
  ::ndm_proto::Polygon* mutable_border();
  void set_allocated_border(::ndm_proto::Polygon* border);

  // optional .ndm_proto.String str = 3;
  bool has_str() const;
  void clear_str();
  static const int kStrFieldNumber = 3;
  const ::ndm_proto::String& str() const;
  ::ndm_proto::String* release_str();
  ::ndm_proto::String* mutable_str();
  void set_allocated_str(::ndm_proto::String* str);

  // optional float exist_conf = 4;
  bool has_exist_conf() const;
  void clear_exist_conf();
  static const int kExistConfFieldNumber = 4;
  float exist_conf() const;
  void set_exist_conf(float value);

  // @@protoc_insertion_point(class_scope:ndm_proto.Board)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_border();
  void clear_has_border();
  void set_has_str();
  void clear_has_str();
  void set_has_exist_conf();
  void clear_has_exist_conf();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::ndm_proto::Polygon* border_;
  ::ndm_proto::String* str_;
  float exist_conf_;
  friend struct ::protobuf_physical_5flayer_2eproto::TableStruct;
  friend void ::protobuf_physical_5flayer_2eproto::InitDefaultsBoardImpl();
};
// -------------------------------------------------------------------

class CrossWalk : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.CrossWalk) */ {
 public:
  CrossWalk();
  virtual ~CrossWalk();

  CrossWalk(const CrossWalk& from);

  inline CrossWalk& operator=(const CrossWalk& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CrossWalk(CrossWalk&& from) noexcept
    : CrossWalk() {
    *this = ::std::move(from);
  }

  inline CrossWalk& operator=(CrossWalk&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CrossWalk& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CrossWalk* internal_default_instance() {
    return reinterpret_cast<const CrossWalk*>(
               &_CrossWalk_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(CrossWalk* other);
  friend void swap(CrossWalk& a, CrossWalk& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CrossWalk* New() const PROTOBUF_FINAL { return New(NULL); }

  CrossWalk* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CrossWalk& from);
  void MergeFrom(const CrossWalk& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CrossWalk* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ndm_proto.Polygon child_borders = 3;
  int child_borders_size() const;
  void clear_child_borders();
  static const int kChildBordersFieldNumber = 3;
  const ::ndm_proto::Polygon& child_borders(int index) const;
  ::ndm_proto::Polygon* mutable_child_borders(int index);
  ::ndm_proto::Polygon* add_child_borders();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Polygon >*
      mutable_child_borders();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Polygon >&
      child_borders() const;

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // required .ndm_proto.Polygon border = 2;
  bool has_border() const;
  void clear_border();
  static const int kBorderFieldNumber = 2;
  const ::ndm_proto::Polygon& border() const;
  ::ndm_proto::Polygon* release_border();
  ::ndm_proto::Polygon* mutable_border();
  void set_allocated_border(::ndm_proto::Polygon* border);

  // optional float exist_conf = 4;
  bool has_exist_conf() const;
  void clear_exist_conf();
  static const int kExistConfFieldNumber = 4;
  float exist_conf() const;
  void set_exist_conf(float value);

  // @@protoc_insertion_point(class_scope:ndm_proto.CrossWalk)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_border();
  void clear_has_border();
  void set_has_exist_conf();
  void clear_has_exist_conf();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Polygon > child_borders_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::ndm_proto::Polygon* border_;
  float exist_conf_;
  friend struct ::protobuf_physical_5flayer_2eproto::TableStruct;
  friend void ::protobuf_physical_5flayer_2eproto::InitDefaultsCrossWalkImpl();
};
// -------------------------------------------------------------------

class Zone : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.Zone) */ {
 public:
  Zone();
  virtual ~Zone();

  Zone(const Zone& from);

  inline Zone& operator=(const Zone& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Zone(Zone&& from) noexcept
    : Zone() {
    *this = ::std::move(from);
  }

  inline Zone& operator=(Zone&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Zone& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Zone* internal_default_instance() {
    return reinterpret_cast<const Zone*>(
               &_Zone_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(Zone* other);
  friend void swap(Zone& a, Zone& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Zone* New() const PROTOBUF_FINAL { return New(NULL); }

  Zone* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Zone& from);
  void MergeFrom(const Zone& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Zone* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // required .ndm_proto.Polygon border = 2;
  bool has_border() const;
  void clear_border();
  static const int kBorderFieldNumber = 2;
  const ::ndm_proto::Polygon& border() const;
  ::ndm_proto::Polygon* release_border();
  ::ndm_proto::Polygon* mutable_border();
  void set_allocated_border(::ndm_proto::Polygon* border);

  // optional .ndm_proto.String str = 3;
  bool has_str() const;
  void clear_str();
  static const int kStrFieldNumber = 3;
  const ::ndm_proto::String& str() const;
  ::ndm_proto::String* release_str();
  ::ndm_proto::String* mutable_str();
  void set_allocated_str(::ndm_proto::String* str);

  // optional .ndm_proto.ZoneType type = 5;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 5;
  const ::ndm_proto::ZoneType& type() const;
  ::ndm_proto::ZoneType* release_type();
  ::ndm_proto::ZoneType* mutable_type();
  void set_allocated_type(::ndm_proto::ZoneType* type);

  // optional float exist_conf = 4;
  bool has_exist_conf() const;
  void clear_exist_conf();
  static const int kExistConfFieldNumber = 4;
  float exist_conf() const;
  void set_exist_conf(float value);

  // @@protoc_insertion_point(class_scope:ndm_proto.Zone)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_border();
  void clear_has_border();
  void set_has_str();
  void clear_has_str();
  void set_has_exist_conf();
  void clear_has_exist_conf();
  void set_has_type();
  void clear_has_type();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::ndm_proto::Polygon* border_;
  ::ndm_proto::String* str_;
  ::ndm_proto::ZoneType* type_;
  float exist_conf_;
  friend struct ::protobuf_physical_5flayer_2eproto::TableStruct;
  friend void ::protobuf_physical_5flayer_2eproto::InitDefaultsZoneImpl();
};
// -------------------------------------------------------------------

class TrafficSign : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.TrafficSign) */ {
 public:
  TrafficSign();
  virtual ~TrafficSign();

  TrafficSign(const TrafficSign& from);

  inline TrafficSign& operator=(const TrafficSign& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TrafficSign(TrafficSign&& from) noexcept
    : TrafficSign() {
    *this = ::std::move(from);
  }

  inline TrafficSign& operator=(TrafficSign&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TrafficSign& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrafficSign* internal_default_instance() {
    return reinterpret_cast<const TrafficSign*>(
               &_TrafficSign_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(TrafficSign* other);
  friend void swap(TrafficSign& a, TrafficSign& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrafficSign* New() const PROTOBUF_FINAL { return New(NULL); }

  TrafficSign* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TrafficSign& from);
  void MergeFrom(const TrafficSign& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TrafficSign* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ndm_proto.Condition panels = 10;
  int panels_size() const;
  void clear_panels();
  static const int kPanelsFieldNumber = 10;
  const ::ndm_proto::Condition& panels(int index) const;
  ::ndm_proto::Condition* mutable_panels(int index);
  ::ndm_proto::Condition* add_panels();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Condition >*
      mutable_panels();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Condition >&
      panels() const;

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // required .ndm_proto.Polygon border = 2;
  bool has_border() const;
  void clear_border();
  static const int kBorderFieldNumber = 2;
  const ::ndm_proto::Polygon& border() const;
  ::ndm_proto::Polygon* release_border();
  ::ndm_proto::Polygon* mutable_border();
  void set_allocated_border(::ndm_proto::Polygon* border);

  // optional .ndm_proto.Circle cborder = 3;
  bool has_cborder() const;
  void clear_cborder();
  static const int kCborderFieldNumber = 3;
  const ::ndm_proto::Circle& cborder() const;
  ::ndm_proto::Circle* release_cborder();
  ::ndm_proto::Circle* mutable_cborder();
  void set_allocated_cborder(::ndm_proto::Circle* cborder);

  // optional .ndm_proto.TrafficSignType type = 4;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 4;
  const ::ndm_proto::TrafficSignType& type() const;
  ::ndm_proto::TrafficSignType* release_type();
  ::ndm_proto::TrafficSignType* mutable_type();
  void set_allocated_type(::ndm_proto::TrafficSignType* type);

  // optional .ndm_proto.Number number = 5;
  bool has_number() const;
  void clear_number();
  static const int kNumberFieldNumber = 5;
  const ::ndm_proto::Number& number() const;
  ::ndm_proto::Number* release_number();
  ::ndm_proto::Number* mutable_number();
  void set_allocated_number(::ndm_proto::Number* number);

  // optional .ndm_proto.String str = 7;
  bool has_str() const;
  void clear_str();
  static const int kStrFieldNumber = 7;
  const ::ndm_proto::String& str() const;
  ::ndm_proto::String* release_str();
  ::ndm_proto::String* mutable_str();
  void set_allocated_str(::ndm_proto::String* str);

  // optional float exist_conf = 6;
  bool has_exist_conf() const;
  void clear_exist_conf();
  static const int kExistConfFieldNumber = 6;
  float exist_conf() const;
  void set_exist_conf(float value);

  // optional .ndm_proto.SignShape shape = 8;
  bool has_shape() const;
  void clear_shape();
  static const int kShapeFieldNumber = 8;
  ::ndm_proto::SignShape shape() const;
  void set_shape(::ndm_proto::SignShape value);

  // optional .ndm_proto.YesNoUnknown vms = 9;
  bool has_vms() const;
  void clear_vms();
  static const int kVmsFieldNumber = 9;
  ::ndm_proto::YesNoUnknown vms() const;
  void set_vms(::ndm_proto::YesNoUnknown value);

  // @@protoc_insertion_point(class_scope:ndm_proto.TrafficSign)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_border();
  void clear_has_border();
  void set_has_cborder();
  void clear_has_cborder();
  void set_has_type();
  void clear_has_type();
  void set_has_number();
  void clear_has_number();
  void set_has_exist_conf();
  void clear_has_exist_conf();
  void set_has_str();
  void clear_has_str();
  void set_has_shape();
  void clear_has_shape();
  void set_has_vms();
  void clear_has_vms();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Condition > panels_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::ndm_proto::Polygon* border_;
  ::ndm_proto::Circle* cborder_;
  ::ndm_proto::TrafficSignType* type_;
  ::ndm_proto::Number* number_;
  ::ndm_proto::String* str_;
  float exist_conf_;
  int shape_;
  int vms_;
  friend struct ::protobuf_physical_5flayer_2eproto::TableStruct;
  friend void ::protobuf_physical_5flayer_2eproto::InitDefaultsTrafficSignImpl();
};
// -------------------------------------------------------------------

class ParkingSlot : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.ParkingSlot) */ {
 public:
  ParkingSlot();
  virtual ~ParkingSlot();

  ParkingSlot(const ParkingSlot& from);

  inline ParkingSlot& operator=(const ParkingSlot& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ParkingSlot(ParkingSlot&& from) noexcept
    : ParkingSlot() {
    *this = ::std::move(from);
  }

  inline ParkingSlot& operator=(ParkingSlot&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ParkingSlot& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ParkingSlot* internal_default_instance() {
    return reinterpret_cast<const ParkingSlot*>(
               &_ParkingSlot_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(ParkingSlot* other);
  friend void swap(ParkingSlot& a, ParkingSlot& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ParkingSlot* New() const PROTOBUF_FINAL { return New(NULL); }

  ParkingSlot* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ParkingSlot& from);
  void MergeFrom(const ParkingSlot& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ParkingSlot* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // required .ndm_proto.Polygon border = 2;
  bool has_border() const;
  void clear_border();
  static const int kBorderFieldNumber = 2;
  const ::ndm_proto::Polygon& border() const;
  ::ndm_proto::Polygon* release_border();
  ::ndm_proto::Polygon* mutable_border();
  void set_allocated_border(::ndm_proto::Polygon* border);

  // optional .ndm_proto.String str = 3;
  bool has_str() const;
  void clear_str();
  static const int kStrFieldNumber = 3;
  const ::ndm_proto::String& str() const;
  ::ndm_proto::String* release_str();
  ::ndm_proto::String* mutable_str();
  void set_allocated_str(::ndm_proto::String* str);

  // optional float exist_conf = 4;
  bool has_exist_conf() const;
  void clear_exist_conf();
  static const int kExistConfFieldNumber = 4;
  float exist_conf() const;
  void set_exist_conf(float value);

  // @@protoc_insertion_point(class_scope:ndm_proto.ParkingSlot)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_border();
  void clear_has_border();
  void set_has_str();
  void clear_has_str();
  void set_has_exist_conf();
  void clear_has_exist_conf();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::ndm_proto::Polygon* border_;
  ::ndm_proto::String* str_;
  float exist_conf_;
  friend struct ::protobuf_physical_5flayer_2eproto::TableStruct;
  friend void ::protobuf_physical_5flayer_2eproto::InitDefaultsParkingSlotImpl();
};
// -------------------------------------------------------------------

class ElevationPlane : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.ElevationPlane) */ {
 public:
  ElevationPlane();
  virtual ~ElevationPlane();

  ElevationPlane(const ElevationPlane& from);

  inline ElevationPlane& operator=(const ElevationPlane& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ElevationPlane(ElevationPlane&& from) noexcept
    : ElevationPlane() {
    *this = ::std::move(from);
  }

  inline ElevationPlane& operator=(ElevationPlane&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ElevationPlane& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ElevationPlane* internal_default_instance() {
    return reinterpret_cast<const ElevationPlane*>(
               &_ElevationPlane_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(ElevationPlane* other);
  friend void swap(ElevationPlane& a, ElevationPlane& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ElevationPlane* New() const PROTOBUF_FINAL { return New(NULL); }

  ElevationPlane* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ElevationPlane& from);
  void MergeFrom(const ElevationPlane& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ElevationPlane* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // required .ndm_proto.Polygon border = 2;
  bool has_border() const;
  void clear_border();
  static const int kBorderFieldNumber = 2;
  const ::ndm_proto::Polygon& border() const;
  ::ndm_proto::Polygon* release_border();
  ::ndm_proto::Polygon* mutable_border();
  void set_allocated_border(::ndm_proto::Polygon* border);

  // optional float exist_conf = 3;
  bool has_exist_conf() const;
  void clear_exist_conf();
  static const int kExistConfFieldNumber = 3;
  float exist_conf() const;
  void set_exist_conf(float value);

  // @@protoc_insertion_point(class_scope:ndm_proto.ElevationPlane)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_border();
  void clear_has_border();
  void set_has_exist_conf();
  void clear_has_exist_conf();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::ndm_proto::Polygon* border_;
  float exist_conf_;
  friend struct ::protobuf_physical_5flayer_2eproto::TableStruct;
  friend void ::protobuf_physical_5flayer_2eproto::InitDefaultsElevationPlaneImpl();
};
// -------------------------------------------------------------------

class AreaPolygon : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.AreaPolygon) */ {
 public:
  AreaPolygon();
  virtual ~AreaPolygon();

  AreaPolygon(const AreaPolygon& from);

  inline AreaPolygon& operator=(const AreaPolygon& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AreaPolygon(AreaPolygon&& from) noexcept
    : AreaPolygon() {
    *this = ::std::move(from);
  }

  inline AreaPolygon& operator=(AreaPolygon&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AreaPolygon& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AreaPolygon* internal_default_instance() {
    return reinterpret_cast<const AreaPolygon*>(
               &_AreaPolygon_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(AreaPolygon* other);
  friend void swap(AreaPolygon& a, AreaPolygon& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AreaPolygon* New() const PROTOBUF_FINAL { return New(NULL); }

  AreaPolygon* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AreaPolygon& from);
  void MergeFrom(const AreaPolygon& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AreaPolygon* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // required .ndm_proto.Polygon border = 2;
  bool has_border() const;
  void clear_border();
  static const int kBorderFieldNumber = 2;
  const ::ndm_proto::Polygon& border() const;
  ::ndm_proto::Polygon* release_border();
  ::ndm_proto::Polygon* mutable_border();
  void set_allocated_border(::ndm_proto::Polygon* border);

  // optional .ndm_proto.String str = 3;
  bool has_str() const;
  void clear_str();
  static const int kStrFieldNumber = 3;
  const ::ndm_proto::String& str() const;
  ::ndm_proto::String* release_str();
  ::ndm_proto::String* mutable_str();
  void set_allocated_str(::ndm_proto::String* str);

  // optional float exist_conf = 4;
  bool has_exist_conf() const;
  void clear_exist_conf();
  static const int kExistConfFieldNumber = 4;
  float exist_conf() const;
  void set_exist_conf(float value);

  // @@protoc_insertion_point(class_scope:ndm_proto.AreaPolygon)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_border();
  void clear_has_border();
  void set_has_str();
  void clear_has_str();
  void set_has_exist_conf();
  void clear_has_exist_conf();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::ndm_proto::Polygon* border_;
  ::ndm_proto::String* str_;
  float exist_conf_;
  friend struct ::protobuf_physical_5flayer_2eproto::TableStruct;
  friend void ::protobuf_physical_5flayer_2eproto::InitDefaultsAreaPolygonImpl();
};
// -------------------------------------------------------------------

class GeneralPolygon : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.GeneralPolygon) */ {
 public:
  GeneralPolygon();
  virtual ~GeneralPolygon();

  GeneralPolygon(const GeneralPolygon& from);

  inline GeneralPolygon& operator=(const GeneralPolygon& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GeneralPolygon(GeneralPolygon&& from) noexcept
    : GeneralPolygon() {
    *this = ::std::move(from);
  }

  inline GeneralPolygon& operator=(GeneralPolygon&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GeneralPolygon& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GeneralPolygon* internal_default_instance() {
    return reinterpret_cast<const GeneralPolygon*>(
               &_GeneralPolygon_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(GeneralPolygon* other);
  friend void swap(GeneralPolygon& a, GeneralPolygon& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GeneralPolygon* New() const PROTOBUF_FINAL { return New(NULL); }

  GeneralPolygon* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GeneralPolygon& from);
  void MergeFrom(const GeneralPolygon& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GeneralPolygon* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // required .ndm_proto.Polygon border = 2;
  bool has_border() const;
  void clear_border();
  static const int kBorderFieldNumber = 2;
  const ::ndm_proto::Polygon& border() const;
  ::ndm_proto::Polygon* release_border();
  ::ndm_proto::Polygon* mutable_border();
  void set_allocated_border(::ndm_proto::Polygon* border);

  // optional .ndm_proto.String str = 3;
  bool has_str() const;
  void clear_str();
  static const int kStrFieldNumber = 3;
  const ::ndm_proto::String& str() const;
  ::ndm_proto::String* release_str();
  ::ndm_proto::String* mutable_str();
  void set_allocated_str(::ndm_proto::String* str);

  // @@protoc_insertion_point(class_scope:ndm_proto.GeneralPolygon)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_border();
  void clear_has_border();
  void set_has_str();
  void clear_has_str();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::ndm_proto::Polygon* border_;
  ::ndm_proto::String* str_;
  friend struct ::protobuf_physical_5flayer_2eproto::TableStruct;
  friend void ::protobuf_physical_5flayer_2eproto::InitDefaultsGeneralPolygonImpl();
};
// -------------------------------------------------------------------

class GeneralLine : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.GeneralLine) */ {
 public:
  GeneralLine();
  virtual ~GeneralLine();

  GeneralLine(const GeneralLine& from);

  inline GeneralLine& operator=(const GeneralLine& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GeneralLine(GeneralLine&& from) noexcept
    : GeneralLine() {
    *this = ::std::move(from);
  }

  inline GeneralLine& operator=(GeneralLine&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GeneralLine& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GeneralLine* internal_default_instance() {
    return reinterpret_cast<const GeneralLine*>(
               &_GeneralLine_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(GeneralLine* other);
  friend void swap(GeneralLine& a, GeneralLine& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GeneralLine* New() const PROTOBUF_FINAL { return New(NULL); }

  GeneralLine* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GeneralLine& from);
  void MergeFrom(const GeneralLine& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GeneralLine* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ndm_proto.CurveLine lines = 2;
  int lines_size() const;
  void clear_lines();
  static const int kLinesFieldNumber = 2;
  const ::ndm_proto::CurveLine& lines(int index) const;
  ::ndm_proto::CurveLine* mutable_lines(int index);
  ::ndm_proto::CurveLine* add_lines();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::CurveLine >*
      mutable_lines();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::CurveLine >&
      lines() const;

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // optional .ndm_proto.String str = 3;
  bool has_str() const;
  void clear_str();
  static const int kStrFieldNumber = 3;
  const ::ndm_proto::String& str() const;
  ::ndm_proto::String* release_str();
  ::ndm_proto::String* mutable_str();
  void set_allocated_str(::ndm_proto::String* str);

  // @@protoc_insertion_point(class_scope:ndm_proto.GeneralLine)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_str();
  void clear_has_str();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::CurveLine > lines_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::ndm_proto::String* str_;
  friend struct ::protobuf_physical_5flayer_2eproto::TableStruct;
  friend void ::protobuf_physical_5flayer_2eproto::InitDefaultsGeneralLineImpl();
};
// -------------------------------------------------------------------

class PhysicalLayer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.PhysicalLayer) */ {
 public:
  PhysicalLayer();
  virtual ~PhysicalLayer();

  PhysicalLayer(const PhysicalLayer& from);

  inline PhysicalLayer& operator=(const PhysicalLayer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PhysicalLayer(PhysicalLayer&& from) noexcept
    : PhysicalLayer() {
    *this = ::std::move(from);
  }

  inline PhysicalLayer& operator=(PhysicalLayer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PhysicalLayer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PhysicalLayer* internal_default_instance() {
    return reinterpret_cast<const PhysicalLayer*>(
               &_PhysicalLayer_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(PhysicalLayer* other);
  friend void swap(PhysicalLayer& a, PhysicalLayer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PhysicalLayer* New() const PROTOBUF_FINAL { return New(NULL); }

  PhysicalLayer* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PhysicalLayer& from);
  void MergeFrom(const PhysicalLayer& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PhysicalLayer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ndm_proto.TrafficLight trafficlights = 1;
  int trafficlights_size() const;
  void clear_trafficlights();
  static const int kTrafficlightsFieldNumber = 1;
  const ::ndm_proto::TrafficLight& trafficlights(int index) const;
  ::ndm_proto::TrafficLight* mutable_trafficlights(int index);
  ::ndm_proto::TrafficLight* add_trafficlights();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::TrafficLight >*
      mutable_trafficlights();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::TrafficLight >&
      trafficlights() const;

  // repeated .ndm_proto.LaneMarking lanemarkings = 2;
  int lanemarkings_size() const;
  void clear_lanemarkings();
  static const int kLanemarkingsFieldNumber = 2;
  const ::ndm_proto::LaneMarking& lanemarkings(int index) const;
  ::ndm_proto::LaneMarking* mutable_lanemarkings(int index);
  ::ndm_proto::LaneMarking* add_lanemarkings();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::LaneMarking >*
      mutable_lanemarkings();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::LaneMarking >&
      lanemarkings() const;

  // repeated .ndm_proto.LaneLine lanelines = 3;
  int lanelines_size() const;
  void clear_lanelines();
  static const int kLanelinesFieldNumber = 3;
  const ::ndm_proto::LaneLine& lanelines(int index) const;
  ::ndm_proto::LaneLine* mutable_lanelines(int index);
  ::ndm_proto::LaneLine* add_lanelines();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::LaneLine >*
      mutable_lanelines();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::LaneLine >&
      lanelines() const;

  // repeated .ndm_proto.StopLine stoplines = 4;
  int stoplines_size() const;
  void clear_stoplines();
  static const int kStoplinesFieldNumber = 4;
  const ::ndm_proto::StopLine& stoplines(int index) const;
  ::ndm_proto::StopLine* mutable_stoplines(int index);
  ::ndm_proto::StopLine* add_stoplines();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::StopLine >*
      mutable_stoplines();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::StopLine >&
      stoplines() const;

  // repeated .ndm_proto.SpeedBump speedbumps = 5;
  int speedbumps_size() const;
  void clear_speedbumps();
  static const int kSpeedbumpsFieldNumber = 5;
  const ::ndm_proto::SpeedBump& speedbumps(int index) const;
  ::ndm_proto::SpeedBump* mutable_speedbumps(int index);
  ::ndm_proto::SpeedBump* add_speedbumps();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::SpeedBump >*
      mutable_speedbumps();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::SpeedBump >&
      speedbumps() const;

  // repeated .ndm_proto.Pole poles = 6;
  int poles_size() const;
  void clear_poles();
  static const int kPolesFieldNumber = 6;
  const ::ndm_proto::Pole& poles(int index) const;
  ::ndm_proto::Pole* mutable_poles(int index);
  ::ndm_proto::Pole* add_poles();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Pole >*
      mutable_poles();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Pole >&
      poles() const;

  // repeated .ndm_proto.Board boards = 7;
  int boards_size() const;
  void clear_boards();
  static const int kBoardsFieldNumber = 7;
  const ::ndm_proto::Board& boards(int index) const;
  ::ndm_proto::Board* mutable_boards(int index);
  ::ndm_proto::Board* add_boards();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Board >*
      mutable_boards();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Board >&
      boards() const;

  // repeated .ndm_proto.CrossWalk crosswalks = 8;
  int crosswalks_size() const;
  void clear_crosswalks();
  static const int kCrosswalksFieldNumber = 8;
  const ::ndm_proto::CrossWalk& crosswalks(int index) const;
  ::ndm_proto::CrossWalk* mutable_crosswalks(int index);
  ::ndm_proto::CrossWalk* add_crosswalks();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::CrossWalk >*
      mutable_crosswalks();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::CrossWalk >&
      crosswalks() const;

  // repeated .ndm_proto.Zone zones = 9;
  int zones_size() const;
  void clear_zones();
  static const int kZonesFieldNumber = 9;
  const ::ndm_proto::Zone& zones(int index) const;
  ::ndm_proto::Zone* mutable_zones(int index);
  ::ndm_proto::Zone* add_zones();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Zone >*
      mutable_zones();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Zone >&
      zones() const;

  // repeated .ndm_proto.TrafficSign trafficsigns = 10;
  int trafficsigns_size() const;
  void clear_trafficsigns();
  static const int kTrafficsignsFieldNumber = 10;
  const ::ndm_proto::TrafficSign& trafficsigns(int index) const;
  ::ndm_proto::TrafficSign* mutable_trafficsigns(int index);
  ::ndm_proto::TrafficSign* add_trafficsigns();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::TrafficSign >*
      mutable_trafficsigns();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::TrafficSign >&
      trafficsigns() const;

  // repeated .ndm_proto.ParkingSlot parkingslots = 11;
  int parkingslots_size() const;
  void clear_parkingslots();
  static const int kParkingslotsFieldNumber = 11;
  const ::ndm_proto::ParkingSlot& parkingslots(int index) const;
  ::ndm_proto::ParkingSlot* mutable_parkingslots(int index);
  ::ndm_proto::ParkingSlot* add_parkingslots();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::ParkingSlot >*
      mutable_parkingslots();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::ParkingSlot >&
      parkingslots() const;

  // repeated .ndm_proto.ElevationPlane elevationplanes = 12;
  int elevationplanes_size() const;
  void clear_elevationplanes();
  static const int kElevationplanesFieldNumber = 12;
  const ::ndm_proto::ElevationPlane& elevationplanes(int index) const;
  ::ndm_proto::ElevationPlane* mutable_elevationplanes(int index);
  ::ndm_proto::ElevationPlane* add_elevationplanes();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::ElevationPlane >*
      mutable_elevationplanes();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::ElevationPlane >&
      elevationplanes() const;

  // repeated .ndm_proto.AreaPolygon areapolygons = 13;
  int areapolygons_size() const;
  void clear_areapolygons();
  static const int kAreapolygonsFieldNumber = 13;
  const ::ndm_proto::AreaPolygon& areapolygons(int index) const;
  ::ndm_proto::AreaPolygon* mutable_areapolygons(int index);
  ::ndm_proto::AreaPolygon* add_areapolygons();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::AreaPolygon >*
      mutable_areapolygons();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::AreaPolygon >&
      areapolygons() const;

  // repeated .ndm_proto.GeneralPolygon general_polygons = 15;
  int general_polygons_size() const;
  void clear_general_polygons();
  static const int kGeneralPolygonsFieldNumber = 15;
  const ::ndm_proto::GeneralPolygon& general_polygons(int index) const;
  ::ndm_proto::GeneralPolygon* mutable_general_polygons(int index);
  ::ndm_proto::GeneralPolygon* add_general_polygons();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::GeneralPolygon >*
      mutable_general_polygons();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::GeneralPolygon >&
      general_polygons() const;

  // repeated .ndm_proto.GeneralLine general_lines = 16;
  int general_lines_size() const;
  void clear_general_lines();
  static const int kGeneralLinesFieldNumber = 16;
  const ::ndm_proto::GeneralLine& general_lines(int index) const;
  ::ndm_proto::GeneralLine* mutable_general_lines(int index);
  ::ndm_proto::GeneralLine* add_general_lines();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::GeneralLine >*
      mutable_general_lines();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::GeneralLine >&
      general_lines() const;

  // @@protoc_insertion_point(class_scope:ndm_proto.PhysicalLayer)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::TrafficLight > trafficlights_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::LaneMarking > lanemarkings_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::LaneLine > lanelines_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::StopLine > stoplines_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::SpeedBump > speedbumps_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Pole > poles_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Board > boards_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::CrossWalk > crosswalks_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Zone > zones_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::TrafficSign > trafficsigns_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::ParkingSlot > parkingslots_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::ElevationPlane > elevationplanes_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::AreaPolygon > areapolygons_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::GeneralPolygon > general_polygons_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::GeneralLine > general_lines_;
  friend struct ::protobuf_physical_5flayer_2eproto::TableStruct;
  friend void ::protobuf_physical_5flayer_2eproto::InitDefaultsPhysicalLayerImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TrafficLight

// required string id = 1;
inline bool TrafficLight::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrafficLight::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrafficLight::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrafficLight::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& TrafficLight::id() const {
  // @@protoc_insertion_point(field_get:ndm_proto.TrafficLight.id)
  return id_.GetNoArena();
}
inline void TrafficLight::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ndm_proto.TrafficLight.id)
}
#if LANG_CXX11
inline void TrafficLight::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ndm_proto.TrafficLight.id)
}
#endif
inline void TrafficLight::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ndm_proto.TrafficLight.id)
}
inline void TrafficLight::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.TrafficLight.id)
}
inline ::std::string* TrafficLight::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:ndm_proto.TrafficLight.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TrafficLight::release_id() {
  // @@protoc_insertion_point(field_release:ndm_proto.TrafficLight.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TrafficLight::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.TrafficLight.id)
}

// required .ndm_proto.Polygon border = 2;
inline bool TrafficLight::has_border() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrafficLight::set_has_border() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrafficLight::clear_has_border() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ndm_proto::Polygon& TrafficLight::border() const {
  const ::ndm_proto::Polygon* p = border_;
  // @@protoc_insertion_point(field_get:ndm_proto.TrafficLight.border)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Polygon*>(
      &::ndm_proto::_Polygon_default_instance_);
}
inline ::ndm_proto::Polygon* TrafficLight::release_border() {
  // @@protoc_insertion_point(field_release:ndm_proto.TrafficLight.border)
  clear_has_border();
  ::ndm_proto::Polygon* temp = border_;
  border_ = NULL;
  return temp;
}
inline ::ndm_proto::Polygon* TrafficLight::mutable_border() {
  set_has_border();
  if (border_ == NULL) {
    border_ = new ::ndm_proto::Polygon;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.TrafficLight.border)
  return border_;
}
inline void TrafficLight::set_allocated_border(::ndm_proto::Polygon* border) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(border_);
  }
  if (border) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      border = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, border, submessage_arena);
    }
    set_has_border();
  } else {
    clear_has_border();
  }
  border_ = border;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.TrafficLight.border)
}

// optional .ndm_proto.TrafficLightType type = 3;
inline bool TrafficLight::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TrafficLight::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TrafficLight::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ndm_proto::TrafficLightType& TrafficLight::type() const {
  const ::ndm_proto::TrafficLightType* p = type_;
  // @@protoc_insertion_point(field_get:ndm_proto.TrafficLight.type)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::TrafficLightType*>(
      &::ndm_proto::_TrafficLightType_default_instance_);
}
inline ::ndm_proto::TrafficLightType* TrafficLight::release_type() {
  // @@protoc_insertion_point(field_release:ndm_proto.TrafficLight.type)
  clear_has_type();
  ::ndm_proto::TrafficLightType* temp = type_;
  type_ = NULL;
  return temp;
}
inline ::ndm_proto::TrafficLightType* TrafficLight::mutable_type() {
  set_has_type();
  if (type_ == NULL) {
    type_ = new ::ndm_proto::TrafficLightType;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.TrafficLight.type)
  return type_;
}
inline void TrafficLight::set_allocated_type(::ndm_proto::TrafficLightType* type) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(type_);
  }
  if (type) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      type = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, type, submessage_arena);
    }
    set_has_type();
  } else {
    clear_has_type();
  }
  type_ = type;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.TrafficLight.type)
}

// optional .ndm_proto.TrafficLightState state = 4;
inline bool TrafficLight::has_state() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TrafficLight::set_has_state() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TrafficLight::clear_has_state() {
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::ndm_proto::TrafficLightState& TrafficLight::state() const {
  const ::ndm_proto::TrafficLightState* p = state_;
  // @@protoc_insertion_point(field_get:ndm_proto.TrafficLight.state)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::TrafficLightState*>(
      &::ndm_proto::_TrafficLightState_default_instance_);
}
inline ::ndm_proto::TrafficLightState* TrafficLight::release_state() {
  // @@protoc_insertion_point(field_release:ndm_proto.TrafficLight.state)
  clear_has_state();
  ::ndm_proto::TrafficLightState* temp = state_;
  state_ = NULL;
  return temp;
}
inline ::ndm_proto::TrafficLightState* TrafficLight::mutable_state() {
  set_has_state();
  if (state_ == NULL) {
    state_ = new ::ndm_proto::TrafficLightState;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.TrafficLight.state)
  return state_;
}
inline void TrafficLight::set_allocated_state(::ndm_proto::TrafficLightState* state) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(state_);
  }
  if (state) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      state = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    set_has_state();
  } else {
    clear_has_state();
  }
  state_ = state;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.TrafficLight.state)
}

// optional float exist_conf = 5;
inline bool TrafficLight::has_exist_conf() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TrafficLight::set_has_exist_conf() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TrafficLight::clear_has_exist_conf() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TrafficLight::clear_exist_conf() {
  exist_conf_ = 0;
  clear_has_exist_conf();
}
inline float TrafficLight::exist_conf() const {
  // @@protoc_insertion_point(field_get:ndm_proto.TrafficLight.exist_conf)
  return exist_conf_;
}
inline void TrafficLight::set_exist_conf(float value) {
  set_has_exist_conf();
  exist_conf_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.TrafficLight.exist_conf)
}

// repeated .ndm_proto.TrafficLightBulb bulbs = 10;
inline int TrafficLight::bulbs_size() const {
  return bulbs_.size();
}
inline void TrafficLight::clear_bulbs() {
  bulbs_.Clear();
}
inline const ::ndm_proto::TrafficLightBulb& TrafficLight::bulbs(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.TrafficLight.bulbs)
  return bulbs_.Get(index);
}
inline ::ndm_proto::TrafficLightBulb* TrafficLight::mutable_bulbs(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.TrafficLight.bulbs)
  return bulbs_.Mutable(index);
}
inline ::ndm_proto::TrafficLightBulb* TrafficLight::add_bulbs() {
  // @@protoc_insertion_point(field_add:ndm_proto.TrafficLight.bulbs)
  return bulbs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::TrafficLightBulb >*
TrafficLight::mutable_bulbs() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.TrafficLight.bulbs)
  return &bulbs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::TrafficLightBulb >&
TrafficLight::bulbs() const {
  // @@protoc_insertion_point(field_list:ndm_proto.TrafficLight.bulbs)
  return bulbs_;
}

// -------------------------------------------------------------------

// TrafficLightBulb

// required string id = 1;
inline bool TrafficLightBulb::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrafficLightBulb::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrafficLightBulb::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrafficLightBulb::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& TrafficLightBulb::id() const {
  // @@protoc_insertion_point(field_get:ndm_proto.TrafficLightBulb.id)
  return id_.GetNoArena();
}
inline void TrafficLightBulb::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ndm_proto.TrafficLightBulb.id)
}
#if LANG_CXX11
inline void TrafficLightBulb::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ndm_proto.TrafficLightBulb.id)
}
#endif
inline void TrafficLightBulb::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ndm_proto.TrafficLightBulb.id)
}
inline void TrafficLightBulb::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.TrafficLightBulb.id)
}
inline ::std::string* TrafficLightBulb::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:ndm_proto.TrafficLightBulb.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TrafficLightBulb::release_id() {
  // @@protoc_insertion_point(field_release:ndm_proto.TrafficLightBulb.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TrafficLightBulb::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.TrafficLightBulb.id)
}

// required .ndm_proto.Circle cborder = 2;
inline bool TrafficLightBulb::has_cborder() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrafficLightBulb::set_has_cborder() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrafficLightBulb::clear_has_cborder() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ndm_proto::Circle& TrafficLightBulb::cborder() const {
  const ::ndm_proto::Circle* p = cborder_;
  // @@protoc_insertion_point(field_get:ndm_proto.TrafficLightBulb.cborder)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Circle*>(
      &::ndm_proto::_Circle_default_instance_);
}
inline ::ndm_proto::Circle* TrafficLightBulb::release_cborder() {
  // @@protoc_insertion_point(field_release:ndm_proto.TrafficLightBulb.cborder)
  clear_has_cborder();
  ::ndm_proto::Circle* temp = cborder_;
  cborder_ = NULL;
  return temp;
}
inline ::ndm_proto::Circle* TrafficLightBulb::mutable_cborder() {
  set_has_cborder();
  if (cborder_ == NULL) {
    cborder_ = new ::ndm_proto::Circle;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.TrafficLightBulb.cborder)
  return cborder_;
}
inline void TrafficLightBulb::set_allocated_cborder(::ndm_proto::Circle* cborder) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(cborder_);
  }
  if (cborder) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      cborder = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, cborder, submessage_arena);
    }
    set_has_cborder();
  } else {
    clear_has_cborder();
  }
  cborder_ = cborder;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.TrafficLightBulb.cborder)
}

// optional .ndm_proto.Polygon border = 3;
inline bool TrafficLightBulb::has_border() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TrafficLightBulb::set_has_border() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TrafficLightBulb::clear_has_border() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ndm_proto::Polygon& TrafficLightBulb::border() const {
  const ::ndm_proto::Polygon* p = border_;
  // @@protoc_insertion_point(field_get:ndm_proto.TrafficLightBulb.border)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Polygon*>(
      &::ndm_proto::_Polygon_default_instance_);
}
inline ::ndm_proto::Polygon* TrafficLightBulb::release_border() {
  // @@protoc_insertion_point(field_release:ndm_proto.TrafficLightBulb.border)
  clear_has_border();
  ::ndm_proto::Polygon* temp = border_;
  border_ = NULL;
  return temp;
}
inline ::ndm_proto::Polygon* TrafficLightBulb::mutable_border() {
  set_has_border();
  if (border_ == NULL) {
    border_ = new ::ndm_proto::Polygon;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.TrafficLightBulb.border)
  return border_;
}
inline void TrafficLightBulb::set_allocated_border(::ndm_proto::Polygon* border) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(border_);
  }
  if (border) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      border = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, border, submessage_arena);
    }
    set_has_border();
  } else {
    clear_has_border();
  }
  border_ = border;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.TrafficLightBulb.border)
}

// optional .ndm_proto.TrafficLightBulbShape shape = 4;
inline bool TrafficLightBulb::has_shape() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TrafficLightBulb::set_has_shape() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TrafficLightBulb::clear_has_shape() {
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::ndm_proto::TrafficLightBulbShape& TrafficLightBulb::shape() const {
  const ::ndm_proto::TrafficLightBulbShape* p = shape_;
  // @@protoc_insertion_point(field_get:ndm_proto.TrafficLightBulb.shape)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::TrafficLightBulbShape*>(
      &::ndm_proto::_TrafficLightBulbShape_default_instance_);
}
inline ::ndm_proto::TrafficLightBulbShape* TrafficLightBulb::release_shape() {
  // @@protoc_insertion_point(field_release:ndm_proto.TrafficLightBulb.shape)
  clear_has_shape();
  ::ndm_proto::TrafficLightBulbShape* temp = shape_;
  shape_ = NULL;
  return temp;
}
inline ::ndm_proto::TrafficLightBulbShape* TrafficLightBulb::mutable_shape() {
  set_has_shape();
  if (shape_ == NULL) {
    shape_ = new ::ndm_proto::TrafficLightBulbShape;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.TrafficLightBulb.shape)
  return shape_;
}
inline void TrafficLightBulb::set_allocated_shape(::ndm_proto::TrafficLightBulbShape* shape) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(shape_);
  }
  if (shape) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      shape = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, shape, submessage_arena);
    }
    set_has_shape();
  } else {
    clear_has_shape();
  }
  shape_ = shape;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.TrafficLightBulb.shape)
}

// optional uint64 time_cycle = 5;
inline bool TrafficLightBulb::has_time_cycle() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TrafficLightBulb::set_has_time_cycle() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TrafficLightBulb::clear_has_time_cycle() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TrafficLightBulb::clear_time_cycle() {
  time_cycle_ = GOOGLE_ULONGLONG(0);
  clear_has_time_cycle();
}
inline ::google::protobuf::uint64 TrafficLightBulb::time_cycle() const {
  // @@protoc_insertion_point(field_get:ndm_proto.TrafficLightBulb.time_cycle)
  return time_cycle_;
}
inline void TrafficLightBulb::set_time_cycle(::google::protobuf::uint64 value) {
  set_has_time_cycle();
  time_cycle_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.TrafficLightBulb.time_cycle)
}

// -------------------------------------------------------------------

// LaneMarking

// required string id = 1;
inline bool LaneMarking::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LaneMarking::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LaneMarking::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LaneMarking::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& LaneMarking::id() const {
  // @@protoc_insertion_point(field_get:ndm_proto.LaneMarking.id)
  return id_.GetNoArena();
}
inline void LaneMarking::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ndm_proto.LaneMarking.id)
}
#if LANG_CXX11
inline void LaneMarking::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ndm_proto.LaneMarking.id)
}
#endif
inline void LaneMarking::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ndm_proto.LaneMarking.id)
}
inline void LaneMarking::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.LaneMarking.id)
}
inline ::std::string* LaneMarking::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:ndm_proto.LaneMarking.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LaneMarking::release_id() {
  // @@protoc_insertion_point(field_release:ndm_proto.LaneMarking.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LaneMarking::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.LaneMarking.id)
}

// required .ndm_proto.Polygon border = 2;
inline bool LaneMarking::has_border() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LaneMarking::set_has_border() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LaneMarking::clear_has_border() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ndm_proto::Polygon& LaneMarking::border() const {
  const ::ndm_proto::Polygon* p = border_;
  // @@protoc_insertion_point(field_get:ndm_proto.LaneMarking.border)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Polygon*>(
      &::ndm_proto::_Polygon_default_instance_);
}
inline ::ndm_proto::Polygon* LaneMarking::release_border() {
  // @@protoc_insertion_point(field_release:ndm_proto.LaneMarking.border)
  clear_has_border();
  ::ndm_proto::Polygon* temp = border_;
  border_ = NULL;
  return temp;
}
inline ::ndm_proto::Polygon* LaneMarking::mutable_border() {
  set_has_border();
  if (border_ == NULL) {
    border_ = new ::ndm_proto::Polygon;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.LaneMarking.border)
  return border_;
}
inline void LaneMarking::set_allocated_border(::ndm_proto::Polygon* border) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(border_);
  }
  if (border) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      border = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, border, submessage_arena);
    }
    set_has_border();
  } else {
    clear_has_border();
  }
  border_ = border;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.LaneMarking.border)
}

// optional .ndm_proto.LaneMarkingType type = 3;
inline bool LaneMarking::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LaneMarking::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LaneMarking::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ndm_proto::LaneMarkingType& LaneMarking::type() const {
  const ::ndm_proto::LaneMarkingType* p = type_;
  // @@protoc_insertion_point(field_get:ndm_proto.LaneMarking.type)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::LaneMarkingType*>(
      &::ndm_proto::_LaneMarkingType_default_instance_);
}
inline ::ndm_proto::LaneMarkingType* LaneMarking::release_type() {
  // @@protoc_insertion_point(field_release:ndm_proto.LaneMarking.type)
  clear_has_type();
  ::ndm_proto::LaneMarkingType* temp = type_;
  type_ = NULL;
  return temp;
}
inline ::ndm_proto::LaneMarkingType* LaneMarking::mutable_type() {
  set_has_type();
  if (type_ == NULL) {
    type_ = new ::ndm_proto::LaneMarkingType;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.LaneMarking.type)
  return type_;
}
inline void LaneMarking::set_allocated_type(::ndm_proto::LaneMarkingType* type) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(type_);
  }
  if (type) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      type = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, type, submessage_arena);
    }
    set_has_type();
  } else {
    clear_has_type();
  }
  type_ = type;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.LaneMarking.type)
}

// optional .ndm_proto.Number number = 4;
inline bool LaneMarking::has_number() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LaneMarking::set_has_number() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LaneMarking::clear_has_number() {
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::ndm_proto::Number& LaneMarking::number() const {
  const ::ndm_proto::Number* p = number_;
  // @@protoc_insertion_point(field_get:ndm_proto.LaneMarking.number)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Number*>(
      &::ndm_proto::_Number_default_instance_);
}
inline ::ndm_proto::Number* LaneMarking::release_number() {
  // @@protoc_insertion_point(field_release:ndm_proto.LaneMarking.number)
  clear_has_number();
  ::ndm_proto::Number* temp = number_;
  number_ = NULL;
  return temp;
}
inline ::ndm_proto::Number* LaneMarking::mutable_number() {
  set_has_number();
  if (number_ == NULL) {
    number_ = new ::ndm_proto::Number;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.LaneMarking.number)
  return number_;
}
inline void LaneMarking::set_allocated_number(::ndm_proto::Number* number) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(number_);
  }
  if (number) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      number = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, number, submessage_arena);
    }
    set_has_number();
  } else {
    clear_has_number();
  }
  number_ = number;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.LaneMarking.number)
}

// optional float exist_conf = 5;
inline bool LaneMarking::has_exist_conf() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LaneMarking::set_has_exist_conf() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LaneMarking::clear_has_exist_conf() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LaneMarking::clear_exist_conf() {
  exist_conf_ = 0;
  clear_has_exist_conf();
}
inline float LaneMarking::exist_conf() const {
  // @@protoc_insertion_point(field_get:ndm_proto.LaneMarking.exist_conf)
  return exist_conf_;
}
inline void LaneMarking::set_exist_conf(float value) {
  set_has_exist_conf();
  exist_conf_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.LaneMarking.exist_conf)
}

// optional .ndm_proto.String str = 6;
inline bool LaneMarking::has_str() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LaneMarking::set_has_str() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LaneMarking::clear_has_str() {
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::ndm_proto::String& LaneMarking::str() const {
  const ::ndm_proto::String* p = str_;
  // @@protoc_insertion_point(field_get:ndm_proto.LaneMarking.str)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::String*>(
      &::ndm_proto::_String_default_instance_);
}
inline ::ndm_proto::String* LaneMarking::release_str() {
  // @@protoc_insertion_point(field_release:ndm_proto.LaneMarking.str)
  clear_has_str();
  ::ndm_proto::String* temp = str_;
  str_ = NULL;
  return temp;
}
inline ::ndm_proto::String* LaneMarking::mutable_str() {
  set_has_str();
  if (str_ == NULL) {
    str_ = new ::ndm_proto::String;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.LaneMarking.str)
  return str_;
}
inline void LaneMarking::set_allocated_str(::ndm_proto::String* str) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(str_);
  }
  if (str) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      str = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, str, submessage_arena);
    }
    set_has_str();
  } else {
    clear_has_str();
  }
  str_ = str;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.LaneMarking.str)
}

// -------------------------------------------------------------------

// LaneLine

// required string id = 1;
inline bool LaneLine::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LaneLine::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LaneLine::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LaneLine::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& LaneLine::id() const {
  // @@protoc_insertion_point(field_get:ndm_proto.LaneLine.id)
  return id_.GetNoArena();
}
inline void LaneLine::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ndm_proto.LaneLine.id)
}
#if LANG_CXX11
inline void LaneLine::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ndm_proto.LaneLine.id)
}
#endif
inline void LaneLine::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ndm_proto.LaneLine.id)
}
inline void LaneLine::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.LaneLine.id)
}
inline ::std::string* LaneLine::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:ndm_proto.LaneLine.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LaneLine::release_id() {
  // @@protoc_insertion_point(field_release:ndm_proto.LaneLine.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LaneLine::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.LaneLine.id)
}

// repeated .ndm_proto.CurveLine lines = 2;
inline int LaneLine::lines_size() const {
  return lines_.size();
}
inline const ::ndm_proto::CurveLine& LaneLine::lines(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.LaneLine.lines)
  return lines_.Get(index);
}
inline ::ndm_proto::CurveLine* LaneLine::mutable_lines(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.LaneLine.lines)
  return lines_.Mutable(index);
}
inline ::ndm_proto::CurveLine* LaneLine::add_lines() {
  // @@protoc_insertion_point(field_add:ndm_proto.LaneLine.lines)
  return lines_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::CurveLine >*
LaneLine::mutable_lines() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.LaneLine.lines)
  return &lines_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::CurveLine >&
LaneLine::lines() const {
  // @@protoc_insertion_point(field_list:ndm_proto.LaneLine.lines)
  return lines_;
}

// optional .ndm_proto.LaneLineType type = 3;
inline bool LaneLine::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LaneLine::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LaneLine::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ndm_proto::LaneLineType& LaneLine::type() const {
  const ::ndm_proto::LaneLineType* p = type_;
  // @@protoc_insertion_point(field_get:ndm_proto.LaneLine.type)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::LaneLineType*>(
      &::ndm_proto::_LaneLineType_default_instance_);
}
inline ::ndm_proto::LaneLineType* LaneLine::release_type() {
  // @@protoc_insertion_point(field_release:ndm_proto.LaneLine.type)
  clear_has_type();
  ::ndm_proto::LaneLineType* temp = type_;
  type_ = NULL;
  return temp;
}
inline ::ndm_proto::LaneLineType* LaneLine::mutable_type() {
  set_has_type();
  if (type_ == NULL) {
    type_ = new ::ndm_proto::LaneLineType;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.LaneLine.type)
  return type_;
}
inline void LaneLine::set_allocated_type(::ndm_proto::LaneLineType* type) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(type_);
  }
  if (type) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      type = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, type, submessage_arena);
    }
    set_has_type();
  } else {
    clear_has_type();
  }
  type_ = type;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.LaneLine.type)
}

// optional .ndm_proto.LaneLineColor color = 4;
inline bool LaneLine::has_color() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LaneLine::set_has_color() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LaneLine::clear_has_color() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ndm_proto::LaneLineColor& LaneLine::color() const {
  const ::ndm_proto::LaneLineColor* p = color_;
  // @@protoc_insertion_point(field_get:ndm_proto.LaneLine.color)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::LaneLineColor*>(
      &::ndm_proto::_LaneLineColor_default_instance_);
}
inline ::ndm_proto::LaneLineColor* LaneLine::release_color() {
  // @@protoc_insertion_point(field_release:ndm_proto.LaneLine.color)
  clear_has_color();
  ::ndm_proto::LaneLineColor* temp = color_;
  color_ = NULL;
  return temp;
}
inline ::ndm_proto::LaneLineColor* LaneLine::mutable_color() {
  set_has_color();
  if (color_ == NULL) {
    color_ = new ::ndm_proto::LaneLineColor;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.LaneLine.color)
  return color_;
}
inline void LaneLine::set_allocated_color(::ndm_proto::LaneLineColor* color) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(color_);
  }
  if (color) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      color = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    set_has_color();
  } else {
    clear_has_color();
  }
  color_ = color;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.LaneLine.color)
}

// optional bool virtual = 5 [default = false];
inline bool LaneLine::has_virtual_() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LaneLine::set_has_virtual_() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LaneLine::clear_has_virtual_() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LaneLine::clear_virtual_() {
  virtual__ = false;
  clear_has_virtual_();
}
inline bool LaneLine::virtual_() const {
  // @@protoc_insertion_point(field_get:ndm_proto.LaneLine.virtual)
  return virtual__;
}
inline void LaneLine::set_virtual_(bool value) {
  set_has_virtual_();
  virtual__ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.LaneLine.virtual)
}

// optional float exist_conf = 6;
inline bool LaneLine::has_exist_conf() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LaneLine::set_has_exist_conf() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LaneLine::clear_has_exist_conf() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LaneLine::clear_exist_conf() {
  exist_conf_ = 0;
  clear_has_exist_conf();
}
inline float LaneLine::exist_conf() const {
  // @@protoc_insertion_point(field_get:ndm_proto.LaneLine.exist_conf)
  return exist_conf_;
}
inline void LaneLine::set_exist_conf(float value) {
  set_has_exist_conf();
  exist_conf_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.LaneLine.exist_conf)
}

// optional .ndm_proto.LaneLineConfidence confidence = 7;
inline bool LaneLine::has_confidence() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LaneLine::set_has_confidence() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LaneLine::clear_has_confidence() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LaneLine::clear_confidence() {
  confidence_ = 0;
  clear_has_confidence();
}
inline ::ndm_proto::LaneLineConfidence LaneLine::confidence() const {
  // @@protoc_insertion_point(field_get:ndm_proto.LaneLine.confidence)
  return static_cast< ::ndm_proto::LaneLineConfidence >(confidence_);
}
inline void LaneLine::set_confidence(::ndm_proto::LaneLineConfidence value) {
  assert(::ndm_proto::LaneLineConfidence_IsValid(value));
  set_has_confidence();
  confidence_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.LaneLine.confidence)
}

// optional .ndm_proto.LineMarking marking = 8;
inline bool LaneLine::has_marking() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LaneLine::set_has_marking() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LaneLine::clear_has_marking() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LaneLine::clear_marking() {
  marking_ = 0;
  clear_has_marking();
}
inline ::ndm_proto::LineMarking LaneLine::marking() const {
  // @@protoc_insertion_point(field_get:ndm_proto.LaneLine.marking)
  return static_cast< ::ndm_proto::LineMarking >(marking_);
}
inline void LaneLine::set_marking(::ndm_proto::LineMarking value) {
  assert(::ndm_proto::LineMarking_IsValid(value));
  set_has_marking();
  marking_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.LaneLine.marking)
}

// optional bool ldm = 9;
inline bool LaneLine::has_ldm() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LaneLine::set_has_ldm() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LaneLine::clear_has_ldm() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LaneLine::clear_ldm() {
  ldm_ = false;
  clear_has_ldm();
}
inline bool LaneLine::ldm() const {
  // @@protoc_insertion_point(field_get:ndm_proto.LaneLine.ldm)
  return ldm_;
}
inline void LaneLine::set_ldm(bool value) {
  set_has_ldm();
  ldm_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.LaneLine.ldm)
}

// -------------------------------------------------------------------

// StopLine

// required string id = 1;
inline bool StopLine::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StopLine::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StopLine::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StopLine::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& StopLine::id() const {
  // @@protoc_insertion_point(field_get:ndm_proto.StopLine.id)
  return id_.GetNoArena();
}
inline void StopLine::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ndm_proto.StopLine.id)
}
#if LANG_CXX11
inline void StopLine::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ndm_proto.StopLine.id)
}
#endif
inline void StopLine::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ndm_proto.StopLine.id)
}
inline void StopLine::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.StopLine.id)
}
inline ::std::string* StopLine::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:ndm_proto.StopLine.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StopLine::release_id() {
  // @@protoc_insertion_point(field_release:ndm_proto.StopLine.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StopLine::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.StopLine.id)
}

// required .ndm_proto.Polygon border = 2;
inline bool StopLine::has_border() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StopLine::set_has_border() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StopLine::clear_has_border() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ndm_proto::Polygon& StopLine::border() const {
  const ::ndm_proto::Polygon* p = border_;
  // @@protoc_insertion_point(field_get:ndm_proto.StopLine.border)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Polygon*>(
      &::ndm_proto::_Polygon_default_instance_);
}
inline ::ndm_proto::Polygon* StopLine::release_border() {
  // @@protoc_insertion_point(field_release:ndm_proto.StopLine.border)
  clear_has_border();
  ::ndm_proto::Polygon* temp = border_;
  border_ = NULL;
  return temp;
}
inline ::ndm_proto::Polygon* StopLine::mutable_border() {
  set_has_border();
  if (border_ == NULL) {
    border_ = new ::ndm_proto::Polygon;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.StopLine.border)
  return border_;
}
inline void StopLine::set_allocated_border(::ndm_proto::Polygon* border) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(border_);
  }
  if (border) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      border = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, border, submessage_arena);
    }
    set_has_border();
  } else {
    clear_has_border();
  }
  border_ = border;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.StopLine.border)
}

// optional float exist_conf = 3;
inline bool StopLine::has_exist_conf() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StopLine::set_has_exist_conf() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StopLine::clear_has_exist_conf() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StopLine::clear_exist_conf() {
  exist_conf_ = 0;
  clear_has_exist_conf();
}
inline float StopLine::exist_conf() const {
  // @@protoc_insertion_point(field_get:ndm_proto.StopLine.exist_conf)
  return exist_conf_;
}
inline void StopLine::set_exist_conf(float value) {
  set_has_exist_conf();
  exist_conf_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.StopLine.exist_conf)
}

// -------------------------------------------------------------------

// SpeedBump

// required string id = 1;
inline bool SpeedBump::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SpeedBump::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SpeedBump::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SpeedBump::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& SpeedBump::id() const {
  // @@protoc_insertion_point(field_get:ndm_proto.SpeedBump.id)
  return id_.GetNoArena();
}
inline void SpeedBump::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ndm_proto.SpeedBump.id)
}
#if LANG_CXX11
inline void SpeedBump::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ndm_proto.SpeedBump.id)
}
#endif
inline void SpeedBump::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ndm_proto.SpeedBump.id)
}
inline void SpeedBump::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.SpeedBump.id)
}
inline ::std::string* SpeedBump::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:ndm_proto.SpeedBump.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SpeedBump::release_id() {
  // @@protoc_insertion_point(field_release:ndm_proto.SpeedBump.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SpeedBump::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.SpeedBump.id)
}

// required .ndm_proto.Polygon border = 2;
inline bool SpeedBump::has_border() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SpeedBump::set_has_border() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SpeedBump::clear_has_border() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ndm_proto::Polygon& SpeedBump::border() const {
  const ::ndm_proto::Polygon* p = border_;
  // @@protoc_insertion_point(field_get:ndm_proto.SpeedBump.border)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Polygon*>(
      &::ndm_proto::_Polygon_default_instance_);
}
inline ::ndm_proto::Polygon* SpeedBump::release_border() {
  // @@protoc_insertion_point(field_release:ndm_proto.SpeedBump.border)
  clear_has_border();
  ::ndm_proto::Polygon* temp = border_;
  border_ = NULL;
  return temp;
}
inline ::ndm_proto::Polygon* SpeedBump::mutable_border() {
  set_has_border();
  if (border_ == NULL) {
    border_ = new ::ndm_proto::Polygon;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.SpeedBump.border)
  return border_;
}
inline void SpeedBump::set_allocated_border(::ndm_proto::Polygon* border) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(border_);
  }
  if (border) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      border = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, border, submessage_arena);
    }
    set_has_border();
  } else {
    clear_has_border();
  }
  border_ = border;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.SpeedBump.border)
}

// optional .ndm_proto.Number height = 3;
inline bool SpeedBump::has_height() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SpeedBump::set_has_height() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SpeedBump::clear_has_height() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ndm_proto::Number& SpeedBump::height() const {
  const ::ndm_proto::Number* p = height_;
  // @@protoc_insertion_point(field_get:ndm_proto.SpeedBump.height)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Number*>(
      &::ndm_proto::_Number_default_instance_);
}
inline ::ndm_proto::Number* SpeedBump::release_height() {
  // @@protoc_insertion_point(field_release:ndm_proto.SpeedBump.height)
  clear_has_height();
  ::ndm_proto::Number* temp = height_;
  height_ = NULL;
  return temp;
}
inline ::ndm_proto::Number* SpeedBump::mutable_height() {
  set_has_height();
  if (height_ == NULL) {
    height_ = new ::ndm_proto::Number;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.SpeedBump.height)
  return height_;
}
inline void SpeedBump::set_allocated_height(::ndm_proto::Number* height) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(height_);
  }
  if (height) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      height = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, height, submessage_arena);
    }
    set_has_height();
  } else {
    clear_has_height();
  }
  height_ = height;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.SpeedBump.height)
}

// optional .ndm_proto.Number speedlimit = 4;
inline bool SpeedBump::has_speedlimit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SpeedBump::set_has_speedlimit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SpeedBump::clear_has_speedlimit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::ndm_proto::Number& SpeedBump::speedlimit() const {
  const ::ndm_proto::Number* p = speedlimit_;
  // @@protoc_insertion_point(field_get:ndm_proto.SpeedBump.speedlimit)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Number*>(
      &::ndm_proto::_Number_default_instance_);
}
inline ::ndm_proto::Number* SpeedBump::release_speedlimit() {
  // @@protoc_insertion_point(field_release:ndm_proto.SpeedBump.speedlimit)
  clear_has_speedlimit();
  ::ndm_proto::Number* temp = speedlimit_;
  speedlimit_ = NULL;
  return temp;
}
inline ::ndm_proto::Number* SpeedBump::mutable_speedlimit() {
  set_has_speedlimit();
  if (speedlimit_ == NULL) {
    speedlimit_ = new ::ndm_proto::Number;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.SpeedBump.speedlimit)
  return speedlimit_;
}
inline void SpeedBump::set_allocated_speedlimit(::ndm_proto::Number* speedlimit) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(speedlimit_);
  }
  if (speedlimit) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      speedlimit = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, speedlimit, submessage_arena);
    }
    set_has_speedlimit();
  } else {
    clear_has_speedlimit();
  }
  speedlimit_ = speedlimit;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.SpeedBump.speedlimit)
}

// optional float exist_conf = 5;
inline bool SpeedBump::has_exist_conf() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SpeedBump::set_has_exist_conf() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SpeedBump::clear_has_exist_conf() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SpeedBump::clear_exist_conf() {
  exist_conf_ = 0;
  clear_has_exist_conf();
}
inline float SpeedBump::exist_conf() const {
  // @@protoc_insertion_point(field_get:ndm_proto.SpeedBump.exist_conf)
  return exist_conf_;
}
inline void SpeedBump::set_exist_conf(float value) {
  set_has_exist_conf();
  exist_conf_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.SpeedBump.exist_conf)
}

// -------------------------------------------------------------------

// Pole

// required string id = 1;
inline bool Pole::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Pole::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Pole::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Pole::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& Pole::id() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Pole.id)
  return id_.GetNoArena();
}
inline void Pole::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ndm_proto.Pole.id)
}
#if LANG_CXX11
inline void Pole::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ndm_proto.Pole.id)
}
#endif
inline void Pole::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ndm_proto.Pole.id)
}
inline void Pole::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.Pole.id)
}
inline ::std::string* Pole::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:ndm_proto.Pole.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Pole::release_id() {
  // @@protoc_insertion_point(field_release:ndm_proto.Pole.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Pole::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.Pole.id)
}

// required .ndm_proto.Cylinder body = 2;
inline bool Pole::has_body() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Pole::set_has_body() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Pole::clear_has_body() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ndm_proto::Cylinder& Pole::body() const {
  const ::ndm_proto::Cylinder* p = body_;
  // @@protoc_insertion_point(field_get:ndm_proto.Pole.body)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Cylinder*>(
      &::ndm_proto::_Cylinder_default_instance_);
}
inline ::ndm_proto::Cylinder* Pole::release_body() {
  // @@protoc_insertion_point(field_release:ndm_proto.Pole.body)
  clear_has_body();
  ::ndm_proto::Cylinder* temp = body_;
  body_ = NULL;
  return temp;
}
inline ::ndm_proto::Cylinder* Pole::mutable_body() {
  set_has_body();
  if (body_ == NULL) {
    body_ = new ::ndm_proto::Cylinder;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.Pole.body)
  return body_;
}
inline void Pole::set_allocated_body(::ndm_proto::Cylinder* body) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(body_);
  }
  if (body) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      body = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, body, submessage_arena);
    }
    set_has_body();
  } else {
    clear_has_body();
  }
  body_ = body;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.Pole.body)
}

// optional float exist_conf = 3;
inline bool Pole::has_exist_conf() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Pole::set_has_exist_conf() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Pole::clear_has_exist_conf() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Pole::clear_exist_conf() {
  exist_conf_ = 0;
  clear_has_exist_conf();
}
inline float Pole::exist_conf() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Pole.exist_conf)
  return exist_conf_;
}
inline void Pole::set_exist_conf(float value) {
  set_has_exist_conf();
  exist_conf_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.Pole.exist_conf)
}

// optional .ndm_proto.PoleType type = 4;
inline bool Pole::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Pole::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Pole::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ndm_proto::PoleType& Pole::type() const {
  const ::ndm_proto::PoleType* p = type_;
  // @@protoc_insertion_point(field_get:ndm_proto.Pole.type)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::PoleType*>(
      &::ndm_proto::_PoleType_default_instance_);
}
inline ::ndm_proto::PoleType* Pole::release_type() {
  // @@protoc_insertion_point(field_release:ndm_proto.Pole.type)
  clear_has_type();
  ::ndm_proto::PoleType* temp = type_;
  type_ = NULL;
  return temp;
}
inline ::ndm_proto::PoleType* Pole::mutable_type() {
  set_has_type();
  if (type_ == NULL) {
    type_ = new ::ndm_proto::PoleType;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.Pole.type)
  return type_;
}
inline void Pole::set_allocated_type(::ndm_proto::PoleType* type) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(type_);
  }
  if (type) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      type = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, type, submessage_arena);
    }
    set_has_type();
  } else {
    clear_has_type();
  }
  type_ = type;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.Pole.type)
}

// -------------------------------------------------------------------

// Board

// required string id = 1;
inline bool Board::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Board::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Board::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Board::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& Board::id() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Board.id)
  return id_.GetNoArena();
}
inline void Board::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ndm_proto.Board.id)
}
#if LANG_CXX11
inline void Board::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ndm_proto.Board.id)
}
#endif
inline void Board::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ndm_proto.Board.id)
}
inline void Board::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.Board.id)
}
inline ::std::string* Board::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:ndm_proto.Board.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Board::release_id() {
  // @@protoc_insertion_point(field_release:ndm_proto.Board.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Board::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.Board.id)
}

// required .ndm_proto.Polygon border = 2;
inline bool Board::has_border() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Board::set_has_border() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Board::clear_has_border() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ndm_proto::Polygon& Board::border() const {
  const ::ndm_proto::Polygon* p = border_;
  // @@protoc_insertion_point(field_get:ndm_proto.Board.border)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Polygon*>(
      &::ndm_proto::_Polygon_default_instance_);
}
inline ::ndm_proto::Polygon* Board::release_border() {
  // @@protoc_insertion_point(field_release:ndm_proto.Board.border)
  clear_has_border();
  ::ndm_proto::Polygon* temp = border_;
  border_ = NULL;
  return temp;
}
inline ::ndm_proto::Polygon* Board::mutable_border() {
  set_has_border();
  if (border_ == NULL) {
    border_ = new ::ndm_proto::Polygon;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.Board.border)
  return border_;
}
inline void Board::set_allocated_border(::ndm_proto::Polygon* border) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(border_);
  }
  if (border) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      border = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, border, submessage_arena);
    }
    set_has_border();
  } else {
    clear_has_border();
  }
  border_ = border;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.Board.border)
}

// optional .ndm_proto.String str = 3;
inline bool Board::has_str() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Board::set_has_str() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Board::clear_has_str() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ndm_proto::String& Board::str() const {
  const ::ndm_proto::String* p = str_;
  // @@protoc_insertion_point(field_get:ndm_proto.Board.str)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::String*>(
      &::ndm_proto::_String_default_instance_);
}
inline ::ndm_proto::String* Board::release_str() {
  // @@protoc_insertion_point(field_release:ndm_proto.Board.str)
  clear_has_str();
  ::ndm_proto::String* temp = str_;
  str_ = NULL;
  return temp;
}
inline ::ndm_proto::String* Board::mutable_str() {
  set_has_str();
  if (str_ == NULL) {
    str_ = new ::ndm_proto::String;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.Board.str)
  return str_;
}
inline void Board::set_allocated_str(::ndm_proto::String* str) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(str_);
  }
  if (str) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      str = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, str, submessage_arena);
    }
    set_has_str();
  } else {
    clear_has_str();
  }
  str_ = str;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.Board.str)
}

// optional float exist_conf = 4;
inline bool Board::has_exist_conf() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Board::set_has_exist_conf() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Board::clear_has_exist_conf() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Board::clear_exist_conf() {
  exist_conf_ = 0;
  clear_has_exist_conf();
}
inline float Board::exist_conf() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Board.exist_conf)
  return exist_conf_;
}
inline void Board::set_exist_conf(float value) {
  set_has_exist_conf();
  exist_conf_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.Board.exist_conf)
}

// -------------------------------------------------------------------

// CrossWalk

// required string id = 1;
inline bool CrossWalk::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CrossWalk::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CrossWalk::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CrossWalk::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& CrossWalk::id() const {
  // @@protoc_insertion_point(field_get:ndm_proto.CrossWalk.id)
  return id_.GetNoArena();
}
inline void CrossWalk::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ndm_proto.CrossWalk.id)
}
#if LANG_CXX11
inline void CrossWalk::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ndm_proto.CrossWalk.id)
}
#endif
inline void CrossWalk::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ndm_proto.CrossWalk.id)
}
inline void CrossWalk::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.CrossWalk.id)
}
inline ::std::string* CrossWalk::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:ndm_proto.CrossWalk.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CrossWalk::release_id() {
  // @@protoc_insertion_point(field_release:ndm_proto.CrossWalk.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CrossWalk::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.CrossWalk.id)
}

// required .ndm_proto.Polygon border = 2;
inline bool CrossWalk::has_border() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CrossWalk::set_has_border() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CrossWalk::clear_has_border() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ndm_proto::Polygon& CrossWalk::border() const {
  const ::ndm_proto::Polygon* p = border_;
  // @@protoc_insertion_point(field_get:ndm_proto.CrossWalk.border)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Polygon*>(
      &::ndm_proto::_Polygon_default_instance_);
}
inline ::ndm_proto::Polygon* CrossWalk::release_border() {
  // @@protoc_insertion_point(field_release:ndm_proto.CrossWalk.border)
  clear_has_border();
  ::ndm_proto::Polygon* temp = border_;
  border_ = NULL;
  return temp;
}
inline ::ndm_proto::Polygon* CrossWalk::mutable_border() {
  set_has_border();
  if (border_ == NULL) {
    border_ = new ::ndm_proto::Polygon;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.CrossWalk.border)
  return border_;
}
inline void CrossWalk::set_allocated_border(::ndm_proto::Polygon* border) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(border_);
  }
  if (border) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      border = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, border, submessage_arena);
    }
    set_has_border();
  } else {
    clear_has_border();
  }
  border_ = border;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.CrossWalk.border)
}

// repeated .ndm_proto.Polygon child_borders = 3;
inline int CrossWalk::child_borders_size() const {
  return child_borders_.size();
}
inline const ::ndm_proto::Polygon& CrossWalk::child_borders(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.CrossWalk.child_borders)
  return child_borders_.Get(index);
}
inline ::ndm_proto::Polygon* CrossWalk::mutable_child_borders(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.CrossWalk.child_borders)
  return child_borders_.Mutable(index);
}
inline ::ndm_proto::Polygon* CrossWalk::add_child_borders() {
  // @@protoc_insertion_point(field_add:ndm_proto.CrossWalk.child_borders)
  return child_borders_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::Polygon >*
CrossWalk::mutable_child_borders() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.CrossWalk.child_borders)
  return &child_borders_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Polygon >&
CrossWalk::child_borders() const {
  // @@protoc_insertion_point(field_list:ndm_proto.CrossWalk.child_borders)
  return child_borders_;
}

// optional float exist_conf = 4;
inline bool CrossWalk::has_exist_conf() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CrossWalk::set_has_exist_conf() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CrossWalk::clear_has_exist_conf() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CrossWalk::clear_exist_conf() {
  exist_conf_ = 0;
  clear_has_exist_conf();
}
inline float CrossWalk::exist_conf() const {
  // @@protoc_insertion_point(field_get:ndm_proto.CrossWalk.exist_conf)
  return exist_conf_;
}
inline void CrossWalk::set_exist_conf(float value) {
  set_has_exist_conf();
  exist_conf_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.CrossWalk.exist_conf)
}

// -------------------------------------------------------------------

// Zone

// required string id = 1;
inline bool Zone::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Zone::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Zone::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Zone::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& Zone::id() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Zone.id)
  return id_.GetNoArena();
}
inline void Zone::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ndm_proto.Zone.id)
}
#if LANG_CXX11
inline void Zone::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ndm_proto.Zone.id)
}
#endif
inline void Zone::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ndm_proto.Zone.id)
}
inline void Zone::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.Zone.id)
}
inline ::std::string* Zone::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:ndm_proto.Zone.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Zone::release_id() {
  // @@protoc_insertion_point(field_release:ndm_proto.Zone.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Zone::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.Zone.id)
}

// required .ndm_proto.Polygon border = 2;
inline bool Zone::has_border() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Zone::set_has_border() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Zone::clear_has_border() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ndm_proto::Polygon& Zone::border() const {
  const ::ndm_proto::Polygon* p = border_;
  // @@protoc_insertion_point(field_get:ndm_proto.Zone.border)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Polygon*>(
      &::ndm_proto::_Polygon_default_instance_);
}
inline ::ndm_proto::Polygon* Zone::release_border() {
  // @@protoc_insertion_point(field_release:ndm_proto.Zone.border)
  clear_has_border();
  ::ndm_proto::Polygon* temp = border_;
  border_ = NULL;
  return temp;
}
inline ::ndm_proto::Polygon* Zone::mutable_border() {
  set_has_border();
  if (border_ == NULL) {
    border_ = new ::ndm_proto::Polygon;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.Zone.border)
  return border_;
}
inline void Zone::set_allocated_border(::ndm_proto::Polygon* border) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(border_);
  }
  if (border) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      border = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, border, submessage_arena);
    }
    set_has_border();
  } else {
    clear_has_border();
  }
  border_ = border;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.Zone.border)
}

// optional .ndm_proto.String str = 3;
inline bool Zone::has_str() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Zone::set_has_str() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Zone::clear_has_str() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ndm_proto::String& Zone::str() const {
  const ::ndm_proto::String* p = str_;
  // @@protoc_insertion_point(field_get:ndm_proto.Zone.str)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::String*>(
      &::ndm_proto::_String_default_instance_);
}
inline ::ndm_proto::String* Zone::release_str() {
  // @@protoc_insertion_point(field_release:ndm_proto.Zone.str)
  clear_has_str();
  ::ndm_proto::String* temp = str_;
  str_ = NULL;
  return temp;
}
inline ::ndm_proto::String* Zone::mutable_str() {
  set_has_str();
  if (str_ == NULL) {
    str_ = new ::ndm_proto::String;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.Zone.str)
  return str_;
}
inline void Zone::set_allocated_str(::ndm_proto::String* str) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(str_);
  }
  if (str) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      str = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, str, submessage_arena);
    }
    set_has_str();
  } else {
    clear_has_str();
  }
  str_ = str;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.Zone.str)
}

// optional float exist_conf = 4;
inline bool Zone::has_exist_conf() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Zone::set_has_exist_conf() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Zone::clear_has_exist_conf() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Zone::clear_exist_conf() {
  exist_conf_ = 0;
  clear_has_exist_conf();
}
inline float Zone::exist_conf() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Zone.exist_conf)
  return exist_conf_;
}
inline void Zone::set_exist_conf(float value) {
  set_has_exist_conf();
  exist_conf_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.Zone.exist_conf)
}

// optional .ndm_proto.ZoneType type = 5;
inline bool Zone::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Zone::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Zone::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::ndm_proto::ZoneType& Zone::type() const {
  const ::ndm_proto::ZoneType* p = type_;
  // @@protoc_insertion_point(field_get:ndm_proto.Zone.type)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::ZoneType*>(
      &::ndm_proto::_ZoneType_default_instance_);
}
inline ::ndm_proto::ZoneType* Zone::release_type() {
  // @@protoc_insertion_point(field_release:ndm_proto.Zone.type)
  clear_has_type();
  ::ndm_proto::ZoneType* temp = type_;
  type_ = NULL;
  return temp;
}
inline ::ndm_proto::ZoneType* Zone::mutable_type() {
  set_has_type();
  if (type_ == NULL) {
    type_ = new ::ndm_proto::ZoneType;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.Zone.type)
  return type_;
}
inline void Zone::set_allocated_type(::ndm_proto::ZoneType* type) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(type_);
  }
  if (type) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      type = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, type, submessage_arena);
    }
    set_has_type();
  } else {
    clear_has_type();
  }
  type_ = type;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.Zone.type)
}

// -------------------------------------------------------------------

// TrafficSign

// required string id = 1;
inline bool TrafficSign::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrafficSign::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrafficSign::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrafficSign::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& TrafficSign::id() const {
  // @@protoc_insertion_point(field_get:ndm_proto.TrafficSign.id)
  return id_.GetNoArena();
}
inline void TrafficSign::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ndm_proto.TrafficSign.id)
}
#if LANG_CXX11
inline void TrafficSign::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ndm_proto.TrafficSign.id)
}
#endif
inline void TrafficSign::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ndm_proto.TrafficSign.id)
}
inline void TrafficSign::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.TrafficSign.id)
}
inline ::std::string* TrafficSign::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:ndm_proto.TrafficSign.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TrafficSign::release_id() {
  // @@protoc_insertion_point(field_release:ndm_proto.TrafficSign.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TrafficSign::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.TrafficSign.id)
}

// required .ndm_proto.Polygon border = 2;
inline bool TrafficSign::has_border() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrafficSign::set_has_border() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrafficSign::clear_has_border() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ndm_proto::Polygon& TrafficSign::border() const {
  const ::ndm_proto::Polygon* p = border_;
  // @@protoc_insertion_point(field_get:ndm_proto.TrafficSign.border)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Polygon*>(
      &::ndm_proto::_Polygon_default_instance_);
}
inline ::ndm_proto::Polygon* TrafficSign::release_border() {
  // @@protoc_insertion_point(field_release:ndm_proto.TrafficSign.border)
  clear_has_border();
  ::ndm_proto::Polygon* temp = border_;
  border_ = NULL;
  return temp;
}
inline ::ndm_proto::Polygon* TrafficSign::mutable_border() {
  set_has_border();
  if (border_ == NULL) {
    border_ = new ::ndm_proto::Polygon;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.TrafficSign.border)
  return border_;
}
inline void TrafficSign::set_allocated_border(::ndm_proto::Polygon* border) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(border_);
  }
  if (border) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      border = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, border, submessage_arena);
    }
    set_has_border();
  } else {
    clear_has_border();
  }
  border_ = border;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.TrafficSign.border)
}

// optional .ndm_proto.Circle cborder = 3;
inline bool TrafficSign::has_cborder() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TrafficSign::set_has_cborder() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TrafficSign::clear_has_cborder() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ndm_proto::Circle& TrafficSign::cborder() const {
  const ::ndm_proto::Circle* p = cborder_;
  // @@protoc_insertion_point(field_get:ndm_proto.TrafficSign.cborder)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Circle*>(
      &::ndm_proto::_Circle_default_instance_);
}
inline ::ndm_proto::Circle* TrafficSign::release_cborder() {
  // @@protoc_insertion_point(field_release:ndm_proto.TrafficSign.cborder)
  clear_has_cborder();
  ::ndm_proto::Circle* temp = cborder_;
  cborder_ = NULL;
  return temp;
}
inline ::ndm_proto::Circle* TrafficSign::mutable_cborder() {
  set_has_cborder();
  if (cborder_ == NULL) {
    cborder_ = new ::ndm_proto::Circle;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.TrafficSign.cborder)
  return cborder_;
}
inline void TrafficSign::set_allocated_cborder(::ndm_proto::Circle* cborder) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(cborder_);
  }
  if (cborder) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      cborder = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, cborder, submessage_arena);
    }
    set_has_cborder();
  } else {
    clear_has_cborder();
  }
  cborder_ = cborder;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.TrafficSign.cborder)
}

// optional .ndm_proto.TrafficSignType type = 4;
inline bool TrafficSign::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TrafficSign::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TrafficSign::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::ndm_proto::TrafficSignType& TrafficSign::type() const {
  const ::ndm_proto::TrafficSignType* p = type_;
  // @@protoc_insertion_point(field_get:ndm_proto.TrafficSign.type)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::TrafficSignType*>(
      &::ndm_proto::_TrafficSignType_default_instance_);
}
inline ::ndm_proto::TrafficSignType* TrafficSign::release_type() {
  // @@protoc_insertion_point(field_release:ndm_proto.TrafficSign.type)
  clear_has_type();
  ::ndm_proto::TrafficSignType* temp = type_;
  type_ = NULL;
  return temp;
}
inline ::ndm_proto::TrafficSignType* TrafficSign::mutable_type() {
  set_has_type();
  if (type_ == NULL) {
    type_ = new ::ndm_proto::TrafficSignType;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.TrafficSign.type)
  return type_;
}
inline void TrafficSign::set_allocated_type(::ndm_proto::TrafficSignType* type) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(type_);
  }
  if (type) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      type = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, type, submessage_arena);
    }
    set_has_type();
  } else {
    clear_has_type();
  }
  type_ = type;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.TrafficSign.type)
}

// optional .ndm_proto.Number number = 5;
inline bool TrafficSign::has_number() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TrafficSign::set_has_number() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TrafficSign::clear_has_number() {
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::ndm_proto::Number& TrafficSign::number() const {
  const ::ndm_proto::Number* p = number_;
  // @@protoc_insertion_point(field_get:ndm_proto.TrafficSign.number)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Number*>(
      &::ndm_proto::_Number_default_instance_);
}
inline ::ndm_proto::Number* TrafficSign::release_number() {
  // @@protoc_insertion_point(field_release:ndm_proto.TrafficSign.number)
  clear_has_number();
  ::ndm_proto::Number* temp = number_;
  number_ = NULL;
  return temp;
}
inline ::ndm_proto::Number* TrafficSign::mutable_number() {
  set_has_number();
  if (number_ == NULL) {
    number_ = new ::ndm_proto::Number;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.TrafficSign.number)
  return number_;
}
inline void TrafficSign::set_allocated_number(::ndm_proto::Number* number) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(number_);
  }
  if (number) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      number = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, number, submessage_arena);
    }
    set_has_number();
  } else {
    clear_has_number();
  }
  number_ = number;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.TrafficSign.number)
}

// optional float exist_conf = 6;
inline bool TrafficSign::has_exist_conf() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TrafficSign::set_has_exist_conf() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TrafficSign::clear_has_exist_conf() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TrafficSign::clear_exist_conf() {
  exist_conf_ = 0;
  clear_has_exist_conf();
}
inline float TrafficSign::exist_conf() const {
  // @@protoc_insertion_point(field_get:ndm_proto.TrafficSign.exist_conf)
  return exist_conf_;
}
inline void TrafficSign::set_exist_conf(float value) {
  set_has_exist_conf();
  exist_conf_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.TrafficSign.exist_conf)
}

// optional .ndm_proto.String str = 7;
inline bool TrafficSign::has_str() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TrafficSign::set_has_str() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TrafficSign::clear_has_str() {
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::ndm_proto::String& TrafficSign::str() const {
  const ::ndm_proto::String* p = str_;
  // @@protoc_insertion_point(field_get:ndm_proto.TrafficSign.str)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::String*>(
      &::ndm_proto::_String_default_instance_);
}
inline ::ndm_proto::String* TrafficSign::release_str() {
  // @@protoc_insertion_point(field_release:ndm_proto.TrafficSign.str)
  clear_has_str();
  ::ndm_proto::String* temp = str_;
  str_ = NULL;
  return temp;
}
inline ::ndm_proto::String* TrafficSign::mutable_str() {
  set_has_str();
  if (str_ == NULL) {
    str_ = new ::ndm_proto::String;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.TrafficSign.str)
  return str_;
}
inline void TrafficSign::set_allocated_str(::ndm_proto::String* str) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(str_);
  }
  if (str) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      str = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, str, submessage_arena);
    }
    set_has_str();
  } else {
    clear_has_str();
  }
  str_ = str;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.TrafficSign.str)
}

// optional .ndm_proto.SignShape shape = 8;
inline bool TrafficSign::has_shape() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TrafficSign::set_has_shape() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TrafficSign::clear_has_shape() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TrafficSign::clear_shape() {
  shape_ = 0;
  clear_has_shape();
}
inline ::ndm_proto::SignShape TrafficSign::shape() const {
  // @@protoc_insertion_point(field_get:ndm_proto.TrafficSign.shape)
  return static_cast< ::ndm_proto::SignShape >(shape_);
}
inline void TrafficSign::set_shape(::ndm_proto::SignShape value) {
  assert(::ndm_proto::SignShape_IsValid(value));
  set_has_shape();
  shape_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.TrafficSign.shape)
}

// optional .ndm_proto.YesNoUnknown vms = 9;
inline bool TrafficSign::has_vms() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TrafficSign::set_has_vms() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TrafficSign::clear_has_vms() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TrafficSign::clear_vms() {
  vms_ = 0;
  clear_has_vms();
}
inline ::ndm_proto::YesNoUnknown TrafficSign::vms() const {
  // @@protoc_insertion_point(field_get:ndm_proto.TrafficSign.vms)
  return static_cast< ::ndm_proto::YesNoUnknown >(vms_);
}
inline void TrafficSign::set_vms(::ndm_proto::YesNoUnknown value) {
  assert(::ndm_proto::YesNoUnknown_IsValid(value));
  set_has_vms();
  vms_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.TrafficSign.vms)
}

// repeated .ndm_proto.Condition panels = 10;
inline int TrafficSign::panels_size() const {
  return panels_.size();
}
inline const ::ndm_proto::Condition& TrafficSign::panels(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.TrafficSign.panels)
  return panels_.Get(index);
}
inline ::ndm_proto::Condition* TrafficSign::mutable_panels(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.TrafficSign.panels)
  return panels_.Mutable(index);
}
inline ::ndm_proto::Condition* TrafficSign::add_panels() {
  // @@protoc_insertion_point(field_add:ndm_proto.TrafficSign.panels)
  return panels_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::Condition >*
TrafficSign::mutable_panels() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.TrafficSign.panels)
  return &panels_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Condition >&
TrafficSign::panels() const {
  // @@protoc_insertion_point(field_list:ndm_proto.TrafficSign.panels)
  return panels_;
}

// -------------------------------------------------------------------

// ParkingSlot

// required string id = 1;
inline bool ParkingSlot::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ParkingSlot::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ParkingSlot::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ParkingSlot::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& ParkingSlot::id() const {
  // @@protoc_insertion_point(field_get:ndm_proto.ParkingSlot.id)
  return id_.GetNoArena();
}
inline void ParkingSlot::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ndm_proto.ParkingSlot.id)
}
#if LANG_CXX11
inline void ParkingSlot::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ndm_proto.ParkingSlot.id)
}
#endif
inline void ParkingSlot::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ndm_proto.ParkingSlot.id)
}
inline void ParkingSlot::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.ParkingSlot.id)
}
inline ::std::string* ParkingSlot::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:ndm_proto.ParkingSlot.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ParkingSlot::release_id() {
  // @@protoc_insertion_point(field_release:ndm_proto.ParkingSlot.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ParkingSlot::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.ParkingSlot.id)
}

// required .ndm_proto.Polygon border = 2;
inline bool ParkingSlot::has_border() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ParkingSlot::set_has_border() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ParkingSlot::clear_has_border() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ndm_proto::Polygon& ParkingSlot::border() const {
  const ::ndm_proto::Polygon* p = border_;
  // @@protoc_insertion_point(field_get:ndm_proto.ParkingSlot.border)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Polygon*>(
      &::ndm_proto::_Polygon_default_instance_);
}
inline ::ndm_proto::Polygon* ParkingSlot::release_border() {
  // @@protoc_insertion_point(field_release:ndm_proto.ParkingSlot.border)
  clear_has_border();
  ::ndm_proto::Polygon* temp = border_;
  border_ = NULL;
  return temp;
}
inline ::ndm_proto::Polygon* ParkingSlot::mutable_border() {
  set_has_border();
  if (border_ == NULL) {
    border_ = new ::ndm_proto::Polygon;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.ParkingSlot.border)
  return border_;
}
inline void ParkingSlot::set_allocated_border(::ndm_proto::Polygon* border) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(border_);
  }
  if (border) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      border = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, border, submessage_arena);
    }
    set_has_border();
  } else {
    clear_has_border();
  }
  border_ = border;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.ParkingSlot.border)
}

// optional .ndm_proto.String str = 3;
inline bool ParkingSlot::has_str() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ParkingSlot::set_has_str() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ParkingSlot::clear_has_str() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ndm_proto::String& ParkingSlot::str() const {
  const ::ndm_proto::String* p = str_;
  // @@protoc_insertion_point(field_get:ndm_proto.ParkingSlot.str)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::String*>(
      &::ndm_proto::_String_default_instance_);
}
inline ::ndm_proto::String* ParkingSlot::release_str() {
  // @@protoc_insertion_point(field_release:ndm_proto.ParkingSlot.str)
  clear_has_str();
  ::ndm_proto::String* temp = str_;
  str_ = NULL;
  return temp;
}
inline ::ndm_proto::String* ParkingSlot::mutable_str() {
  set_has_str();
  if (str_ == NULL) {
    str_ = new ::ndm_proto::String;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.ParkingSlot.str)
  return str_;
}
inline void ParkingSlot::set_allocated_str(::ndm_proto::String* str) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(str_);
  }
  if (str) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      str = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, str, submessage_arena);
    }
    set_has_str();
  } else {
    clear_has_str();
  }
  str_ = str;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.ParkingSlot.str)
}

// optional float exist_conf = 4;
inline bool ParkingSlot::has_exist_conf() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ParkingSlot::set_has_exist_conf() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ParkingSlot::clear_has_exist_conf() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ParkingSlot::clear_exist_conf() {
  exist_conf_ = 0;
  clear_has_exist_conf();
}
inline float ParkingSlot::exist_conf() const {
  // @@protoc_insertion_point(field_get:ndm_proto.ParkingSlot.exist_conf)
  return exist_conf_;
}
inline void ParkingSlot::set_exist_conf(float value) {
  set_has_exist_conf();
  exist_conf_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.ParkingSlot.exist_conf)
}

// -------------------------------------------------------------------

// ElevationPlane

// required string id = 1;
inline bool ElevationPlane::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ElevationPlane::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ElevationPlane::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ElevationPlane::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& ElevationPlane::id() const {
  // @@protoc_insertion_point(field_get:ndm_proto.ElevationPlane.id)
  return id_.GetNoArena();
}
inline void ElevationPlane::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ndm_proto.ElevationPlane.id)
}
#if LANG_CXX11
inline void ElevationPlane::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ndm_proto.ElevationPlane.id)
}
#endif
inline void ElevationPlane::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ndm_proto.ElevationPlane.id)
}
inline void ElevationPlane::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.ElevationPlane.id)
}
inline ::std::string* ElevationPlane::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:ndm_proto.ElevationPlane.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ElevationPlane::release_id() {
  // @@protoc_insertion_point(field_release:ndm_proto.ElevationPlane.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ElevationPlane::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.ElevationPlane.id)
}

// required .ndm_proto.Polygon border = 2;
inline bool ElevationPlane::has_border() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ElevationPlane::set_has_border() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ElevationPlane::clear_has_border() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ndm_proto::Polygon& ElevationPlane::border() const {
  const ::ndm_proto::Polygon* p = border_;
  // @@protoc_insertion_point(field_get:ndm_proto.ElevationPlane.border)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Polygon*>(
      &::ndm_proto::_Polygon_default_instance_);
}
inline ::ndm_proto::Polygon* ElevationPlane::release_border() {
  // @@protoc_insertion_point(field_release:ndm_proto.ElevationPlane.border)
  clear_has_border();
  ::ndm_proto::Polygon* temp = border_;
  border_ = NULL;
  return temp;
}
inline ::ndm_proto::Polygon* ElevationPlane::mutable_border() {
  set_has_border();
  if (border_ == NULL) {
    border_ = new ::ndm_proto::Polygon;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.ElevationPlane.border)
  return border_;
}
inline void ElevationPlane::set_allocated_border(::ndm_proto::Polygon* border) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(border_);
  }
  if (border) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      border = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, border, submessage_arena);
    }
    set_has_border();
  } else {
    clear_has_border();
  }
  border_ = border;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.ElevationPlane.border)
}

// optional float exist_conf = 3;
inline bool ElevationPlane::has_exist_conf() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ElevationPlane::set_has_exist_conf() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ElevationPlane::clear_has_exist_conf() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ElevationPlane::clear_exist_conf() {
  exist_conf_ = 0;
  clear_has_exist_conf();
}
inline float ElevationPlane::exist_conf() const {
  // @@protoc_insertion_point(field_get:ndm_proto.ElevationPlane.exist_conf)
  return exist_conf_;
}
inline void ElevationPlane::set_exist_conf(float value) {
  set_has_exist_conf();
  exist_conf_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.ElevationPlane.exist_conf)
}

// -------------------------------------------------------------------

// AreaPolygon

// required string id = 1;
inline bool AreaPolygon::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AreaPolygon::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AreaPolygon::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AreaPolygon::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& AreaPolygon::id() const {
  // @@protoc_insertion_point(field_get:ndm_proto.AreaPolygon.id)
  return id_.GetNoArena();
}
inline void AreaPolygon::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ndm_proto.AreaPolygon.id)
}
#if LANG_CXX11
inline void AreaPolygon::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ndm_proto.AreaPolygon.id)
}
#endif
inline void AreaPolygon::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ndm_proto.AreaPolygon.id)
}
inline void AreaPolygon::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.AreaPolygon.id)
}
inline ::std::string* AreaPolygon::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:ndm_proto.AreaPolygon.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AreaPolygon::release_id() {
  // @@protoc_insertion_point(field_release:ndm_proto.AreaPolygon.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AreaPolygon::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.AreaPolygon.id)
}

// required .ndm_proto.Polygon border = 2;
inline bool AreaPolygon::has_border() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AreaPolygon::set_has_border() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AreaPolygon::clear_has_border() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ndm_proto::Polygon& AreaPolygon::border() const {
  const ::ndm_proto::Polygon* p = border_;
  // @@protoc_insertion_point(field_get:ndm_proto.AreaPolygon.border)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Polygon*>(
      &::ndm_proto::_Polygon_default_instance_);
}
inline ::ndm_proto::Polygon* AreaPolygon::release_border() {
  // @@protoc_insertion_point(field_release:ndm_proto.AreaPolygon.border)
  clear_has_border();
  ::ndm_proto::Polygon* temp = border_;
  border_ = NULL;
  return temp;
}
inline ::ndm_proto::Polygon* AreaPolygon::mutable_border() {
  set_has_border();
  if (border_ == NULL) {
    border_ = new ::ndm_proto::Polygon;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.AreaPolygon.border)
  return border_;
}
inline void AreaPolygon::set_allocated_border(::ndm_proto::Polygon* border) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(border_);
  }
  if (border) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      border = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, border, submessage_arena);
    }
    set_has_border();
  } else {
    clear_has_border();
  }
  border_ = border;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.AreaPolygon.border)
}

// optional .ndm_proto.String str = 3;
inline bool AreaPolygon::has_str() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AreaPolygon::set_has_str() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AreaPolygon::clear_has_str() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ndm_proto::String& AreaPolygon::str() const {
  const ::ndm_proto::String* p = str_;
  // @@protoc_insertion_point(field_get:ndm_proto.AreaPolygon.str)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::String*>(
      &::ndm_proto::_String_default_instance_);
}
inline ::ndm_proto::String* AreaPolygon::release_str() {
  // @@protoc_insertion_point(field_release:ndm_proto.AreaPolygon.str)
  clear_has_str();
  ::ndm_proto::String* temp = str_;
  str_ = NULL;
  return temp;
}
inline ::ndm_proto::String* AreaPolygon::mutable_str() {
  set_has_str();
  if (str_ == NULL) {
    str_ = new ::ndm_proto::String;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.AreaPolygon.str)
  return str_;
}
inline void AreaPolygon::set_allocated_str(::ndm_proto::String* str) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(str_);
  }
  if (str) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      str = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, str, submessage_arena);
    }
    set_has_str();
  } else {
    clear_has_str();
  }
  str_ = str;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.AreaPolygon.str)
}

// optional float exist_conf = 4;
inline bool AreaPolygon::has_exist_conf() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AreaPolygon::set_has_exist_conf() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AreaPolygon::clear_has_exist_conf() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AreaPolygon::clear_exist_conf() {
  exist_conf_ = 0;
  clear_has_exist_conf();
}
inline float AreaPolygon::exist_conf() const {
  // @@protoc_insertion_point(field_get:ndm_proto.AreaPolygon.exist_conf)
  return exist_conf_;
}
inline void AreaPolygon::set_exist_conf(float value) {
  set_has_exist_conf();
  exist_conf_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.AreaPolygon.exist_conf)
}

// -------------------------------------------------------------------

// GeneralPolygon

// required string id = 1;
inline bool GeneralPolygon::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GeneralPolygon::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GeneralPolygon::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GeneralPolygon::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& GeneralPolygon::id() const {
  // @@protoc_insertion_point(field_get:ndm_proto.GeneralPolygon.id)
  return id_.GetNoArena();
}
inline void GeneralPolygon::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ndm_proto.GeneralPolygon.id)
}
#if LANG_CXX11
inline void GeneralPolygon::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ndm_proto.GeneralPolygon.id)
}
#endif
inline void GeneralPolygon::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ndm_proto.GeneralPolygon.id)
}
inline void GeneralPolygon::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.GeneralPolygon.id)
}
inline ::std::string* GeneralPolygon::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:ndm_proto.GeneralPolygon.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GeneralPolygon::release_id() {
  // @@protoc_insertion_point(field_release:ndm_proto.GeneralPolygon.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GeneralPolygon::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.GeneralPolygon.id)
}

// required .ndm_proto.Polygon border = 2;
inline bool GeneralPolygon::has_border() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GeneralPolygon::set_has_border() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GeneralPolygon::clear_has_border() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ndm_proto::Polygon& GeneralPolygon::border() const {
  const ::ndm_proto::Polygon* p = border_;
  // @@protoc_insertion_point(field_get:ndm_proto.GeneralPolygon.border)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Polygon*>(
      &::ndm_proto::_Polygon_default_instance_);
}
inline ::ndm_proto::Polygon* GeneralPolygon::release_border() {
  // @@protoc_insertion_point(field_release:ndm_proto.GeneralPolygon.border)
  clear_has_border();
  ::ndm_proto::Polygon* temp = border_;
  border_ = NULL;
  return temp;
}
inline ::ndm_proto::Polygon* GeneralPolygon::mutable_border() {
  set_has_border();
  if (border_ == NULL) {
    border_ = new ::ndm_proto::Polygon;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.GeneralPolygon.border)
  return border_;
}
inline void GeneralPolygon::set_allocated_border(::ndm_proto::Polygon* border) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(border_);
  }
  if (border) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      border = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, border, submessage_arena);
    }
    set_has_border();
  } else {
    clear_has_border();
  }
  border_ = border;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.GeneralPolygon.border)
}

// optional .ndm_proto.String str = 3;
inline bool GeneralPolygon::has_str() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GeneralPolygon::set_has_str() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GeneralPolygon::clear_has_str() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ndm_proto::String& GeneralPolygon::str() const {
  const ::ndm_proto::String* p = str_;
  // @@protoc_insertion_point(field_get:ndm_proto.GeneralPolygon.str)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::String*>(
      &::ndm_proto::_String_default_instance_);
}
inline ::ndm_proto::String* GeneralPolygon::release_str() {
  // @@protoc_insertion_point(field_release:ndm_proto.GeneralPolygon.str)
  clear_has_str();
  ::ndm_proto::String* temp = str_;
  str_ = NULL;
  return temp;
}
inline ::ndm_proto::String* GeneralPolygon::mutable_str() {
  set_has_str();
  if (str_ == NULL) {
    str_ = new ::ndm_proto::String;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.GeneralPolygon.str)
  return str_;
}
inline void GeneralPolygon::set_allocated_str(::ndm_proto::String* str) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(str_);
  }
  if (str) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      str = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, str, submessage_arena);
    }
    set_has_str();
  } else {
    clear_has_str();
  }
  str_ = str;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.GeneralPolygon.str)
}

// -------------------------------------------------------------------

// GeneralLine

// required string id = 1;
inline bool GeneralLine::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GeneralLine::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GeneralLine::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GeneralLine::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& GeneralLine::id() const {
  // @@protoc_insertion_point(field_get:ndm_proto.GeneralLine.id)
  return id_.GetNoArena();
}
inline void GeneralLine::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ndm_proto.GeneralLine.id)
}
#if LANG_CXX11
inline void GeneralLine::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ndm_proto.GeneralLine.id)
}
#endif
inline void GeneralLine::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ndm_proto.GeneralLine.id)
}
inline void GeneralLine::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.GeneralLine.id)
}
inline ::std::string* GeneralLine::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:ndm_proto.GeneralLine.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GeneralLine::release_id() {
  // @@protoc_insertion_point(field_release:ndm_proto.GeneralLine.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GeneralLine::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.GeneralLine.id)
}

// repeated .ndm_proto.CurveLine lines = 2;
inline int GeneralLine::lines_size() const {
  return lines_.size();
}
inline const ::ndm_proto::CurveLine& GeneralLine::lines(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.GeneralLine.lines)
  return lines_.Get(index);
}
inline ::ndm_proto::CurveLine* GeneralLine::mutable_lines(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.GeneralLine.lines)
  return lines_.Mutable(index);
}
inline ::ndm_proto::CurveLine* GeneralLine::add_lines() {
  // @@protoc_insertion_point(field_add:ndm_proto.GeneralLine.lines)
  return lines_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::CurveLine >*
GeneralLine::mutable_lines() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.GeneralLine.lines)
  return &lines_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::CurveLine >&
GeneralLine::lines() const {
  // @@protoc_insertion_point(field_list:ndm_proto.GeneralLine.lines)
  return lines_;
}

// optional .ndm_proto.String str = 3;
inline bool GeneralLine::has_str() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GeneralLine::set_has_str() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GeneralLine::clear_has_str() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ndm_proto::String& GeneralLine::str() const {
  const ::ndm_proto::String* p = str_;
  // @@protoc_insertion_point(field_get:ndm_proto.GeneralLine.str)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::String*>(
      &::ndm_proto::_String_default_instance_);
}
inline ::ndm_proto::String* GeneralLine::release_str() {
  // @@protoc_insertion_point(field_release:ndm_proto.GeneralLine.str)
  clear_has_str();
  ::ndm_proto::String* temp = str_;
  str_ = NULL;
  return temp;
}
inline ::ndm_proto::String* GeneralLine::mutable_str() {
  set_has_str();
  if (str_ == NULL) {
    str_ = new ::ndm_proto::String;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.GeneralLine.str)
  return str_;
}
inline void GeneralLine::set_allocated_str(::ndm_proto::String* str) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(str_);
  }
  if (str) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      str = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, str, submessage_arena);
    }
    set_has_str();
  } else {
    clear_has_str();
  }
  str_ = str;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.GeneralLine.str)
}

// -------------------------------------------------------------------

// PhysicalLayer

// repeated .ndm_proto.TrafficLight trafficlights = 1;
inline int PhysicalLayer::trafficlights_size() const {
  return trafficlights_.size();
}
inline void PhysicalLayer::clear_trafficlights() {
  trafficlights_.Clear();
}
inline const ::ndm_proto::TrafficLight& PhysicalLayer::trafficlights(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.PhysicalLayer.trafficlights)
  return trafficlights_.Get(index);
}
inline ::ndm_proto::TrafficLight* PhysicalLayer::mutable_trafficlights(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.PhysicalLayer.trafficlights)
  return trafficlights_.Mutable(index);
}
inline ::ndm_proto::TrafficLight* PhysicalLayer::add_trafficlights() {
  // @@protoc_insertion_point(field_add:ndm_proto.PhysicalLayer.trafficlights)
  return trafficlights_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::TrafficLight >*
PhysicalLayer::mutable_trafficlights() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.PhysicalLayer.trafficlights)
  return &trafficlights_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::TrafficLight >&
PhysicalLayer::trafficlights() const {
  // @@protoc_insertion_point(field_list:ndm_proto.PhysicalLayer.trafficlights)
  return trafficlights_;
}

// repeated .ndm_proto.LaneMarking lanemarkings = 2;
inline int PhysicalLayer::lanemarkings_size() const {
  return lanemarkings_.size();
}
inline void PhysicalLayer::clear_lanemarkings() {
  lanemarkings_.Clear();
}
inline const ::ndm_proto::LaneMarking& PhysicalLayer::lanemarkings(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.PhysicalLayer.lanemarkings)
  return lanemarkings_.Get(index);
}
inline ::ndm_proto::LaneMarking* PhysicalLayer::mutable_lanemarkings(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.PhysicalLayer.lanemarkings)
  return lanemarkings_.Mutable(index);
}
inline ::ndm_proto::LaneMarking* PhysicalLayer::add_lanemarkings() {
  // @@protoc_insertion_point(field_add:ndm_proto.PhysicalLayer.lanemarkings)
  return lanemarkings_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::LaneMarking >*
PhysicalLayer::mutable_lanemarkings() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.PhysicalLayer.lanemarkings)
  return &lanemarkings_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::LaneMarking >&
PhysicalLayer::lanemarkings() const {
  // @@protoc_insertion_point(field_list:ndm_proto.PhysicalLayer.lanemarkings)
  return lanemarkings_;
}

// repeated .ndm_proto.LaneLine lanelines = 3;
inline int PhysicalLayer::lanelines_size() const {
  return lanelines_.size();
}
inline void PhysicalLayer::clear_lanelines() {
  lanelines_.Clear();
}
inline const ::ndm_proto::LaneLine& PhysicalLayer::lanelines(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.PhysicalLayer.lanelines)
  return lanelines_.Get(index);
}
inline ::ndm_proto::LaneLine* PhysicalLayer::mutable_lanelines(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.PhysicalLayer.lanelines)
  return lanelines_.Mutable(index);
}
inline ::ndm_proto::LaneLine* PhysicalLayer::add_lanelines() {
  // @@protoc_insertion_point(field_add:ndm_proto.PhysicalLayer.lanelines)
  return lanelines_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::LaneLine >*
PhysicalLayer::mutable_lanelines() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.PhysicalLayer.lanelines)
  return &lanelines_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::LaneLine >&
PhysicalLayer::lanelines() const {
  // @@protoc_insertion_point(field_list:ndm_proto.PhysicalLayer.lanelines)
  return lanelines_;
}

// repeated .ndm_proto.StopLine stoplines = 4;
inline int PhysicalLayer::stoplines_size() const {
  return stoplines_.size();
}
inline void PhysicalLayer::clear_stoplines() {
  stoplines_.Clear();
}
inline const ::ndm_proto::StopLine& PhysicalLayer::stoplines(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.PhysicalLayer.stoplines)
  return stoplines_.Get(index);
}
inline ::ndm_proto::StopLine* PhysicalLayer::mutable_stoplines(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.PhysicalLayer.stoplines)
  return stoplines_.Mutable(index);
}
inline ::ndm_proto::StopLine* PhysicalLayer::add_stoplines() {
  // @@protoc_insertion_point(field_add:ndm_proto.PhysicalLayer.stoplines)
  return stoplines_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::StopLine >*
PhysicalLayer::mutable_stoplines() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.PhysicalLayer.stoplines)
  return &stoplines_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::StopLine >&
PhysicalLayer::stoplines() const {
  // @@protoc_insertion_point(field_list:ndm_proto.PhysicalLayer.stoplines)
  return stoplines_;
}

// repeated .ndm_proto.SpeedBump speedbumps = 5;
inline int PhysicalLayer::speedbumps_size() const {
  return speedbumps_.size();
}
inline void PhysicalLayer::clear_speedbumps() {
  speedbumps_.Clear();
}
inline const ::ndm_proto::SpeedBump& PhysicalLayer::speedbumps(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.PhysicalLayer.speedbumps)
  return speedbumps_.Get(index);
}
inline ::ndm_proto::SpeedBump* PhysicalLayer::mutable_speedbumps(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.PhysicalLayer.speedbumps)
  return speedbumps_.Mutable(index);
}
inline ::ndm_proto::SpeedBump* PhysicalLayer::add_speedbumps() {
  // @@protoc_insertion_point(field_add:ndm_proto.PhysicalLayer.speedbumps)
  return speedbumps_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::SpeedBump >*
PhysicalLayer::mutable_speedbumps() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.PhysicalLayer.speedbumps)
  return &speedbumps_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::SpeedBump >&
PhysicalLayer::speedbumps() const {
  // @@protoc_insertion_point(field_list:ndm_proto.PhysicalLayer.speedbumps)
  return speedbumps_;
}

// repeated .ndm_proto.Pole poles = 6;
inline int PhysicalLayer::poles_size() const {
  return poles_.size();
}
inline void PhysicalLayer::clear_poles() {
  poles_.Clear();
}
inline const ::ndm_proto::Pole& PhysicalLayer::poles(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.PhysicalLayer.poles)
  return poles_.Get(index);
}
inline ::ndm_proto::Pole* PhysicalLayer::mutable_poles(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.PhysicalLayer.poles)
  return poles_.Mutable(index);
}
inline ::ndm_proto::Pole* PhysicalLayer::add_poles() {
  // @@protoc_insertion_point(field_add:ndm_proto.PhysicalLayer.poles)
  return poles_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::Pole >*
PhysicalLayer::mutable_poles() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.PhysicalLayer.poles)
  return &poles_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Pole >&
PhysicalLayer::poles() const {
  // @@protoc_insertion_point(field_list:ndm_proto.PhysicalLayer.poles)
  return poles_;
}

// repeated .ndm_proto.Board boards = 7;
inline int PhysicalLayer::boards_size() const {
  return boards_.size();
}
inline void PhysicalLayer::clear_boards() {
  boards_.Clear();
}
inline const ::ndm_proto::Board& PhysicalLayer::boards(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.PhysicalLayer.boards)
  return boards_.Get(index);
}
inline ::ndm_proto::Board* PhysicalLayer::mutable_boards(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.PhysicalLayer.boards)
  return boards_.Mutable(index);
}
inline ::ndm_proto::Board* PhysicalLayer::add_boards() {
  // @@protoc_insertion_point(field_add:ndm_proto.PhysicalLayer.boards)
  return boards_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::Board >*
PhysicalLayer::mutable_boards() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.PhysicalLayer.boards)
  return &boards_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Board >&
PhysicalLayer::boards() const {
  // @@protoc_insertion_point(field_list:ndm_proto.PhysicalLayer.boards)
  return boards_;
}

// repeated .ndm_proto.CrossWalk crosswalks = 8;
inline int PhysicalLayer::crosswalks_size() const {
  return crosswalks_.size();
}
inline void PhysicalLayer::clear_crosswalks() {
  crosswalks_.Clear();
}
inline const ::ndm_proto::CrossWalk& PhysicalLayer::crosswalks(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.PhysicalLayer.crosswalks)
  return crosswalks_.Get(index);
}
inline ::ndm_proto::CrossWalk* PhysicalLayer::mutable_crosswalks(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.PhysicalLayer.crosswalks)
  return crosswalks_.Mutable(index);
}
inline ::ndm_proto::CrossWalk* PhysicalLayer::add_crosswalks() {
  // @@protoc_insertion_point(field_add:ndm_proto.PhysicalLayer.crosswalks)
  return crosswalks_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::CrossWalk >*
PhysicalLayer::mutable_crosswalks() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.PhysicalLayer.crosswalks)
  return &crosswalks_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::CrossWalk >&
PhysicalLayer::crosswalks() const {
  // @@protoc_insertion_point(field_list:ndm_proto.PhysicalLayer.crosswalks)
  return crosswalks_;
}

// repeated .ndm_proto.Zone zones = 9;
inline int PhysicalLayer::zones_size() const {
  return zones_.size();
}
inline void PhysicalLayer::clear_zones() {
  zones_.Clear();
}
inline const ::ndm_proto::Zone& PhysicalLayer::zones(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.PhysicalLayer.zones)
  return zones_.Get(index);
}
inline ::ndm_proto::Zone* PhysicalLayer::mutable_zones(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.PhysicalLayer.zones)
  return zones_.Mutable(index);
}
inline ::ndm_proto::Zone* PhysicalLayer::add_zones() {
  // @@protoc_insertion_point(field_add:ndm_proto.PhysicalLayer.zones)
  return zones_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::Zone >*
PhysicalLayer::mutable_zones() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.PhysicalLayer.zones)
  return &zones_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Zone >&
PhysicalLayer::zones() const {
  // @@protoc_insertion_point(field_list:ndm_proto.PhysicalLayer.zones)
  return zones_;
}

// repeated .ndm_proto.TrafficSign trafficsigns = 10;
inline int PhysicalLayer::trafficsigns_size() const {
  return trafficsigns_.size();
}
inline void PhysicalLayer::clear_trafficsigns() {
  trafficsigns_.Clear();
}
inline const ::ndm_proto::TrafficSign& PhysicalLayer::trafficsigns(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.PhysicalLayer.trafficsigns)
  return trafficsigns_.Get(index);
}
inline ::ndm_proto::TrafficSign* PhysicalLayer::mutable_trafficsigns(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.PhysicalLayer.trafficsigns)
  return trafficsigns_.Mutable(index);
}
inline ::ndm_proto::TrafficSign* PhysicalLayer::add_trafficsigns() {
  // @@protoc_insertion_point(field_add:ndm_proto.PhysicalLayer.trafficsigns)
  return trafficsigns_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::TrafficSign >*
PhysicalLayer::mutable_trafficsigns() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.PhysicalLayer.trafficsigns)
  return &trafficsigns_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::TrafficSign >&
PhysicalLayer::trafficsigns() const {
  // @@protoc_insertion_point(field_list:ndm_proto.PhysicalLayer.trafficsigns)
  return trafficsigns_;
}

// repeated .ndm_proto.ParkingSlot parkingslots = 11;
inline int PhysicalLayer::parkingslots_size() const {
  return parkingslots_.size();
}
inline void PhysicalLayer::clear_parkingslots() {
  parkingslots_.Clear();
}
inline const ::ndm_proto::ParkingSlot& PhysicalLayer::parkingslots(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.PhysicalLayer.parkingslots)
  return parkingslots_.Get(index);
}
inline ::ndm_proto::ParkingSlot* PhysicalLayer::mutable_parkingslots(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.PhysicalLayer.parkingslots)
  return parkingslots_.Mutable(index);
}
inline ::ndm_proto::ParkingSlot* PhysicalLayer::add_parkingslots() {
  // @@protoc_insertion_point(field_add:ndm_proto.PhysicalLayer.parkingslots)
  return parkingslots_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::ParkingSlot >*
PhysicalLayer::mutable_parkingslots() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.PhysicalLayer.parkingslots)
  return &parkingslots_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::ParkingSlot >&
PhysicalLayer::parkingslots() const {
  // @@protoc_insertion_point(field_list:ndm_proto.PhysicalLayer.parkingslots)
  return parkingslots_;
}

// repeated .ndm_proto.ElevationPlane elevationplanes = 12;
inline int PhysicalLayer::elevationplanes_size() const {
  return elevationplanes_.size();
}
inline void PhysicalLayer::clear_elevationplanes() {
  elevationplanes_.Clear();
}
inline const ::ndm_proto::ElevationPlane& PhysicalLayer::elevationplanes(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.PhysicalLayer.elevationplanes)
  return elevationplanes_.Get(index);
}
inline ::ndm_proto::ElevationPlane* PhysicalLayer::mutable_elevationplanes(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.PhysicalLayer.elevationplanes)
  return elevationplanes_.Mutable(index);
}
inline ::ndm_proto::ElevationPlane* PhysicalLayer::add_elevationplanes() {
  // @@protoc_insertion_point(field_add:ndm_proto.PhysicalLayer.elevationplanes)
  return elevationplanes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::ElevationPlane >*
PhysicalLayer::mutable_elevationplanes() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.PhysicalLayer.elevationplanes)
  return &elevationplanes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::ElevationPlane >&
PhysicalLayer::elevationplanes() const {
  // @@protoc_insertion_point(field_list:ndm_proto.PhysicalLayer.elevationplanes)
  return elevationplanes_;
}

// repeated .ndm_proto.AreaPolygon areapolygons = 13;
inline int PhysicalLayer::areapolygons_size() const {
  return areapolygons_.size();
}
inline void PhysicalLayer::clear_areapolygons() {
  areapolygons_.Clear();
}
inline const ::ndm_proto::AreaPolygon& PhysicalLayer::areapolygons(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.PhysicalLayer.areapolygons)
  return areapolygons_.Get(index);
}
inline ::ndm_proto::AreaPolygon* PhysicalLayer::mutable_areapolygons(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.PhysicalLayer.areapolygons)
  return areapolygons_.Mutable(index);
}
inline ::ndm_proto::AreaPolygon* PhysicalLayer::add_areapolygons() {
  // @@protoc_insertion_point(field_add:ndm_proto.PhysicalLayer.areapolygons)
  return areapolygons_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::AreaPolygon >*
PhysicalLayer::mutable_areapolygons() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.PhysicalLayer.areapolygons)
  return &areapolygons_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::AreaPolygon >&
PhysicalLayer::areapolygons() const {
  // @@protoc_insertion_point(field_list:ndm_proto.PhysicalLayer.areapolygons)
  return areapolygons_;
}

// repeated .ndm_proto.GeneralPolygon general_polygons = 15;
inline int PhysicalLayer::general_polygons_size() const {
  return general_polygons_.size();
}
inline void PhysicalLayer::clear_general_polygons() {
  general_polygons_.Clear();
}
inline const ::ndm_proto::GeneralPolygon& PhysicalLayer::general_polygons(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.PhysicalLayer.general_polygons)
  return general_polygons_.Get(index);
}
inline ::ndm_proto::GeneralPolygon* PhysicalLayer::mutable_general_polygons(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.PhysicalLayer.general_polygons)
  return general_polygons_.Mutable(index);
}
inline ::ndm_proto::GeneralPolygon* PhysicalLayer::add_general_polygons() {
  // @@protoc_insertion_point(field_add:ndm_proto.PhysicalLayer.general_polygons)
  return general_polygons_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::GeneralPolygon >*
PhysicalLayer::mutable_general_polygons() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.PhysicalLayer.general_polygons)
  return &general_polygons_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::GeneralPolygon >&
PhysicalLayer::general_polygons() const {
  // @@protoc_insertion_point(field_list:ndm_proto.PhysicalLayer.general_polygons)
  return general_polygons_;
}

// repeated .ndm_proto.GeneralLine general_lines = 16;
inline int PhysicalLayer::general_lines_size() const {
  return general_lines_.size();
}
inline void PhysicalLayer::clear_general_lines() {
  general_lines_.Clear();
}
inline const ::ndm_proto::GeneralLine& PhysicalLayer::general_lines(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.PhysicalLayer.general_lines)
  return general_lines_.Get(index);
}
inline ::ndm_proto::GeneralLine* PhysicalLayer::mutable_general_lines(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.PhysicalLayer.general_lines)
  return general_lines_.Mutable(index);
}
inline ::ndm_proto::GeneralLine* PhysicalLayer::add_general_lines() {
  // @@protoc_insertion_point(field_add:ndm_proto.PhysicalLayer.general_lines)
  return general_lines_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::GeneralLine >*
PhysicalLayer::mutable_general_lines() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.PhysicalLayer.general_lines)
  return &general_lines_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::GeneralLine >&
PhysicalLayer::general_lines() const {
  // @@protoc_insertion_point(field_list:ndm_proto.PhysicalLayer.general_lines)
  return general_lines_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ndm_proto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_physical_5flayer_2eproto__INCLUDED
