// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: traffic/traffic.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_traffic_2ftraffic_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_traffic_2ftraffic_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "metadata/metadata.pb.h"
#include "common/common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_traffic_2ftraffic_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_traffic_2ftraffic_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[6]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_traffic_2ftraffic_2eproto;
namespace RoadPB {
class LaneMarking;
class LaneMarkingDefaultTypeInternal;
extern LaneMarkingDefaultTypeInternal _LaneMarking_default_instance_;
class SpeedBump;
class SpeedBumpDefaultTypeInternal;
extern SpeedBumpDefaultTypeInternal _SpeedBump_default_instance_;
class TrafficCondition;
class TrafficConditionDefaultTypeInternal;
extern TrafficConditionDefaultTypeInternal _TrafficCondition_default_instance_;
class TrafficInfo;
class TrafficInfoDefaultTypeInternal;
extern TrafficInfoDefaultTypeInternal _TrafficInfo_default_instance_;
class TrafficLight;
class TrafficLightDefaultTypeInternal;
extern TrafficLightDefaultTypeInternal _TrafficLight_default_instance_;
class TrafficSign;
class TrafficSignDefaultTypeInternal;
extern TrafficSignDefaultTypeInternal _TrafficSign_default_instance_;
}  // namespace RoadPB
PROTOBUF_NAMESPACE_OPEN
template<> ::RoadPB::LaneMarking* Arena::CreateMaybeMessage<::RoadPB::LaneMarking>(Arena*);
template<> ::RoadPB::SpeedBump* Arena::CreateMaybeMessage<::RoadPB::SpeedBump>(Arena*);
template<> ::RoadPB::TrafficCondition* Arena::CreateMaybeMessage<::RoadPB::TrafficCondition>(Arena*);
template<> ::RoadPB::TrafficInfo* Arena::CreateMaybeMessage<::RoadPB::TrafficInfo>(Arena*);
template<> ::RoadPB::TrafficLight* Arena::CreateMaybeMessage<::RoadPB::TrafficLight>(Arena*);
template<> ::RoadPB::TrafficSign* Arena::CreateMaybeMessage<::RoadPB::TrafficSign>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace RoadPB {

enum TrafficCondition_ConditionType : int {
  TrafficCondition_ConditionType_NUMERIC = 0,
  TrafficCondition_ConditionType_VEHICLE = 1,
  TrafficCondition_ConditionType_LOAD = 2,
  TrafficCondition_ConditionType_TIME_OF_DAY = 3,
  TrafficCondition_ConditionType_WEATHER = 4,
  TrafficCondition_ConditionType_FUZZY_TIME = 5,
  TrafficCondition_ConditionType_TURN_DIRECTION = 6
};
bool TrafficCondition_ConditionType_IsValid(int value);
constexpr TrafficCondition_ConditionType TrafficCondition_ConditionType_ConditionType_MIN = TrafficCondition_ConditionType_NUMERIC;
constexpr TrafficCondition_ConditionType TrafficCondition_ConditionType_ConditionType_MAX = TrafficCondition_ConditionType_TURN_DIRECTION;
constexpr int TrafficCondition_ConditionType_ConditionType_ARRAYSIZE = TrafficCondition_ConditionType_ConditionType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TrafficCondition_ConditionType_descriptor();
template<typename T>
inline const std::string& TrafficCondition_ConditionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TrafficCondition_ConditionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TrafficCondition_ConditionType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TrafficCondition_ConditionType_descriptor(), enum_t_value);
}
inline bool TrafficCondition_ConditionType_Parse(
    const std::string& name, TrafficCondition_ConditionType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TrafficCondition_ConditionType>(
    TrafficCondition_ConditionType_descriptor(), name, value);
}
enum TrafficCondition_LoadType : int {
  TrafficCondition_LoadType_WATER_POLLUTING = 1,
  TrafficCondition_LoadType_EXPLOSIVE = 2,
  TrafficCondition_LoadType_OTHER_DANGEROUS = 3,
  TrafficCondition_LoadType_EMPTY = 4,
  TrafficCondition_LoadType_SPECIAL = 5,
  TrafficCondition_LoadType_GASSES = 6,
  TrafficCondition_LoadType_FLAMMABLE_LIQUIDS = 7,
  TrafficCondition_LoadType_FLAMMABLE_SOLIDS = 8,
  TrafficCondition_LoadType_OXIDIZING = 9,
  TrafficCondition_LoadType_TOXIC_INFECTIOUS = 10,
  TrafficCondition_LoadType_RADIO_ACTIVE = 11,
  TrafficCondition_LoadType_CORROSIVE = 12
};
bool TrafficCondition_LoadType_IsValid(int value);
constexpr TrafficCondition_LoadType TrafficCondition_LoadType_LoadType_MIN = TrafficCondition_LoadType_WATER_POLLUTING;
constexpr TrafficCondition_LoadType TrafficCondition_LoadType_LoadType_MAX = TrafficCondition_LoadType_CORROSIVE;
constexpr int TrafficCondition_LoadType_LoadType_ARRAYSIZE = TrafficCondition_LoadType_LoadType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TrafficCondition_LoadType_descriptor();
template<typename T>
inline const std::string& TrafficCondition_LoadType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TrafficCondition_LoadType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TrafficCondition_LoadType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TrafficCondition_LoadType_descriptor(), enum_t_value);
}
inline bool TrafficCondition_LoadType_Parse(
    const std::string& name, TrafficCondition_LoadType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TrafficCondition_LoadType>(
    TrafficCondition_LoadType_descriptor(), name, value);
}
enum TrafficCondition_Weather : int {
  TrafficCondition_Weather_UNKNOWN = 0,
  TrafficCondition_Weather_NO_SPECIAL = 1,
  TrafficCondition_Weather_SUNSHINE = 2,
  TrafficCondition_Weather_RAIN = 3,
  TrafficCondition_Weather_FOG = 4,
  TrafficCondition_Weather_SNOW = 5,
  TrafficCondition_Weather_ICE = 6,
  TrafficCondition_Weather_STRONG_WIND = 7
};
bool TrafficCondition_Weather_IsValid(int value);
constexpr TrafficCondition_Weather TrafficCondition_Weather_Weather_MIN = TrafficCondition_Weather_UNKNOWN;
constexpr TrafficCondition_Weather TrafficCondition_Weather_Weather_MAX = TrafficCondition_Weather_STRONG_WIND;
constexpr int TrafficCondition_Weather_Weather_ARRAYSIZE = TrafficCondition_Weather_Weather_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TrafficCondition_Weather_descriptor();
template<typename T>
inline const std::string& TrafficCondition_Weather_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TrafficCondition_Weather>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TrafficCondition_Weather_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TrafficCondition_Weather_descriptor(), enum_t_value);
}
inline bool TrafficCondition_Weather_Parse(
    const std::string& name, TrafficCondition_Weather* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TrafficCondition_Weather>(
    TrafficCondition_Weather_descriptor(), name, value);
}
enum TrafficCondition_FuzzyTime : int {
  TrafficCondition_FuzzyTime_TIME_UNKNOWN = 1,
  TrafficCondition_FuzzyTime_TIME_DAY = 2,
  TrafficCondition_FuzzyTime_TIME_NIGHT = 3
};
bool TrafficCondition_FuzzyTime_IsValid(int value);
constexpr TrafficCondition_FuzzyTime TrafficCondition_FuzzyTime_FuzzyTime_MIN = TrafficCondition_FuzzyTime_TIME_UNKNOWN;
constexpr TrafficCondition_FuzzyTime TrafficCondition_FuzzyTime_FuzzyTime_MAX = TrafficCondition_FuzzyTime_TIME_NIGHT;
constexpr int TrafficCondition_FuzzyTime_FuzzyTime_ARRAYSIZE = TrafficCondition_FuzzyTime_FuzzyTime_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TrafficCondition_FuzzyTime_descriptor();
template<typename T>
inline const std::string& TrafficCondition_FuzzyTime_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TrafficCondition_FuzzyTime>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TrafficCondition_FuzzyTime_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TrafficCondition_FuzzyTime_descriptor(), enum_t_value);
}
inline bool TrafficCondition_FuzzyTime_Parse(
    const std::string& name, TrafficCondition_FuzzyTime* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TrafficCondition_FuzzyTime>(
    TrafficCondition_FuzzyTime_descriptor(), name, value);
}
enum TrafficCondition_TurnDirection : int {
  TrafficCondition_TurnDirection_NONE = 0,
  TrafficCondition_TurnDirection_STRAIGHT = 1,
  TrafficCondition_TurnDirection_SLIGHT_RIGHT = 2,
  TrafficCondition_TurnDirection_RIGHT = 4,
  TrafficCondition_TurnDirection_HARD_RIGHT = 8,
  TrafficCondition_TurnDirection_UTURN = 16,
  TrafficCondition_TurnDirection_HARD_LEFT = 32,
  TrafficCondition_TurnDirection_LEFT = 64,
  TrafficCondition_TurnDirection_SLIGHT_LEFT = 128,
  TrafficCondition_TurnDirection_NA = -1
};
bool TrafficCondition_TurnDirection_IsValid(int value);
constexpr TrafficCondition_TurnDirection TrafficCondition_TurnDirection_TurnDirection_MIN = TrafficCondition_TurnDirection_NA;
constexpr TrafficCondition_TurnDirection TrafficCondition_TurnDirection_TurnDirection_MAX = TrafficCondition_TurnDirection_SLIGHT_LEFT;
constexpr int TrafficCondition_TurnDirection_TurnDirection_ARRAYSIZE = TrafficCondition_TurnDirection_TurnDirection_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TrafficCondition_TurnDirection_descriptor();
template<typename T>
inline const std::string& TrafficCondition_TurnDirection_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TrafficCondition_TurnDirection>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TrafficCondition_TurnDirection_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TrafficCondition_TurnDirection_descriptor(), enum_t_value);
}
inline bool TrafficCondition_TurnDirection_Parse(
    const std::string& name, TrafficCondition_TurnDirection* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TrafficCondition_TurnDirection>(
    TrafficCondition_TurnDirection_descriptor(), name, value);
}
enum TrafficSign_SignType : int {
  TrafficSign_SignType_UNKNOWN = 0,
  TrafficSign_SignType_STOP_FOR = 1,
  TrafficSign_SignType_SLOW_FOR = 2,
  TrafficSign_SignType_GIVE_WAY = 3,
  TrafficSign_SignType_NOWAY = 4,
  TrafficSign_SignType_NO_ENTRY = 5,
  TrafficSign_SignType_NO_PARKING = 6,
  TrafficSign_SignType_NO_LONG_PARKING = 7,
  TrafficSign_SignType_PARKING_CHECK = 8,
  TrafficSign_SignType_NO_MOTOR = 9,
  TrafficSign_SignType_SPEED_LIMIT_HIGH = 10,
  TrafficSign_SignType_SPEED_LIMIT_LOW = 11,
  TrafficSign_SignType_SPEED_LIMIT_REMOVED = 12,
  TrafficSign_SignType_CHILDREN_SCHOOLZONE = 13,
  TrafficSign_SignType_ROADWORKS = 14,
  TrafficSign_SignType_OVERTAKINGPROHIBITED = 15,
  TrafficSign_SignType_ENDOFPROHIBITIONONOVERTAKING = 16,
  TrafficSign_SignType_ENDOFHIGHWAY = 17,
  TrafficSign_SignType_STARTOFHIGHWAY = 18,
  TrafficSign_SignType_LEFTCURVE = 19,
  TrafficSign_SignType_RIGHTCURVE = 20,
  TrafficSign_SignType_SERIESCURVES = 21
};
bool TrafficSign_SignType_IsValid(int value);
constexpr TrafficSign_SignType TrafficSign_SignType_SignType_MIN = TrafficSign_SignType_UNKNOWN;
constexpr TrafficSign_SignType TrafficSign_SignType_SignType_MAX = TrafficSign_SignType_SERIESCURVES;
constexpr int TrafficSign_SignType_SignType_ARRAYSIZE = TrafficSign_SignType_SignType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TrafficSign_SignType_descriptor();
template<typename T>
inline const std::string& TrafficSign_SignType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TrafficSign_SignType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TrafficSign_SignType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TrafficSign_SignType_descriptor(), enum_t_value);
}
inline bool TrafficSign_SignType_Parse(
    const std::string& name, TrafficSign_SignType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TrafficSign_SignType>(
    TrafficSign_SignType_descriptor(), name, value);
}
enum TrafficSign_Shape : int {
  TrafficSign_Shape_UNKNOWN_SHAPE = 0,
  TrafficSign_Shape_RECTANGLE = 1,
  TrafficSign_Shape_TRIANGLE = 2,
  TrafficSign_Shape_CIRCLE = 3,
  TrafficSign_Shape_DIAMOND = 4,
  TrafficSign_Shape_HEXAGON = 5,
  TrafficSign_Shape_OCTAGON = 6,
  TrafficSign_Shape_FURCATION = 7,
  TrafficSign_Shape_COMBINATION = 8,
  TrafficSign_Shape_OTHER_SHAPE = 99
};
bool TrafficSign_Shape_IsValid(int value);
constexpr TrafficSign_Shape TrafficSign_Shape_Shape_MIN = TrafficSign_Shape_UNKNOWN_SHAPE;
constexpr TrafficSign_Shape TrafficSign_Shape_Shape_MAX = TrafficSign_Shape_OTHER_SHAPE;
constexpr int TrafficSign_Shape_Shape_ARRAYSIZE = TrafficSign_Shape_Shape_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TrafficSign_Shape_descriptor();
template<typename T>
inline const std::string& TrafficSign_Shape_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TrafficSign_Shape>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TrafficSign_Shape_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TrafficSign_Shape_descriptor(), enum_t_value);
}
inline bool TrafficSign_Shape_Parse(
    const std::string& name, TrafficSign_Shape* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TrafficSign_Shape>(
    TrafficSign_Shape_descriptor(), name, value);
}
enum TrafficLight_LightType : int {
  TrafficLight_LightType_NONE = 0,
  TrafficLight_LightType_ROUND = 1,
  TrafficLight_LightType_CROSS = 2,
  TrafficLight_LightType_PEDESTRIAN = 3,
  TrafficLight_LightType_BICYCLE = 4,
  TrafficLight_LightType_ARROW = 5,
  TrafficLight_LightType_TIME = 6
};
bool TrafficLight_LightType_IsValid(int value);
constexpr TrafficLight_LightType TrafficLight_LightType_LightType_MIN = TrafficLight_LightType_NONE;
constexpr TrafficLight_LightType TrafficLight_LightType_LightType_MAX = TrafficLight_LightType_TIME;
constexpr int TrafficLight_LightType_LightType_ARRAYSIZE = TrafficLight_LightType_LightType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TrafficLight_LightType_descriptor();
template<typename T>
inline const std::string& TrafficLight_LightType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TrafficLight_LightType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TrafficLight_LightType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TrafficLight_LightType_descriptor(), enum_t_value);
}
inline bool TrafficLight_LightType_Parse(
    const std::string& name, TrafficLight_LightType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TrafficLight_LightType>(
    TrafficLight_LightType_descriptor(), name, value);
}
enum LaneMarking_MarkingType : int {
  LaneMarking_MarkingType_ARROW_UNKNOWN = 0,
  LaneMarking_MarkingType_ARROW_LEFT = 1,
  LaneMarking_MarkingType_ARROW_FORWARD = 2,
  LaneMarking_MarkingType_ARROW_RIGHT = 3,
  LaneMarking_MarkingType_ARROW_LEFT_AND_FORWARD = 4,
  LaneMarking_MarkingType_ARROW_RIGHT_AND_FORWARD = 5,
  LaneMarking_MarkingType_ARROW_LEFT_AND_RIGHT = 6,
  LaneMarking_MarkingType_ARROW_U_TURN = 7,
  LaneMarking_MarkingType_ARROW_U_TURN_AND_FORWARD = 8,
  LaneMarking_MarkingType_ARROW_U_TURN_AND_LEFT = 9,
  LaneMarking_MarkingType_ARROW_MERGE_LEFT = 10,
  LaneMarking_MarkingType_ARROW_MERGE_RIGHT = 11,
  LaneMarking_MarkingType_CROSSWALK_NOTICE = 12,
  LaneMarking_MarkingType_SPEED_LIMIT_LOW = 13,
  LaneMarking_MarkingType_SPEED_LIMIT_HIGH = 14,
  LaneMarking_MarkingType_ARROW_NO_LEFT_TURN = 15,
  LaneMarking_MarkingType_ARROW_NO_RIGHT_TURN = 16,
  LaneMarking_MarkingType_ARROW_NO_U_TURN = 17,
  LaneMarking_MarkingType_ARROW_FORWARD_AND_LEFT_AND_RIGHT = 18,
  LaneMarking_MarkingType_ARROW_FORWARD_AND_U_TURN_AND_LEFT = 19,
  LaneMarking_MarkingType_ARROW_RIGHT_AND_U_TURN = 20,
  LaneMarking_MarkingType_MARKING_TEXT = 21,
  LaneMarking_MarkingType_MARKING_TIME = 22,
  LaneMarking_MarkingType_CHECK_FOLLOWING_DISTANCE = 23,
  LaneMarking_MarkingType_STOPTO_GIVE_WAY = 24,
  LaneMarking_MarkingType_SLOWDOWN_TO_GIVE_WAY = 25,
  LaneMarking_MarkingType_MARKING_NETS = 27
};
bool LaneMarking_MarkingType_IsValid(int value);
constexpr LaneMarking_MarkingType LaneMarking_MarkingType_MarkingType_MIN = LaneMarking_MarkingType_ARROW_UNKNOWN;
constexpr LaneMarking_MarkingType LaneMarking_MarkingType_MarkingType_MAX = LaneMarking_MarkingType_MARKING_NETS;
constexpr int LaneMarking_MarkingType_MarkingType_ARRAYSIZE = LaneMarking_MarkingType_MarkingType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LaneMarking_MarkingType_descriptor();
template<typename T>
inline const std::string& LaneMarking_MarkingType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LaneMarking_MarkingType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LaneMarking_MarkingType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LaneMarking_MarkingType_descriptor(), enum_t_value);
}
inline bool LaneMarking_MarkingType_Parse(
    const std::string& name, LaneMarking_MarkingType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LaneMarking_MarkingType>(
    LaneMarking_MarkingType_descriptor(), name, value);
}
enum TrafficInfo_InfoType : int {
  TrafficInfo_InfoType_SIGN = 1,
  TrafficInfo_InfoType_LIGHT = 2,
  TrafficInfo_InfoType_LANE_MARK = 4,
  TrafficInfo_InfoType_SPEED_BUMP = 5
};
bool TrafficInfo_InfoType_IsValid(int value);
constexpr TrafficInfo_InfoType TrafficInfo_InfoType_InfoType_MIN = TrafficInfo_InfoType_SIGN;
constexpr TrafficInfo_InfoType TrafficInfo_InfoType_InfoType_MAX = TrafficInfo_InfoType_SPEED_BUMP;
constexpr int TrafficInfo_InfoType_InfoType_ARRAYSIZE = TrafficInfo_InfoType_InfoType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TrafficInfo_InfoType_descriptor();
template<typename T>
inline const std::string& TrafficInfo_InfoType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TrafficInfo_InfoType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TrafficInfo_InfoType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TrafficInfo_InfoType_descriptor(), enum_t_value);
}
inline bool TrafficInfo_InfoType_Parse(
    const std::string& name, TrafficInfo_InfoType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TrafficInfo_InfoType>(
    TrafficInfo_InfoType_descriptor(), name, value);
}
// ===================================================================

class TrafficCondition PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RoadPB.TrafficCondition) */ {
 public:
  inline TrafficCondition() : TrafficCondition(nullptr) {};
  virtual ~TrafficCondition();

  TrafficCondition(const TrafficCondition& from);
  TrafficCondition(TrafficCondition&& from) noexcept
    : TrafficCondition() {
    *this = ::std::move(from);
  }

  inline TrafficCondition& operator=(const TrafficCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrafficCondition& operator=(TrafficCondition&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TrafficCondition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrafficCondition* internal_default_instance() {
    return reinterpret_cast<const TrafficCondition*>(
               &_TrafficCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(TrafficCondition& a, TrafficCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(TrafficCondition* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrafficCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TrafficCondition* New() const final {
    return CreateMaybeMessage<TrafficCondition>(nullptr);
  }

  TrafficCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TrafficCondition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TrafficCondition& from);
  void MergeFrom(const TrafficCondition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrafficCondition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RoadPB.TrafficCondition";
  }
  protected:
  explicit TrafficCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_traffic_2ftraffic_2eproto);
    return ::descriptor_table_traffic_2ftraffic_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef TrafficCondition_ConditionType ConditionType;
  static constexpr ConditionType NUMERIC =
    TrafficCondition_ConditionType_NUMERIC;
  static constexpr ConditionType VEHICLE =
    TrafficCondition_ConditionType_VEHICLE;
  static constexpr ConditionType LOAD =
    TrafficCondition_ConditionType_LOAD;
  static constexpr ConditionType TIME_OF_DAY =
    TrafficCondition_ConditionType_TIME_OF_DAY;
  static constexpr ConditionType WEATHER =
    TrafficCondition_ConditionType_WEATHER;
  static constexpr ConditionType FUZZY_TIME =
    TrafficCondition_ConditionType_FUZZY_TIME;
  static constexpr ConditionType TURN_DIRECTION =
    TrafficCondition_ConditionType_TURN_DIRECTION;
  static inline bool ConditionType_IsValid(int value) {
    return TrafficCondition_ConditionType_IsValid(value);
  }
  static constexpr ConditionType ConditionType_MIN =
    TrafficCondition_ConditionType_ConditionType_MIN;
  static constexpr ConditionType ConditionType_MAX =
    TrafficCondition_ConditionType_ConditionType_MAX;
  static constexpr int ConditionType_ARRAYSIZE =
    TrafficCondition_ConditionType_ConditionType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ConditionType_descriptor() {
    return TrafficCondition_ConditionType_descriptor();
  }
  template<typename T>
  static inline const std::string& ConditionType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ConditionType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ConditionType_Name.");
    return TrafficCondition_ConditionType_Name(enum_t_value);
  }
  static inline bool ConditionType_Parse(const std::string& name,
      ConditionType* value) {
    return TrafficCondition_ConditionType_Parse(name, value);
  }

  typedef TrafficCondition_LoadType LoadType;
  static constexpr LoadType WATER_POLLUTING =
    TrafficCondition_LoadType_WATER_POLLUTING;
  static constexpr LoadType EXPLOSIVE =
    TrafficCondition_LoadType_EXPLOSIVE;
  static constexpr LoadType OTHER_DANGEROUS =
    TrafficCondition_LoadType_OTHER_DANGEROUS;
  static constexpr LoadType EMPTY =
    TrafficCondition_LoadType_EMPTY;
  static constexpr LoadType SPECIAL =
    TrafficCondition_LoadType_SPECIAL;
  static constexpr LoadType GASSES =
    TrafficCondition_LoadType_GASSES;
  static constexpr LoadType FLAMMABLE_LIQUIDS =
    TrafficCondition_LoadType_FLAMMABLE_LIQUIDS;
  static constexpr LoadType FLAMMABLE_SOLIDS =
    TrafficCondition_LoadType_FLAMMABLE_SOLIDS;
  static constexpr LoadType OXIDIZING =
    TrafficCondition_LoadType_OXIDIZING;
  static constexpr LoadType TOXIC_INFECTIOUS =
    TrafficCondition_LoadType_TOXIC_INFECTIOUS;
  static constexpr LoadType RADIO_ACTIVE =
    TrafficCondition_LoadType_RADIO_ACTIVE;
  static constexpr LoadType CORROSIVE =
    TrafficCondition_LoadType_CORROSIVE;
  static inline bool LoadType_IsValid(int value) {
    return TrafficCondition_LoadType_IsValid(value);
  }
  static constexpr LoadType LoadType_MIN =
    TrafficCondition_LoadType_LoadType_MIN;
  static constexpr LoadType LoadType_MAX =
    TrafficCondition_LoadType_LoadType_MAX;
  static constexpr int LoadType_ARRAYSIZE =
    TrafficCondition_LoadType_LoadType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  LoadType_descriptor() {
    return TrafficCondition_LoadType_descriptor();
  }
  template<typename T>
  static inline const std::string& LoadType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LoadType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LoadType_Name.");
    return TrafficCondition_LoadType_Name(enum_t_value);
  }
  static inline bool LoadType_Parse(const std::string& name,
      LoadType* value) {
    return TrafficCondition_LoadType_Parse(name, value);
  }

  typedef TrafficCondition_Weather Weather;
  static constexpr Weather UNKNOWN =
    TrafficCondition_Weather_UNKNOWN;
  static constexpr Weather NO_SPECIAL =
    TrafficCondition_Weather_NO_SPECIAL;
  static constexpr Weather SUNSHINE =
    TrafficCondition_Weather_SUNSHINE;
  static constexpr Weather RAIN =
    TrafficCondition_Weather_RAIN;
  static constexpr Weather FOG =
    TrafficCondition_Weather_FOG;
  static constexpr Weather SNOW =
    TrafficCondition_Weather_SNOW;
  static constexpr Weather ICE =
    TrafficCondition_Weather_ICE;
  static constexpr Weather STRONG_WIND =
    TrafficCondition_Weather_STRONG_WIND;
  static inline bool Weather_IsValid(int value) {
    return TrafficCondition_Weather_IsValid(value);
  }
  static constexpr Weather Weather_MIN =
    TrafficCondition_Weather_Weather_MIN;
  static constexpr Weather Weather_MAX =
    TrafficCondition_Weather_Weather_MAX;
  static constexpr int Weather_ARRAYSIZE =
    TrafficCondition_Weather_Weather_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Weather_descriptor() {
    return TrafficCondition_Weather_descriptor();
  }
  template<typename T>
  static inline const std::string& Weather_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Weather>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Weather_Name.");
    return TrafficCondition_Weather_Name(enum_t_value);
  }
  static inline bool Weather_Parse(const std::string& name,
      Weather* value) {
    return TrafficCondition_Weather_Parse(name, value);
  }

  typedef TrafficCondition_FuzzyTime FuzzyTime;
  static constexpr FuzzyTime TIME_UNKNOWN =
    TrafficCondition_FuzzyTime_TIME_UNKNOWN;
  static constexpr FuzzyTime TIME_DAY =
    TrafficCondition_FuzzyTime_TIME_DAY;
  static constexpr FuzzyTime TIME_NIGHT =
    TrafficCondition_FuzzyTime_TIME_NIGHT;
  static inline bool FuzzyTime_IsValid(int value) {
    return TrafficCondition_FuzzyTime_IsValid(value);
  }
  static constexpr FuzzyTime FuzzyTime_MIN =
    TrafficCondition_FuzzyTime_FuzzyTime_MIN;
  static constexpr FuzzyTime FuzzyTime_MAX =
    TrafficCondition_FuzzyTime_FuzzyTime_MAX;
  static constexpr int FuzzyTime_ARRAYSIZE =
    TrafficCondition_FuzzyTime_FuzzyTime_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  FuzzyTime_descriptor() {
    return TrafficCondition_FuzzyTime_descriptor();
  }
  template<typename T>
  static inline const std::string& FuzzyTime_Name(T enum_t_value) {
    static_assert(::std::is_same<T, FuzzyTime>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function FuzzyTime_Name.");
    return TrafficCondition_FuzzyTime_Name(enum_t_value);
  }
  static inline bool FuzzyTime_Parse(const std::string& name,
      FuzzyTime* value) {
    return TrafficCondition_FuzzyTime_Parse(name, value);
  }

  typedef TrafficCondition_TurnDirection TurnDirection;
  static constexpr TurnDirection NONE =
    TrafficCondition_TurnDirection_NONE;
  static constexpr TurnDirection STRAIGHT =
    TrafficCondition_TurnDirection_STRAIGHT;
  static constexpr TurnDirection SLIGHT_RIGHT =
    TrafficCondition_TurnDirection_SLIGHT_RIGHT;
  static constexpr TurnDirection RIGHT =
    TrafficCondition_TurnDirection_RIGHT;
  static constexpr TurnDirection HARD_RIGHT =
    TrafficCondition_TurnDirection_HARD_RIGHT;
  static constexpr TurnDirection UTURN =
    TrafficCondition_TurnDirection_UTURN;
  static constexpr TurnDirection HARD_LEFT =
    TrafficCondition_TurnDirection_HARD_LEFT;
  static constexpr TurnDirection LEFT =
    TrafficCondition_TurnDirection_LEFT;
  static constexpr TurnDirection SLIGHT_LEFT =
    TrafficCondition_TurnDirection_SLIGHT_LEFT;
  static constexpr TurnDirection NA =
    TrafficCondition_TurnDirection_NA;
  static inline bool TurnDirection_IsValid(int value) {
    return TrafficCondition_TurnDirection_IsValid(value);
  }
  static constexpr TurnDirection TurnDirection_MIN =
    TrafficCondition_TurnDirection_TurnDirection_MIN;
  static constexpr TurnDirection TurnDirection_MAX =
    TrafficCondition_TurnDirection_TurnDirection_MAX;
  static constexpr int TurnDirection_ARRAYSIZE =
    TrafficCondition_TurnDirection_TurnDirection_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  TurnDirection_descriptor() {
    return TrafficCondition_TurnDirection_descriptor();
  }
  template<typename T>
  static inline const std::string& TurnDirection_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TurnDirection>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TurnDirection_Name.");
    return TrafficCondition_TurnDirection_Name(enum_t_value);
  }
  static inline bool TurnDirection_Parse(const std::string& name,
      TurnDirection* value) {
    return TrafficCondition_TurnDirection_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kValueFieldNumber = 2,
    kVehicleTypeMaskFieldNumber = 3,
    kLoadTypeFieldNumber = 4,
    kStartMinuesFieldNumber = 5,
    kEndMinuesFieldNumber = 6,
    kWeatherFieldNumber = 7,
    kFuzzyTimeFieldNumber = 8,
    kDirectionFieldNumber = 9,
  };
  // optional int32 type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::PROTOBUF_NAMESPACE_ID::int32 type() const;
  void set_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_type() const;
  void _internal_set_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  ::PROTOBUF_NAMESPACE_ID::int32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_value() const;
  void _internal_set_value(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 vehicle_type_mask = 3;
  bool has_vehicle_type_mask() const;
  private:
  bool _internal_has_vehicle_type_mask() const;
  public:
  void clear_vehicle_type_mask();
  ::PROTOBUF_NAMESPACE_ID::int32 vehicle_type_mask() const;
  void set_vehicle_type_mask(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_vehicle_type_mask() const;
  void _internal_set_vehicle_type_mask(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 load_type = 4;
  bool has_load_type() const;
  private:
  bool _internal_has_load_type() const;
  public:
  void clear_load_type();
  ::PROTOBUF_NAMESPACE_ID::int32 load_type() const;
  void set_load_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_load_type() const;
  void _internal_set_load_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 start_minues = 5;
  bool has_start_minues() const;
  private:
  bool _internal_has_start_minues() const;
  public:
  void clear_start_minues();
  ::PROTOBUF_NAMESPACE_ID::int32 start_minues() const;
  void set_start_minues(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_start_minues() const;
  void _internal_set_start_minues(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 end_minues = 6;
  bool has_end_minues() const;
  private:
  bool _internal_has_end_minues() const;
  public:
  void clear_end_minues();
  ::PROTOBUF_NAMESPACE_ID::int32 end_minues() const;
  void set_end_minues(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_end_minues() const;
  void _internal_set_end_minues(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 weather = 7;
  bool has_weather() const;
  private:
  bool _internal_has_weather() const;
  public:
  void clear_weather();
  ::PROTOBUF_NAMESPACE_ID::int32 weather() const;
  void set_weather(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_weather() const;
  void _internal_set_weather(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 fuzzy_time = 8;
  bool has_fuzzy_time() const;
  private:
  bool _internal_has_fuzzy_time() const;
  public:
  void clear_fuzzy_time();
  ::PROTOBUF_NAMESPACE_ID::int32 fuzzy_time() const;
  void set_fuzzy_time(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_fuzzy_time() const;
  void _internal_set_fuzzy_time(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 direction = 9;
  bool has_direction() const;
  private:
  bool _internal_has_direction() const;
  public:
  void clear_direction();
  ::PROTOBUF_NAMESPACE_ID::int32 direction() const;
  void set_direction(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_direction() const;
  void _internal_set_direction(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:RoadPB.TrafficCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 type_;
  ::PROTOBUF_NAMESPACE_ID::int32 value_;
  ::PROTOBUF_NAMESPACE_ID::int32 vehicle_type_mask_;
  ::PROTOBUF_NAMESPACE_ID::int32 load_type_;
  ::PROTOBUF_NAMESPACE_ID::int32 start_minues_;
  ::PROTOBUF_NAMESPACE_ID::int32 end_minues_;
  ::PROTOBUF_NAMESPACE_ID::int32 weather_;
  ::PROTOBUF_NAMESPACE_ID::int32 fuzzy_time_;
  ::PROTOBUF_NAMESPACE_ID::int32 direction_;
  friend struct ::TableStruct_traffic_2ftraffic_2eproto;
};
// -------------------------------------------------------------------

class TrafficSign PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RoadPB.TrafficSign) */ {
 public:
  inline TrafficSign() : TrafficSign(nullptr) {};
  virtual ~TrafficSign();

  TrafficSign(const TrafficSign& from);
  TrafficSign(TrafficSign&& from) noexcept
    : TrafficSign() {
    *this = ::std::move(from);
  }

  inline TrafficSign& operator=(const TrafficSign& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrafficSign& operator=(TrafficSign&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TrafficSign& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrafficSign* internal_default_instance() {
    return reinterpret_cast<const TrafficSign*>(
               &_TrafficSign_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(TrafficSign& a, TrafficSign& b) {
    a.Swap(&b);
  }
  inline void Swap(TrafficSign* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrafficSign* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TrafficSign* New() const final {
    return CreateMaybeMessage<TrafficSign>(nullptr);
  }

  TrafficSign* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TrafficSign>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TrafficSign& from);
  void MergeFrom(const TrafficSign& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrafficSign* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RoadPB.TrafficSign";
  }
  protected:
  explicit TrafficSign(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_traffic_2ftraffic_2eproto);
    return ::descriptor_table_traffic_2ftraffic_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef TrafficSign_SignType SignType;
  static constexpr SignType UNKNOWN =
    TrafficSign_SignType_UNKNOWN;
  static constexpr SignType STOP_FOR =
    TrafficSign_SignType_STOP_FOR;
  static constexpr SignType SLOW_FOR =
    TrafficSign_SignType_SLOW_FOR;
  static constexpr SignType GIVE_WAY =
    TrafficSign_SignType_GIVE_WAY;
  static constexpr SignType NOWAY =
    TrafficSign_SignType_NOWAY;
  static constexpr SignType NO_ENTRY =
    TrafficSign_SignType_NO_ENTRY;
  static constexpr SignType NO_PARKING =
    TrafficSign_SignType_NO_PARKING;
  static constexpr SignType NO_LONG_PARKING =
    TrafficSign_SignType_NO_LONG_PARKING;
  static constexpr SignType PARKING_CHECK =
    TrafficSign_SignType_PARKING_CHECK;
  static constexpr SignType NO_MOTOR =
    TrafficSign_SignType_NO_MOTOR;
  static constexpr SignType SPEED_LIMIT_HIGH =
    TrafficSign_SignType_SPEED_LIMIT_HIGH;
  static constexpr SignType SPEED_LIMIT_LOW =
    TrafficSign_SignType_SPEED_LIMIT_LOW;
  static constexpr SignType SPEED_LIMIT_REMOVED =
    TrafficSign_SignType_SPEED_LIMIT_REMOVED;
  static constexpr SignType CHILDREN_SCHOOLZONE =
    TrafficSign_SignType_CHILDREN_SCHOOLZONE;
  static constexpr SignType ROADWORKS =
    TrafficSign_SignType_ROADWORKS;
  static constexpr SignType OVERTAKINGPROHIBITED =
    TrafficSign_SignType_OVERTAKINGPROHIBITED;
  static constexpr SignType ENDOFPROHIBITIONONOVERTAKING =
    TrafficSign_SignType_ENDOFPROHIBITIONONOVERTAKING;
  static constexpr SignType ENDOFHIGHWAY =
    TrafficSign_SignType_ENDOFHIGHWAY;
  static constexpr SignType STARTOFHIGHWAY =
    TrafficSign_SignType_STARTOFHIGHWAY;
  static constexpr SignType LEFTCURVE =
    TrafficSign_SignType_LEFTCURVE;
  static constexpr SignType RIGHTCURVE =
    TrafficSign_SignType_RIGHTCURVE;
  static constexpr SignType SERIESCURVES =
    TrafficSign_SignType_SERIESCURVES;
  static inline bool SignType_IsValid(int value) {
    return TrafficSign_SignType_IsValid(value);
  }
  static constexpr SignType SignType_MIN =
    TrafficSign_SignType_SignType_MIN;
  static constexpr SignType SignType_MAX =
    TrafficSign_SignType_SignType_MAX;
  static constexpr int SignType_ARRAYSIZE =
    TrafficSign_SignType_SignType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SignType_descriptor() {
    return TrafficSign_SignType_descriptor();
  }
  template<typename T>
  static inline const std::string& SignType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SignType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SignType_Name.");
    return TrafficSign_SignType_Name(enum_t_value);
  }
  static inline bool SignType_Parse(const std::string& name,
      SignType* value) {
    return TrafficSign_SignType_Parse(name, value);
  }

  typedef TrafficSign_Shape Shape;
  static constexpr Shape UNKNOWN_SHAPE =
    TrafficSign_Shape_UNKNOWN_SHAPE;
  static constexpr Shape RECTANGLE =
    TrafficSign_Shape_RECTANGLE;
  static constexpr Shape TRIANGLE =
    TrafficSign_Shape_TRIANGLE;
  static constexpr Shape CIRCLE =
    TrafficSign_Shape_CIRCLE;
  static constexpr Shape DIAMOND =
    TrafficSign_Shape_DIAMOND;
  static constexpr Shape HEXAGON =
    TrafficSign_Shape_HEXAGON;
  static constexpr Shape OCTAGON =
    TrafficSign_Shape_OCTAGON;
  static constexpr Shape FURCATION =
    TrafficSign_Shape_FURCATION;
  static constexpr Shape COMBINATION =
    TrafficSign_Shape_COMBINATION;
  static constexpr Shape OTHER_SHAPE =
    TrafficSign_Shape_OTHER_SHAPE;
  static inline bool Shape_IsValid(int value) {
    return TrafficSign_Shape_IsValid(value);
  }
  static constexpr Shape Shape_MIN =
    TrafficSign_Shape_Shape_MIN;
  static constexpr Shape Shape_MAX =
    TrafficSign_Shape_Shape_MAX;
  static constexpr int Shape_ARRAYSIZE =
    TrafficSign_Shape_Shape_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Shape_descriptor() {
    return TrafficSign_Shape_descriptor();
  }
  template<typename T>
  static inline const std::string& Shape_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Shape>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Shape_Name.");
    return TrafficSign_Shape_Name(enum_t_value);
  }
  static inline bool Shape_Parse(const std::string& name,
      Shape* value) {
    return TrafficSign_Shape_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPanelsFieldNumber = 9,
    kContentFieldNumber = 7,
    kTypeFieldNumber = 3,
    kShapeFieldNumber = 4,
    kValueFieldNumber = 6,
    kVariableFieldNumber = 8,
  };
  // repeated .RoadPB.TrafficCondition panels = 9;
  int panels_size() const;
  private:
  int _internal_panels_size() const;
  public:
  void clear_panels();
  ::RoadPB::TrafficCondition* mutable_panels(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::TrafficCondition >*
      mutable_panels();
  private:
  const ::RoadPB::TrafficCondition& _internal_panels(int index) const;
  ::RoadPB::TrafficCondition* _internal_add_panels();
  public:
  const ::RoadPB::TrafficCondition& panels(int index) const;
  ::RoadPB::TrafficCondition* add_panels();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::TrafficCondition >&
      panels() const;

  // optional string content = 7;
  bool has_content() const;
  private:
  bool _internal_has_content() const;
  public:
  void clear_content();
  const std::string& content() const;
  void set_content(const std::string& value);
  void set_content(std::string&& value);
  void set_content(const char* value);
  void set_content(const char* value, size_t size);
  std::string* mutable_content();
  std::string* release_content();
  void set_allocated_content(std::string* content);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_content();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_content(
      std::string* content);
  private:
  const std::string& _internal_content() const;
  void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // optional int32 type = 3;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::PROTOBUF_NAMESPACE_ID::int32 type() const;
  void set_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_type() const;
  void _internal_set_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 shape = 4;
  bool has_shape() const;
  private:
  bool _internal_has_shape() const;
  public:
  void clear_shape();
  ::PROTOBUF_NAMESPACE_ID::int32 shape() const;
  void set_shape(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_shape() const;
  void _internal_set_shape(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional float value = 6;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  float value() const;
  void set_value(float value);
  private:
  float _internal_value() const;
  void _internal_set_value(float value);
  public:

  // optional bool variable = 8;
  bool has_variable() const;
  private:
  bool _internal_has_variable() const;
  public:
  void clear_variable();
  bool variable() const;
  void set_variable(bool value);
  private:
  bool _internal_variable() const;
  void _internal_set_variable(bool value);
  public:

  // @@protoc_insertion_point(class_scope:RoadPB.TrafficSign)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::TrafficCondition > panels_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
  ::PROTOBUF_NAMESPACE_ID::int32 type_;
  ::PROTOBUF_NAMESPACE_ID::int32 shape_;
  float value_;
  bool variable_;
  friend struct ::TableStruct_traffic_2ftraffic_2eproto;
};
// -------------------------------------------------------------------

class TrafficLight PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RoadPB.TrafficLight) */ {
 public:
  inline TrafficLight() : TrafficLight(nullptr) {};
  virtual ~TrafficLight();

  TrafficLight(const TrafficLight& from);
  TrafficLight(TrafficLight&& from) noexcept
    : TrafficLight() {
    *this = ::std::move(from);
  }

  inline TrafficLight& operator=(const TrafficLight& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrafficLight& operator=(TrafficLight&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TrafficLight& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrafficLight* internal_default_instance() {
    return reinterpret_cast<const TrafficLight*>(
               &_TrafficLight_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(TrafficLight& a, TrafficLight& b) {
    a.Swap(&b);
  }
  inline void Swap(TrafficLight* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrafficLight* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TrafficLight* New() const final {
    return CreateMaybeMessage<TrafficLight>(nullptr);
  }

  TrafficLight* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TrafficLight>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TrafficLight& from);
  void MergeFrom(const TrafficLight& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrafficLight* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RoadPB.TrafficLight";
  }
  protected:
  explicit TrafficLight(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_traffic_2ftraffic_2eproto);
    return ::descriptor_table_traffic_2ftraffic_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef TrafficLight_LightType LightType;
  static constexpr LightType NONE =
    TrafficLight_LightType_NONE;
  static constexpr LightType ROUND =
    TrafficLight_LightType_ROUND;
  static constexpr LightType CROSS =
    TrafficLight_LightType_CROSS;
  static constexpr LightType PEDESTRIAN =
    TrafficLight_LightType_PEDESTRIAN;
  static constexpr LightType BICYCLE =
    TrafficLight_LightType_BICYCLE;
  static constexpr LightType ARROW =
    TrafficLight_LightType_ARROW;
  static constexpr LightType TIME =
    TrafficLight_LightType_TIME;
  static inline bool LightType_IsValid(int value) {
    return TrafficLight_LightType_IsValid(value);
  }
  static constexpr LightType LightType_MIN =
    TrafficLight_LightType_LightType_MIN;
  static constexpr LightType LightType_MAX =
    TrafficLight_LightType_LightType_MAX;
  static constexpr int LightType_ARRAYSIZE =
    TrafficLight_LightType_LightType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  LightType_descriptor() {
    return TrafficLight_LightType_descriptor();
  }
  template<typename T>
  static inline const std::string& LightType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LightType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LightType_Name.");
    return TrafficLight_LightType_Name(enum_t_value);
  }
  static inline bool LightType_Parse(const std::string& name,
      LightType* value) {
    return TrafficLight_LightType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kArrangeFieldNumber = 4,
    kBulbsNumFieldNumber = 10,
  };
  // optional int32 type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::PROTOBUF_NAMESPACE_ID::int32 type() const;
  void set_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_type() const;
  void _internal_set_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 arrange = 4;
  bool has_arrange() const;
  private:
  bool _internal_has_arrange() const;
  public:
  void clear_arrange();
  ::PROTOBUF_NAMESPACE_ID::int32 arrange() const;
  void set_arrange(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_arrange() const;
  void _internal_set_arrange(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 bulbs_num = 10;
  bool has_bulbs_num() const;
  private:
  bool _internal_has_bulbs_num() const;
  public:
  void clear_bulbs_num();
  ::PROTOBUF_NAMESPACE_ID::int32 bulbs_num() const;
  void set_bulbs_num(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_bulbs_num() const;
  void _internal_set_bulbs_num(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:RoadPB.TrafficLight)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 type_;
  ::PROTOBUF_NAMESPACE_ID::int32 arrange_;
  ::PROTOBUF_NAMESPACE_ID::int32 bulbs_num_;
  friend struct ::TableStruct_traffic_2ftraffic_2eproto;
};
// -------------------------------------------------------------------

class LaneMarking PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RoadPB.LaneMarking) */ {
 public:
  inline LaneMarking() : LaneMarking(nullptr) {};
  virtual ~LaneMarking();

  LaneMarking(const LaneMarking& from);
  LaneMarking(LaneMarking&& from) noexcept
    : LaneMarking() {
    *this = ::std::move(from);
  }

  inline LaneMarking& operator=(const LaneMarking& from) {
    CopyFrom(from);
    return *this;
  }
  inline LaneMarking& operator=(LaneMarking&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LaneMarking& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LaneMarking* internal_default_instance() {
    return reinterpret_cast<const LaneMarking*>(
               &_LaneMarking_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(LaneMarking& a, LaneMarking& b) {
    a.Swap(&b);
  }
  inline void Swap(LaneMarking* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LaneMarking* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LaneMarking* New() const final {
    return CreateMaybeMessage<LaneMarking>(nullptr);
  }

  LaneMarking* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LaneMarking>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LaneMarking& from);
  void MergeFrom(const LaneMarking& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LaneMarking* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RoadPB.LaneMarking";
  }
  protected:
  explicit LaneMarking(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_traffic_2ftraffic_2eproto);
    return ::descriptor_table_traffic_2ftraffic_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef LaneMarking_MarkingType MarkingType;
  static constexpr MarkingType ARROW_UNKNOWN =
    LaneMarking_MarkingType_ARROW_UNKNOWN;
  static constexpr MarkingType ARROW_LEFT =
    LaneMarking_MarkingType_ARROW_LEFT;
  static constexpr MarkingType ARROW_FORWARD =
    LaneMarking_MarkingType_ARROW_FORWARD;
  static constexpr MarkingType ARROW_RIGHT =
    LaneMarking_MarkingType_ARROW_RIGHT;
  static constexpr MarkingType ARROW_LEFT_AND_FORWARD =
    LaneMarking_MarkingType_ARROW_LEFT_AND_FORWARD;
  static constexpr MarkingType ARROW_RIGHT_AND_FORWARD =
    LaneMarking_MarkingType_ARROW_RIGHT_AND_FORWARD;
  static constexpr MarkingType ARROW_LEFT_AND_RIGHT =
    LaneMarking_MarkingType_ARROW_LEFT_AND_RIGHT;
  static constexpr MarkingType ARROW_U_TURN =
    LaneMarking_MarkingType_ARROW_U_TURN;
  static constexpr MarkingType ARROW_U_TURN_AND_FORWARD =
    LaneMarking_MarkingType_ARROW_U_TURN_AND_FORWARD;
  static constexpr MarkingType ARROW_U_TURN_AND_LEFT =
    LaneMarking_MarkingType_ARROW_U_TURN_AND_LEFT;
  static constexpr MarkingType ARROW_MERGE_LEFT =
    LaneMarking_MarkingType_ARROW_MERGE_LEFT;
  static constexpr MarkingType ARROW_MERGE_RIGHT =
    LaneMarking_MarkingType_ARROW_MERGE_RIGHT;
  static constexpr MarkingType CROSSWALK_NOTICE =
    LaneMarking_MarkingType_CROSSWALK_NOTICE;
  static constexpr MarkingType SPEED_LIMIT_LOW =
    LaneMarking_MarkingType_SPEED_LIMIT_LOW;
  static constexpr MarkingType SPEED_LIMIT_HIGH =
    LaneMarking_MarkingType_SPEED_LIMIT_HIGH;
  static constexpr MarkingType ARROW_NO_LEFT_TURN =
    LaneMarking_MarkingType_ARROW_NO_LEFT_TURN;
  static constexpr MarkingType ARROW_NO_RIGHT_TURN =
    LaneMarking_MarkingType_ARROW_NO_RIGHT_TURN;
  static constexpr MarkingType ARROW_NO_U_TURN =
    LaneMarking_MarkingType_ARROW_NO_U_TURN;
  static constexpr MarkingType ARROW_FORWARD_AND_LEFT_AND_RIGHT =
    LaneMarking_MarkingType_ARROW_FORWARD_AND_LEFT_AND_RIGHT;
  static constexpr MarkingType ARROW_FORWARD_AND_U_TURN_AND_LEFT =
    LaneMarking_MarkingType_ARROW_FORWARD_AND_U_TURN_AND_LEFT;
  static constexpr MarkingType ARROW_RIGHT_AND_U_TURN =
    LaneMarking_MarkingType_ARROW_RIGHT_AND_U_TURN;
  static constexpr MarkingType MARKING_TEXT =
    LaneMarking_MarkingType_MARKING_TEXT;
  static constexpr MarkingType MARKING_TIME =
    LaneMarking_MarkingType_MARKING_TIME;
  static constexpr MarkingType CHECK_FOLLOWING_DISTANCE =
    LaneMarking_MarkingType_CHECK_FOLLOWING_DISTANCE;
  static constexpr MarkingType STOPTO_GIVE_WAY =
    LaneMarking_MarkingType_STOPTO_GIVE_WAY;
  static constexpr MarkingType SLOWDOWN_TO_GIVE_WAY =
    LaneMarking_MarkingType_SLOWDOWN_TO_GIVE_WAY;
  static constexpr MarkingType MARKING_NETS =
    LaneMarking_MarkingType_MARKING_NETS;
  static inline bool MarkingType_IsValid(int value) {
    return LaneMarking_MarkingType_IsValid(value);
  }
  static constexpr MarkingType MarkingType_MIN =
    LaneMarking_MarkingType_MarkingType_MIN;
  static constexpr MarkingType MarkingType_MAX =
    LaneMarking_MarkingType_MarkingType_MAX;
  static constexpr int MarkingType_ARRAYSIZE =
    LaneMarking_MarkingType_MarkingType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  MarkingType_descriptor() {
    return LaneMarking_MarkingType_descriptor();
  }
  template<typename T>
  static inline const std::string& MarkingType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MarkingType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MarkingType_Name.");
    return LaneMarking_MarkingType_Name(enum_t_value);
  }
  static inline bool MarkingType_Parse(const std::string& name,
      MarkingType* value) {
    return LaneMarking_MarkingType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kContentFieldNumber = 7,
    kTypeFieldNumber = 1,
    kValueFieldNumber = 6,
  };
  // optional string content = 7;
  bool has_content() const;
  private:
  bool _internal_has_content() const;
  public:
  void clear_content();
  const std::string& content() const;
  void set_content(const std::string& value);
  void set_content(std::string&& value);
  void set_content(const char* value);
  void set_content(const char* value, size_t size);
  std::string* mutable_content();
  std::string* release_content();
  void set_allocated_content(std::string* content);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_content();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_content(
      std::string* content);
  private:
  const std::string& _internal_content() const;
  void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // optional int32 type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::PROTOBUF_NAMESPACE_ID::int32 type() const;
  void set_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_type() const;
  void _internal_set_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional float value = 6;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  float value() const;
  void set_value(float value);
  private:
  float _internal_value() const;
  void _internal_set_value(float value);
  public:

  // @@protoc_insertion_point(class_scope:RoadPB.LaneMarking)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
  ::PROTOBUF_NAMESPACE_ID::int32 type_;
  float value_;
  friend struct ::TableStruct_traffic_2ftraffic_2eproto;
};
// -------------------------------------------------------------------

class SpeedBump PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RoadPB.SpeedBump) */ {
 public:
  inline SpeedBump() : SpeedBump(nullptr) {};
  virtual ~SpeedBump();

  SpeedBump(const SpeedBump& from);
  SpeedBump(SpeedBump&& from) noexcept
    : SpeedBump() {
    *this = ::std::move(from);
  }

  inline SpeedBump& operator=(const SpeedBump& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpeedBump& operator=(SpeedBump&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SpeedBump& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SpeedBump* internal_default_instance() {
    return reinterpret_cast<const SpeedBump*>(
               &_SpeedBump_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SpeedBump& a, SpeedBump& b) {
    a.Swap(&b);
  }
  inline void Swap(SpeedBump* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpeedBump* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpeedBump* New() const final {
    return CreateMaybeMessage<SpeedBump>(nullptr);
  }

  SpeedBump* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpeedBump>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SpeedBump& from);
  void MergeFrom(const SpeedBump& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpeedBump* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RoadPB.SpeedBump";
  }
  protected:
  explicit SpeedBump(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_traffic_2ftraffic_2eproto);
    return ::descriptor_table_traffic_2ftraffic_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeightFieldNumber = 1,
  };
  // optional float height = 1;
  bool has_height() const;
  private:
  bool _internal_has_height() const;
  public:
  void clear_height();
  float height() const;
  void set_height(float value);
  private:
  float _internal_height() const;
  void _internal_set_height(float value);
  public:

  // @@protoc_insertion_point(class_scope:RoadPB.SpeedBump)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float height_;
  friend struct ::TableStruct_traffic_2ftraffic_2eproto;
};
// -------------------------------------------------------------------

class TrafficInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RoadPB.TrafficInfo) */ {
 public:
  inline TrafficInfo() : TrafficInfo(nullptr) {};
  virtual ~TrafficInfo();

  TrafficInfo(const TrafficInfo& from);
  TrafficInfo(TrafficInfo&& from) noexcept
    : TrafficInfo() {
    *this = ::std::move(from);
  }

  inline TrafficInfo& operator=(const TrafficInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrafficInfo& operator=(TrafficInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TrafficInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrafficInfo* internal_default_instance() {
    return reinterpret_cast<const TrafficInfo*>(
               &_TrafficInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(TrafficInfo& a, TrafficInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TrafficInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrafficInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TrafficInfo* New() const final {
    return CreateMaybeMessage<TrafficInfo>(nullptr);
  }

  TrafficInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TrafficInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TrafficInfo& from);
  void MergeFrom(const TrafficInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrafficInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RoadPB.TrafficInfo";
  }
  protected:
  explicit TrafficInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_traffic_2ftraffic_2eproto);
    return ::descriptor_table_traffic_2ftraffic_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef TrafficInfo_InfoType InfoType;
  static constexpr InfoType SIGN =
    TrafficInfo_InfoType_SIGN;
  static constexpr InfoType LIGHT =
    TrafficInfo_InfoType_LIGHT;
  static constexpr InfoType LANE_MARK =
    TrafficInfo_InfoType_LANE_MARK;
  static constexpr InfoType SPEED_BUMP =
    TrafficInfo_InfoType_SPEED_BUMP;
  static inline bool InfoType_IsValid(int value) {
    return TrafficInfo_InfoType_IsValid(value);
  }
  static constexpr InfoType InfoType_MIN =
    TrafficInfo_InfoType_InfoType_MIN;
  static constexpr InfoType InfoType_MAX =
    TrafficInfo_InfoType_InfoType_MAX;
  static constexpr int InfoType_ARRAYSIZE =
    TrafficInfo_InfoType_InfoType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  InfoType_descriptor() {
    return TrafficInfo_InfoType_descriptor();
  }
  template<typename T>
  static inline const std::string& InfoType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, InfoType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function InfoType_Name.");
    return TrafficInfo_InfoType_Name(enum_t_value);
  }
  static inline bool InfoType_Parse(const std::string& name,
      InfoType* value) {
    return TrafficInfo_InfoType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kObjsFieldNumber = 2,
    kIdFieldNumber = 1,
    kLanesFieldNumber = 4,
    kLanegroupsFieldNumber = 5,
    kSignFieldNumber = 6,
    kLightFieldNumber = 7,
    kMarkingFieldNumber = 9,
    kBumpFieldNumber = 10,
    kTypeFieldNumber = 3,
  };
  // repeated .RoadPB.FeatureID objs = 2;
  int objs_size() const;
  private:
  int _internal_objs_size() const;
  public:
  void clear_objs();
  ::RoadPB::FeatureID* mutable_objs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID >*
      mutable_objs();
  private:
  const ::RoadPB::FeatureID& _internal_objs(int index) const;
  ::RoadPB::FeatureID* _internal_add_objs();
  public:
  const ::RoadPB::FeatureID& objs(int index) const;
  ::RoadPB::FeatureID* add_objs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID >&
      objs() const;

  // optional .RoadPB.FeatureID id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::RoadPB::FeatureID& id() const;
  ::RoadPB::FeatureID* release_id();
  ::RoadPB::FeatureID* mutable_id();
  void set_allocated_id(::RoadPB::FeatureID* id);
  private:
  const ::RoadPB::FeatureID& _internal_id() const;
  ::RoadPB::FeatureID* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::RoadPB::FeatureID* id);
  ::RoadPB::FeatureID* unsafe_arena_release_id();

  // optional .RoadPB.FeatureID lanes = 4;
  bool has_lanes() const;
  private:
  bool _internal_has_lanes() const;
  public:
  void clear_lanes();
  const ::RoadPB::FeatureID& lanes() const;
  ::RoadPB::FeatureID* release_lanes();
  ::RoadPB::FeatureID* mutable_lanes();
  void set_allocated_lanes(::RoadPB::FeatureID* lanes);
  private:
  const ::RoadPB::FeatureID& _internal_lanes() const;
  ::RoadPB::FeatureID* _internal_mutable_lanes();
  public:
  void unsafe_arena_set_allocated_lanes(
      ::RoadPB::FeatureID* lanes);
  ::RoadPB::FeatureID* unsafe_arena_release_lanes();

  // optional .RoadPB.FeatureID lanegroups = 5;
  bool has_lanegroups() const;
  private:
  bool _internal_has_lanegroups() const;
  public:
  void clear_lanegroups();
  const ::RoadPB::FeatureID& lanegroups() const;
  ::RoadPB::FeatureID* release_lanegroups();
  ::RoadPB::FeatureID* mutable_lanegroups();
  void set_allocated_lanegroups(::RoadPB::FeatureID* lanegroups);
  private:
  const ::RoadPB::FeatureID& _internal_lanegroups() const;
  ::RoadPB::FeatureID* _internal_mutable_lanegroups();
  public:
  void unsafe_arena_set_allocated_lanegroups(
      ::RoadPB::FeatureID* lanegroups);
  ::RoadPB::FeatureID* unsafe_arena_release_lanegroups();

  // optional .RoadPB.TrafficSign sign = 6;
  bool has_sign() const;
  private:
  bool _internal_has_sign() const;
  public:
  void clear_sign();
  const ::RoadPB::TrafficSign& sign() const;
  ::RoadPB::TrafficSign* release_sign();
  ::RoadPB::TrafficSign* mutable_sign();
  void set_allocated_sign(::RoadPB::TrafficSign* sign);
  private:
  const ::RoadPB::TrafficSign& _internal_sign() const;
  ::RoadPB::TrafficSign* _internal_mutable_sign();
  public:
  void unsafe_arena_set_allocated_sign(
      ::RoadPB::TrafficSign* sign);
  ::RoadPB::TrafficSign* unsafe_arena_release_sign();

  // optional .RoadPB.TrafficLight light = 7;
  bool has_light() const;
  private:
  bool _internal_has_light() const;
  public:
  void clear_light();
  const ::RoadPB::TrafficLight& light() const;
  ::RoadPB::TrafficLight* release_light();
  ::RoadPB::TrafficLight* mutable_light();
  void set_allocated_light(::RoadPB::TrafficLight* light);
  private:
  const ::RoadPB::TrafficLight& _internal_light() const;
  ::RoadPB::TrafficLight* _internal_mutable_light();
  public:
  void unsafe_arena_set_allocated_light(
      ::RoadPB::TrafficLight* light);
  ::RoadPB::TrafficLight* unsafe_arena_release_light();

  // optional .RoadPB.LaneMarking marking = 9;
  bool has_marking() const;
  private:
  bool _internal_has_marking() const;
  public:
  void clear_marking();
  const ::RoadPB::LaneMarking& marking() const;
  ::RoadPB::LaneMarking* release_marking();
  ::RoadPB::LaneMarking* mutable_marking();
  void set_allocated_marking(::RoadPB::LaneMarking* marking);
  private:
  const ::RoadPB::LaneMarking& _internal_marking() const;
  ::RoadPB::LaneMarking* _internal_mutable_marking();
  public:
  void unsafe_arena_set_allocated_marking(
      ::RoadPB::LaneMarking* marking);
  ::RoadPB::LaneMarking* unsafe_arena_release_marking();

  // optional .RoadPB.SpeedBump bump = 10;
  bool has_bump() const;
  private:
  bool _internal_has_bump() const;
  public:
  void clear_bump();
  const ::RoadPB::SpeedBump& bump() const;
  ::RoadPB::SpeedBump* release_bump();
  ::RoadPB::SpeedBump* mutable_bump();
  void set_allocated_bump(::RoadPB::SpeedBump* bump);
  private:
  const ::RoadPB::SpeedBump& _internal_bump() const;
  ::RoadPB::SpeedBump* _internal_mutable_bump();
  public:
  void unsafe_arena_set_allocated_bump(
      ::RoadPB::SpeedBump* bump);
  ::RoadPB::SpeedBump* unsafe_arena_release_bump();

  // optional int32 type = 3;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::PROTOBUF_NAMESPACE_ID::int32 type() const;
  void set_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_type() const;
  void _internal_set_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:RoadPB.TrafficInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID > objs_;
  ::RoadPB::FeatureID* id_;
  ::RoadPB::FeatureID* lanes_;
  ::RoadPB::FeatureID* lanegroups_;
  ::RoadPB::TrafficSign* sign_;
  ::RoadPB::TrafficLight* light_;
  ::RoadPB::LaneMarking* marking_;
  ::RoadPB::SpeedBump* bump_;
  ::PROTOBUF_NAMESPACE_ID::int32 type_;
  friend struct ::TableStruct_traffic_2ftraffic_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TrafficCondition

// optional int32 type = 1;
inline bool TrafficCondition::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TrafficCondition::has_type() const {
  return _internal_has_type();
}
inline void TrafficCondition::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TrafficCondition::_internal_type() const {
  return type_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TrafficCondition::type() const {
  // @@protoc_insertion_point(field_get:RoadPB.TrafficCondition.type)
  return _internal_type();
}
inline void TrafficCondition::_internal_set_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  type_ = value;
}
inline void TrafficCondition::set_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:RoadPB.TrafficCondition.type)
}

// optional int32 value = 2;
inline bool TrafficCondition::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TrafficCondition::has_value() const {
  return _internal_has_value();
}
inline void TrafficCondition::clear_value() {
  value_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TrafficCondition::_internal_value() const {
  return value_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TrafficCondition::value() const {
  // @@protoc_insertion_point(field_get:RoadPB.TrafficCondition.value)
  return _internal_value();
}
inline void TrafficCondition::_internal_set_value(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  value_ = value;
}
inline void TrafficCondition::set_value(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:RoadPB.TrafficCondition.value)
}

// optional int32 vehicle_type_mask = 3;
inline bool TrafficCondition::_internal_has_vehicle_type_mask() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TrafficCondition::has_vehicle_type_mask() const {
  return _internal_has_vehicle_type_mask();
}
inline void TrafficCondition::clear_vehicle_type_mask() {
  vehicle_type_mask_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TrafficCondition::_internal_vehicle_type_mask() const {
  return vehicle_type_mask_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TrafficCondition::vehicle_type_mask() const {
  // @@protoc_insertion_point(field_get:RoadPB.TrafficCondition.vehicle_type_mask)
  return _internal_vehicle_type_mask();
}
inline void TrafficCondition::_internal_set_vehicle_type_mask(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  vehicle_type_mask_ = value;
}
inline void TrafficCondition::set_vehicle_type_mask(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_vehicle_type_mask(value);
  // @@protoc_insertion_point(field_set:RoadPB.TrafficCondition.vehicle_type_mask)
}

// optional int32 load_type = 4;
inline bool TrafficCondition::_internal_has_load_type() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TrafficCondition::has_load_type() const {
  return _internal_has_load_type();
}
inline void TrafficCondition::clear_load_type() {
  load_type_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TrafficCondition::_internal_load_type() const {
  return load_type_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TrafficCondition::load_type() const {
  // @@protoc_insertion_point(field_get:RoadPB.TrafficCondition.load_type)
  return _internal_load_type();
}
inline void TrafficCondition::_internal_set_load_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  load_type_ = value;
}
inline void TrafficCondition::set_load_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_load_type(value);
  // @@protoc_insertion_point(field_set:RoadPB.TrafficCondition.load_type)
}

// optional int32 start_minues = 5;
inline bool TrafficCondition::_internal_has_start_minues() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TrafficCondition::has_start_minues() const {
  return _internal_has_start_minues();
}
inline void TrafficCondition::clear_start_minues() {
  start_minues_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TrafficCondition::_internal_start_minues() const {
  return start_minues_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TrafficCondition::start_minues() const {
  // @@protoc_insertion_point(field_get:RoadPB.TrafficCondition.start_minues)
  return _internal_start_minues();
}
inline void TrafficCondition::_internal_set_start_minues(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  start_minues_ = value;
}
inline void TrafficCondition::set_start_minues(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_start_minues(value);
  // @@protoc_insertion_point(field_set:RoadPB.TrafficCondition.start_minues)
}

// optional int32 end_minues = 6;
inline bool TrafficCondition::_internal_has_end_minues() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TrafficCondition::has_end_minues() const {
  return _internal_has_end_minues();
}
inline void TrafficCondition::clear_end_minues() {
  end_minues_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TrafficCondition::_internal_end_minues() const {
  return end_minues_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TrafficCondition::end_minues() const {
  // @@protoc_insertion_point(field_get:RoadPB.TrafficCondition.end_minues)
  return _internal_end_minues();
}
inline void TrafficCondition::_internal_set_end_minues(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000020u;
  end_minues_ = value;
}
inline void TrafficCondition::set_end_minues(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_end_minues(value);
  // @@protoc_insertion_point(field_set:RoadPB.TrafficCondition.end_minues)
}

// optional int32 weather = 7;
inline bool TrafficCondition::_internal_has_weather() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool TrafficCondition::has_weather() const {
  return _internal_has_weather();
}
inline void TrafficCondition::clear_weather() {
  weather_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TrafficCondition::_internal_weather() const {
  return weather_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TrafficCondition::weather() const {
  // @@protoc_insertion_point(field_get:RoadPB.TrafficCondition.weather)
  return _internal_weather();
}
inline void TrafficCondition::_internal_set_weather(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000040u;
  weather_ = value;
}
inline void TrafficCondition::set_weather(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_weather(value);
  // @@protoc_insertion_point(field_set:RoadPB.TrafficCondition.weather)
}

// optional int32 fuzzy_time = 8;
inline bool TrafficCondition::_internal_has_fuzzy_time() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool TrafficCondition::has_fuzzy_time() const {
  return _internal_has_fuzzy_time();
}
inline void TrafficCondition::clear_fuzzy_time() {
  fuzzy_time_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TrafficCondition::_internal_fuzzy_time() const {
  return fuzzy_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TrafficCondition::fuzzy_time() const {
  // @@protoc_insertion_point(field_get:RoadPB.TrafficCondition.fuzzy_time)
  return _internal_fuzzy_time();
}
inline void TrafficCondition::_internal_set_fuzzy_time(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000080u;
  fuzzy_time_ = value;
}
inline void TrafficCondition::set_fuzzy_time(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_fuzzy_time(value);
  // @@protoc_insertion_point(field_set:RoadPB.TrafficCondition.fuzzy_time)
}

// optional int32 direction = 9;
inline bool TrafficCondition::_internal_has_direction() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool TrafficCondition::has_direction() const {
  return _internal_has_direction();
}
inline void TrafficCondition::clear_direction() {
  direction_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TrafficCondition::_internal_direction() const {
  return direction_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TrafficCondition::direction() const {
  // @@protoc_insertion_point(field_get:RoadPB.TrafficCondition.direction)
  return _internal_direction();
}
inline void TrafficCondition::_internal_set_direction(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000100u;
  direction_ = value;
}
inline void TrafficCondition::set_direction(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_direction(value);
  // @@protoc_insertion_point(field_set:RoadPB.TrafficCondition.direction)
}

// -------------------------------------------------------------------

// TrafficSign

// optional int32 type = 3;
inline bool TrafficSign::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TrafficSign::has_type() const {
  return _internal_has_type();
}
inline void TrafficSign::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TrafficSign::_internal_type() const {
  return type_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TrafficSign::type() const {
  // @@protoc_insertion_point(field_get:RoadPB.TrafficSign.type)
  return _internal_type();
}
inline void TrafficSign::_internal_set_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  type_ = value;
}
inline void TrafficSign::set_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:RoadPB.TrafficSign.type)
}

// optional int32 shape = 4;
inline bool TrafficSign::_internal_has_shape() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TrafficSign::has_shape() const {
  return _internal_has_shape();
}
inline void TrafficSign::clear_shape() {
  shape_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TrafficSign::_internal_shape() const {
  return shape_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TrafficSign::shape() const {
  // @@protoc_insertion_point(field_get:RoadPB.TrafficSign.shape)
  return _internal_shape();
}
inline void TrafficSign::_internal_set_shape(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  shape_ = value;
}
inline void TrafficSign::set_shape(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_shape(value);
  // @@protoc_insertion_point(field_set:RoadPB.TrafficSign.shape)
}

// optional float value = 6;
inline bool TrafficSign::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TrafficSign::has_value() const {
  return _internal_has_value();
}
inline void TrafficSign::clear_value() {
  value_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float TrafficSign::_internal_value() const {
  return value_;
}
inline float TrafficSign::value() const {
  // @@protoc_insertion_point(field_get:RoadPB.TrafficSign.value)
  return _internal_value();
}
inline void TrafficSign::_internal_set_value(float value) {
  _has_bits_[0] |= 0x00000008u;
  value_ = value;
}
inline void TrafficSign::set_value(float value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:RoadPB.TrafficSign.value)
}

// optional string content = 7;
inline bool TrafficSign::_internal_has_content() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TrafficSign::has_content() const {
  return _internal_has_content();
}
inline void TrafficSign::clear_content() {
  content_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TrafficSign::content() const {
  // @@protoc_insertion_point(field_get:RoadPB.TrafficSign.content)
  return _internal_content();
}
inline void TrafficSign::set_content(const std::string& value) {
  _internal_set_content(value);
  // @@protoc_insertion_point(field_set:RoadPB.TrafficSign.content)
}
inline std::string* TrafficSign::mutable_content() {
  // @@protoc_insertion_point(field_mutable:RoadPB.TrafficSign.content)
  return _internal_mutable_content();
}
inline const std::string& TrafficSign::_internal_content() const {
  return content_.Get();
}
inline void TrafficSign::_internal_set_content(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  content_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TrafficSign::set_content(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  content_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:RoadPB.TrafficSign.content)
}
inline void TrafficSign::set_content(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  content_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:RoadPB.TrafficSign.content)
}
inline void TrafficSign::set_content(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  content_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:RoadPB.TrafficSign.content)
}
inline std::string* TrafficSign::_internal_mutable_content() {
  _has_bits_[0] |= 0x00000001u;
  return content_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TrafficSign::release_content() {
  // @@protoc_insertion_point(field_release:RoadPB.TrafficSign.content)
  if (!_internal_has_content()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return content_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TrafficSign::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  content_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), content,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:RoadPB.TrafficSign.content)
}
inline std::string* TrafficSign::unsafe_arena_release_content() {
  // @@protoc_insertion_point(field_unsafe_arena_release:RoadPB.TrafficSign.content)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return content_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void TrafficSign::unsafe_arena_set_allocated_content(
    std::string* content) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (content != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  content_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      content, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RoadPB.TrafficSign.content)
}

// optional bool variable = 8;
inline bool TrafficSign::_internal_has_variable() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TrafficSign::has_variable() const {
  return _internal_has_variable();
}
inline void TrafficSign::clear_variable() {
  variable_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool TrafficSign::_internal_variable() const {
  return variable_;
}
inline bool TrafficSign::variable() const {
  // @@protoc_insertion_point(field_get:RoadPB.TrafficSign.variable)
  return _internal_variable();
}
inline void TrafficSign::_internal_set_variable(bool value) {
  _has_bits_[0] |= 0x00000010u;
  variable_ = value;
}
inline void TrafficSign::set_variable(bool value) {
  _internal_set_variable(value);
  // @@protoc_insertion_point(field_set:RoadPB.TrafficSign.variable)
}

// repeated .RoadPB.TrafficCondition panels = 9;
inline int TrafficSign::_internal_panels_size() const {
  return panels_.size();
}
inline int TrafficSign::panels_size() const {
  return _internal_panels_size();
}
inline void TrafficSign::clear_panels() {
  panels_.Clear();
}
inline ::RoadPB::TrafficCondition* TrafficSign::mutable_panels(int index) {
  // @@protoc_insertion_point(field_mutable:RoadPB.TrafficSign.panels)
  return panels_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::TrafficCondition >*
TrafficSign::mutable_panels() {
  // @@protoc_insertion_point(field_mutable_list:RoadPB.TrafficSign.panels)
  return &panels_;
}
inline const ::RoadPB::TrafficCondition& TrafficSign::_internal_panels(int index) const {
  return panels_.Get(index);
}
inline const ::RoadPB::TrafficCondition& TrafficSign::panels(int index) const {
  // @@protoc_insertion_point(field_get:RoadPB.TrafficSign.panels)
  return _internal_panels(index);
}
inline ::RoadPB::TrafficCondition* TrafficSign::_internal_add_panels() {
  return panels_.Add();
}
inline ::RoadPB::TrafficCondition* TrafficSign::add_panels() {
  // @@protoc_insertion_point(field_add:RoadPB.TrafficSign.panels)
  return _internal_add_panels();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::TrafficCondition >&
TrafficSign::panels() const {
  // @@protoc_insertion_point(field_list:RoadPB.TrafficSign.panels)
  return panels_;
}

// -------------------------------------------------------------------

// TrafficLight

// optional int32 type = 1;
inline bool TrafficLight::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TrafficLight::has_type() const {
  return _internal_has_type();
}
inline void TrafficLight::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TrafficLight::_internal_type() const {
  return type_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TrafficLight::type() const {
  // @@protoc_insertion_point(field_get:RoadPB.TrafficLight.type)
  return _internal_type();
}
inline void TrafficLight::_internal_set_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  type_ = value;
}
inline void TrafficLight::set_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:RoadPB.TrafficLight.type)
}

// optional int32 arrange = 4;
inline bool TrafficLight::_internal_has_arrange() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TrafficLight::has_arrange() const {
  return _internal_has_arrange();
}
inline void TrafficLight::clear_arrange() {
  arrange_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TrafficLight::_internal_arrange() const {
  return arrange_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TrafficLight::arrange() const {
  // @@protoc_insertion_point(field_get:RoadPB.TrafficLight.arrange)
  return _internal_arrange();
}
inline void TrafficLight::_internal_set_arrange(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  arrange_ = value;
}
inline void TrafficLight::set_arrange(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_arrange(value);
  // @@protoc_insertion_point(field_set:RoadPB.TrafficLight.arrange)
}

// optional int32 bulbs_num = 10;
inline bool TrafficLight::_internal_has_bulbs_num() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TrafficLight::has_bulbs_num() const {
  return _internal_has_bulbs_num();
}
inline void TrafficLight::clear_bulbs_num() {
  bulbs_num_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TrafficLight::_internal_bulbs_num() const {
  return bulbs_num_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TrafficLight::bulbs_num() const {
  // @@protoc_insertion_point(field_get:RoadPB.TrafficLight.bulbs_num)
  return _internal_bulbs_num();
}
inline void TrafficLight::_internal_set_bulbs_num(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  bulbs_num_ = value;
}
inline void TrafficLight::set_bulbs_num(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_bulbs_num(value);
  // @@protoc_insertion_point(field_set:RoadPB.TrafficLight.bulbs_num)
}

// -------------------------------------------------------------------

// LaneMarking

// optional int32 type = 1;
inline bool LaneMarking::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LaneMarking::has_type() const {
  return _internal_has_type();
}
inline void LaneMarking::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LaneMarking::_internal_type() const {
  return type_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LaneMarking::type() const {
  // @@protoc_insertion_point(field_get:RoadPB.LaneMarking.type)
  return _internal_type();
}
inline void LaneMarking::_internal_set_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  type_ = value;
}
inline void LaneMarking::set_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:RoadPB.LaneMarking.type)
}

// optional float value = 6;
inline bool LaneMarking::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LaneMarking::has_value() const {
  return _internal_has_value();
}
inline void LaneMarking::clear_value() {
  value_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float LaneMarking::_internal_value() const {
  return value_;
}
inline float LaneMarking::value() const {
  // @@protoc_insertion_point(field_get:RoadPB.LaneMarking.value)
  return _internal_value();
}
inline void LaneMarking::_internal_set_value(float value) {
  _has_bits_[0] |= 0x00000004u;
  value_ = value;
}
inline void LaneMarking::set_value(float value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:RoadPB.LaneMarking.value)
}

// optional string content = 7;
inline bool LaneMarking::_internal_has_content() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LaneMarking::has_content() const {
  return _internal_has_content();
}
inline void LaneMarking::clear_content() {
  content_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LaneMarking::content() const {
  // @@protoc_insertion_point(field_get:RoadPB.LaneMarking.content)
  return _internal_content();
}
inline void LaneMarking::set_content(const std::string& value) {
  _internal_set_content(value);
  // @@protoc_insertion_point(field_set:RoadPB.LaneMarking.content)
}
inline std::string* LaneMarking::mutable_content() {
  // @@protoc_insertion_point(field_mutable:RoadPB.LaneMarking.content)
  return _internal_mutable_content();
}
inline const std::string& LaneMarking::_internal_content() const {
  return content_.Get();
}
inline void LaneMarking::_internal_set_content(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  content_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void LaneMarking::set_content(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  content_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:RoadPB.LaneMarking.content)
}
inline void LaneMarking::set_content(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  content_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:RoadPB.LaneMarking.content)
}
inline void LaneMarking::set_content(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  content_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:RoadPB.LaneMarking.content)
}
inline std::string* LaneMarking::_internal_mutable_content() {
  _has_bits_[0] |= 0x00000001u;
  return content_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* LaneMarking::release_content() {
  // @@protoc_insertion_point(field_release:RoadPB.LaneMarking.content)
  if (!_internal_has_content()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return content_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LaneMarking::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  content_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), content,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:RoadPB.LaneMarking.content)
}
inline std::string* LaneMarking::unsafe_arena_release_content() {
  // @@protoc_insertion_point(field_unsafe_arena_release:RoadPB.LaneMarking.content)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return content_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void LaneMarking::unsafe_arena_set_allocated_content(
    std::string* content) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (content != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  content_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      content, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RoadPB.LaneMarking.content)
}

// -------------------------------------------------------------------

// SpeedBump

// optional float height = 1;
inline bool SpeedBump::_internal_has_height() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SpeedBump::has_height() const {
  return _internal_has_height();
}
inline void SpeedBump::clear_height() {
  height_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float SpeedBump::_internal_height() const {
  return height_;
}
inline float SpeedBump::height() const {
  // @@protoc_insertion_point(field_get:RoadPB.SpeedBump.height)
  return _internal_height();
}
inline void SpeedBump::_internal_set_height(float value) {
  _has_bits_[0] |= 0x00000001u;
  height_ = value;
}
inline void SpeedBump::set_height(float value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:RoadPB.SpeedBump.height)
}

// -------------------------------------------------------------------

// TrafficInfo

// optional .RoadPB.FeatureID id = 1;
inline bool TrafficInfo::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || id_ != nullptr);
  return value;
}
inline bool TrafficInfo::has_id() const {
  return _internal_has_id();
}
inline const ::RoadPB::FeatureID& TrafficInfo::_internal_id() const {
  const ::RoadPB::FeatureID* p = id_;
  return p != nullptr ? *p : *reinterpret_cast<const ::RoadPB::FeatureID*>(
      &::RoadPB::_FeatureID_default_instance_);
}
inline const ::RoadPB::FeatureID& TrafficInfo::id() const {
  // @@protoc_insertion_point(field_get:RoadPB.TrafficInfo.id)
  return _internal_id();
}
inline void TrafficInfo::unsafe_arena_set_allocated_id(
    ::RoadPB::FeatureID* id) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  id_ = id;
  if (id) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RoadPB.TrafficInfo.id)
}
inline ::RoadPB::FeatureID* TrafficInfo::release_id() {
  auto temp = unsafe_arena_release_id();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::RoadPB::FeatureID* TrafficInfo::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:RoadPB.TrafficInfo.id)
  _has_bits_[0] &= ~0x00000001u;
  ::RoadPB::FeatureID* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::RoadPB::FeatureID* TrafficInfo::_internal_mutable_id() {
  _has_bits_[0] |= 0x00000001u;
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::RoadPB::FeatureID>(GetArena());
    id_ = p;
  }
  return id_;
}
inline ::RoadPB::FeatureID* TrafficInfo::mutable_id() {
  // @@protoc_insertion_point(field_mutable:RoadPB.TrafficInfo.id)
  return _internal_mutable_id();
}
inline void TrafficInfo::set_allocated_id(::RoadPB::FeatureID* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id)->GetArena();
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:RoadPB.TrafficInfo.id)
}

// repeated .RoadPB.FeatureID objs = 2;
inline int TrafficInfo::_internal_objs_size() const {
  return objs_.size();
}
inline int TrafficInfo::objs_size() const {
  return _internal_objs_size();
}
inline ::RoadPB::FeatureID* TrafficInfo::mutable_objs(int index) {
  // @@protoc_insertion_point(field_mutable:RoadPB.TrafficInfo.objs)
  return objs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID >*
TrafficInfo::mutable_objs() {
  // @@protoc_insertion_point(field_mutable_list:RoadPB.TrafficInfo.objs)
  return &objs_;
}
inline const ::RoadPB::FeatureID& TrafficInfo::_internal_objs(int index) const {
  return objs_.Get(index);
}
inline const ::RoadPB::FeatureID& TrafficInfo::objs(int index) const {
  // @@protoc_insertion_point(field_get:RoadPB.TrafficInfo.objs)
  return _internal_objs(index);
}
inline ::RoadPB::FeatureID* TrafficInfo::_internal_add_objs() {
  return objs_.Add();
}
inline ::RoadPB::FeatureID* TrafficInfo::add_objs() {
  // @@protoc_insertion_point(field_add:RoadPB.TrafficInfo.objs)
  return _internal_add_objs();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoadPB::FeatureID >&
TrafficInfo::objs() const {
  // @@protoc_insertion_point(field_list:RoadPB.TrafficInfo.objs)
  return objs_;
}

// optional int32 type = 3;
inline bool TrafficInfo::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool TrafficInfo::has_type() const {
  return _internal_has_type();
}
inline void TrafficInfo::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TrafficInfo::_internal_type() const {
  return type_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TrafficInfo::type() const {
  // @@protoc_insertion_point(field_get:RoadPB.TrafficInfo.type)
  return _internal_type();
}
inline void TrafficInfo::_internal_set_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000080u;
  type_ = value;
}
inline void TrafficInfo::set_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:RoadPB.TrafficInfo.type)
}

// optional .RoadPB.FeatureID lanes = 4;
inline bool TrafficInfo::_internal_has_lanes() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || lanes_ != nullptr);
  return value;
}
inline bool TrafficInfo::has_lanes() const {
  return _internal_has_lanes();
}
inline const ::RoadPB::FeatureID& TrafficInfo::_internal_lanes() const {
  const ::RoadPB::FeatureID* p = lanes_;
  return p != nullptr ? *p : *reinterpret_cast<const ::RoadPB::FeatureID*>(
      &::RoadPB::_FeatureID_default_instance_);
}
inline const ::RoadPB::FeatureID& TrafficInfo::lanes() const {
  // @@protoc_insertion_point(field_get:RoadPB.TrafficInfo.lanes)
  return _internal_lanes();
}
inline void TrafficInfo::unsafe_arena_set_allocated_lanes(
    ::RoadPB::FeatureID* lanes) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lanes_);
  }
  lanes_ = lanes;
  if (lanes) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RoadPB.TrafficInfo.lanes)
}
inline ::RoadPB::FeatureID* TrafficInfo::release_lanes() {
  auto temp = unsafe_arena_release_lanes();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::RoadPB::FeatureID* TrafficInfo::unsafe_arena_release_lanes() {
  // @@protoc_insertion_point(field_release:RoadPB.TrafficInfo.lanes)
  _has_bits_[0] &= ~0x00000002u;
  ::RoadPB::FeatureID* temp = lanes_;
  lanes_ = nullptr;
  return temp;
}
inline ::RoadPB::FeatureID* TrafficInfo::_internal_mutable_lanes() {
  _has_bits_[0] |= 0x00000002u;
  if (lanes_ == nullptr) {
    auto* p = CreateMaybeMessage<::RoadPB::FeatureID>(GetArena());
    lanes_ = p;
  }
  return lanes_;
}
inline ::RoadPB::FeatureID* TrafficInfo::mutable_lanes() {
  // @@protoc_insertion_point(field_mutable:RoadPB.TrafficInfo.lanes)
  return _internal_mutable_lanes();
}
inline void TrafficInfo::set_allocated_lanes(::RoadPB::FeatureID* lanes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(lanes_);
  }
  if (lanes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lanes)->GetArena();
    if (message_arena != submessage_arena) {
      lanes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lanes, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  lanes_ = lanes;
  // @@protoc_insertion_point(field_set_allocated:RoadPB.TrafficInfo.lanes)
}

// optional .RoadPB.FeatureID lanegroups = 5;
inline bool TrafficInfo::_internal_has_lanegroups() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || lanegroups_ != nullptr);
  return value;
}
inline bool TrafficInfo::has_lanegroups() const {
  return _internal_has_lanegroups();
}
inline const ::RoadPB::FeatureID& TrafficInfo::_internal_lanegroups() const {
  const ::RoadPB::FeatureID* p = lanegroups_;
  return p != nullptr ? *p : *reinterpret_cast<const ::RoadPB::FeatureID*>(
      &::RoadPB::_FeatureID_default_instance_);
}
inline const ::RoadPB::FeatureID& TrafficInfo::lanegroups() const {
  // @@protoc_insertion_point(field_get:RoadPB.TrafficInfo.lanegroups)
  return _internal_lanegroups();
}
inline void TrafficInfo::unsafe_arena_set_allocated_lanegroups(
    ::RoadPB::FeatureID* lanegroups) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lanegroups_);
  }
  lanegroups_ = lanegroups;
  if (lanegroups) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RoadPB.TrafficInfo.lanegroups)
}
inline ::RoadPB::FeatureID* TrafficInfo::release_lanegroups() {
  auto temp = unsafe_arena_release_lanegroups();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::RoadPB::FeatureID* TrafficInfo::unsafe_arena_release_lanegroups() {
  // @@protoc_insertion_point(field_release:RoadPB.TrafficInfo.lanegroups)
  _has_bits_[0] &= ~0x00000004u;
  ::RoadPB::FeatureID* temp = lanegroups_;
  lanegroups_ = nullptr;
  return temp;
}
inline ::RoadPB::FeatureID* TrafficInfo::_internal_mutable_lanegroups() {
  _has_bits_[0] |= 0x00000004u;
  if (lanegroups_ == nullptr) {
    auto* p = CreateMaybeMessage<::RoadPB::FeatureID>(GetArena());
    lanegroups_ = p;
  }
  return lanegroups_;
}
inline ::RoadPB::FeatureID* TrafficInfo::mutable_lanegroups() {
  // @@protoc_insertion_point(field_mutable:RoadPB.TrafficInfo.lanegroups)
  return _internal_mutable_lanegroups();
}
inline void TrafficInfo::set_allocated_lanegroups(::RoadPB::FeatureID* lanegroups) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(lanegroups_);
  }
  if (lanegroups) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lanegroups)->GetArena();
    if (message_arena != submessage_arena) {
      lanegroups = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lanegroups, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  lanegroups_ = lanegroups;
  // @@protoc_insertion_point(field_set_allocated:RoadPB.TrafficInfo.lanegroups)
}

// optional .RoadPB.TrafficSign sign = 6;
inline bool TrafficInfo::_internal_has_sign() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || sign_ != nullptr);
  return value;
}
inline bool TrafficInfo::has_sign() const {
  return _internal_has_sign();
}
inline void TrafficInfo::clear_sign() {
  if (sign_ != nullptr) sign_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::RoadPB::TrafficSign& TrafficInfo::_internal_sign() const {
  const ::RoadPB::TrafficSign* p = sign_;
  return p != nullptr ? *p : *reinterpret_cast<const ::RoadPB::TrafficSign*>(
      &::RoadPB::_TrafficSign_default_instance_);
}
inline const ::RoadPB::TrafficSign& TrafficInfo::sign() const {
  // @@protoc_insertion_point(field_get:RoadPB.TrafficInfo.sign)
  return _internal_sign();
}
inline void TrafficInfo::unsafe_arena_set_allocated_sign(
    ::RoadPB::TrafficSign* sign) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sign_);
  }
  sign_ = sign;
  if (sign) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RoadPB.TrafficInfo.sign)
}
inline ::RoadPB::TrafficSign* TrafficInfo::release_sign() {
  auto temp = unsafe_arena_release_sign();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::RoadPB::TrafficSign* TrafficInfo::unsafe_arena_release_sign() {
  // @@protoc_insertion_point(field_release:RoadPB.TrafficInfo.sign)
  _has_bits_[0] &= ~0x00000008u;
  ::RoadPB::TrafficSign* temp = sign_;
  sign_ = nullptr;
  return temp;
}
inline ::RoadPB::TrafficSign* TrafficInfo::_internal_mutable_sign() {
  _has_bits_[0] |= 0x00000008u;
  if (sign_ == nullptr) {
    auto* p = CreateMaybeMessage<::RoadPB::TrafficSign>(GetArena());
    sign_ = p;
  }
  return sign_;
}
inline ::RoadPB::TrafficSign* TrafficInfo::mutable_sign() {
  // @@protoc_insertion_point(field_mutable:RoadPB.TrafficInfo.sign)
  return _internal_mutable_sign();
}
inline void TrafficInfo::set_allocated_sign(::RoadPB::TrafficSign* sign) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete sign_;
  }
  if (sign) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(sign);
    if (message_arena != submessage_arena) {
      sign = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sign, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  sign_ = sign;
  // @@protoc_insertion_point(field_set_allocated:RoadPB.TrafficInfo.sign)
}

// optional .RoadPB.TrafficLight light = 7;
inline bool TrafficInfo::_internal_has_light() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || light_ != nullptr);
  return value;
}
inline bool TrafficInfo::has_light() const {
  return _internal_has_light();
}
inline void TrafficInfo::clear_light() {
  if (light_ != nullptr) light_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::RoadPB::TrafficLight& TrafficInfo::_internal_light() const {
  const ::RoadPB::TrafficLight* p = light_;
  return p != nullptr ? *p : *reinterpret_cast<const ::RoadPB::TrafficLight*>(
      &::RoadPB::_TrafficLight_default_instance_);
}
inline const ::RoadPB::TrafficLight& TrafficInfo::light() const {
  // @@protoc_insertion_point(field_get:RoadPB.TrafficInfo.light)
  return _internal_light();
}
inline void TrafficInfo::unsafe_arena_set_allocated_light(
    ::RoadPB::TrafficLight* light) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(light_);
  }
  light_ = light;
  if (light) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RoadPB.TrafficInfo.light)
}
inline ::RoadPB::TrafficLight* TrafficInfo::release_light() {
  auto temp = unsafe_arena_release_light();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::RoadPB::TrafficLight* TrafficInfo::unsafe_arena_release_light() {
  // @@protoc_insertion_point(field_release:RoadPB.TrafficInfo.light)
  _has_bits_[0] &= ~0x00000010u;
  ::RoadPB::TrafficLight* temp = light_;
  light_ = nullptr;
  return temp;
}
inline ::RoadPB::TrafficLight* TrafficInfo::_internal_mutable_light() {
  _has_bits_[0] |= 0x00000010u;
  if (light_ == nullptr) {
    auto* p = CreateMaybeMessage<::RoadPB::TrafficLight>(GetArena());
    light_ = p;
  }
  return light_;
}
inline ::RoadPB::TrafficLight* TrafficInfo::mutable_light() {
  // @@protoc_insertion_point(field_mutable:RoadPB.TrafficInfo.light)
  return _internal_mutable_light();
}
inline void TrafficInfo::set_allocated_light(::RoadPB::TrafficLight* light) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete light_;
  }
  if (light) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(light);
    if (message_arena != submessage_arena) {
      light = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, light, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  light_ = light;
  // @@protoc_insertion_point(field_set_allocated:RoadPB.TrafficInfo.light)
}

// optional .RoadPB.LaneMarking marking = 9;
inline bool TrafficInfo::_internal_has_marking() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || marking_ != nullptr);
  return value;
}
inline bool TrafficInfo::has_marking() const {
  return _internal_has_marking();
}
inline void TrafficInfo::clear_marking() {
  if (marking_ != nullptr) marking_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::RoadPB::LaneMarking& TrafficInfo::_internal_marking() const {
  const ::RoadPB::LaneMarking* p = marking_;
  return p != nullptr ? *p : *reinterpret_cast<const ::RoadPB::LaneMarking*>(
      &::RoadPB::_LaneMarking_default_instance_);
}
inline const ::RoadPB::LaneMarking& TrafficInfo::marking() const {
  // @@protoc_insertion_point(field_get:RoadPB.TrafficInfo.marking)
  return _internal_marking();
}
inline void TrafficInfo::unsafe_arena_set_allocated_marking(
    ::RoadPB::LaneMarking* marking) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(marking_);
  }
  marking_ = marking;
  if (marking) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RoadPB.TrafficInfo.marking)
}
inline ::RoadPB::LaneMarking* TrafficInfo::release_marking() {
  auto temp = unsafe_arena_release_marking();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::RoadPB::LaneMarking* TrafficInfo::unsafe_arena_release_marking() {
  // @@protoc_insertion_point(field_release:RoadPB.TrafficInfo.marking)
  _has_bits_[0] &= ~0x00000020u;
  ::RoadPB::LaneMarking* temp = marking_;
  marking_ = nullptr;
  return temp;
}
inline ::RoadPB::LaneMarking* TrafficInfo::_internal_mutable_marking() {
  _has_bits_[0] |= 0x00000020u;
  if (marking_ == nullptr) {
    auto* p = CreateMaybeMessage<::RoadPB::LaneMarking>(GetArena());
    marking_ = p;
  }
  return marking_;
}
inline ::RoadPB::LaneMarking* TrafficInfo::mutable_marking() {
  // @@protoc_insertion_point(field_mutable:RoadPB.TrafficInfo.marking)
  return _internal_mutable_marking();
}
inline void TrafficInfo::set_allocated_marking(::RoadPB::LaneMarking* marking) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete marking_;
  }
  if (marking) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(marking);
    if (message_arena != submessage_arena) {
      marking = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, marking, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  marking_ = marking;
  // @@protoc_insertion_point(field_set_allocated:RoadPB.TrafficInfo.marking)
}

// optional .RoadPB.SpeedBump bump = 10;
inline bool TrafficInfo::_internal_has_bump() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || bump_ != nullptr);
  return value;
}
inline bool TrafficInfo::has_bump() const {
  return _internal_has_bump();
}
inline void TrafficInfo::clear_bump() {
  if (bump_ != nullptr) bump_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::RoadPB::SpeedBump& TrafficInfo::_internal_bump() const {
  const ::RoadPB::SpeedBump* p = bump_;
  return p != nullptr ? *p : *reinterpret_cast<const ::RoadPB::SpeedBump*>(
      &::RoadPB::_SpeedBump_default_instance_);
}
inline const ::RoadPB::SpeedBump& TrafficInfo::bump() const {
  // @@protoc_insertion_point(field_get:RoadPB.TrafficInfo.bump)
  return _internal_bump();
}
inline void TrafficInfo::unsafe_arena_set_allocated_bump(
    ::RoadPB::SpeedBump* bump) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bump_);
  }
  bump_ = bump;
  if (bump) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RoadPB.TrafficInfo.bump)
}
inline ::RoadPB::SpeedBump* TrafficInfo::release_bump() {
  auto temp = unsafe_arena_release_bump();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::RoadPB::SpeedBump* TrafficInfo::unsafe_arena_release_bump() {
  // @@protoc_insertion_point(field_release:RoadPB.TrafficInfo.bump)
  _has_bits_[0] &= ~0x00000040u;
  ::RoadPB::SpeedBump* temp = bump_;
  bump_ = nullptr;
  return temp;
}
inline ::RoadPB::SpeedBump* TrafficInfo::_internal_mutable_bump() {
  _has_bits_[0] |= 0x00000040u;
  if (bump_ == nullptr) {
    auto* p = CreateMaybeMessage<::RoadPB::SpeedBump>(GetArena());
    bump_ = p;
  }
  return bump_;
}
inline ::RoadPB::SpeedBump* TrafficInfo::mutable_bump() {
  // @@protoc_insertion_point(field_mutable:RoadPB.TrafficInfo.bump)
  return _internal_mutable_bump();
}
inline void TrafficInfo::set_allocated_bump(::RoadPB::SpeedBump* bump) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete bump_;
  }
  if (bump) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(bump);
    if (message_arena != submessage_arena) {
      bump = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bump, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  bump_ = bump;
  // @@protoc_insertion_point(field_set_allocated:RoadPB.TrafficInfo.bump)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace RoadPB

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::RoadPB::TrafficCondition_ConditionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RoadPB::TrafficCondition_ConditionType>() {
  return ::RoadPB::TrafficCondition_ConditionType_descriptor();
}
template <> struct is_proto_enum< ::RoadPB::TrafficCondition_LoadType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RoadPB::TrafficCondition_LoadType>() {
  return ::RoadPB::TrafficCondition_LoadType_descriptor();
}
template <> struct is_proto_enum< ::RoadPB::TrafficCondition_Weather> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RoadPB::TrafficCondition_Weather>() {
  return ::RoadPB::TrafficCondition_Weather_descriptor();
}
template <> struct is_proto_enum< ::RoadPB::TrafficCondition_FuzzyTime> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RoadPB::TrafficCondition_FuzzyTime>() {
  return ::RoadPB::TrafficCondition_FuzzyTime_descriptor();
}
template <> struct is_proto_enum< ::RoadPB::TrafficCondition_TurnDirection> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RoadPB::TrafficCondition_TurnDirection>() {
  return ::RoadPB::TrafficCondition_TurnDirection_descriptor();
}
template <> struct is_proto_enum< ::RoadPB::TrafficSign_SignType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RoadPB::TrafficSign_SignType>() {
  return ::RoadPB::TrafficSign_SignType_descriptor();
}
template <> struct is_proto_enum< ::RoadPB::TrafficSign_Shape> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RoadPB::TrafficSign_Shape>() {
  return ::RoadPB::TrafficSign_Shape_descriptor();
}
template <> struct is_proto_enum< ::RoadPB::TrafficLight_LightType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RoadPB::TrafficLight_LightType>() {
  return ::RoadPB::TrafficLight_LightType_descriptor();
}
template <> struct is_proto_enum< ::RoadPB::LaneMarking_MarkingType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RoadPB::LaneMarking_MarkingType>() {
  return ::RoadPB::LaneMarking_MarkingType_descriptor();
}
template <> struct is_proto_enum< ::RoadPB::TrafficInfo_InfoType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RoadPB::TrafficInfo_InfoType>() {
  return ::RoadPB::TrafficInfo_InfoType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_traffic_2ftraffic_2eproto
