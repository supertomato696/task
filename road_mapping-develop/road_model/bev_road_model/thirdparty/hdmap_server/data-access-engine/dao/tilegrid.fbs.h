// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TILEGRID_HADMAPFBS_H_
#define FLATBUFFERS_GENERATED_TILEGRID_HADMAPFBS_H_

#include "flatbuffers/flatbuffers.h"

namespace HadmapFBS {

struct TileGridPoint;

struct ElementID;
struct ElementIDT;

struct CellElement;
struct CellElementT;

struct GridCell;
struct GridCellT;

struct HyperCell;
struct HyperCellT;

struct GridNode;
struct GridNodeT;

struct Point3D;

struct LaneLine3D;
struct LaneLine3DT;

struct TileGrid;
struct TileGridT;

MANUALLY_ALIGNED_STRUCT(8) TileGridPoint FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;
  uint8_t intensity_;
  uint8_t r_or_low_;
  uint8_t g_or_middle_;
  uint8_t b_or_high_;
  int16_t type_;
  int16_t distance_;
  int32_t padding0__;
  int64_t frame_id_;
  double timestamp_;

 public:
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "HadmapFBS.TileGridPoint";
  }
  TileGridPoint() {
    memset(this, 0, sizeof(TileGridPoint));
  }
  TileGridPoint(const TileGridPoint &_o) {
    memcpy(this, &_o, sizeof(TileGridPoint));
  }
  TileGridPoint(float _x, float _y, float _z, uint8_t _intensity, uint8_t _r_or_low, uint8_t _g_or_middle, uint8_t _b_or_high, int16_t _type, int16_t _distance, int64_t _frame_id, double _timestamp)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)),
        intensity_(flatbuffers::EndianScalar(_intensity)),
        r_or_low_(flatbuffers::EndianScalar(_r_or_low)),
        g_or_middle_(flatbuffers::EndianScalar(_g_or_middle)),
        b_or_high_(flatbuffers::EndianScalar(_b_or_high)),
        type_(flatbuffers::EndianScalar(_type)),
        distance_(flatbuffers::EndianScalar(_distance)),
        padding0__(0),
        frame_id_(flatbuffers::EndianScalar(_frame_id)),
        timestamp_(flatbuffers::EndianScalar(_timestamp)) {
    (void)padding0__;
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  void mutate_x(float _x) {
    flatbuffers::WriteScalar(&x_, _x);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  void mutate_y(float _y) {
    flatbuffers::WriteScalar(&y_, _y);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
  void mutate_z(float _z) {
    flatbuffers::WriteScalar(&z_, _z);
  }
  uint8_t intensity() const {
    return flatbuffers::EndianScalar(intensity_);
  }
  void mutate_intensity(uint8_t _intensity) {
    flatbuffers::WriteScalar(&intensity_, _intensity);
  }
  uint8_t r_or_low() const {
    return flatbuffers::EndianScalar(r_or_low_);
  }
  void mutate_r_or_low(uint8_t _r_or_low) {
    flatbuffers::WriteScalar(&r_or_low_, _r_or_low);
  }
  uint8_t g_or_middle() const {
    return flatbuffers::EndianScalar(g_or_middle_);
  }
  void mutate_g_or_middle(uint8_t _g_or_middle) {
    flatbuffers::WriteScalar(&g_or_middle_, _g_or_middle);
  }
  uint8_t b_or_high() const {
    return flatbuffers::EndianScalar(b_or_high_);
  }
  void mutate_b_or_high(uint8_t _b_or_high) {
    flatbuffers::WriteScalar(&b_or_high_, _b_or_high);
  }
  int16_t type() const {
    return flatbuffers::EndianScalar(type_);
  }
  void mutate_type(int16_t _type) {
    flatbuffers::WriteScalar(&type_, _type);
  }
  int16_t distance() const {
    return flatbuffers::EndianScalar(distance_);
  }
  void mutate_distance(int16_t _distance) {
    flatbuffers::WriteScalar(&distance_, _distance);
  }
  int64_t frame_id() const {
    return flatbuffers::EndianScalar(frame_id_);
  }
  void mutate_frame_id(int64_t _frame_id) {
    flatbuffers::WriteScalar(&frame_id_, _frame_id);
  }
  double timestamp() const {
    return flatbuffers::EndianScalar(timestamp_);
  }
  void mutate_timestamp(double _timestamp) {
    flatbuffers::WriteScalar(&timestamp_, _timestamp);
  }
};
STRUCT_END(TileGridPoint, 40);

MANUALLY_ALIGNED_STRUCT(8) Point3D FLATBUFFERS_FINAL_CLASS {
 private:
  double x_;
  double y_;
  double z_;

 public:
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "HadmapFBS.Point3D";
  }
  Point3D() {
    memset(this, 0, sizeof(Point3D));
  }
  Point3D(const Point3D &_o) {
    memcpy(this, &_o, sizeof(Point3D));
  }
  Point3D(double _x, double _y, double _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  double x() const {
    return flatbuffers::EndianScalar(x_);
  }
  void mutate_x(double _x) {
    flatbuffers::WriteScalar(&x_, _x);
  }
  double y() const {
    return flatbuffers::EndianScalar(y_);
  }
  void mutate_y(double _y) {
    flatbuffers::WriteScalar(&y_, _y);
  }
  double z() const {
    return flatbuffers::EndianScalar(z_);
  }
  void mutate_z(double _z) {
    flatbuffers::WriteScalar(&z_, _z);
  }
};
STRUCT_END(Point3D, 24);

struct ElementIDT : public flatbuffers::NativeTable {
  typedef ElementID TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "HadmapFBS.ElementIDT";
  }
  int32_t tile_id;
  uint64_t index;
  uint8_t type;
  int64_t version;
  ElementIDT()
      : tile_id(0),
        index(0),
        type(0),
        version(0) {
  }
};

struct ElementID FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ElementIDT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "HadmapFBS.ElementID";
  }
  enum {
    VT_TILE_ID = 4,
    VT_INDEX = 6,
    VT_TYPE = 8,
    VT_VERSION = 10
  };
  int32_t tile_id() const {
    return GetField<int32_t>(VT_TILE_ID, 0);
  }
  bool mutate_tile_id(int32_t _tile_id) {
    return SetField<int32_t>(VT_TILE_ID, _tile_id, 0);
  }
  uint64_t index() const {
    return GetField<uint64_t>(VT_INDEX, 0);
  }
  bool mutate_index(uint64_t _index) {
    return SetField<uint64_t>(VT_INDEX, _index, 0);
  }
  uint8_t type() const {
    return GetField<uint8_t>(VT_TYPE, 0);
  }
  bool mutate_type(uint8_t _type) {
    return SetField<uint8_t>(VT_TYPE, _type, 0);
  }
  int64_t version() const {
    return GetField<int64_t>(VT_VERSION, 0);
  }
  bool mutate_version(int64_t _version) {
    return SetField<int64_t>(VT_VERSION, _version, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TILE_ID) &&
           VerifyField<uint64_t>(verifier, VT_INDEX) &&
           VerifyField<uint8_t>(verifier, VT_TYPE) &&
           VerifyField<int64_t>(verifier, VT_VERSION) &&
           verifier.EndTable();
  }
  ElementIDT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ElementIDT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ElementID> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ElementIDT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ElementIDBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_tile_id(int32_t tile_id) {
    fbb_.AddElement<int32_t>(ElementID::VT_TILE_ID, tile_id, 0);
  }
  void add_index(uint64_t index) {
    fbb_.AddElement<uint64_t>(ElementID::VT_INDEX, index, 0);
  }
  void add_type(uint8_t type) {
    fbb_.AddElement<uint8_t>(ElementID::VT_TYPE, type, 0);
  }
  void add_version(int64_t version) {
    fbb_.AddElement<int64_t>(ElementID::VT_VERSION, version, 0);
  }
  ElementIDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ElementIDBuilder &operator=(const ElementIDBuilder &);
  flatbuffers::Offset<ElementID> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<ElementID>(end);
    return o;
  }
};

inline flatbuffers::Offset<ElementID> CreateElementID(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t tile_id = 0,
    uint64_t index = 0,
    uint8_t type = 0,
    int64_t version = 0) {
  ElementIDBuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_index(index);
  builder_.add_tile_id(tile_id);
  builder_.add_type(type);
  return builder_.Finish();
}

flatbuffers::Offset<ElementID> CreateElementID(flatbuffers::FlatBufferBuilder &_fbb, const ElementIDT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CellElementT : public flatbuffers::NativeTable {
  typedef CellElement TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "HadmapFBS.CellElementT";
  }
  float center_x;
  float length_x;
  float center_y;
  float length_y;
  float center_z;
  float length_z;
  uint32_t type;
  uint32_t subtype;
  std::unique_ptr<ElementIDT> elem_id;
  float pros;
  float cons;
  float heading_x;
  float heading_y;
  float heading_z;
  float heading_w;
  CellElementT()
      : center_x(0.0f),
        length_x(0.0f),
        center_y(0.0f),
        length_y(0.0f),
        center_z(0.0f),
        length_z(0.0f),
        type(0),
        subtype(0),
        pros(0.0f),
        cons(0.0f),
        heading_x(0.0f),
        heading_y(0.0f),
        heading_z(0.0f),
        heading_w(0.0f) {
  }
};

struct CellElement FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CellElementT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "HadmapFBS.CellElement";
  }
  enum {
    VT_CENTER_X = 4,
    VT_LENGTH_X = 6,
    VT_CENTER_Y = 8,
    VT_LENGTH_Y = 10,
    VT_CENTER_Z = 12,
    VT_LENGTH_Z = 14,
    VT_TYPE = 16,
    VT_SUBTYPE = 18,
    VT_ELEM_ID = 20,
    VT_PROS = 22,
    VT_CONS = 24,
    VT_HEADING_X = 26,
    VT_HEADING_Y = 28,
    VT_HEADING_Z = 30,
    VT_HEADING_W = 32
  };
  float center_x() const {
    return GetField<float>(VT_CENTER_X, 0.0f);
  }
  bool mutate_center_x(float _center_x) {
    return SetField<float>(VT_CENTER_X, _center_x, 0.0f);
  }
  float length_x() const {
    return GetField<float>(VT_LENGTH_X, 0.0f);
  }
  bool mutate_length_x(float _length_x) {
    return SetField<float>(VT_LENGTH_X, _length_x, 0.0f);
  }
  float center_y() const {
    return GetField<float>(VT_CENTER_Y, 0.0f);
  }
  bool mutate_center_y(float _center_y) {
    return SetField<float>(VT_CENTER_Y, _center_y, 0.0f);
  }
  float length_y() const {
    return GetField<float>(VT_LENGTH_Y, 0.0f);
  }
  bool mutate_length_y(float _length_y) {
    return SetField<float>(VT_LENGTH_Y, _length_y, 0.0f);
  }
  float center_z() const {
    return GetField<float>(VT_CENTER_Z, 0.0f);
  }
  bool mutate_center_z(float _center_z) {
    return SetField<float>(VT_CENTER_Z, _center_z, 0.0f);
  }
  float length_z() const {
    return GetField<float>(VT_LENGTH_Z, 0.0f);
  }
  bool mutate_length_z(float _length_z) {
    return SetField<float>(VT_LENGTH_Z, _length_z, 0.0f);
  }
  uint32_t type() const {
    return GetField<uint32_t>(VT_TYPE, 0);
  }
  bool mutate_type(uint32_t _type) {
    return SetField<uint32_t>(VT_TYPE, _type, 0);
  }
  uint32_t subtype() const {
    return GetField<uint32_t>(VT_SUBTYPE, 0);
  }
  bool mutate_subtype(uint32_t _subtype) {
    return SetField<uint32_t>(VT_SUBTYPE, _subtype, 0);
  }
  const ElementID *elem_id() const {
    return GetPointer<const ElementID *>(VT_ELEM_ID);
  }
  ElementID *mutable_elem_id() {
    return GetPointer<ElementID *>(VT_ELEM_ID);
  }
  float pros() const {
    return GetField<float>(VT_PROS, 0.0f);
  }
  bool mutate_pros(float _pros) {
    return SetField<float>(VT_PROS, _pros, 0.0f);
  }
  float cons() const {
    return GetField<float>(VT_CONS, 0.0f);
  }
  bool mutate_cons(float _cons) {
    return SetField<float>(VT_CONS, _cons, 0.0f);
  }
  float heading_x() const {
    return GetField<float>(VT_HEADING_X, 0.0f);
  }
  bool mutate_heading_x(float _heading_x) {
    return SetField<float>(VT_HEADING_X, _heading_x, 0.0f);
  }
  float heading_y() const {
    return GetField<float>(VT_HEADING_Y, 0.0f);
  }
  bool mutate_heading_y(float _heading_y) {
    return SetField<float>(VT_HEADING_Y, _heading_y, 0.0f);
  }
  float heading_z() const {
    return GetField<float>(VT_HEADING_Z, 0.0f);
  }
  bool mutate_heading_z(float _heading_z) {
    return SetField<float>(VT_HEADING_Z, _heading_z, 0.0f);
  }
  float heading_w() const {
    return GetField<float>(VT_HEADING_W, 0.0f);
  }
  bool mutate_heading_w(float _heading_w) {
    return SetField<float>(VT_HEADING_W, _heading_w, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_CENTER_X) &&
           VerifyField<float>(verifier, VT_LENGTH_X) &&
           VerifyField<float>(verifier, VT_CENTER_Y) &&
           VerifyField<float>(verifier, VT_LENGTH_Y) &&
           VerifyField<float>(verifier, VT_CENTER_Z) &&
           VerifyField<float>(verifier, VT_LENGTH_Z) &&
           VerifyField<uint32_t>(verifier, VT_TYPE) &&
           VerifyField<uint32_t>(verifier, VT_SUBTYPE) &&
           VerifyOffset(verifier, VT_ELEM_ID) &&
           verifier.VerifyTable(elem_id()) &&
           VerifyField<float>(verifier, VT_PROS) &&
           VerifyField<float>(verifier, VT_CONS) &&
           VerifyField<float>(verifier, VT_HEADING_X) &&
           VerifyField<float>(verifier, VT_HEADING_Y) &&
           VerifyField<float>(verifier, VT_HEADING_Z) &&
           VerifyField<float>(verifier, VT_HEADING_W) &&
           verifier.EndTable();
  }
  CellElementT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CellElementT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CellElement> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CellElementT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CellElementBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_center_x(float center_x) {
    fbb_.AddElement<float>(CellElement::VT_CENTER_X, center_x, 0.0f);
  }
  void add_length_x(float length_x) {
    fbb_.AddElement<float>(CellElement::VT_LENGTH_X, length_x, 0.0f);
  }
  void add_center_y(float center_y) {
    fbb_.AddElement<float>(CellElement::VT_CENTER_Y, center_y, 0.0f);
  }
  void add_length_y(float length_y) {
    fbb_.AddElement<float>(CellElement::VT_LENGTH_Y, length_y, 0.0f);
  }
  void add_center_z(float center_z) {
    fbb_.AddElement<float>(CellElement::VT_CENTER_Z, center_z, 0.0f);
  }
  void add_length_z(float length_z) {
    fbb_.AddElement<float>(CellElement::VT_LENGTH_Z, length_z, 0.0f);
  }
  void add_type(uint32_t type) {
    fbb_.AddElement<uint32_t>(CellElement::VT_TYPE, type, 0);
  }
  void add_subtype(uint32_t subtype) {
    fbb_.AddElement<uint32_t>(CellElement::VT_SUBTYPE, subtype, 0);
  }
  void add_elem_id(flatbuffers::Offset<ElementID> elem_id) {
    fbb_.AddOffset(CellElement::VT_ELEM_ID, elem_id);
  }
  void add_pros(float pros) {
    fbb_.AddElement<float>(CellElement::VT_PROS, pros, 0.0f);
  }
  void add_cons(float cons) {
    fbb_.AddElement<float>(CellElement::VT_CONS, cons, 0.0f);
  }
  void add_heading_x(float heading_x) {
    fbb_.AddElement<float>(CellElement::VT_HEADING_X, heading_x, 0.0f);
  }
  void add_heading_y(float heading_y) {
    fbb_.AddElement<float>(CellElement::VT_HEADING_Y, heading_y, 0.0f);
  }
  void add_heading_z(float heading_z) {
    fbb_.AddElement<float>(CellElement::VT_HEADING_Z, heading_z, 0.0f);
  }
  void add_heading_w(float heading_w) {
    fbb_.AddElement<float>(CellElement::VT_HEADING_W, heading_w, 0.0f);
  }
  CellElementBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CellElementBuilder &operator=(const CellElementBuilder &);
  flatbuffers::Offset<CellElement> Finish() {
    const auto end = fbb_.EndTable(start_, 15);
    auto o = flatbuffers::Offset<CellElement>(end);
    return o;
  }
};

inline flatbuffers::Offset<CellElement> CreateCellElement(
    flatbuffers::FlatBufferBuilder &_fbb,
    float center_x = 0.0f,
    float length_x = 0.0f,
    float center_y = 0.0f,
    float length_y = 0.0f,
    float center_z = 0.0f,
    float length_z = 0.0f,
    uint32_t type = 0,
    uint32_t subtype = 0,
    flatbuffers::Offset<ElementID> elem_id = 0,
    float pros = 0.0f,
    float cons = 0.0f,
    float heading_x = 0.0f,
    float heading_y = 0.0f,
    float heading_z = 0.0f,
    float heading_w = 0.0f) {
  CellElementBuilder builder_(_fbb);
  builder_.add_heading_w(heading_w);
  builder_.add_heading_z(heading_z);
  builder_.add_heading_y(heading_y);
  builder_.add_heading_x(heading_x);
  builder_.add_cons(cons);
  builder_.add_pros(pros);
  builder_.add_elem_id(elem_id);
  builder_.add_subtype(subtype);
  builder_.add_type(type);
  builder_.add_length_z(length_z);
  builder_.add_center_z(center_z);
  builder_.add_length_y(length_y);
  builder_.add_center_y(center_y);
  builder_.add_length_x(length_x);
  builder_.add_center_x(center_x);
  return builder_.Finish();
}

flatbuffers::Offset<CellElement> CreateCellElement(flatbuffers::FlatBufferBuilder &_fbb, const CellElementT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GridCellT : public flatbuffers::NativeTable {
  typedef GridCell TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "HadmapFBS.GridCellT";
  }
  int32_t x_index;
  int32_t y_index;
  float zmin;
  float zmax;
  uint32_t type;
  std::vector<TileGridPoint> points;
  std::vector<int32_t> cell_ends;
  std::vector<int32_t> elem_index;
  std::vector<float> cell_zmin;
  std::vector<float> cell_zmax;
  std::vector<uint64_t> cell_occupy_mask;
  std::vector<uint64_t> cell_intensity;
  std::vector<uint64_t> cell_color_r;
  std::vector<uint64_t> cell_color_g;
  std::vector<uint64_t> cell_color_b;
  std::vector<uint64_t> cell_masks;
  uint64_t valid_time;
  bool changed;
  GridCellT()
      : x_index(0),
        y_index(0),
        zmin(0.0f),
        zmax(0.0f),
        type(0),
        valid_time(0),
        changed(false) {
  }
};

struct GridCell FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GridCellT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "HadmapFBS.GridCell";
  }
  enum {
    VT_X_INDEX = 4,
    VT_Y_INDEX = 6,
    VT_ZMIN = 8,
    VT_ZMAX = 10,
    VT_TYPE = 12,
    VT_POINTS = 14,
    VT_CELL_ENDS = 16,
    VT_ELEM_INDEX = 18,
    VT_CELL_ZMIN = 20,
    VT_CELL_ZMAX = 22,
    VT_CELL_OCCUPY_MASK = 24,
    VT_CELL_INTENSITY = 26,
    VT_CELL_COLOR_R = 28,
    VT_CELL_COLOR_G = 30,
    VT_CELL_COLOR_B = 32,
    VT_CELL_MASKS = 34,
    VT_VALID_TIME = 36,
    VT_CHANGED = 38
  };
  int32_t x_index() const {
    return GetField<int32_t>(VT_X_INDEX, 0);
  }
  bool mutate_x_index(int32_t _x_index) {
    return SetField<int32_t>(VT_X_INDEX, _x_index, 0);
  }
  int32_t y_index() const {
    return GetField<int32_t>(VT_Y_INDEX, 0);
  }
  bool mutate_y_index(int32_t _y_index) {
    return SetField<int32_t>(VT_Y_INDEX, _y_index, 0);
  }
  float zmin() const {
    return GetField<float>(VT_ZMIN, 0.0f);
  }
  bool mutate_zmin(float _zmin) {
    return SetField<float>(VT_ZMIN, _zmin, 0.0f);
  }
  float zmax() const {
    return GetField<float>(VT_ZMAX, 0.0f);
  }
  bool mutate_zmax(float _zmax) {
    return SetField<float>(VT_ZMAX, _zmax, 0.0f);
  }
  uint32_t type() const {
    return GetField<uint32_t>(VT_TYPE, 0);
  }
  bool mutate_type(uint32_t _type) {
    return SetField<uint32_t>(VT_TYPE, _type, 0);
  }
  const flatbuffers::Vector<const TileGridPoint *> *points() const {
    return GetPointer<const flatbuffers::Vector<const TileGridPoint *> *>(VT_POINTS);
  }
  flatbuffers::Vector<const TileGridPoint *> *mutable_points() {
    return GetPointer<flatbuffers::Vector<const TileGridPoint *> *>(VT_POINTS);
  }
  const flatbuffers::Vector<int32_t> *cell_ends() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_CELL_ENDS);
  }
  flatbuffers::Vector<int32_t> *mutable_cell_ends() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_CELL_ENDS);
  }
  const flatbuffers::Vector<int32_t> *elem_index() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_ELEM_INDEX);
  }
  flatbuffers::Vector<int32_t> *mutable_elem_index() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_ELEM_INDEX);
  }
  const flatbuffers::Vector<float> *cell_zmin() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_CELL_ZMIN);
  }
  flatbuffers::Vector<float> *mutable_cell_zmin() {
    return GetPointer<flatbuffers::Vector<float> *>(VT_CELL_ZMIN);
  }
  const flatbuffers::Vector<float> *cell_zmax() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_CELL_ZMAX);
  }
  flatbuffers::Vector<float> *mutable_cell_zmax() {
    return GetPointer<flatbuffers::Vector<float> *>(VT_CELL_ZMAX);
  }
  const flatbuffers::Vector<uint64_t> *cell_occupy_mask() const {
    return GetPointer<const flatbuffers::Vector<uint64_t> *>(VT_CELL_OCCUPY_MASK);
  }
  flatbuffers::Vector<uint64_t> *mutable_cell_occupy_mask() {
    return GetPointer<flatbuffers::Vector<uint64_t> *>(VT_CELL_OCCUPY_MASK);
  }
  const flatbuffers::Vector<uint64_t> *cell_intensity() const {
    return GetPointer<const flatbuffers::Vector<uint64_t> *>(VT_CELL_INTENSITY);
  }
  flatbuffers::Vector<uint64_t> *mutable_cell_intensity() {
    return GetPointer<flatbuffers::Vector<uint64_t> *>(VT_CELL_INTENSITY);
  }
  const flatbuffers::Vector<uint64_t> *cell_color_r() const {
    return GetPointer<const flatbuffers::Vector<uint64_t> *>(VT_CELL_COLOR_R);
  }
  flatbuffers::Vector<uint64_t> *mutable_cell_color_r() {
    return GetPointer<flatbuffers::Vector<uint64_t> *>(VT_CELL_COLOR_R);
  }
  const flatbuffers::Vector<uint64_t> *cell_color_g() const {
    return GetPointer<const flatbuffers::Vector<uint64_t> *>(VT_CELL_COLOR_G);
  }
  flatbuffers::Vector<uint64_t> *mutable_cell_color_g() {
    return GetPointer<flatbuffers::Vector<uint64_t> *>(VT_CELL_COLOR_G);
  }
  const flatbuffers::Vector<uint64_t> *cell_color_b() const {
    return GetPointer<const flatbuffers::Vector<uint64_t> *>(VT_CELL_COLOR_B);
  }
  flatbuffers::Vector<uint64_t> *mutable_cell_color_b() {
    return GetPointer<flatbuffers::Vector<uint64_t> *>(VT_CELL_COLOR_B);
  }
  const flatbuffers::Vector<uint64_t> *cell_masks() const {
    return GetPointer<const flatbuffers::Vector<uint64_t> *>(VT_CELL_MASKS);
  }
  flatbuffers::Vector<uint64_t> *mutable_cell_masks() {
    return GetPointer<flatbuffers::Vector<uint64_t> *>(VT_CELL_MASKS);
  }
  uint64_t valid_time() const {
    return GetField<uint64_t>(VT_VALID_TIME, 0);
  }
  bool mutate_valid_time(uint64_t _valid_time) {
    return SetField<uint64_t>(VT_VALID_TIME, _valid_time, 0);
  }
  bool changed() const {
    return GetField<uint8_t>(VT_CHANGED, 0) != 0;
  }
  bool mutate_changed(bool _changed) {
    return SetField<uint8_t>(VT_CHANGED, static_cast<uint8_t>(_changed), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_X_INDEX) &&
           VerifyField<int32_t>(verifier, VT_Y_INDEX) &&
           VerifyField<float>(verifier, VT_ZMIN) &&
           VerifyField<float>(verifier, VT_ZMAX) &&
           VerifyField<uint32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_POINTS) &&
           verifier.Verify(points()) &&
           VerifyOffset(verifier, VT_CELL_ENDS) &&
           verifier.Verify(cell_ends()) &&
           VerifyOffset(verifier, VT_ELEM_INDEX) &&
           verifier.Verify(elem_index()) &&
           VerifyOffset(verifier, VT_CELL_ZMIN) &&
           verifier.Verify(cell_zmin()) &&
           VerifyOffset(verifier, VT_CELL_ZMAX) &&
           verifier.Verify(cell_zmax()) &&
           VerifyOffset(verifier, VT_CELL_OCCUPY_MASK) &&
           verifier.Verify(cell_occupy_mask()) &&
           VerifyOffset(verifier, VT_CELL_INTENSITY) &&
           verifier.Verify(cell_intensity()) &&
           VerifyOffset(verifier, VT_CELL_COLOR_R) &&
           verifier.Verify(cell_color_r()) &&
           VerifyOffset(verifier, VT_CELL_COLOR_G) &&
           verifier.Verify(cell_color_g()) &&
           VerifyOffset(verifier, VT_CELL_COLOR_B) &&
           verifier.Verify(cell_color_b()) &&
           VerifyOffset(verifier, VT_CELL_MASKS) &&
           verifier.Verify(cell_masks()) &&
           VerifyField<uint64_t>(verifier, VT_VALID_TIME) &&
           VerifyField<uint8_t>(verifier, VT_CHANGED) &&
           verifier.EndTable();
  }
  GridCellT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GridCellT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GridCell> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GridCellT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GridCellBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_x_index(int32_t x_index) {
    fbb_.AddElement<int32_t>(GridCell::VT_X_INDEX, x_index, 0);
  }
  void add_y_index(int32_t y_index) {
    fbb_.AddElement<int32_t>(GridCell::VT_Y_INDEX, y_index, 0);
  }
  void add_zmin(float zmin) {
    fbb_.AddElement<float>(GridCell::VT_ZMIN, zmin, 0.0f);
  }
  void add_zmax(float zmax) {
    fbb_.AddElement<float>(GridCell::VT_ZMAX, zmax, 0.0f);
  }
  void add_type(uint32_t type) {
    fbb_.AddElement<uint32_t>(GridCell::VT_TYPE, type, 0);
  }
  void add_points(flatbuffers::Offset<flatbuffers::Vector<const TileGridPoint *>> points) {
    fbb_.AddOffset(GridCell::VT_POINTS, points);
  }
  void add_cell_ends(flatbuffers::Offset<flatbuffers::Vector<int32_t>> cell_ends) {
    fbb_.AddOffset(GridCell::VT_CELL_ENDS, cell_ends);
  }
  void add_elem_index(flatbuffers::Offset<flatbuffers::Vector<int32_t>> elem_index) {
    fbb_.AddOffset(GridCell::VT_ELEM_INDEX, elem_index);
  }
  void add_cell_zmin(flatbuffers::Offset<flatbuffers::Vector<float>> cell_zmin) {
    fbb_.AddOffset(GridCell::VT_CELL_ZMIN, cell_zmin);
  }
  void add_cell_zmax(flatbuffers::Offset<flatbuffers::Vector<float>> cell_zmax) {
    fbb_.AddOffset(GridCell::VT_CELL_ZMAX, cell_zmax);
  }
  void add_cell_occupy_mask(flatbuffers::Offset<flatbuffers::Vector<uint64_t>> cell_occupy_mask) {
    fbb_.AddOffset(GridCell::VT_CELL_OCCUPY_MASK, cell_occupy_mask);
  }
  void add_cell_intensity(flatbuffers::Offset<flatbuffers::Vector<uint64_t>> cell_intensity) {
    fbb_.AddOffset(GridCell::VT_CELL_INTENSITY, cell_intensity);
  }
  void add_cell_color_r(flatbuffers::Offset<flatbuffers::Vector<uint64_t>> cell_color_r) {
    fbb_.AddOffset(GridCell::VT_CELL_COLOR_R, cell_color_r);
  }
  void add_cell_color_g(flatbuffers::Offset<flatbuffers::Vector<uint64_t>> cell_color_g) {
    fbb_.AddOffset(GridCell::VT_CELL_COLOR_G, cell_color_g);
  }
  void add_cell_color_b(flatbuffers::Offset<flatbuffers::Vector<uint64_t>> cell_color_b) {
    fbb_.AddOffset(GridCell::VT_CELL_COLOR_B, cell_color_b);
  }
  void add_cell_masks(flatbuffers::Offset<flatbuffers::Vector<uint64_t>> cell_masks) {
    fbb_.AddOffset(GridCell::VT_CELL_MASKS, cell_masks);
  }
  void add_valid_time(uint64_t valid_time) {
    fbb_.AddElement<uint64_t>(GridCell::VT_VALID_TIME, valid_time, 0);
  }
  void add_changed(bool changed) {
    fbb_.AddElement<uint8_t>(GridCell::VT_CHANGED, static_cast<uint8_t>(changed), 0);
  }
  GridCellBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GridCellBuilder &operator=(const GridCellBuilder &);
  flatbuffers::Offset<GridCell> Finish() {
    const auto end = fbb_.EndTable(start_, 18);
    auto o = flatbuffers::Offset<GridCell>(end);
    return o;
  }
};

inline flatbuffers::Offset<GridCell> CreateGridCell(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t x_index = 0,
    int32_t y_index = 0,
    float zmin = 0.0f,
    float zmax = 0.0f,
    uint32_t type = 0,
    flatbuffers::Offset<flatbuffers::Vector<const TileGridPoint *>> points = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> cell_ends = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> elem_index = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> cell_zmin = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> cell_zmax = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint64_t>> cell_occupy_mask = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint64_t>> cell_intensity = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint64_t>> cell_color_r = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint64_t>> cell_color_g = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint64_t>> cell_color_b = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint64_t>> cell_masks = 0,
    uint64_t valid_time = 0,
    bool changed = false) {
  GridCellBuilder builder_(_fbb);
  builder_.add_valid_time(valid_time);
  builder_.add_cell_masks(cell_masks);
  builder_.add_cell_color_b(cell_color_b);
  builder_.add_cell_color_g(cell_color_g);
  builder_.add_cell_color_r(cell_color_r);
  builder_.add_cell_intensity(cell_intensity);
  builder_.add_cell_occupy_mask(cell_occupy_mask);
  builder_.add_cell_zmax(cell_zmax);
  builder_.add_cell_zmin(cell_zmin);
  builder_.add_elem_index(elem_index);
  builder_.add_cell_ends(cell_ends);
  builder_.add_points(points);
  builder_.add_type(type);
  builder_.add_zmax(zmax);
  builder_.add_zmin(zmin);
  builder_.add_y_index(y_index);
  builder_.add_x_index(x_index);
  builder_.add_changed(changed);
  return builder_.Finish();
}

inline flatbuffers::Offset<GridCell> CreateGridCellDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t x_index = 0,
    int32_t y_index = 0,
    float zmin = 0.0f,
    float zmax = 0.0f,
    uint32_t type = 0,
    const std::vector<const TileGridPoint *> *points = nullptr,
    const std::vector<int32_t> *cell_ends = nullptr,
    const std::vector<int32_t> *elem_index = nullptr,
    const std::vector<float> *cell_zmin = nullptr,
    const std::vector<float> *cell_zmax = nullptr,
    const std::vector<uint64_t> *cell_occupy_mask = nullptr,
    const std::vector<uint64_t> *cell_intensity = nullptr,
    const std::vector<uint64_t> *cell_color_r = nullptr,
    const std::vector<uint64_t> *cell_color_g = nullptr,
    const std::vector<uint64_t> *cell_color_b = nullptr,
    const std::vector<uint64_t> *cell_masks = nullptr,
    uint64_t valid_time = 0,
    bool changed = false) {
  return HadmapFBS::CreateGridCell(
      _fbb,
      x_index,
      y_index,
      zmin,
      zmax,
      type,
      points ? _fbb.CreateVector<const TileGridPoint *>(*points) : 0,
      cell_ends ? _fbb.CreateVector<int32_t>(*cell_ends) : 0,
      elem_index ? _fbb.CreateVector<int32_t>(*elem_index) : 0,
      cell_zmin ? _fbb.CreateVector<float>(*cell_zmin) : 0,
      cell_zmax ? _fbb.CreateVector<float>(*cell_zmax) : 0,
      cell_occupy_mask ? _fbb.CreateVector<uint64_t>(*cell_occupy_mask) : 0,
      cell_intensity ? _fbb.CreateVector<uint64_t>(*cell_intensity) : 0,
      cell_color_r ? _fbb.CreateVector<uint64_t>(*cell_color_r) : 0,
      cell_color_g ? _fbb.CreateVector<uint64_t>(*cell_color_g) : 0,
      cell_color_b ? _fbb.CreateVector<uint64_t>(*cell_color_b) : 0,
      cell_masks ? _fbb.CreateVector<uint64_t>(*cell_masks) : 0,
      valid_time,
      changed);
}

flatbuffers::Offset<GridCell> CreateGridCell(flatbuffers::FlatBufferBuilder &_fbb, const GridCellT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HyperCellT : public flatbuffers::NativeTable {
  typedef HyperCell TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "HadmapFBS.HyperCellT";
  }
  int32_t row;
  int32_t col;
  float gnd;
  float coeff0;
  float coeff1;
  float coeff2;
  float coeff3;
  HyperCellT()
      : row(0),
        col(0),
        gnd(0.0f),
        coeff0(0.0f),
        coeff1(0.0f),
        coeff2(0.0f),
        coeff3(0.0f) {
  }
};

struct HyperCell FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HyperCellT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "HadmapFBS.HyperCell";
  }
  enum {
    VT_ROW = 4,
    VT_COL = 6,
    VT_GND = 8,
    VT_COEFF0 = 10,
    VT_COEFF1 = 12,
    VT_COEFF2 = 14,
    VT_COEFF3 = 16
  };
  int32_t row() const {
    return GetField<int32_t>(VT_ROW, 0);
  }
  bool mutate_row(int32_t _row) {
    return SetField<int32_t>(VT_ROW, _row, 0);
  }
  int32_t col() const {
    return GetField<int32_t>(VT_COL, 0);
  }
  bool mutate_col(int32_t _col) {
    return SetField<int32_t>(VT_COL, _col, 0);
  }
  float gnd() const {
    return GetField<float>(VT_GND, 0.0f);
  }
  bool mutate_gnd(float _gnd) {
    return SetField<float>(VT_GND, _gnd, 0.0f);
  }
  float coeff0() const {
    return GetField<float>(VT_COEFF0, 0.0f);
  }
  bool mutate_coeff0(float _coeff0) {
    return SetField<float>(VT_COEFF0, _coeff0, 0.0f);
  }
  float coeff1() const {
    return GetField<float>(VT_COEFF1, 0.0f);
  }
  bool mutate_coeff1(float _coeff1) {
    return SetField<float>(VT_COEFF1, _coeff1, 0.0f);
  }
  float coeff2() const {
    return GetField<float>(VT_COEFF2, 0.0f);
  }
  bool mutate_coeff2(float _coeff2) {
    return SetField<float>(VT_COEFF2, _coeff2, 0.0f);
  }
  float coeff3() const {
    return GetField<float>(VT_COEFF3, 0.0f);
  }
  bool mutate_coeff3(float _coeff3) {
    return SetField<float>(VT_COEFF3, _coeff3, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ROW) &&
           VerifyField<int32_t>(verifier, VT_COL) &&
           VerifyField<float>(verifier, VT_GND) &&
           VerifyField<float>(verifier, VT_COEFF0) &&
           VerifyField<float>(verifier, VT_COEFF1) &&
           VerifyField<float>(verifier, VT_COEFF2) &&
           VerifyField<float>(verifier, VT_COEFF3) &&
           verifier.EndTable();
  }
  HyperCellT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HyperCellT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HyperCell> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HyperCellT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HyperCellBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_row(int32_t row) {
    fbb_.AddElement<int32_t>(HyperCell::VT_ROW, row, 0);
  }
  void add_col(int32_t col) {
    fbb_.AddElement<int32_t>(HyperCell::VT_COL, col, 0);
  }
  void add_gnd(float gnd) {
    fbb_.AddElement<float>(HyperCell::VT_GND, gnd, 0.0f);
  }
  void add_coeff0(float coeff0) {
    fbb_.AddElement<float>(HyperCell::VT_COEFF0, coeff0, 0.0f);
  }
  void add_coeff1(float coeff1) {
    fbb_.AddElement<float>(HyperCell::VT_COEFF1, coeff1, 0.0f);
  }
  void add_coeff2(float coeff2) {
    fbb_.AddElement<float>(HyperCell::VT_COEFF2, coeff2, 0.0f);
  }
  void add_coeff3(float coeff3) {
    fbb_.AddElement<float>(HyperCell::VT_COEFF3, coeff3, 0.0f);
  }
  HyperCellBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HyperCellBuilder &operator=(const HyperCellBuilder &);
  flatbuffers::Offset<HyperCell> Finish() {
    const auto end = fbb_.EndTable(start_, 7);
    auto o = flatbuffers::Offset<HyperCell>(end);
    return o;
  }
};

inline flatbuffers::Offset<HyperCell> CreateHyperCell(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t row = 0,
    int32_t col = 0,
    float gnd = 0.0f,
    float coeff0 = 0.0f,
    float coeff1 = 0.0f,
    float coeff2 = 0.0f,
    float coeff3 = 0.0f) {
  HyperCellBuilder builder_(_fbb);
  builder_.add_coeff3(coeff3);
  builder_.add_coeff2(coeff2);
  builder_.add_coeff1(coeff1);
  builder_.add_coeff0(coeff0);
  builder_.add_gnd(gnd);
  builder_.add_col(col);
  builder_.add_row(row);
  return builder_.Finish();
}

flatbuffers::Offset<HyperCell> CreateHyperCell(flatbuffers::FlatBufferBuilder &_fbb, const HyperCellT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GridNodeT : public flatbuffers::NativeTable {
  typedef GridNode TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "HadmapFBS.GridNodeT";
  }
  int32_t x_off;
  int32_t y_off;
  float zmin;
  float zmax;
  std::vector<std::unique_ptr<GridCellT>> cells;
  int32_t x_range;
  int32_t y_range;
  std::vector<std::unique_ptr<HyperCellT>> grid;
  std::vector<std::unique_ptr<CellElementT>> elems;
  uint32_t index;
  uint64_t valid_time;
  bool changed;
  GridNodeT()
      : x_off(0),
        y_off(0),
        zmin(0.0f),
        zmax(0.0f),
        x_range(0),
        y_range(0),
        index(0),
        valid_time(0),
        changed(false) {
  }
};

struct GridNode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GridNodeT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "HadmapFBS.GridNode";
  }
  enum {
    VT_X_OFF = 4,
    VT_Y_OFF = 6,
    VT_ZMIN = 8,
    VT_ZMAX = 10,
    VT_CELLS = 12,
    VT_X_RANGE = 14,
    VT_Y_RANGE = 16,
    VT_GRID = 18,
    VT_ELEMS = 20,
    VT_INDEX = 22,
    VT_VALID_TIME = 24,
    VT_CHANGED = 26
  };
  int32_t x_off() const {
    return GetField<int32_t>(VT_X_OFF, 0);
  }
  bool mutate_x_off(int32_t _x_off) {
    return SetField<int32_t>(VT_X_OFF, _x_off, 0);
  }
  int32_t y_off() const {
    return GetField<int32_t>(VT_Y_OFF, 0);
  }
  bool mutate_y_off(int32_t _y_off) {
    return SetField<int32_t>(VT_Y_OFF, _y_off, 0);
  }
  float zmin() const {
    return GetField<float>(VT_ZMIN, 0.0f);
  }
  bool mutate_zmin(float _zmin) {
    return SetField<float>(VT_ZMIN, _zmin, 0.0f);
  }
  float zmax() const {
    return GetField<float>(VT_ZMAX, 0.0f);
  }
  bool mutate_zmax(float _zmax) {
    return SetField<float>(VT_ZMAX, _zmax, 0.0f);
  }
  const flatbuffers::Vector<flatbuffers::Offset<GridCell>> *cells() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<GridCell>> *>(VT_CELLS);
  }
  flatbuffers::Vector<flatbuffers::Offset<GridCell>> *mutable_cells() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<GridCell>> *>(VT_CELLS);
  }
  int32_t x_range() const {
    return GetField<int32_t>(VT_X_RANGE, 0);
  }
  bool mutate_x_range(int32_t _x_range) {
    return SetField<int32_t>(VT_X_RANGE, _x_range, 0);
  }
  int32_t y_range() const {
    return GetField<int32_t>(VT_Y_RANGE, 0);
  }
  bool mutate_y_range(int32_t _y_range) {
    return SetField<int32_t>(VT_Y_RANGE, _y_range, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<HyperCell>> *grid() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<HyperCell>> *>(VT_GRID);
  }
  flatbuffers::Vector<flatbuffers::Offset<HyperCell>> *mutable_grid() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<HyperCell>> *>(VT_GRID);
  }
  const flatbuffers::Vector<flatbuffers::Offset<CellElement>> *elems() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<CellElement>> *>(VT_ELEMS);
  }
  flatbuffers::Vector<flatbuffers::Offset<CellElement>> *mutable_elems() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<CellElement>> *>(VT_ELEMS);
  }
  uint32_t index() const {
    return GetField<uint32_t>(VT_INDEX, 0);
  }
  bool mutate_index(uint32_t _index) {
    return SetField<uint32_t>(VT_INDEX, _index, 0);
  }
  uint64_t valid_time() const {
    return GetField<uint64_t>(VT_VALID_TIME, 0);
  }
  bool mutate_valid_time(uint64_t _valid_time) {
    return SetField<uint64_t>(VT_VALID_TIME, _valid_time, 0);
  }
  bool changed() const {
    return GetField<uint8_t>(VT_CHANGED, 0) != 0;
  }
  bool mutate_changed(bool _changed) {
    return SetField<uint8_t>(VT_CHANGED, static_cast<uint8_t>(_changed), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_X_OFF) &&
           VerifyField<int32_t>(verifier, VT_Y_OFF) &&
           VerifyField<float>(verifier, VT_ZMIN) &&
           VerifyField<float>(verifier, VT_ZMAX) &&
           VerifyOffset(verifier, VT_CELLS) &&
           verifier.Verify(cells()) &&
           verifier.VerifyVectorOfTables(cells()) &&
           VerifyField<int32_t>(verifier, VT_X_RANGE) &&
           VerifyField<int32_t>(verifier, VT_Y_RANGE) &&
           VerifyOffset(verifier, VT_GRID) &&
           verifier.Verify(grid()) &&
           verifier.VerifyVectorOfTables(grid()) &&
           VerifyOffset(verifier, VT_ELEMS) &&
           verifier.Verify(elems()) &&
           verifier.VerifyVectorOfTables(elems()) &&
           VerifyField<uint32_t>(verifier, VT_INDEX) &&
           VerifyField<uint64_t>(verifier, VT_VALID_TIME) &&
           VerifyField<uint8_t>(verifier, VT_CHANGED) &&
           verifier.EndTable();
  }
  GridNodeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GridNodeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GridNode> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GridNodeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GridNodeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_x_off(int32_t x_off) {
    fbb_.AddElement<int32_t>(GridNode::VT_X_OFF, x_off, 0);
  }
  void add_y_off(int32_t y_off) {
    fbb_.AddElement<int32_t>(GridNode::VT_Y_OFF, y_off, 0);
  }
  void add_zmin(float zmin) {
    fbb_.AddElement<float>(GridNode::VT_ZMIN, zmin, 0.0f);
  }
  void add_zmax(float zmax) {
    fbb_.AddElement<float>(GridNode::VT_ZMAX, zmax, 0.0f);
  }
  void add_cells(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GridCell>>> cells) {
    fbb_.AddOffset(GridNode::VT_CELLS, cells);
  }
  void add_x_range(int32_t x_range) {
    fbb_.AddElement<int32_t>(GridNode::VT_X_RANGE, x_range, 0);
  }
  void add_y_range(int32_t y_range) {
    fbb_.AddElement<int32_t>(GridNode::VT_Y_RANGE, y_range, 0);
  }
  void add_grid(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<HyperCell>>> grid) {
    fbb_.AddOffset(GridNode::VT_GRID, grid);
  }
  void add_elems(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CellElement>>> elems) {
    fbb_.AddOffset(GridNode::VT_ELEMS, elems);
  }
  void add_index(uint32_t index) {
    fbb_.AddElement<uint32_t>(GridNode::VT_INDEX, index, 0);
  }
  void add_valid_time(uint64_t valid_time) {
    fbb_.AddElement<uint64_t>(GridNode::VT_VALID_TIME, valid_time, 0);
  }
  void add_changed(bool changed) {
    fbb_.AddElement<uint8_t>(GridNode::VT_CHANGED, static_cast<uint8_t>(changed), 0);
  }
  GridNodeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GridNodeBuilder &operator=(const GridNodeBuilder &);
  flatbuffers::Offset<GridNode> Finish() {
    const auto end = fbb_.EndTable(start_, 12);
    auto o = flatbuffers::Offset<GridNode>(end);
    return o;
  }
};

inline flatbuffers::Offset<GridNode> CreateGridNode(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t x_off = 0,
    int32_t y_off = 0,
    float zmin = 0.0f,
    float zmax = 0.0f,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GridCell>>> cells = 0,
    int32_t x_range = 0,
    int32_t y_range = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<HyperCell>>> grid = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CellElement>>> elems = 0,
    uint32_t index = 0,
    uint64_t valid_time = 0,
    bool changed = false) {
  GridNodeBuilder builder_(_fbb);
  builder_.add_valid_time(valid_time);
  builder_.add_index(index);
  builder_.add_elems(elems);
  builder_.add_grid(grid);
  builder_.add_y_range(y_range);
  builder_.add_x_range(x_range);
  builder_.add_cells(cells);
  builder_.add_zmax(zmax);
  builder_.add_zmin(zmin);
  builder_.add_y_off(y_off);
  builder_.add_x_off(x_off);
  builder_.add_changed(changed);
  return builder_.Finish();
}

inline flatbuffers::Offset<GridNode> CreateGridNodeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t x_off = 0,
    int32_t y_off = 0,
    float zmin = 0.0f,
    float zmax = 0.0f,
    const std::vector<flatbuffers::Offset<GridCell>> *cells = nullptr,
    int32_t x_range = 0,
    int32_t y_range = 0,
    const std::vector<flatbuffers::Offset<HyperCell>> *grid = nullptr,
    const std::vector<flatbuffers::Offset<CellElement>> *elems = nullptr,
    uint32_t index = 0,
    uint64_t valid_time = 0,
    bool changed = false) {
  return HadmapFBS::CreateGridNode(
      _fbb,
      x_off,
      y_off,
      zmin,
      zmax,
      cells ? _fbb.CreateVector<flatbuffers::Offset<GridCell>>(*cells) : 0,
      x_range,
      y_range,
      grid ? _fbb.CreateVector<flatbuffers::Offset<HyperCell>>(*grid) : 0,
      elems ? _fbb.CreateVector<flatbuffers::Offset<CellElement>>(*elems) : 0,
      index,
      valid_time,
      changed);
}

flatbuffers::Offset<GridNode> CreateGridNode(flatbuffers::FlatBufferBuilder &_fbb, const GridNodeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LaneLine3DT : public flatbuffers::NativeTable {
  typedef LaneLine3D TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "HadmapFBS.LaneLine3DT";
  }
  int32_t color;
  float confidence;
  float width;
  float length;
  int32_t type;
  int64_t lane2d_id;
  int32_t trail_id;
  std::unique_ptr<Point3D> eye_pos;
  std::vector<Point3D> points;
  int32_t pro_ind;
  int16_t thresh;
  int16_t mean;
  LaneLine3DT()
      : color(0),
        confidence(0.0f),
        width(0.0f),
        length(0.0f),
        type(0),
        lane2d_id(0),
        trail_id(0),
        pro_ind(0),
        thresh(0),
        mean(0) {
  }
};

struct LaneLine3D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LaneLine3DT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "HadmapFBS.LaneLine3D";
  }
  enum {
    VT_COLOR = 4,
    VT_CONFIDENCE = 6,
    VT_WIDTH = 8,
    VT_LENGTH = 10,
    VT_TYPE = 12,
    VT_LANE2D_ID = 14,
    VT_TRAIL_ID = 16,
    VT_EYE_POS = 18,
    VT_POINTS = 20,
    VT_PRO_IND = 22,
    VT_THRESH = 24,
    VT_MEAN = 26
  };
  int32_t color() const {
    return GetField<int32_t>(VT_COLOR, 0);
  }
  bool mutate_color(int32_t _color) {
    return SetField<int32_t>(VT_COLOR, _color, 0);
  }
  float confidence() const {
    return GetField<float>(VT_CONFIDENCE, 0.0f);
  }
  bool mutate_confidence(float _confidence) {
    return SetField<float>(VT_CONFIDENCE, _confidence, 0.0f);
  }
  float width() const {
    return GetField<float>(VT_WIDTH, 0.0f);
  }
  bool mutate_width(float _width) {
    return SetField<float>(VT_WIDTH, _width, 0.0f);
  }
  float length() const {
    return GetField<float>(VT_LENGTH, 0.0f);
  }
  bool mutate_length(float _length) {
    return SetField<float>(VT_LENGTH, _length, 0.0f);
  }
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  bool mutate_type(int32_t _type) {
    return SetField<int32_t>(VT_TYPE, _type, 0);
  }
  int64_t lane2d_id() const {
    return GetField<int64_t>(VT_LANE2D_ID, 0);
  }
  bool mutate_lane2d_id(int64_t _lane2d_id) {
    return SetField<int64_t>(VT_LANE2D_ID, _lane2d_id, 0);
  }
  int32_t trail_id() const {
    return GetField<int32_t>(VT_TRAIL_ID, 0);
  }
  bool mutate_trail_id(int32_t _trail_id) {
    return SetField<int32_t>(VT_TRAIL_ID, _trail_id, 0);
  }
  const Point3D *eye_pos() const {
    return GetStruct<const Point3D *>(VT_EYE_POS);
  }
  Point3D *mutable_eye_pos() {
    return GetStruct<Point3D *>(VT_EYE_POS);
  }
  const flatbuffers::Vector<const Point3D *> *points() const {
    return GetPointer<const flatbuffers::Vector<const Point3D *> *>(VT_POINTS);
  }
  flatbuffers::Vector<const Point3D *> *mutable_points() {
    return GetPointer<flatbuffers::Vector<const Point3D *> *>(VT_POINTS);
  }
  int32_t pro_ind() const {
    return GetField<int32_t>(VT_PRO_IND, 0);
  }
  bool mutate_pro_ind(int32_t _pro_ind) {
    return SetField<int32_t>(VT_PRO_IND, _pro_ind, 0);
  }
  int16_t thresh() const {
    return GetField<int16_t>(VT_THRESH, 0);
  }
  bool mutate_thresh(int16_t _thresh) {
    return SetField<int16_t>(VT_THRESH, _thresh, 0);
  }
  int16_t mean() const {
    return GetField<int16_t>(VT_MEAN, 0);
  }
  bool mutate_mean(int16_t _mean) {
    return SetField<int16_t>(VT_MEAN, _mean, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_COLOR) &&
           VerifyField<float>(verifier, VT_CONFIDENCE) &&
           VerifyField<float>(verifier, VT_WIDTH) &&
           VerifyField<float>(verifier, VT_LENGTH) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyField<int64_t>(verifier, VT_LANE2D_ID) &&
           VerifyField<int32_t>(verifier, VT_TRAIL_ID) &&
           VerifyField<Point3D>(verifier, VT_EYE_POS) &&
           VerifyOffset(verifier, VT_POINTS) &&
           verifier.Verify(points()) &&
           VerifyField<int32_t>(verifier, VT_PRO_IND) &&
           VerifyField<int16_t>(verifier, VT_THRESH) &&
           VerifyField<int16_t>(verifier, VT_MEAN) &&
           verifier.EndTable();
  }
  LaneLine3DT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LaneLine3DT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LaneLine3D> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LaneLine3DT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LaneLine3DBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_color(int32_t color) {
    fbb_.AddElement<int32_t>(LaneLine3D::VT_COLOR, color, 0);
  }
  void add_confidence(float confidence) {
    fbb_.AddElement<float>(LaneLine3D::VT_CONFIDENCE, confidence, 0.0f);
  }
  void add_width(float width) {
    fbb_.AddElement<float>(LaneLine3D::VT_WIDTH, width, 0.0f);
  }
  void add_length(float length) {
    fbb_.AddElement<float>(LaneLine3D::VT_LENGTH, length, 0.0f);
  }
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(LaneLine3D::VT_TYPE, type, 0);
  }
  void add_lane2d_id(int64_t lane2d_id) {
    fbb_.AddElement<int64_t>(LaneLine3D::VT_LANE2D_ID, lane2d_id, 0);
  }
  void add_trail_id(int32_t trail_id) {
    fbb_.AddElement<int32_t>(LaneLine3D::VT_TRAIL_ID, trail_id, 0);
  }
  void add_eye_pos(const Point3D *eye_pos) {
    fbb_.AddStruct(LaneLine3D::VT_EYE_POS, eye_pos);
  }
  void add_points(flatbuffers::Offset<flatbuffers::Vector<const Point3D *>> points) {
    fbb_.AddOffset(LaneLine3D::VT_POINTS, points);
  }
  void add_pro_ind(int32_t pro_ind) {
    fbb_.AddElement<int32_t>(LaneLine3D::VT_PRO_IND, pro_ind, 0);
  }
  void add_thresh(int16_t thresh) {
    fbb_.AddElement<int16_t>(LaneLine3D::VT_THRESH, thresh, 0);
  }
  void add_mean(int16_t mean) {
    fbb_.AddElement<int16_t>(LaneLine3D::VT_MEAN, mean, 0);
  }
  LaneLine3DBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LaneLine3DBuilder &operator=(const LaneLine3DBuilder &);
  flatbuffers::Offset<LaneLine3D> Finish() {
    const auto end = fbb_.EndTable(start_, 12);
    auto o = flatbuffers::Offset<LaneLine3D>(end);
    return o;
  }
};

inline flatbuffers::Offset<LaneLine3D> CreateLaneLine3D(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t color = 0,
    float confidence = 0.0f,
    float width = 0.0f,
    float length = 0.0f,
    int32_t type = 0,
    int64_t lane2d_id = 0,
    int32_t trail_id = 0,
    const Point3D *eye_pos = 0,
    flatbuffers::Offset<flatbuffers::Vector<const Point3D *>> points = 0,
    int32_t pro_ind = 0,
    int16_t thresh = 0,
    int16_t mean = 0) {
  LaneLine3DBuilder builder_(_fbb);
  builder_.add_lane2d_id(lane2d_id);
  builder_.add_pro_ind(pro_ind);
  builder_.add_points(points);
  builder_.add_eye_pos(eye_pos);
  builder_.add_trail_id(trail_id);
  builder_.add_type(type);
  builder_.add_length(length);
  builder_.add_width(width);
  builder_.add_confidence(confidence);
  builder_.add_color(color);
  builder_.add_mean(mean);
  builder_.add_thresh(thresh);
  return builder_.Finish();
}

inline flatbuffers::Offset<LaneLine3D> CreateLaneLine3DDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t color = 0,
    float confidence = 0.0f,
    float width = 0.0f,
    float length = 0.0f,
    int32_t type = 0,
    int64_t lane2d_id = 0,
    int32_t trail_id = 0,
    const Point3D *eye_pos = 0,
    const std::vector<const Point3D *> *points = nullptr,
    int32_t pro_ind = 0,
    int16_t thresh = 0,
    int16_t mean = 0) {
  return HadmapFBS::CreateLaneLine3D(
      _fbb,
      color,
      confidence,
      width,
      length,
      type,
      lane2d_id,
      trail_id,
      eye_pos,
      points ? _fbb.CreateVector<const Point3D *>(*points) : 0,
      pro_ind,
      thresh,
      mean);
}

flatbuffers::Offset<LaneLine3D> CreateLaneLine3D(flatbuffers::FlatBufferBuilder &_fbb, const LaneLine3DT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TileGridT : public flatbuffers::NativeTable {
  typedef TileGrid TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "HadmapFBS.TileGridT";
  }
  uint32_t tile_id;
  uint64_t version;
  std::vector<std::unique_ptr<GridNodeT>> nodes;
  int32_t x_range;
  int32_t y_range;
  double x_center;
  double y_center;
  std::vector<int32_t> x_min_offs;
  std::vector<int32_t> y_min_offs;
  std::vector<int32_t> x_max_offs;
  std::vector<int32_t> y_max_offs;
  std::vector<std::unique_ptr<LaneLine3DT>> lane3ds;
  std::vector<std::unique_ptr<LaneLine3DT>> traffics;
  std::vector<std::string> nodes_path;
  uint64_t valid_time;
  bool changed;
  TileGridT()
      : tile_id(0),
        version(0),
        x_range(0),
        y_range(0),
        x_center(0.0),
        y_center(0.0),
        valid_time(0),
        changed(false) {
  }
};

struct TileGrid FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TileGridT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "HadmapFBS.TileGrid";
  }
  enum {
    VT_TILE_ID = 4,
    VT_VERSION = 6,
    VT_NODES = 8,
    VT_X_RANGE = 10,
    VT_Y_RANGE = 12,
    VT_X_CENTER = 14,
    VT_Y_CENTER = 16,
    VT_X_MIN_OFFS = 18,
    VT_Y_MIN_OFFS = 20,
    VT_X_MAX_OFFS = 22,
    VT_Y_MAX_OFFS = 24,
    VT_LANE3DS = 26,
    VT_TRAFFICS = 28,
    VT_NODES_PATH = 30,
    VT_VALID_TIME = 32,
    VT_CHANGED = 34
  };
  uint32_t tile_id() const {
    return GetField<uint32_t>(VT_TILE_ID, 0);
  }
  bool mutate_tile_id(uint32_t _tile_id) {
    return SetField<uint32_t>(VT_TILE_ID, _tile_id, 0);
  }
  uint64_t version() const {
    return GetField<uint64_t>(VT_VERSION, 0);
  }
  bool mutate_version(uint64_t _version) {
    return SetField<uint64_t>(VT_VERSION, _version, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<GridNode>> *nodes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<GridNode>> *>(VT_NODES);
  }
  flatbuffers::Vector<flatbuffers::Offset<GridNode>> *mutable_nodes() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<GridNode>> *>(VT_NODES);
  }
  int32_t x_range() const {
    return GetField<int32_t>(VT_X_RANGE, 0);
  }
  bool mutate_x_range(int32_t _x_range) {
    return SetField<int32_t>(VT_X_RANGE, _x_range, 0);
  }
  int32_t y_range() const {
    return GetField<int32_t>(VT_Y_RANGE, 0);
  }
  bool mutate_y_range(int32_t _y_range) {
    return SetField<int32_t>(VT_Y_RANGE, _y_range, 0);
  }
  double x_center() const {
    return GetField<double>(VT_X_CENTER, 0.0);
  }
  bool mutate_x_center(double _x_center) {
    return SetField<double>(VT_X_CENTER, _x_center, 0.0);
  }
  double y_center() const {
    return GetField<double>(VT_Y_CENTER, 0.0);
  }
  bool mutate_y_center(double _y_center) {
    return SetField<double>(VT_Y_CENTER, _y_center, 0.0);
  }
  const flatbuffers::Vector<int32_t> *x_min_offs() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_X_MIN_OFFS);
  }
  flatbuffers::Vector<int32_t> *mutable_x_min_offs() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_X_MIN_OFFS);
  }
  const flatbuffers::Vector<int32_t> *y_min_offs() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_Y_MIN_OFFS);
  }
  flatbuffers::Vector<int32_t> *mutable_y_min_offs() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_Y_MIN_OFFS);
  }
  const flatbuffers::Vector<int32_t> *x_max_offs() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_X_MAX_OFFS);
  }
  flatbuffers::Vector<int32_t> *mutable_x_max_offs() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_X_MAX_OFFS);
  }
  const flatbuffers::Vector<int32_t> *y_max_offs() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_Y_MAX_OFFS);
  }
  flatbuffers::Vector<int32_t> *mutable_y_max_offs() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_Y_MAX_OFFS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<LaneLine3D>> *lane3ds() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<LaneLine3D>> *>(VT_LANE3DS);
  }
  flatbuffers::Vector<flatbuffers::Offset<LaneLine3D>> *mutable_lane3ds() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<LaneLine3D>> *>(VT_LANE3DS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<LaneLine3D>> *traffics() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<LaneLine3D>> *>(VT_TRAFFICS);
  }
  flatbuffers::Vector<flatbuffers::Offset<LaneLine3D>> *mutable_traffics() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<LaneLine3D>> *>(VT_TRAFFICS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *nodes_path() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_NODES_PATH);
  }
  flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *mutable_nodes_path() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_NODES_PATH);
  }
  uint64_t valid_time() const {
    return GetField<uint64_t>(VT_VALID_TIME, 0);
  }
  bool mutate_valid_time(uint64_t _valid_time) {
    return SetField<uint64_t>(VT_VALID_TIME, _valid_time, 0);
  }
  bool changed() const {
    return GetField<uint8_t>(VT_CHANGED, 0) != 0;
  }
  bool mutate_changed(bool _changed) {
    return SetField<uint8_t>(VT_CHANGED, static_cast<uint8_t>(_changed), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_TILE_ID) &&
           VerifyField<uint64_t>(verifier, VT_VERSION) &&
           VerifyOffset(verifier, VT_NODES) &&
           verifier.Verify(nodes()) &&
           verifier.VerifyVectorOfTables(nodes()) &&
           VerifyField<int32_t>(verifier, VT_X_RANGE) &&
           VerifyField<int32_t>(verifier, VT_Y_RANGE) &&
           VerifyField<double>(verifier, VT_X_CENTER) &&
           VerifyField<double>(verifier, VT_Y_CENTER) &&
           VerifyOffset(verifier, VT_X_MIN_OFFS) &&
           verifier.Verify(x_min_offs()) &&
           VerifyOffset(verifier, VT_Y_MIN_OFFS) &&
           verifier.Verify(y_min_offs()) &&
           VerifyOffset(verifier, VT_X_MAX_OFFS) &&
           verifier.Verify(x_max_offs()) &&
           VerifyOffset(verifier, VT_Y_MAX_OFFS) &&
           verifier.Verify(y_max_offs()) &&
           VerifyOffset(verifier, VT_LANE3DS) &&
           verifier.Verify(lane3ds()) &&
           verifier.VerifyVectorOfTables(lane3ds()) &&
           VerifyOffset(verifier, VT_TRAFFICS) &&
           verifier.Verify(traffics()) &&
           verifier.VerifyVectorOfTables(traffics()) &&
           VerifyOffset(verifier, VT_NODES_PATH) &&
           verifier.Verify(nodes_path()) &&
           verifier.VerifyVectorOfStrings(nodes_path()) &&
           VerifyField<uint64_t>(verifier, VT_VALID_TIME) &&
           VerifyField<uint8_t>(verifier, VT_CHANGED) &&
           verifier.EndTable();
  }
  TileGridT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TileGridT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TileGrid> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TileGridT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TileGridBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_tile_id(uint32_t tile_id) {
    fbb_.AddElement<uint32_t>(TileGrid::VT_TILE_ID, tile_id, 0);
  }
  void add_version(uint64_t version) {
    fbb_.AddElement<uint64_t>(TileGrid::VT_VERSION, version, 0);
  }
  void add_nodes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GridNode>>> nodes) {
    fbb_.AddOffset(TileGrid::VT_NODES, nodes);
  }
  void add_x_range(int32_t x_range) {
    fbb_.AddElement<int32_t>(TileGrid::VT_X_RANGE, x_range, 0);
  }
  void add_y_range(int32_t y_range) {
    fbb_.AddElement<int32_t>(TileGrid::VT_Y_RANGE, y_range, 0);
  }
  void add_x_center(double x_center) {
    fbb_.AddElement<double>(TileGrid::VT_X_CENTER, x_center, 0.0);
  }
  void add_y_center(double y_center) {
    fbb_.AddElement<double>(TileGrid::VT_Y_CENTER, y_center, 0.0);
  }
  void add_x_min_offs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> x_min_offs) {
    fbb_.AddOffset(TileGrid::VT_X_MIN_OFFS, x_min_offs);
  }
  void add_y_min_offs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> y_min_offs) {
    fbb_.AddOffset(TileGrid::VT_Y_MIN_OFFS, y_min_offs);
  }
  void add_x_max_offs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> x_max_offs) {
    fbb_.AddOffset(TileGrid::VT_X_MAX_OFFS, x_max_offs);
  }
  void add_y_max_offs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> y_max_offs) {
    fbb_.AddOffset(TileGrid::VT_Y_MAX_OFFS, y_max_offs);
  }
  void add_lane3ds(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LaneLine3D>>> lane3ds) {
    fbb_.AddOffset(TileGrid::VT_LANE3DS, lane3ds);
  }
  void add_traffics(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LaneLine3D>>> traffics) {
    fbb_.AddOffset(TileGrid::VT_TRAFFICS, traffics);
  }
  void add_nodes_path(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> nodes_path) {
    fbb_.AddOffset(TileGrid::VT_NODES_PATH, nodes_path);
  }
  void add_valid_time(uint64_t valid_time) {
    fbb_.AddElement<uint64_t>(TileGrid::VT_VALID_TIME, valid_time, 0);
  }
  void add_changed(bool changed) {
    fbb_.AddElement<uint8_t>(TileGrid::VT_CHANGED, static_cast<uint8_t>(changed), 0);
  }
  TileGridBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TileGridBuilder &operator=(const TileGridBuilder &);
  flatbuffers::Offset<TileGrid> Finish() {
    const auto end = fbb_.EndTable(start_, 16);
    auto o = flatbuffers::Offset<TileGrid>(end);
    return o;
  }
};

inline flatbuffers::Offset<TileGrid> CreateTileGrid(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t tile_id = 0,
    uint64_t version = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GridNode>>> nodes = 0,
    int32_t x_range = 0,
    int32_t y_range = 0,
    double x_center = 0.0,
    double y_center = 0.0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> x_min_offs = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> y_min_offs = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> x_max_offs = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> y_max_offs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LaneLine3D>>> lane3ds = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LaneLine3D>>> traffics = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> nodes_path = 0,
    uint64_t valid_time = 0,
    bool changed = false) {
  TileGridBuilder builder_(_fbb);
  builder_.add_valid_time(valid_time);
  builder_.add_y_center(y_center);
  builder_.add_x_center(x_center);
  builder_.add_version(version);
  builder_.add_nodes_path(nodes_path);
  builder_.add_traffics(traffics);
  builder_.add_lane3ds(lane3ds);
  builder_.add_y_max_offs(y_max_offs);
  builder_.add_x_max_offs(x_max_offs);
  builder_.add_y_min_offs(y_min_offs);
  builder_.add_x_min_offs(x_min_offs);
  builder_.add_y_range(y_range);
  builder_.add_x_range(x_range);
  builder_.add_nodes(nodes);
  builder_.add_tile_id(tile_id);
  builder_.add_changed(changed);
  return builder_.Finish();
}

inline flatbuffers::Offset<TileGrid> CreateTileGridDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t tile_id = 0,
    uint64_t version = 0,
    const std::vector<flatbuffers::Offset<GridNode>> *nodes = nullptr,
    int32_t x_range = 0,
    int32_t y_range = 0,
    double x_center = 0.0,
    double y_center = 0.0,
    const std::vector<int32_t> *x_min_offs = nullptr,
    const std::vector<int32_t> *y_min_offs = nullptr,
    const std::vector<int32_t> *x_max_offs = nullptr,
    const std::vector<int32_t> *y_max_offs = nullptr,
    const std::vector<flatbuffers::Offset<LaneLine3D>> *lane3ds = nullptr,
    const std::vector<flatbuffers::Offset<LaneLine3D>> *traffics = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *nodes_path = nullptr,
    uint64_t valid_time = 0,
    bool changed = false) {
  return HadmapFBS::CreateTileGrid(
      _fbb,
      tile_id,
      version,
      nodes ? _fbb.CreateVector<flatbuffers::Offset<GridNode>>(*nodes) : 0,
      x_range,
      y_range,
      x_center,
      y_center,
      x_min_offs ? _fbb.CreateVector<int32_t>(*x_min_offs) : 0,
      y_min_offs ? _fbb.CreateVector<int32_t>(*y_min_offs) : 0,
      x_max_offs ? _fbb.CreateVector<int32_t>(*x_max_offs) : 0,
      y_max_offs ? _fbb.CreateVector<int32_t>(*y_max_offs) : 0,
      lane3ds ? _fbb.CreateVector<flatbuffers::Offset<LaneLine3D>>(*lane3ds) : 0,
      traffics ? _fbb.CreateVector<flatbuffers::Offset<LaneLine3D>>(*traffics) : 0,
      nodes_path ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*nodes_path) : 0,
      valid_time,
      changed);
}

flatbuffers::Offset<TileGrid> CreateTileGrid(flatbuffers::FlatBufferBuilder &_fbb, const TileGridT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline ElementIDT *ElementID::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ElementIDT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ElementID::UnPackTo(ElementIDT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = tile_id(); _o->tile_id = _e; };
  { auto _e = index(); _o->index = _e; };
  { auto _e = type(); _o->type = _e; };
  { auto _e = version(); _o->version = _e; };
}

inline flatbuffers::Offset<ElementID> ElementID::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ElementIDT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateElementID(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ElementID> CreateElementID(flatbuffers::FlatBufferBuilder &_fbb, const ElementIDT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _tile_id = _o->tile_id;
  auto _index = _o->index;
  auto _type = _o->type;
  auto _version = _o->version;
  return HadmapFBS::CreateElementID(
      _fbb,
      _tile_id,
      _index,
      _type,
      _version);
}

inline CellElementT *CellElement::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CellElementT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void CellElement::UnPackTo(CellElementT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = center_x(); _o->center_x = _e; };
  { auto _e = length_x(); _o->length_x = _e; };
  { auto _e = center_y(); _o->center_y = _e; };
  { auto _e = length_y(); _o->length_y = _e; };
  { auto _e = center_z(); _o->center_z = _e; };
  { auto _e = length_z(); _o->length_z = _e; };
  { auto _e = type(); _o->type = _e; };
  { auto _e = subtype(); _o->subtype = _e; };
  { auto _e = elem_id(); if (_e) _o->elem_id = std::unique_ptr<ElementIDT>(_e->UnPack(_resolver)); };
  { auto _e = pros(); _o->pros = _e; };
  { auto _e = cons(); _o->cons = _e; };
  { auto _e = heading_x(); _o->heading_x = _e; };
  { auto _e = heading_y(); _o->heading_y = _e; };
  { auto _e = heading_z(); _o->heading_z = _e; };
  { auto _e = heading_w(); _o->heading_w = _e; };
}

inline flatbuffers::Offset<CellElement> CellElement::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CellElementT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCellElement(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CellElement> CreateCellElement(flatbuffers::FlatBufferBuilder &_fbb, const CellElementT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _center_x = _o->center_x;
  auto _length_x = _o->length_x;
  auto _center_y = _o->center_y;
  auto _length_y = _o->length_y;
  auto _center_z = _o->center_z;
  auto _length_z = _o->length_z;
  auto _type = _o->type;
  auto _subtype = _o->subtype;
  auto _elem_id = _o->elem_id ? CreateElementID(_fbb, _o->elem_id.get(), _rehasher) : 0;
  auto _pros = _o->pros;
  auto _cons = _o->cons;
  auto _heading_x = _o->heading_x;
  auto _heading_y = _o->heading_y;
  auto _heading_z = _o->heading_z;
  auto _heading_w = _o->heading_w;
  return HadmapFBS::CreateCellElement(
      _fbb,
      _center_x,
      _length_x,
      _center_y,
      _length_y,
      _center_z,
      _length_z,
      _type,
      _subtype,
      _elem_id,
      _pros,
      _cons,
      _heading_x,
      _heading_y,
      _heading_z,
      _heading_w);
}

inline GridCellT *GridCell::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GridCellT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GridCell::UnPackTo(GridCellT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = x_index(); _o->x_index = _e; };
  { auto _e = y_index(); _o->y_index = _e; };
  { auto _e = zmin(); _o->zmin = _e; };
  { auto _e = zmax(); _o->zmax = _e; };
  { auto _e = type(); _o->type = _e; };
  { auto _e = points(); if (_e) { _o->points.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->points[_i] = *_e->Get(_i); } } };
  { auto _e = cell_ends(); if (_e) { _o->cell_ends.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->cell_ends[_i] = _e->Get(_i); } } };
  { auto _e = elem_index(); if (_e) { _o->elem_index.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->elem_index[_i] = _e->Get(_i); } } };
  { auto _e = cell_zmin(); if (_e) { _o->cell_zmin.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->cell_zmin[_i] = _e->Get(_i); } } };
  { auto _e = cell_zmax(); if (_e) { _o->cell_zmax.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->cell_zmax[_i] = _e->Get(_i); } } };
  { auto _e = cell_occupy_mask(); if (_e) { _o->cell_occupy_mask.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->cell_occupy_mask[_i] = _e->Get(_i); } } };
  { auto _e = cell_intensity(); if (_e) { _o->cell_intensity.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->cell_intensity[_i] = _e->Get(_i); } } };
  { auto _e = cell_color_r(); if (_e) { _o->cell_color_r.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->cell_color_r[_i] = _e->Get(_i); } } };
  { auto _e = cell_color_g(); if (_e) { _o->cell_color_g.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->cell_color_g[_i] = _e->Get(_i); } } };
  { auto _e = cell_color_b(); if (_e) { _o->cell_color_b.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->cell_color_b[_i] = _e->Get(_i); } } };
  { auto _e = cell_masks(); if (_e) { _o->cell_masks.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->cell_masks[_i] = _e->Get(_i); } } };
  { auto _e = valid_time(); _o->valid_time = _e; };
  { auto _e = changed(); _o->changed = _e; };
}

inline flatbuffers::Offset<GridCell> GridCell::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GridCellT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGridCell(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GridCell> CreateGridCell(flatbuffers::FlatBufferBuilder &_fbb, const GridCellT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _x_index = _o->x_index;
  auto _y_index = _o->y_index;
  auto _zmin = _o->zmin;
  auto _zmax = _o->zmax;
  auto _type = _o->type;
  auto _points = _o->points.size() ? _fbb.CreateVectorOfStructs(_o->points) : 0;
  auto _cell_ends = _o->cell_ends.size() ? _fbb.CreateVector(_o->cell_ends) : 0;
  auto _elem_index = _o->elem_index.size() ? _fbb.CreateVector(_o->elem_index) : 0;
  auto _cell_zmin = _o->cell_zmin.size() ? _fbb.CreateVector(_o->cell_zmin) : 0;
  auto _cell_zmax = _o->cell_zmax.size() ? _fbb.CreateVector(_o->cell_zmax) : 0;
  auto _cell_occupy_mask = _o->cell_occupy_mask.size() ? _fbb.CreateVector(_o->cell_occupy_mask) : 0;
  auto _cell_intensity = _o->cell_intensity.size() ? _fbb.CreateVector(_o->cell_intensity) : 0;
  auto _cell_color_r = _o->cell_color_r.size() ? _fbb.CreateVector(_o->cell_color_r) : 0;
  auto _cell_color_g = _o->cell_color_g.size() ? _fbb.CreateVector(_o->cell_color_g) : 0;
  auto _cell_color_b = _o->cell_color_b.size() ? _fbb.CreateVector(_o->cell_color_b) : 0;
  auto _cell_masks = _o->cell_masks.size() ? _fbb.CreateVector(_o->cell_masks) : 0;
  auto _valid_time = _o->valid_time;
  auto _changed = _o->changed;
  return HadmapFBS::CreateGridCell(
      _fbb,
      _x_index,
      _y_index,
      _zmin,
      _zmax,
      _type,
      _points,
      _cell_ends,
      _elem_index,
      _cell_zmin,
      _cell_zmax,
      _cell_occupy_mask,
      _cell_intensity,
      _cell_color_r,
      _cell_color_g,
      _cell_color_b,
      _cell_masks,
      _valid_time,
      _changed);
}

inline HyperCellT *HyperCell::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new HyperCellT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void HyperCell::UnPackTo(HyperCellT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = row(); _o->row = _e; };
  { auto _e = col(); _o->col = _e; };
  { auto _e = gnd(); _o->gnd = _e; };
  { auto _e = coeff0(); _o->coeff0 = _e; };
  { auto _e = coeff1(); _o->coeff1 = _e; };
  { auto _e = coeff2(); _o->coeff2 = _e; };
  { auto _e = coeff3(); _o->coeff3 = _e; };
}

inline flatbuffers::Offset<HyperCell> HyperCell::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HyperCellT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHyperCell(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HyperCell> CreateHyperCell(flatbuffers::FlatBufferBuilder &_fbb, const HyperCellT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _row = _o->row;
  auto _col = _o->col;
  auto _gnd = _o->gnd;
  auto _coeff0 = _o->coeff0;
  auto _coeff1 = _o->coeff1;
  auto _coeff2 = _o->coeff2;
  auto _coeff3 = _o->coeff3;
  return HadmapFBS::CreateHyperCell(
      _fbb,
      _row,
      _col,
      _gnd,
      _coeff0,
      _coeff1,
      _coeff2,
      _coeff3);
}

inline GridNodeT *GridNode::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GridNodeT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GridNode::UnPackTo(GridNodeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = x_off(); _o->x_off = _e; };
  { auto _e = y_off(); _o->y_off = _e; };
  { auto _e = zmin(); _o->zmin = _e; };
  { auto _e = zmax(); _o->zmax = _e; };
  { auto _e = cells(); if (_e) { _o->cells.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->cells[_i] = std::unique_ptr<GridCellT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = x_range(); _o->x_range = _e; };
  { auto _e = y_range(); _o->y_range = _e; };
  { auto _e = grid(); if (_e) { _o->grid.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->grid[_i] = std::unique_ptr<HyperCellT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = elems(); if (_e) { _o->elems.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->elems[_i] = std::unique_ptr<CellElementT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = index(); _o->index = _e; };
  { auto _e = valid_time(); _o->valid_time = _e; };
  { auto _e = changed(); _o->changed = _e; };
}

inline flatbuffers::Offset<GridNode> GridNode::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GridNodeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGridNode(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GridNode> CreateGridNode(flatbuffers::FlatBufferBuilder &_fbb, const GridNodeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _x_off = _o->x_off;
  auto _y_off = _o->y_off;
  auto _zmin = _o->zmin;
  auto _zmax = _o->zmax;
  auto _cells = _o->cells.size() ? _fbb.CreateVector<flatbuffers::Offset<GridCell>>(_o->cells.size(), [&](size_t i) { return CreateGridCell(_fbb, _o->cells[i].get(), _rehasher); }) : 0;
  auto _x_range = _o->x_range;
  auto _y_range = _o->y_range;
  auto _grid = _o->grid.size() ? _fbb.CreateVector<flatbuffers::Offset<HyperCell>>(_o->grid.size(), [&](size_t i) { return CreateHyperCell(_fbb, _o->grid[i].get(), _rehasher); }) : 0;
  auto _elems = _o->elems.size() ? _fbb.CreateVector<flatbuffers::Offset<CellElement>>(_o->elems.size(), [&](size_t i) { return CreateCellElement(_fbb, _o->elems[i].get(), _rehasher); }) : 0;
  auto _index = _o->index;
  auto _valid_time = _o->valid_time;
  auto _changed = _o->changed;
  return HadmapFBS::CreateGridNode(
      _fbb,
      _x_off,
      _y_off,
      _zmin,
      _zmax,
      _cells,
      _x_range,
      _y_range,
      _grid,
      _elems,
      _index,
      _valid_time,
      _changed);
}

inline LaneLine3DT *LaneLine3D::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new LaneLine3DT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void LaneLine3D::UnPackTo(LaneLine3DT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = color(); _o->color = _e; };
  { auto _e = confidence(); _o->confidence = _e; };
  { auto _e = width(); _o->width = _e; };
  { auto _e = length(); _o->length = _e; };
  { auto _e = type(); _o->type = _e; };
  { auto _e = lane2d_id(); _o->lane2d_id = _e; };
  { auto _e = trail_id(); _o->trail_id = _e; };
  { auto _e = eye_pos(); if (_e) _o->eye_pos = std::unique_ptr<Point3D>(new Point3D(*_e)); };
  { auto _e = points(); if (_e) { _o->points.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->points[_i] = *_e->Get(_i); } } };
  { auto _e = pro_ind(); _o->pro_ind = _e; };
  { auto _e = thresh(); _o->thresh = _e; };
  { auto _e = mean(); _o->mean = _e; };
}

inline flatbuffers::Offset<LaneLine3D> LaneLine3D::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LaneLine3DT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLaneLine3D(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LaneLine3D> CreateLaneLine3D(flatbuffers::FlatBufferBuilder &_fbb, const LaneLine3DT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _color = _o->color;
  auto _confidence = _o->confidence;
  auto _width = _o->width;
  auto _length = _o->length;
  auto _type = _o->type;
  auto _lane2d_id = _o->lane2d_id;
  auto _trail_id = _o->trail_id;
  auto _eye_pos = _o->eye_pos ? _o->eye_pos.get() : 0;
  auto _points = _o->points.size() ? _fbb.CreateVectorOfStructs(_o->points) : 0;
  auto _pro_ind = _o->pro_ind;
  auto _thresh = _o->thresh;
  auto _mean = _o->mean;
  return HadmapFBS::CreateLaneLine3D(
      _fbb,
      _color,
      _confidence,
      _width,
      _length,
      _type,
      _lane2d_id,
      _trail_id,
      _eye_pos,
      _points,
      _pro_ind,
      _thresh,
      _mean);
}

inline TileGridT *TileGrid::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TileGridT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TileGrid::UnPackTo(TileGridT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = tile_id(); _o->tile_id = _e; };
  { auto _e = version(); _o->version = _e; };
  { auto _e = nodes(); if (_e) { _o->nodes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->nodes[_i] = std::unique_ptr<GridNodeT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = x_range(); _o->x_range = _e; };
  { auto _e = y_range(); _o->y_range = _e; };
  { auto _e = x_center(); _o->x_center = _e; };
  { auto _e = y_center(); _o->y_center = _e; };
  { auto _e = x_min_offs(); if (_e) { _o->x_min_offs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->x_min_offs[_i] = _e->Get(_i); } } };
  { auto _e = y_min_offs(); if (_e) { _o->y_min_offs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->y_min_offs[_i] = _e->Get(_i); } } };
  { auto _e = x_max_offs(); if (_e) { _o->x_max_offs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->x_max_offs[_i] = _e->Get(_i); } } };
  { auto _e = y_max_offs(); if (_e) { _o->y_max_offs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->y_max_offs[_i] = _e->Get(_i); } } };
  { auto _e = lane3ds(); if (_e) { _o->lane3ds.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->lane3ds[_i] = std::unique_ptr<LaneLine3DT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = traffics(); if (_e) { _o->traffics.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->traffics[_i] = std::unique_ptr<LaneLine3DT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = nodes_path(); if (_e) { _o->nodes_path.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->nodes_path[_i] = _e->Get(_i)->str(); } } };
  { auto _e = valid_time(); _o->valid_time = _e; };
  { auto _e = changed(); _o->changed = _e; };
}

inline flatbuffers::Offset<TileGrid> TileGrid::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TileGridT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTileGrid(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TileGrid> CreateTileGrid(flatbuffers::FlatBufferBuilder &_fbb, const TileGridT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _tile_id = _o->tile_id;
  auto _version = _o->version;
  auto _nodes = _o->nodes.size() ? _fbb.CreateVector<flatbuffers::Offset<GridNode>>(_o->nodes.size(), [&](size_t i) { return CreateGridNode(_fbb, _o->nodes[i].get(), _rehasher); }) : 0;
  auto _x_range = _o->x_range;
  auto _y_range = _o->y_range;
  auto _x_center = _o->x_center;
  auto _y_center = _o->y_center;
  auto _x_min_offs = _o->x_min_offs.size() ? _fbb.CreateVector(_o->x_min_offs) : 0;
  auto _y_min_offs = _o->y_min_offs.size() ? _fbb.CreateVector(_o->y_min_offs) : 0;
  auto _x_max_offs = _o->x_max_offs.size() ? _fbb.CreateVector(_o->x_max_offs) : 0;
  auto _y_max_offs = _o->y_max_offs.size() ? _fbb.CreateVector(_o->y_max_offs) : 0;
  auto _lane3ds = _o->lane3ds.size() ? _fbb.CreateVector<flatbuffers::Offset<LaneLine3D>>(_o->lane3ds.size(), [&](size_t i) { return CreateLaneLine3D(_fbb, _o->lane3ds[i].get(), _rehasher); }) : 0;
  auto _traffics = _o->traffics.size() ? _fbb.CreateVector<flatbuffers::Offset<LaneLine3D>>(_o->traffics.size(), [&](size_t i) { return CreateLaneLine3D(_fbb, _o->traffics[i].get(), _rehasher); }) : 0;
  auto _nodes_path = _o->nodes_path.size() ? _fbb.CreateVectorOfStrings(_o->nodes_path) : 0;
  auto _valid_time = _o->valid_time;
  auto _changed = _o->changed;
  return HadmapFBS::CreateTileGrid(
      _fbb,
      _tile_id,
      _version,
      _nodes,
      _x_range,
      _y_range,
      _x_center,
      _y_center,
      _x_min_offs,
      _y_min_offs,
      _x_max_offs,
      _y_max_offs,
      _lane3ds,
      _traffics,
      _nodes_path,
      _valid_time,
      _changed);
}

inline const HadmapFBS::TileGrid *GetTileGrid(const void *buf) {
  return flatbuffers::GetRoot<HadmapFBS::TileGrid>(buf);
}

inline TileGrid *GetMutableTileGrid(void *buf) {
  return flatbuffers::GetMutableRoot<TileGrid>(buf);
}

inline bool VerifyTileGridBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<HadmapFBS::TileGrid>(nullptr);
}

inline void FinishTileGridBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<HadmapFBS::TileGrid> root) {
  fbb.Finish(root);
}

inline std::unique_ptr<TileGridT> UnPackTileGrid(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<TileGridT>(GetTileGrid(buf)->UnPack(res));
}

}  // namespace HadmapFBS

#endif  // FLATBUFFERS_GENERATED_TILEGRID_HADMAPFBS_H_
