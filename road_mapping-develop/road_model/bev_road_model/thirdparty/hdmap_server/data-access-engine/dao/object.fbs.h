// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_OBJECT_HADMAPFBS_H_
#define FLATBUFFERS_GENERATED_OBJECT_HADMAPFBS_H_

#include "flatbuffers/flatbuffers.h"

namespace HadmapFBS {

struct Box;

struct Object;
struct ObjectT;

struct Objects;
struct ObjectsT;

MANUALLY_ALIGNED_STRUCT(4) Box FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;
  float w_;
  float l_;
  float h_;

 public:
  Box() {
    memset(this, 0, sizeof(Box));
  }
  Box(const Box &_o) {
    memcpy(this, &_o, sizeof(Box));
  }
  Box(float _x, float _y, float _z, float _w, float _l, float _h)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)),
        w_(flatbuffers::EndianScalar(_w)),
        l_(flatbuffers::EndianScalar(_l)),
        h_(flatbuffers::EndianScalar(_h)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
  float w() const {
    return flatbuffers::EndianScalar(w_);
  }
  float l() const {
    return flatbuffers::EndianScalar(l_);
  }
  float h() const {
    return flatbuffers::EndianScalar(h_);
  }
};
STRUCT_END(Box, 24);

struct ObjectT : public flatbuffers::NativeTable {
  typedef Object TableType;
  std::string type;
  int16_t label;
  std::unique_ptr<Box> box;
  ObjectT()
      : label(0) {
  }
};

struct Object FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ObjectT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_LABEL = 6,
    VT_BOX = 8
  };
  const flatbuffers::String *type() const {
    return GetPointer<const flatbuffers::String *>(VT_TYPE);
  }
  int16_t label() const {
    return GetField<int16_t>(VT_LABEL, 0);
  }
  const Box *box() const {
    return GetStruct<const Box *>(VT_BOX);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.Verify(type()) &&
           VerifyField<int16_t>(verifier, VT_LABEL) &&
           VerifyField<Box>(verifier, VT_BOX) &&
           verifier.EndTable();
  }
  ObjectT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ObjectT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Object> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ObjectT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ObjectBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(flatbuffers::Offset<flatbuffers::String> type) {
    fbb_.AddOffset(Object::VT_TYPE, type);
  }
  void add_label(int16_t label) {
    fbb_.AddElement<int16_t>(Object::VT_LABEL, label, 0);
  }
  void add_box(const Box *box) {
    fbb_.AddStruct(Object::VT_BOX, box);
  }
  ObjectBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ObjectBuilder &operator=(const ObjectBuilder &);
  flatbuffers::Offset<Object> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<Object>(end);
    return o;
  }
};

inline flatbuffers::Offset<Object> CreateObject(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> type = 0,
    int16_t label = 0,
    const Box *box = 0) {
  ObjectBuilder builder_(_fbb);
  builder_.add_box(box);
  builder_.add_type(type);
  builder_.add_label(label);
  return builder_.Finish();
}

inline flatbuffers::Offset<Object> CreateObjectDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *type = nullptr,
    int16_t label = 0,
    const Box *box = 0) {
  return HadmapFBS::CreateObject(
      _fbb,
      type ? _fbb.CreateString(type) : 0,
      label,
      box);
}

flatbuffers::Offset<Object> CreateObject(flatbuffers::FlatBufferBuilder &_fbb, const ObjectT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ObjectsT : public flatbuffers::NativeTable {
  typedef Objects TableType;
  std::vector<std::unique_ptr<ObjectT>> content;
  ObjectsT() {
  }
};

struct Objects FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ObjectsT NativeTableType;
  enum {
    VT_CONTENT = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<Object>> *content() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Object>> *>(VT_CONTENT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONTENT) &&
           verifier.Verify(content()) &&
           verifier.VerifyVectorOfTables(content()) &&
           verifier.EndTable();
  }
  ObjectsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ObjectsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Objects> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ObjectsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ObjectsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_content(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Object>>> content) {
    fbb_.AddOffset(Objects::VT_CONTENT, content);
  }
  ObjectsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ObjectsBuilder &operator=(const ObjectsBuilder &);
  flatbuffers::Offset<Objects> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Objects>(end);
    return o;
  }
};

inline flatbuffers::Offset<Objects> CreateObjects(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Object>>> content = 0) {
  ObjectsBuilder builder_(_fbb);
  builder_.add_content(content);
  return builder_.Finish();
}

inline flatbuffers::Offset<Objects> CreateObjectsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Object>> *content = nullptr) {
  return HadmapFBS::CreateObjects(
      _fbb,
      content ? _fbb.CreateVector<flatbuffers::Offset<Object>>(*content) : 0);
}

flatbuffers::Offset<Objects> CreateObjects(flatbuffers::FlatBufferBuilder &_fbb, const ObjectsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline ObjectT *Object::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ObjectT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Object::UnPackTo(ObjectT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); if (_e) _o->type = _e->str(); };
  { auto _e = label(); _o->label = _e; };
  { auto _e = box(); if (_e) _o->box = std::unique_ptr<Box>(new Box(*_e)); };
}

inline flatbuffers::Offset<Object> Object::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ObjectT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateObject(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Object> CreateObject(flatbuffers::FlatBufferBuilder &_fbb, const ObjectT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _type = _o->type.size() ? _fbb.CreateString(_o->type) : 0;
  auto _label = _o->label;
  auto _box = _o->box ? _o->box.get() : 0;
  return HadmapFBS::CreateObject(
      _fbb,
      _type,
      _label,
      _box);
}

inline ObjectsT *Objects::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ObjectsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Objects::UnPackTo(ObjectsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = content(); if (_e) { _o->content.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->content[_i] = std::unique_ptr<ObjectT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<Objects> Objects::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ObjectsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateObjects(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Objects> CreateObjects(flatbuffers::FlatBufferBuilder &_fbb, const ObjectsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _content = _o->content.size() ? _fbb.CreateVector<flatbuffers::Offset<Object>>(_o->content.size(), [&](size_t i) { return CreateObject(_fbb, _o->content[i].get(), _rehasher); }) : 0;
  return HadmapFBS::CreateObjects(
      _fbb,
      _content);
}

inline const HadmapFBS::Objects *GetObjects(const void *buf) {
  return flatbuffers::GetRoot<HadmapFBS::Objects>(buf);
}

inline bool VerifyObjectsBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<HadmapFBS::Objects>(nullptr);
}

inline void FinishObjectsBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<HadmapFBS::Objects> root) {
  fbb.Finish(root);
}

inline std::unique_ptr<ObjectsT> UnPackObjects(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<ObjectsT>(GetObjects(buf)->UnPack(res));
}

}  // namespace HadmapFBS

#endif  // FLATBUFFERS_GENERATED_OBJECT_HADMAPFBS_H_
