// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: lane/lane.proto

#include "lane/lane.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace RoadPB {
constexpr LaneDirection::LaneDirection(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : allowed_vehicle_types_()
  , valid_period_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , direction_(0){}
struct LaneDirectionDefaultTypeInternal {
  constexpr LaneDirectionDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~LaneDirectionDefaultTypeInternal() {}
  union {
    LaneDirection _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT LaneDirectionDefaultTypeInternal _LaneDirection_default_instance_;
constexpr LaneBoundary::LaneBoundary(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : types_()
  , id_(nullptr)
  , geom_(nullptr)
  , color_(0)
  , marking_(0)
  , ldm_(false){}
struct LaneBoundaryDefaultTypeInternal {
  constexpr LaneBoundaryDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~LaneBoundaryDefaultTypeInternal() {}
  union {
    LaneBoundary _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT LaneBoundaryDefaultTypeInternal _LaneBoundary_default_instance_;
constexpr LaneBoundaryRange::LaneBoundaryRange(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : bound_id_(nullptr)
  , start_pt_(nullptr)
  , end_pt_(nullptr){}
struct LaneBoundaryRangeDefaultTypeInternal {
  constexpr LaneBoundaryRangeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~LaneBoundaryRangeDefaultTypeInternal() {}
  union {
    LaneBoundaryRange _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT LaneBoundaryRangeDefaultTypeInternal _LaneBoundaryRange_default_instance_;
constexpr RoadBoundary::RoadBoundary(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : id_(nullptr)
  , geom_(nullptr)
  , type_(0){}
struct RoadBoundaryDefaultTypeInternal {
  constexpr RoadBoundaryDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~RoadBoundaryDefaultTypeInternal() {}
  union {
    RoadBoundary _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT RoadBoundaryDefaultTypeInternal _RoadBoundary_default_instance_;
constexpr LaneSection::LaneSection(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : speed_limits_()
  , objects_()
  , traffics_()
  , left_boundary_(nullptr)
  , right_boundary_(nullptr)
  , width_(0)
  , height_limit_(0)
  , weight_limit_(0)
  , width_limit_(0){}
struct LaneSectionDefaultTypeInternal {
  constexpr LaneSectionDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~LaneSectionDefaultTypeInternal() {}
  union {
    LaneSection _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT LaneSectionDefaultTypeInternal _LaneSection_default_instance_;
constexpr Lane::Lane(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : lanes_()
  , drivelines_()
  , directions_()
  , preds_()
  , succs_()
  , l_restrictions_()
  , r_restrictions_()
  , id_(nullptr)
  , type_(uint64_t{0u})
  , function_(0)
  , priority_(0)
  , length_(0)
  , seq_no_(0)
  , transition_(0)
  , turn_limit_(0){}
struct LaneDefaultTypeInternal {
  constexpr LaneDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~LaneDefaultTypeInternal() {}
  union {
    Lane _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT LaneDefaultTypeInternal _Lane_default_instance_;
constexpr LaneGroup::LaneGroup(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : types_()
  , left_boundarys_()
  , right_boundarys_()
  , lanes_()
  , preds_()
  , succs_()
  , id_(nullptr)
  , link_id_(nullptr){}
struct LaneGroupDefaultTypeInternal {
  constexpr LaneGroupDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~LaneGroupDefaultTypeInternal() {}
  union {
    LaneGroup _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT LaneGroupDefaultTypeInternal _LaneGroup_default_instance_;
constexpr ImpassableArea::ImpassableArea(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : geom_(nullptr)
  , type_(0)
  , kind_(0){}
struct ImpassableAreaDefaultTypeInternal {
  constexpr ImpassableAreaDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ImpassableAreaDefaultTypeInternal() {}
  union {
    ImpassableArea _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ImpassableAreaDefaultTypeInternal _ImpassableArea_default_instance_;
constexpr Junction::Junction(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : areas_()
  , boundarys_()
  , conn_groups_()
  , in_groups_()
  , out_groups_()
  , id_(nullptr)
  , node_id_(nullptr){}
struct JunctionDefaultTypeInternal {
  constexpr JunctionDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~JunctionDefaultTypeInternal() {}
  union {
    Junction _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT JunctionDefaultTypeInternal _Junction_default_instance_;
}  // namespace RoadPB
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_lane_2flane_2eproto[9];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_lane_2flane_2eproto[16];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_lane_2flane_2eproto = nullptr;

const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_lane_2flane_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::RoadPB::LaneDirection, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::RoadPB::LaneDirection, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::RoadPB::LaneDirection, direction_),
  PROTOBUF_FIELD_OFFSET(::RoadPB::LaneDirection, valid_period_),
  PROTOBUF_FIELD_OFFSET(::RoadPB::LaneDirection, allowed_vehicle_types_),
  1,
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::RoadPB::LaneBoundary, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::RoadPB::LaneBoundary, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::RoadPB::LaneBoundary, id_),
  PROTOBUF_FIELD_OFFSET(::RoadPB::LaneBoundary, geom_),
  PROTOBUF_FIELD_OFFSET(::RoadPB::LaneBoundary, color_),
  PROTOBUF_FIELD_OFFSET(::RoadPB::LaneBoundary, types_),
  PROTOBUF_FIELD_OFFSET(::RoadPB::LaneBoundary, marking_),
  PROTOBUF_FIELD_OFFSET(::RoadPB::LaneBoundary, ldm_),
  0,
  1,
  2,
  ~0u,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::RoadPB::LaneBoundaryRange, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::RoadPB::LaneBoundaryRange, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::RoadPB::LaneBoundaryRange, bound_id_),
  PROTOBUF_FIELD_OFFSET(::RoadPB::LaneBoundaryRange, start_pt_),
  PROTOBUF_FIELD_OFFSET(::RoadPB::LaneBoundaryRange, end_pt_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::RoadPB::RoadBoundary, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::RoadPB::RoadBoundary, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::RoadPB::RoadBoundary, id_),
  PROTOBUF_FIELD_OFFSET(::RoadPB::RoadBoundary, type_),
  PROTOBUF_FIELD_OFFSET(::RoadPB::RoadBoundary, geom_),
  0,
  2,
  1,
  PROTOBUF_FIELD_OFFSET(::RoadPB::LaneSection, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::RoadPB::LaneSection, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::RoadPB::LaneSection, left_boundary_),
  PROTOBUF_FIELD_OFFSET(::RoadPB::LaneSection, right_boundary_),
  PROTOBUF_FIELD_OFFSET(::RoadPB::LaneSection, speed_limits_),
  PROTOBUF_FIELD_OFFSET(::RoadPB::LaneSection, objects_),
  PROTOBUF_FIELD_OFFSET(::RoadPB::LaneSection, traffics_),
  PROTOBUF_FIELD_OFFSET(::RoadPB::LaneSection, width_),
  PROTOBUF_FIELD_OFFSET(::RoadPB::LaneSection, height_limit_),
  PROTOBUF_FIELD_OFFSET(::RoadPB::LaneSection, weight_limit_),
  PROTOBUF_FIELD_OFFSET(::RoadPB::LaneSection, width_limit_),
  0,
  1,
  ~0u,
  ~0u,
  ~0u,
  2,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::RoadPB::Lane, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::RoadPB::Lane, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::RoadPB::Lane, id_),
  PROTOBUF_FIELD_OFFSET(::RoadPB::Lane, lanes_),
  PROTOBUF_FIELD_OFFSET(::RoadPB::Lane, drivelines_),
  PROTOBUF_FIELD_OFFSET(::RoadPB::Lane, function_),
  PROTOBUF_FIELD_OFFSET(::RoadPB::Lane, type_),
  PROTOBUF_FIELD_OFFSET(::RoadPB::Lane, directions_),
  PROTOBUF_FIELD_OFFSET(::RoadPB::Lane, priority_),
  PROTOBUF_FIELD_OFFSET(::RoadPB::Lane, length_),
  PROTOBUF_FIELD_OFFSET(::RoadPB::Lane, seq_no_),
  PROTOBUF_FIELD_OFFSET(::RoadPB::Lane, preds_),
  PROTOBUF_FIELD_OFFSET(::RoadPB::Lane, succs_),
  PROTOBUF_FIELD_OFFSET(::RoadPB::Lane, l_restrictions_),
  PROTOBUF_FIELD_OFFSET(::RoadPB::Lane, r_restrictions_),
  PROTOBUF_FIELD_OFFSET(::RoadPB::Lane, transition_),
  PROTOBUF_FIELD_OFFSET(::RoadPB::Lane, turn_limit_),
  0,
  ~0u,
  ~0u,
  2,
  1,
  ~0u,
  3,
  4,
  5,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  6,
  7,
  PROTOBUF_FIELD_OFFSET(::RoadPB::LaneGroup, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::RoadPB::LaneGroup, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::RoadPB::LaneGroup, id_),
  PROTOBUF_FIELD_OFFSET(::RoadPB::LaneGroup, link_id_),
  PROTOBUF_FIELD_OFFSET(::RoadPB::LaneGroup, types_),
  PROTOBUF_FIELD_OFFSET(::RoadPB::LaneGroup, left_boundarys_),
  PROTOBUF_FIELD_OFFSET(::RoadPB::LaneGroup, right_boundarys_),
  PROTOBUF_FIELD_OFFSET(::RoadPB::LaneGroup, lanes_),
  PROTOBUF_FIELD_OFFSET(::RoadPB::LaneGroup, preds_),
  PROTOBUF_FIELD_OFFSET(::RoadPB::LaneGroup, succs_),
  0,
  1,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::RoadPB::ImpassableArea, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::RoadPB::ImpassableArea, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::RoadPB::ImpassableArea, geom_),
  PROTOBUF_FIELD_OFFSET(::RoadPB::ImpassableArea, type_),
  PROTOBUF_FIELD_OFFSET(::RoadPB::ImpassableArea, kind_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::RoadPB::Junction, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::RoadPB::Junction, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::RoadPB::Junction, id_),
  PROTOBUF_FIELD_OFFSET(::RoadPB::Junction, node_id_),
  PROTOBUF_FIELD_OFFSET(::RoadPB::Junction, areas_),
  PROTOBUF_FIELD_OFFSET(::RoadPB::Junction, boundarys_),
  PROTOBUF_FIELD_OFFSET(::RoadPB::Junction, conn_groups_),
  PROTOBUF_FIELD_OFFSET(::RoadPB::Junction, in_groups_),
  PROTOBUF_FIELD_OFFSET(::RoadPB::Junction, out_groups_),
  0,
  1,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 8, sizeof(::RoadPB::LaneDirection)},
  { 11, 22, sizeof(::RoadPB::LaneBoundary)},
  { 28, 36, sizeof(::RoadPB::LaneBoundaryRange)},
  { 39, 47, sizeof(::RoadPB::RoadBoundary)},
  { 50, 64, sizeof(::RoadPB::LaneSection)},
  { 73, 93, sizeof(::RoadPB::Lane)},
  { 108, 121, sizeof(::RoadPB::LaneGroup)},
  { 129, 137, sizeof(::RoadPB::ImpassableArea)},
  { 140, 152, sizeof(::RoadPB::Junction)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::RoadPB::_LaneDirection_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::RoadPB::_LaneBoundary_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::RoadPB::_LaneBoundaryRange_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::RoadPB::_RoadBoundary_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::RoadPB::_LaneSection_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::RoadPB::_Lane_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::RoadPB::_LaneGroup_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::RoadPB::_ImpassableArea_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::RoadPB::_Junction_default_instance_),
};

const char descriptor_table_protodef_lane_2flane_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\017lane/lane.proto\022\006RoadPB\032\027metadata/meta"
  "data.proto\032\023common/common.proto\"\245\001\n\rLane"
  "Direction\022\021\n\tdirection\030\001 \001(\005\022\024\n\014valid_pe"
  "riod\030\002 \001(\t\022\035\n\025allowed_vehicle_types\030\003 \003("
  "\005\"L\n\tDirection\022\013\n\007FORWARD\020\001\022\014\n\010BACKWARD\020"
  "\002\022\017\n\013BIDIRECTION\020\003\022\t\n\005TIDAL\020\004\022\010\n\004NONE\020\005\""
  "\247\013\n\014LaneBoundary\022\035\n\002id\030\001 \001(\0132\021.RoadPB.Fe"
  "atureID\022\036\n\004geom\030\002 \001(\0132\020.RoadPB.Polyline\022"
  "\r\n\005color\030\003 \001(\005\022\r\n\005types\030\004 \003(\005\022\017\n\007marking"
  "\030\005 \001(\005\022\013\n\003ldm\030\007 \001(\010\"\262\001\n\005Color\022\021\n\rUNKNOWN"
  "_COLOR\020\000\022\t\n\005WHITE\020\001\022\n\n\006YELLOW\020\002\022\n\n\006ORANG"
  "E\020\003\022\010\n\004BLUE\020\004\022\t\n\005GREEN\020\005\022\010\n\004GRAY\020\006\022\032\n\026LE"
  "FT_GRAY_RIGHT_YELLOW\020\007\022\033\n\027LEFT_YELLOW_RI"
  "GHT_WHITE\020\010\022\033\n\027LEFT_WHITE_RIGHT_YELLOW\020\t"
  "\"\254\002\n\021LaneLineType_Type\022\035\n\031LaneLineType_T"
  "ype_UNKNOWN\020\000\022\036\n\032LaneLineType_Type_LANEL"
  "INE\020\001\022\032\n\026LaneLineType_Type_CURB\020\002\022\034\n\030Lan"
  "eLineType_Type_CENTER\020\003\022\037\n\033LaneLineType_"
  "Type_GUARDRAIL\020\004\022&\n\"LaneLineType_Type_CO"
  "NCRETE_BARRIER\020\005\022\033\n\027LaneLineType_Type_FE"
  "NCE\020\006\022\032\n\026LaneLineType_Type_WALL\020\007\022\034\n\030Lan"
  "eLineType_Type_CANOPY\020\010\"e\n\020LaneBoundaryT"
  "ype\022\024\n\020UNKNOWN_BOUNDARY\020\000\022\014\n\010LANELINE\020\001\022"
  "\r\n\tGUARDRAIL\020\002\022\020\n\014TRAFFIC_CONE\020\n\022\014\n\010PUNC"
  "HEON\020\013\"\362\003\n\013LineMarking\022\027\n\023LineMarking_Un"
  "known\020\000\022\031\n\025LineMarking_SolidLine\020\001\022\032\n\026Li"
  "neMarking_DashedLine\020\002\022\037\n\033LineMarking_Sh"
  "ortDashedLine\020\003\022\037\n\033LineMarking_DoubleSol"
  "idLine\020\004\022 \n\034LineMarking_DoubleDashedLine"
  "\020\005\022$\n LineMarking_LeftSolidRightDashed\020\006"
  "\022$\n LineMarking_RightSolidLeftDashed\020\007\022\032"
  "\n\026LineMarking_ShadedArea\020\010\022\"\n\036LineMarkin"
  "g_LaneVirtualMarking\020\t\022)\n%LineMarking_In"
  "tersectionVirualMarking\020\n\022\"\n\036LineMarking"
  "_CurbVirtualMarking\020\013\022\034\n\030LineMarking_Unc"
  "losedRoad\020\014\022\037\n\033LineMarking_RoadVirtualLi"
  "ne\020\r\022\025\n\021LineMarking_Other\020c\"\333\001\n\013MarkingT"
  "ype\022\013\n\007UNKNOWN\020\000\022\t\n\005SOLID\020\001\022\n\n\006DASHED\020\002\022"
  "\020\n\014SHORT_DASHED\020\003\022\020\n\014DOUBLE_SOLID\020\004\022\021\n\rD"
  "OUBLE_DASHED\020\005\022\033\n\027LEFT_SOLID_RIGHT_DASHE"
  "D\020\006\022\033\n\027LEFT_DASHED_RIGHT_SOLID\020\007\022\017\n\013SHAD"
  "ED_AREA\020\010\022\020\n\014VIRTUAL_LANE\020\t\022\024\n\020VIRTUAL_J"
  "UNCTION\020\n\"x\n\021LaneBoundaryRange\022#\n\010bound_"
  "id\030\001 \001(\0132\021.RoadPB.FeatureID\022\037\n\010start_pt\030"
  "\002 \001(\0132\r.RoadPB.Point\022\035\n\006end_pt\030\003 \001(\0132\r.R"
  "oadPB.Point\"\371\001\n\014RoadBoundary\022\035\n\002id\030\001 \001(\013"
  "2\021.RoadPB.FeatureID\022\014\n\004type\030\002 \001(\005\022\036\n\004geo"
  "m\030\n \001(\0132\020.RoadPB.Polyline\"\233\001\n\020RoadBounda"
  "ryType\022\024\n\020UNKNOWN_BOUNDARY\020\000\022\010\n\004CURB\020\002\022\r"
  "\n\tGUARDRAIL\020\004\022\024\n\020CONCRETE_BARRIER\020\005\022\t\n\005F"
  "ENCE\020\006\022\010\n\004WALL\020\007\022\n\n\006CANOPY\020\010\022\010\n\004PAVE\020\t\022\t"
  "\n\005DITCH\020\n\022\014\n\010PUNCHEON\020\013\"\272\002\n\013LaneSection\022"
  "0\n\rleft_boundary\030\001 \001(\0132\031.RoadPB.LaneBoun"
  "daryRange\0221\n\016right_boundary\030\002 \001(\0132\031.Road"
  "PB.LaneBoundaryRange\022-\n\014speed_limits\030\003 \003"
  "(\0132\027.RoadPB.FixedSpeedLimit\022\"\n\007objects\030\005"
  " \003(\0132\021.RoadPB.FeatureID\022#\n\010traffics\030\006 \003("
  "\0132\021.RoadPB.FeatureID\022\r\n\005width\030\007 \001(\002\022\024\n\014h"
  "eight_limit\030\010 \001(\002\022\024\n\014weight_limit\030\t \001(\002\022"
  "\023\n\013width_limit\030\n \001(\002\"\331\020\n\004Lane\022\035\n\002id\030\001 \001("
  "\0132\021.RoadPB.FeatureID\022\"\n\005lanes\030\002 \003(\0132\023.Ro"
  "adPB.LaneSection\022%\n\ndrivelines\030\003 \003(\0132\021.R"
  "oadPB.FeatureID\022\020\n\010function\030\004 \001(\005\022\014\n\004typ"
  "e\030\005 \001(\004\022)\n\ndirections\030\007 \003(\0132\025.RoadPB.Lan"
  "eDirection\022\020\n\010priority\030\010 \001(\005\022\016\n\006length\030\t"
  " \001(\002\022\016\n\006seq_no\030\n \001(\005\022 \n\005preds\030\013 \003(\0132\021.Ro"
  "adPB.FeatureID\022 \n\005succs\030\014 \003(\0132\021.RoadPB.F"
  "eatureID\022\026\n\016l_restrictions\030\r \003(\005\022\026\n\016r_re"
  "strictions\030\016 \003(\005\022\022\n\ntransition\030\017 \001(\005\022\022\n\n"
  "turn_limit\030\020 \001(\005\"\333\001\n\010Function\022\021\n\rFunctio"
  "n_NONE\020\000\022\031\n\025Function_CITY_DRIVING\020\001\022\031\n\025F"
  "unction_HIGH_DRIVING\020\002\022\023\n\017Function_BIKIN"
  "G\020\003\022\025\n\021Function_SIDEWALK\020\004\022\024\n\020Function_P"
  "ARKING\020\005\022\021\n\rFunction_RAMP\020\006\022\026\n\022Function_"
  "EMERGENCY\020\007\022\031\n\025Function_ACCELERATION\020\010\"\312"
  "\001\n\010LaneType\022\024\n\020UNKNOWN_LANETYPE\020\000\022\021\n\rSTA"
  "NDARD_LANE\020\002\022\025\n\021ACCELERATION_LANE\020\003\022\025\n\021D"
  "ECELERATION_LANE\020\004\022\025\n\021SPEED_CHANGE_LANE\020"
  "\005\022\r\n\tTOLL_LANE\020\013\022\022\n\016EMERGENCY_LANE\020\014\022\014\n\010"
  "BUS_LANE\020\r\022\016\n\nCYCLE_PATH\020\016\022\017\n\013U_TURN_LAN"
  "E\020\017\"\307\001\n\014LanePriority\022\031\n\025LANE_PRIORITY_UN"
  "KNOWN\020\000\022\030\n\024LANE_PRIORITY_HIGHER\020\001\022\027\n\023LAN"
  "E_PRIORITY_EQUAL\020\002\022\027\n\023LANE_PRIORITY_LOWE"
  "R\020\003\022&\n\"LANE_PRIORITY_CONTROLLED_BY_SIGNA"
  "L\020\004\022(\n$LANE_PRIORITY_CONTROLLED_BY_STOPL"
  "INE\020\005\"\236\006\n\027LaneLineRestrictionType\022!\n\035UNK"
  "NOWN_LINE_RESTRICTION_TYPE\020\000\022\026\n\022BUS_LANE"
  "_LEFT_EDGE\020\001\022\027\n\023BUS_LANE_RIGHT_EDGE\020\002\022\027\n"
  "\023BIKE_LANE_LEFT_EDGE\020\003\022\030\n\024BIKE_LANE_RIGH"
  "T_EDGE\020\004\022\024\n\020OPPOSITE_NO_PASS\020\005\022\025\n\021OPPOSI"
  "TE_CAN_PASS\020\006\022\035\n\031PEDESTRAIN_LANE_LEFT_ED"
  "GE\020\007\022\036\n\032PEDESTRAIN_LANE_RIGHT_EDGE\020\010\022\034\n\030"
  "WHITE_STRIP_ZONE_ON_LEFT\020\t\022\035\n\031WHITE_STRI"
  "P_ZONE_ON_RIGHT\020\n\022\035\n\031YELLOW_STRIP_ZONE_O"
  "N_LEFT\020\013\022\036\n\032YELLOW_STRIP_ZONE_ON_RIGHT\020\014"
  "\022\025\n\021CABLE_CAR_ON_LEFT\020\r\022\026\n\022CABLE_CAR_ON_"
  "RIGHT\020\016\022\022\n\016NO_CAR_ON_LEFT\020\017\022\023\n\017NO_CAR_ON"
  "_RIGHT\020\020\022\027\n\023EXIT_LANE_LEFT_EDGE\020\021\022\030\n\024EXI"
  "T_LANE_RIGHT_EDGE\020\022\022\030\n\024ENTRY_LANE_LEFT_E"
  "DGE\020\023\022\031\n\025ENTRY_LANE_RIGHT_EDGE\020\024\022\026\n\022HOV_"
  "LANE_LEFT_EDGE\020\025\022\027\n\023HOV_LANE_RIGHT_EDGE\020"
  "\026\022\026\n\022SIDEWALK_LEFT_EDGE\020\027\022\027\n\023SIDEWALK_RI"
  "GHT_EDGE\020\030\022\032\n\026PARKING_LANE_LEFT_EDGE\020\031\022\033"
  "\n\027PARKING_LANE_RIGHT_EDGE\020\032\022\033\n\027SHOULDER_"
  "LANE_LEFT_EDGE\020\033\022\034\n\030SHOULDER_LANE_RIGHT_"
  "EDGE\020\034\"\235\001\n\016LaneTransition\022\032\n\026LaneTransit"
  "ion_Unknown\020\000\022\033\n\027LaneTransition_Continue"
  "\020\001\022\032\n\026LaneTransition_Merging\020\002\022\034\n\030LaneTr"
  "ansition_Splitting\020\003\022\030\n\024LaneTransition_O"
  "ther\020c\"\227\001\n\tTurnLimit\022\010\n\004NONE\020\000\022\014\n\010STRAIG"
  "HT\020\001\022\020\n\014SLIGHT_RIGHT\020\002\022\t\n\005RIGHT\020\004\022\016\n\nHAR"
  "D_RIGHT\020\010\022\t\n\005UTURN\020\020\022\r\n\tHARD_LEFT\020 \022\010\n\004L"
  "EFT\020@\022\020\n\013SLIGHT_LEFT\020\200\001\022\017\n\002NA\020\377\377\377\377\377\377\377\377\377\001"
  "\"\235\004\n\tLaneGroup\022\035\n\002id\030\001 \001(\0132\021.RoadPB.Feat"
  "ureID\022\"\n\007link_id\030\002 \001(\0132\021.RoadPB.FeatureI"
  "D\022\r\n\005types\030\004 \003(\005\022)\n\016left_boundarys\030\006 \003(\013"
  "2\021.RoadPB.FeatureID\022*\n\017right_boundarys\030\007"
  " \003(\0132\021.RoadPB.FeatureID\022 \n\005lanes\030\010 \003(\0132\021"
  ".RoadPB.FeatureID\022 \n\005preds\030\t \003(\0132\021.RoadP"
  "B.FeatureID\022 \n\005succs\030\n \003(\0132\021.RoadPB.Feat"
  "ureID\"\200\002\n\rLaneGroupType\022\030\n\024UNKOWN_LANEGR"
  "OUPTYPE\020\000\022\n\n\006OTHERS\020\001\022\021\n\rLANES_TO_TOLL\020\025"
  "\022\021\n\rLANES_AT_TOLL\020\026\022\020\n\014EXITING_TOLL\020\027\022\023\n"
  "\017LANES_TO_BRIGHT\020\030\022\023\n\017LANES_ON_BRIGHT\020\031\022"
  "\022\n\016EXITING_BRIGHT\020\032\022\023\n\017LANES_TO_TUNNEL\020\033"
  "\022\023\n\017LANES_IN_TUNNEL\020\034\022\022\n\016EXITING_TUNNEL\020"
  "\035\022\025\n\021LANES_ON_JUNCTION\020\036\"\225\001\n\016ImpassableA"
  "rea\022\035\n\004geom\030\001 \001(\0132\017.RoadPB.Polygon\022\014\n\004ty"
  "pe\030\002 \001(\005\022\014\n\004kind\030\003 \001(\005\"H\n\004Kind\022\020\n\014UNKNOW"
  "N_KIND\020\000\022\r\n\tFLOWERBED\020\001\022\016\n\nSENTRY_BOX\020\002\022"
  "\017\n\013SAFE_ISLAND\020\003\"\217\002\n\010Junction\022\035\n\002id\030\001 \001("
  "\0132\021.RoadPB.FeatureID\022\"\n\007node_id\030\003 \001(\0132\021."
  "RoadPB.FeatureID\022%\n\005areas\030\005 \003(\0132\026.RoadPB"
  ".ImpassableArea\022$\n\tboundarys\030\006 \003(\0132\021.Roa"
  "dPB.FeatureID\022&\n\013conn_groups\030\007 \003(\0132\021.Roa"
  "dPB.FeatureID\022$\n\tin_groups\030\010 \003(\0132\021.RoadP"
  "B.FeatureID\022%\n\nout_groups\030\t \003(\0132\021.RoadPB"
  ".FeatureID*\205\001\n\013VehicleType\022\023\n\017UNKNOWN_VE"
  "HICLE\020\000\022\007\n\003CAR\020\001\022\016\n\nMOTORCYCLE\020\002\022\013\n\007BICY"
  "CLE\020\003\022\t\n\005TRUCK\020\004\022\010\n\004TAXI\020\005\022\007\n\003BUS\020\006\022\016\n\nP"
  "EDESTRAIN\020\007\022\r\n\tCABLE_CAR\020\010"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_lane_2flane_2eproto_deps[2] = {
  &::descriptor_table_common_2fcommon_2eproto,
  &::descriptor_table_metadata_2fmetadata_2eproto,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_lane_2flane_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_lane_2flane_2eproto = {
  false, false, 5626, descriptor_table_protodef_lane_2flane_2eproto, "lane/lane.proto", 
  &descriptor_table_lane_2flane_2eproto_once, descriptor_table_lane_2flane_2eproto_deps, 2, 9,
  schemas, file_default_instances, TableStruct_lane_2flane_2eproto::offsets,
  file_level_metadata_lane_2flane_2eproto, file_level_enum_descriptors_lane_2flane_2eproto, file_level_service_descriptors_lane_2flane_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_lane_2flane_2eproto_getter() {
  return &descriptor_table_lane_2flane_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_lane_2flane_2eproto(&descriptor_table_lane_2flane_2eproto);
namespace RoadPB {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LaneDirection_Direction_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_lane_2flane_2eproto);
  return file_level_enum_descriptors_lane_2flane_2eproto[0];
}
bool LaneDirection_Direction_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr LaneDirection_Direction LaneDirection::FORWARD;
constexpr LaneDirection_Direction LaneDirection::BACKWARD;
constexpr LaneDirection_Direction LaneDirection::BIDIRECTION;
constexpr LaneDirection_Direction LaneDirection::TIDAL;
constexpr LaneDirection_Direction LaneDirection::NONE;
constexpr LaneDirection_Direction LaneDirection::Direction_MIN;
constexpr LaneDirection_Direction LaneDirection::Direction_MAX;
constexpr int LaneDirection::Direction_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LaneBoundary_Color_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_lane_2flane_2eproto);
  return file_level_enum_descriptors_lane_2flane_2eproto[1];
}
bool LaneBoundary_Color_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr LaneBoundary_Color LaneBoundary::UNKNOWN_COLOR;
constexpr LaneBoundary_Color LaneBoundary::WHITE;
constexpr LaneBoundary_Color LaneBoundary::YELLOW;
constexpr LaneBoundary_Color LaneBoundary::ORANGE;
constexpr LaneBoundary_Color LaneBoundary::BLUE;
constexpr LaneBoundary_Color LaneBoundary::GREEN;
constexpr LaneBoundary_Color LaneBoundary::GRAY;
constexpr LaneBoundary_Color LaneBoundary::LEFT_GRAY_RIGHT_YELLOW;
constexpr LaneBoundary_Color LaneBoundary::LEFT_YELLOW_RIGHT_WHITE;
constexpr LaneBoundary_Color LaneBoundary::LEFT_WHITE_RIGHT_YELLOW;
constexpr LaneBoundary_Color LaneBoundary::Color_MIN;
constexpr LaneBoundary_Color LaneBoundary::Color_MAX;
constexpr int LaneBoundary::Color_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LaneBoundary_LaneLineType_Type_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_lane_2flane_2eproto);
  return file_level_enum_descriptors_lane_2flane_2eproto[2];
}
bool LaneBoundary_LaneLineType_Type_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr LaneBoundary_LaneLineType_Type LaneBoundary::LaneLineType_Type_UNKNOWN;
constexpr LaneBoundary_LaneLineType_Type LaneBoundary::LaneLineType_Type_LANELINE;
constexpr LaneBoundary_LaneLineType_Type LaneBoundary::LaneLineType_Type_CURB;
constexpr LaneBoundary_LaneLineType_Type LaneBoundary::LaneLineType_Type_CENTER;
constexpr LaneBoundary_LaneLineType_Type LaneBoundary::LaneLineType_Type_GUARDRAIL;
constexpr LaneBoundary_LaneLineType_Type LaneBoundary::LaneLineType_Type_CONCRETE_BARRIER;
constexpr LaneBoundary_LaneLineType_Type LaneBoundary::LaneLineType_Type_FENCE;
constexpr LaneBoundary_LaneLineType_Type LaneBoundary::LaneLineType_Type_WALL;
constexpr LaneBoundary_LaneLineType_Type LaneBoundary::LaneLineType_Type_CANOPY;
constexpr LaneBoundary_LaneLineType_Type LaneBoundary::LaneLineType_Type_MIN;
constexpr LaneBoundary_LaneLineType_Type LaneBoundary::LaneLineType_Type_MAX;
constexpr int LaneBoundary::LaneLineType_Type_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LaneBoundary_LaneBoundaryType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_lane_2flane_2eproto);
  return file_level_enum_descriptors_lane_2flane_2eproto[3];
}
bool LaneBoundary_LaneBoundaryType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 10:
    case 11:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr LaneBoundary_LaneBoundaryType LaneBoundary::UNKNOWN_BOUNDARY;
constexpr LaneBoundary_LaneBoundaryType LaneBoundary::LANELINE;
constexpr LaneBoundary_LaneBoundaryType LaneBoundary::GUARDRAIL;
constexpr LaneBoundary_LaneBoundaryType LaneBoundary::TRAFFIC_CONE;
constexpr LaneBoundary_LaneBoundaryType LaneBoundary::PUNCHEON;
constexpr LaneBoundary_LaneBoundaryType LaneBoundary::LaneBoundaryType_MIN;
constexpr LaneBoundary_LaneBoundaryType LaneBoundary::LaneBoundaryType_MAX;
constexpr int LaneBoundary::LaneBoundaryType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LaneBoundary_LineMarking_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_lane_2flane_2eproto);
  return file_level_enum_descriptors_lane_2flane_2eproto[4];
}
bool LaneBoundary_LineMarking_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 99:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr LaneBoundary_LineMarking LaneBoundary::LineMarking_Unknown;
constexpr LaneBoundary_LineMarking LaneBoundary::LineMarking_SolidLine;
constexpr LaneBoundary_LineMarking LaneBoundary::LineMarking_DashedLine;
constexpr LaneBoundary_LineMarking LaneBoundary::LineMarking_ShortDashedLine;
constexpr LaneBoundary_LineMarking LaneBoundary::LineMarking_DoubleSolidLine;
constexpr LaneBoundary_LineMarking LaneBoundary::LineMarking_DoubleDashedLine;
constexpr LaneBoundary_LineMarking LaneBoundary::LineMarking_LeftSolidRightDashed;
constexpr LaneBoundary_LineMarking LaneBoundary::LineMarking_RightSolidLeftDashed;
constexpr LaneBoundary_LineMarking LaneBoundary::LineMarking_ShadedArea;
constexpr LaneBoundary_LineMarking LaneBoundary::LineMarking_LaneVirtualMarking;
constexpr LaneBoundary_LineMarking LaneBoundary::LineMarking_IntersectionVirualMarking;
constexpr LaneBoundary_LineMarking LaneBoundary::LineMarking_CurbVirtualMarking;
constexpr LaneBoundary_LineMarking LaneBoundary::LineMarking_UnclosedRoad;
constexpr LaneBoundary_LineMarking LaneBoundary::LineMarking_RoadVirtualLine;
constexpr LaneBoundary_LineMarking LaneBoundary::LineMarking_Other;
constexpr LaneBoundary_LineMarking LaneBoundary::LineMarking_MIN;
constexpr LaneBoundary_LineMarking LaneBoundary::LineMarking_MAX;
constexpr int LaneBoundary::LineMarking_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LaneBoundary_MarkingType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_lane_2flane_2eproto);
  return file_level_enum_descriptors_lane_2flane_2eproto[5];
}
bool LaneBoundary_MarkingType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr LaneBoundary_MarkingType LaneBoundary::UNKNOWN;
constexpr LaneBoundary_MarkingType LaneBoundary::SOLID;
constexpr LaneBoundary_MarkingType LaneBoundary::DASHED;
constexpr LaneBoundary_MarkingType LaneBoundary::SHORT_DASHED;
constexpr LaneBoundary_MarkingType LaneBoundary::DOUBLE_SOLID;
constexpr LaneBoundary_MarkingType LaneBoundary::DOUBLE_DASHED;
constexpr LaneBoundary_MarkingType LaneBoundary::LEFT_SOLID_RIGHT_DASHED;
constexpr LaneBoundary_MarkingType LaneBoundary::LEFT_DASHED_RIGHT_SOLID;
constexpr LaneBoundary_MarkingType LaneBoundary::SHADED_AREA;
constexpr LaneBoundary_MarkingType LaneBoundary::VIRTUAL_LANE;
constexpr LaneBoundary_MarkingType LaneBoundary::VIRTUAL_JUNCTION;
constexpr LaneBoundary_MarkingType LaneBoundary::MarkingType_MIN;
constexpr LaneBoundary_MarkingType LaneBoundary::MarkingType_MAX;
constexpr int LaneBoundary::MarkingType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RoadBoundary_RoadBoundaryType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_lane_2flane_2eproto);
  return file_level_enum_descriptors_lane_2flane_2eproto[6];
}
bool RoadBoundary_RoadBoundaryType_IsValid(int value) {
  switch (value) {
    case 0:
    case 2:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr RoadBoundary_RoadBoundaryType RoadBoundary::UNKNOWN_BOUNDARY;
constexpr RoadBoundary_RoadBoundaryType RoadBoundary::CURB;
constexpr RoadBoundary_RoadBoundaryType RoadBoundary::GUARDRAIL;
constexpr RoadBoundary_RoadBoundaryType RoadBoundary::CONCRETE_BARRIER;
constexpr RoadBoundary_RoadBoundaryType RoadBoundary::FENCE;
constexpr RoadBoundary_RoadBoundaryType RoadBoundary::WALL;
constexpr RoadBoundary_RoadBoundaryType RoadBoundary::CANOPY;
constexpr RoadBoundary_RoadBoundaryType RoadBoundary::PAVE;
constexpr RoadBoundary_RoadBoundaryType RoadBoundary::DITCH;
constexpr RoadBoundary_RoadBoundaryType RoadBoundary::PUNCHEON;
constexpr RoadBoundary_RoadBoundaryType RoadBoundary::RoadBoundaryType_MIN;
constexpr RoadBoundary_RoadBoundaryType RoadBoundary::RoadBoundaryType_MAX;
constexpr int RoadBoundary::RoadBoundaryType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Lane_Function_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_lane_2flane_2eproto);
  return file_level_enum_descriptors_lane_2flane_2eproto[7];
}
bool Lane_Function_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr Lane_Function Lane::Function_NONE;
constexpr Lane_Function Lane::Function_CITY_DRIVING;
constexpr Lane_Function Lane::Function_HIGH_DRIVING;
constexpr Lane_Function Lane::Function_BIKING;
constexpr Lane_Function Lane::Function_SIDEWALK;
constexpr Lane_Function Lane::Function_PARKING;
constexpr Lane_Function Lane::Function_RAMP;
constexpr Lane_Function Lane::Function_EMERGENCY;
constexpr Lane_Function Lane::Function_ACCELERATION;
constexpr Lane_Function Lane::Function_MIN;
constexpr Lane_Function Lane::Function_MAX;
constexpr int Lane::Function_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Lane_LaneType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_lane_2flane_2eproto);
  return file_level_enum_descriptors_lane_2flane_2eproto[8];
}
bool Lane_LaneType_IsValid(int value) {
  switch (value) {
    case 0:
    case 2:
    case 3:
    case 4:
    case 5:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr Lane_LaneType Lane::UNKNOWN_LANETYPE;
constexpr Lane_LaneType Lane::STANDARD_LANE;
constexpr Lane_LaneType Lane::ACCELERATION_LANE;
constexpr Lane_LaneType Lane::DECELERATION_LANE;
constexpr Lane_LaneType Lane::SPEED_CHANGE_LANE;
constexpr Lane_LaneType Lane::TOLL_LANE;
constexpr Lane_LaneType Lane::EMERGENCY_LANE;
constexpr Lane_LaneType Lane::BUS_LANE;
constexpr Lane_LaneType Lane::CYCLE_PATH;
constexpr Lane_LaneType Lane::U_TURN_LANE;
constexpr Lane_LaneType Lane::LaneType_MIN;
constexpr Lane_LaneType Lane::LaneType_MAX;
constexpr int Lane::LaneType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Lane_LanePriority_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_lane_2flane_2eproto);
  return file_level_enum_descriptors_lane_2flane_2eproto[9];
}
bool Lane_LanePriority_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr Lane_LanePriority Lane::LANE_PRIORITY_UNKNOWN;
constexpr Lane_LanePriority Lane::LANE_PRIORITY_HIGHER;
constexpr Lane_LanePriority Lane::LANE_PRIORITY_EQUAL;
constexpr Lane_LanePriority Lane::LANE_PRIORITY_LOWER;
constexpr Lane_LanePriority Lane::LANE_PRIORITY_CONTROLLED_BY_SIGNAL;
constexpr Lane_LanePriority Lane::LANE_PRIORITY_CONTROLLED_BY_STOPLINE;
constexpr Lane_LanePriority Lane::LanePriority_MIN;
constexpr Lane_LanePriority Lane::LanePriority_MAX;
constexpr int Lane::LanePriority_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Lane_LaneLineRestrictionType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_lane_2flane_2eproto);
  return file_level_enum_descriptors_lane_2flane_2eproto[10];
}
bool Lane_LaneLineRestrictionType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr Lane_LaneLineRestrictionType Lane::UNKNOWN_LINE_RESTRICTION_TYPE;
constexpr Lane_LaneLineRestrictionType Lane::BUS_LANE_LEFT_EDGE;
constexpr Lane_LaneLineRestrictionType Lane::BUS_LANE_RIGHT_EDGE;
constexpr Lane_LaneLineRestrictionType Lane::BIKE_LANE_LEFT_EDGE;
constexpr Lane_LaneLineRestrictionType Lane::BIKE_LANE_RIGHT_EDGE;
constexpr Lane_LaneLineRestrictionType Lane::OPPOSITE_NO_PASS;
constexpr Lane_LaneLineRestrictionType Lane::OPPOSITE_CAN_PASS;
constexpr Lane_LaneLineRestrictionType Lane::PEDESTRAIN_LANE_LEFT_EDGE;
constexpr Lane_LaneLineRestrictionType Lane::PEDESTRAIN_LANE_RIGHT_EDGE;
constexpr Lane_LaneLineRestrictionType Lane::WHITE_STRIP_ZONE_ON_LEFT;
constexpr Lane_LaneLineRestrictionType Lane::WHITE_STRIP_ZONE_ON_RIGHT;
constexpr Lane_LaneLineRestrictionType Lane::YELLOW_STRIP_ZONE_ON_LEFT;
constexpr Lane_LaneLineRestrictionType Lane::YELLOW_STRIP_ZONE_ON_RIGHT;
constexpr Lane_LaneLineRestrictionType Lane::CABLE_CAR_ON_LEFT;
constexpr Lane_LaneLineRestrictionType Lane::CABLE_CAR_ON_RIGHT;
constexpr Lane_LaneLineRestrictionType Lane::NO_CAR_ON_LEFT;
constexpr Lane_LaneLineRestrictionType Lane::NO_CAR_ON_RIGHT;
constexpr Lane_LaneLineRestrictionType Lane::EXIT_LANE_LEFT_EDGE;
constexpr Lane_LaneLineRestrictionType Lane::EXIT_LANE_RIGHT_EDGE;
constexpr Lane_LaneLineRestrictionType Lane::ENTRY_LANE_LEFT_EDGE;
constexpr Lane_LaneLineRestrictionType Lane::ENTRY_LANE_RIGHT_EDGE;
constexpr Lane_LaneLineRestrictionType Lane::HOV_LANE_LEFT_EDGE;
constexpr Lane_LaneLineRestrictionType Lane::HOV_LANE_RIGHT_EDGE;
constexpr Lane_LaneLineRestrictionType Lane::SIDEWALK_LEFT_EDGE;
constexpr Lane_LaneLineRestrictionType Lane::SIDEWALK_RIGHT_EDGE;
constexpr Lane_LaneLineRestrictionType Lane::PARKING_LANE_LEFT_EDGE;
constexpr Lane_LaneLineRestrictionType Lane::PARKING_LANE_RIGHT_EDGE;
constexpr Lane_LaneLineRestrictionType Lane::SHOULDER_LANE_LEFT_EDGE;
constexpr Lane_LaneLineRestrictionType Lane::SHOULDER_LANE_RIGHT_EDGE;
constexpr Lane_LaneLineRestrictionType Lane::LaneLineRestrictionType_MIN;
constexpr Lane_LaneLineRestrictionType Lane::LaneLineRestrictionType_MAX;
constexpr int Lane::LaneLineRestrictionType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Lane_LaneTransition_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_lane_2flane_2eproto);
  return file_level_enum_descriptors_lane_2flane_2eproto[11];
}
bool Lane_LaneTransition_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 99:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr Lane_LaneTransition Lane::LaneTransition_Unknown;
constexpr Lane_LaneTransition Lane::LaneTransition_Continue;
constexpr Lane_LaneTransition Lane::LaneTransition_Merging;
constexpr Lane_LaneTransition Lane::LaneTransition_Splitting;
constexpr Lane_LaneTransition Lane::LaneTransition_Other;
constexpr Lane_LaneTransition Lane::LaneTransition_MIN;
constexpr Lane_LaneTransition Lane::LaneTransition_MAX;
constexpr int Lane::LaneTransition_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Lane_TurnLimit_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_lane_2flane_2eproto);
  return file_level_enum_descriptors_lane_2flane_2eproto[12];
}
bool Lane_TurnLimit_IsValid(int value) {
  switch (value) {
    case -1:
    case 0:
    case 1:
    case 2:
    case 4:
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr Lane_TurnLimit Lane::NONE;
constexpr Lane_TurnLimit Lane::STRAIGHT;
constexpr Lane_TurnLimit Lane::SLIGHT_RIGHT;
constexpr Lane_TurnLimit Lane::RIGHT;
constexpr Lane_TurnLimit Lane::HARD_RIGHT;
constexpr Lane_TurnLimit Lane::UTURN;
constexpr Lane_TurnLimit Lane::HARD_LEFT;
constexpr Lane_TurnLimit Lane::LEFT;
constexpr Lane_TurnLimit Lane::SLIGHT_LEFT;
constexpr Lane_TurnLimit Lane::NA;
constexpr Lane_TurnLimit Lane::TurnLimit_MIN;
constexpr Lane_TurnLimit Lane::TurnLimit_MAX;
constexpr int Lane::TurnLimit_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LaneGroup_LaneGroupType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_lane_2flane_2eproto);
  return file_level_enum_descriptors_lane_2flane_2eproto[13];
}
bool LaneGroup_LaneGroupType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr LaneGroup_LaneGroupType LaneGroup::UNKOWN_LANEGROUPTYPE;
constexpr LaneGroup_LaneGroupType LaneGroup::OTHERS;
constexpr LaneGroup_LaneGroupType LaneGroup::LANES_TO_TOLL;
constexpr LaneGroup_LaneGroupType LaneGroup::LANES_AT_TOLL;
constexpr LaneGroup_LaneGroupType LaneGroup::EXITING_TOLL;
constexpr LaneGroup_LaneGroupType LaneGroup::LANES_TO_BRIGHT;
constexpr LaneGroup_LaneGroupType LaneGroup::LANES_ON_BRIGHT;
constexpr LaneGroup_LaneGroupType LaneGroup::EXITING_BRIGHT;
constexpr LaneGroup_LaneGroupType LaneGroup::LANES_TO_TUNNEL;
constexpr LaneGroup_LaneGroupType LaneGroup::LANES_IN_TUNNEL;
constexpr LaneGroup_LaneGroupType LaneGroup::EXITING_TUNNEL;
constexpr LaneGroup_LaneGroupType LaneGroup::LANES_ON_JUNCTION;
constexpr LaneGroup_LaneGroupType LaneGroup::LaneGroupType_MIN;
constexpr LaneGroup_LaneGroupType LaneGroup::LaneGroupType_MAX;
constexpr int LaneGroup::LaneGroupType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ImpassableArea_Kind_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_lane_2flane_2eproto);
  return file_level_enum_descriptors_lane_2flane_2eproto[14];
}
bool ImpassableArea_Kind_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr ImpassableArea_Kind ImpassableArea::UNKNOWN_KIND;
constexpr ImpassableArea_Kind ImpassableArea::FLOWERBED;
constexpr ImpassableArea_Kind ImpassableArea::SENTRY_BOX;
constexpr ImpassableArea_Kind ImpassableArea::SAFE_ISLAND;
constexpr ImpassableArea_Kind ImpassableArea::Kind_MIN;
constexpr ImpassableArea_Kind ImpassableArea::Kind_MAX;
constexpr int ImpassableArea::Kind_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VehicleType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_lane_2flane_2eproto);
  return file_level_enum_descriptors_lane_2flane_2eproto[15];
}
bool VehicleType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class LaneDirection::_Internal {
 public:
  using HasBits = decltype(std::declval<LaneDirection>()._has_bits_);
  static void set_has_direction(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_valid_period(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

LaneDirection::LaneDirection(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  allowed_vehicle_types_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:RoadPB.LaneDirection)
}
LaneDirection::LaneDirection(const LaneDirection& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      allowed_vehicle_types_(from.allowed_vehicle_types_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  valid_period_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_valid_period()) {
    valid_period_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_valid_period(), 
      GetArenaForAllocation());
  }
  direction_ = from.direction_;
  // @@protoc_insertion_point(copy_constructor:RoadPB.LaneDirection)
}

inline void LaneDirection::SharedCtor() {
valid_period_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
direction_ = 0;
}

LaneDirection::~LaneDirection() {
  // @@protoc_insertion_point(destructor:RoadPB.LaneDirection)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void LaneDirection::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  valid_period_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void LaneDirection::ArenaDtor(void* object) {
  LaneDirection* _this = reinterpret_cast< LaneDirection* >(object);
  (void)_this;
}
void LaneDirection::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LaneDirection::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LaneDirection::Clear() {
// @@protoc_insertion_point(message_clear_start:RoadPB.LaneDirection)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  allowed_vehicle_types_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    valid_period_.ClearNonDefaultToEmpty();
  }
  direction_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LaneDirection::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 direction = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_direction(&has_bits);
          direction_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string valid_period = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_valid_period();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "RoadPB.LaneDirection.valid_period");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated int32 allowed_vehicle_types = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_allowed_vehicle_types(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<24>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_allowed_vehicle_types(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* LaneDirection::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:RoadPB.LaneDirection)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 direction = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_direction(), target);
  }

  // optional string valid_period = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_valid_period().data(), static_cast<int>(this->_internal_valid_period().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "RoadPB.LaneDirection.valid_period");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_valid_period(), target);
  }

  // repeated int32 allowed_vehicle_types = 3;
  for (int i = 0, n = this->_internal_allowed_vehicle_types_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_allowed_vehicle_types(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:RoadPB.LaneDirection)
  return target;
}

size_t LaneDirection::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:RoadPB.LaneDirection)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 allowed_vehicle_types = 3;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->allowed_vehicle_types_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_allowed_vehicle_types_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string valid_period = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_valid_period());
    }

    // optional int32 direction = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_direction());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LaneDirection::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    LaneDirection::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LaneDirection::GetClassData() const { return &_class_data_; }

void LaneDirection::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to,
                      const ::PROTOBUF_NAMESPACE_ID::Message&from) {
  static_cast<LaneDirection *>(to)->MergeFrom(
      static_cast<const LaneDirection &>(from));
}


void LaneDirection::MergeFrom(const LaneDirection& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:RoadPB.LaneDirection)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  allowed_vehicle_types_.MergeFrom(from.allowed_vehicle_types_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_valid_period(from._internal_valid_period());
    }
    if (cached_has_bits & 0x00000002u) {
      direction_ = from.direction_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LaneDirection::CopyFrom(const LaneDirection& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:RoadPB.LaneDirection)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LaneDirection::IsInitialized() const {
  return true;
}

void LaneDirection::InternalSwap(LaneDirection* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  allowed_vehicle_types_.InternalSwap(&other->allowed_vehicle_types_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &valid_period_, GetArenaForAllocation(),
      &other->valid_period_, other->GetArenaForAllocation()
  );
  swap(direction_, other->direction_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LaneDirection::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_lane_2flane_2eproto_getter, &descriptor_table_lane_2flane_2eproto_once,
      file_level_metadata_lane_2flane_2eproto[0]);
}

// ===================================================================

class LaneBoundary::_Internal {
 public:
  using HasBits = decltype(std::declval<LaneBoundary>()._has_bits_);
  static const ::RoadPB::FeatureID& id(const LaneBoundary* msg);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::RoadPB::Polyline& geom(const LaneBoundary* msg);
  static void set_has_geom(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_color(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_marking(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_ldm(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::RoadPB::FeatureID&
LaneBoundary::_Internal::id(const LaneBoundary* msg) {
  return *msg->id_;
}
const ::RoadPB::Polyline&
LaneBoundary::_Internal::geom(const LaneBoundary* msg) {
  return *msg->geom_;
}
void LaneBoundary::clear_id() {
  if (id_ != nullptr) id_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void LaneBoundary::clear_geom() {
  if (geom_ != nullptr) geom_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
LaneBoundary::LaneBoundary(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  types_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:RoadPB.LaneBoundary)
}
LaneBoundary::LaneBoundary(const LaneBoundary& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      types_(from.types_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_id()) {
    id_ = new ::RoadPB::FeatureID(*from.id_);
  } else {
    id_ = nullptr;
  }
  if (from._internal_has_geom()) {
    geom_ = new ::RoadPB::Polyline(*from.geom_);
  } else {
    geom_ = nullptr;
  }
  ::memcpy(&color_, &from.color_,
    static_cast<size_t>(reinterpret_cast<char*>(&ldm_) -
    reinterpret_cast<char*>(&color_)) + sizeof(ldm_));
  // @@protoc_insertion_point(copy_constructor:RoadPB.LaneBoundary)
}

inline void LaneBoundary::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&ldm_) -
    reinterpret_cast<char*>(&id_)) + sizeof(ldm_));
}

LaneBoundary::~LaneBoundary() {
  // @@protoc_insertion_point(destructor:RoadPB.LaneBoundary)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void LaneBoundary::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete id_;
  if (this != internal_default_instance()) delete geom_;
}

void LaneBoundary::ArenaDtor(void* object) {
  LaneBoundary* _this = reinterpret_cast< LaneBoundary* >(object);
  (void)_this;
}
void LaneBoundary::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LaneBoundary::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LaneBoundary::Clear() {
// @@protoc_insertion_point(message_clear_start:RoadPB.LaneBoundary)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  types_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(id_ != nullptr);
      id_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(geom_ != nullptr);
      geom_->Clear();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&color_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&ldm_) -
        reinterpret_cast<char*>(&color_)) + sizeof(ldm_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LaneBoundary::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .RoadPB.FeatureID id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_id(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .RoadPB.Polyline geom = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_geom(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 color = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_color(&has_bits);
          color_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated int32 types = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_types(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<32>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_types(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 marking = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_marking(&has_bits);
          marking_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool ldm = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_ldm(&has_bits);
          ldm_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* LaneBoundary::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:RoadPB.LaneBoundary)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .RoadPB.FeatureID id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::id(this), target, stream);
  }

  // optional .RoadPB.Polyline geom = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::geom(this), target, stream);
  }

  // optional int32 color = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_color(), target);
  }

  // repeated int32 types = 4;
  for (int i = 0, n = this->_internal_types_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_types(i), target);
  }

  // optional int32 marking = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(5, this->_internal_marking(), target);
  }

  // optional bool ldm = 7;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(7, this->_internal_ldm(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:RoadPB.LaneBoundary)
  return target;
}

size_t LaneBoundary::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:RoadPB.LaneBoundary)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 types = 4;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->types_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_types_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .RoadPB.FeatureID id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *id_);
    }

    // optional .RoadPB.Polyline geom = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *geom_);
    }

    // optional int32 color = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_color());
    }

    // optional int32 marking = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_marking());
    }

    // optional bool ldm = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LaneBoundary::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    LaneBoundary::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LaneBoundary::GetClassData() const { return &_class_data_; }

void LaneBoundary::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to,
                      const ::PROTOBUF_NAMESPACE_ID::Message&from) {
  static_cast<LaneBoundary *>(to)->MergeFrom(
      static_cast<const LaneBoundary &>(from));
}


void LaneBoundary::MergeFrom(const LaneBoundary& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:RoadPB.LaneBoundary)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  types_.MergeFrom(from.types_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_id()->::RoadPB::FeatureID::MergeFrom(from._internal_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_geom()->::RoadPB::Polyline::MergeFrom(from._internal_geom());
    }
    if (cached_has_bits & 0x00000004u) {
      color_ = from.color_;
    }
    if (cached_has_bits & 0x00000008u) {
      marking_ = from.marking_;
    }
    if (cached_has_bits & 0x00000010u) {
      ldm_ = from.ldm_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LaneBoundary::CopyFrom(const LaneBoundary& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:RoadPB.LaneBoundary)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LaneBoundary::IsInitialized() const {
  return true;
}

void LaneBoundary::InternalSwap(LaneBoundary* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  types_.InternalSwap(&other->types_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LaneBoundary, ldm_)
      + sizeof(LaneBoundary::ldm_)
      - PROTOBUF_FIELD_OFFSET(LaneBoundary, id_)>(
          reinterpret_cast<char*>(&id_),
          reinterpret_cast<char*>(&other->id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LaneBoundary::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_lane_2flane_2eproto_getter, &descriptor_table_lane_2flane_2eproto_once,
      file_level_metadata_lane_2flane_2eproto[1]);
}

// ===================================================================

class LaneBoundaryRange::_Internal {
 public:
  using HasBits = decltype(std::declval<LaneBoundaryRange>()._has_bits_);
  static const ::RoadPB::FeatureID& bound_id(const LaneBoundaryRange* msg);
  static void set_has_bound_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::RoadPB::Point& start_pt(const LaneBoundaryRange* msg);
  static void set_has_start_pt(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::RoadPB::Point& end_pt(const LaneBoundaryRange* msg);
  static void set_has_end_pt(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::RoadPB::FeatureID&
LaneBoundaryRange::_Internal::bound_id(const LaneBoundaryRange* msg) {
  return *msg->bound_id_;
}
const ::RoadPB::Point&
LaneBoundaryRange::_Internal::start_pt(const LaneBoundaryRange* msg) {
  return *msg->start_pt_;
}
const ::RoadPB::Point&
LaneBoundaryRange::_Internal::end_pt(const LaneBoundaryRange* msg) {
  return *msg->end_pt_;
}
void LaneBoundaryRange::clear_bound_id() {
  if (bound_id_ != nullptr) bound_id_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void LaneBoundaryRange::clear_start_pt() {
  if (start_pt_ != nullptr) start_pt_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
void LaneBoundaryRange::clear_end_pt() {
  if (end_pt_ != nullptr) end_pt_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
LaneBoundaryRange::LaneBoundaryRange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:RoadPB.LaneBoundaryRange)
}
LaneBoundaryRange::LaneBoundaryRange(const LaneBoundaryRange& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_bound_id()) {
    bound_id_ = new ::RoadPB::FeatureID(*from.bound_id_);
  } else {
    bound_id_ = nullptr;
  }
  if (from._internal_has_start_pt()) {
    start_pt_ = new ::RoadPB::Point(*from.start_pt_);
  } else {
    start_pt_ = nullptr;
  }
  if (from._internal_has_end_pt()) {
    end_pt_ = new ::RoadPB::Point(*from.end_pt_);
  } else {
    end_pt_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:RoadPB.LaneBoundaryRange)
}

inline void LaneBoundaryRange::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&bound_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&end_pt_) -
    reinterpret_cast<char*>(&bound_id_)) + sizeof(end_pt_));
}

LaneBoundaryRange::~LaneBoundaryRange() {
  // @@protoc_insertion_point(destructor:RoadPB.LaneBoundaryRange)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void LaneBoundaryRange::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete bound_id_;
  if (this != internal_default_instance()) delete start_pt_;
  if (this != internal_default_instance()) delete end_pt_;
}

void LaneBoundaryRange::ArenaDtor(void* object) {
  LaneBoundaryRange* _this = reinterpret_cast< LaneBoundaryRange* >(object);
  (void)_this;
}
void LaneBoundaryRange::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LaneBoundaryRange::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LaneBoundaryRange::Clear() {
// @@protoc_insertion_point(message_clear_start:RoadPB.LaneBoundaryRange)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(bound_id_ != nullptr);
      bound_id_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(start_pt_ != nullptr);
      start_pt_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(end_pt_ != nullptr);
      end_pt_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LaneBoundaryRange::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .RoadPB.FeatureID bound_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_bound_id(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .RoadPB.Point start_pt = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_start_pt(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .RoadPB.Point end_pt = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_end_pt(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* LaneBoundaryRange::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:RoadPB.LaneBoundaryRange)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .RoadPB.FeatureID bound_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::bound_id(this), target, stream);
  }

  // optional .RoadPB.Point start_pt = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::start_pt(this), target, stream);
  }

  // optional .RoadPB.Point end_pt = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::end_pt(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:RoadPB.LaneBoundaryRange)
  return target;
}

size_t LaneBoundaryRange::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:RoadPB.LaneBoundaryRange)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .RoadPB.FeatureID bound_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *bound_id_);
    }

    // optional .RoadPB.Point start_pt = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *start_pt_);
    }

    // optional .RoadPB.Point end_pt = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *end_pt_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LaneBoundaryRange::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    LaneBoundaryRange::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LaneBoundaryRange::GetClassData() const { return &_class_data_; }

void LaneBoundaryRange::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to,
                      const ::PROTOBUF_NAMESPACE_ID::Message&from) {
  static_cast<LaneBoundaryRange *>(to)->MergeFrom(
      static_cast<const LaneBoundaryRange &>(from));
}


void LaneBoundaryRange::MergeFrom(const LaneBoundaryRange& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:RoadPB.LaneBoundaryRange)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_bound_id()->::RoadPB::FeatureID::MergeFrom(from._internal_bound_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_start_pt()->::RoadPB::Point::MergeFrom(from._internal_start_pt());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_end_pt()->::RoadPB::Point::MergeFrom(from._internal_end_pt());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LaneBoundaryRange::CopyFrom(const LaneBoundaryRange& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:RoadPB.LaneBoundaryRange)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LaneBoundaryRange::IsInitialized() const {
  return true;
}

void LaneBoundaryRange::InternalSwap(LaneBoundaryRange* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LaneBoundaryRange, end_pt_)
      + sizeof(LaneBoundaryRange::end_pt_)
      - PROTOBUF_FIELD_OFFSET(LaneBoundaryRange, bound_id_)>(
          reinterpret_cast<char*>(&bound_id_),
          reinterpret_cast<char*>(&other->bound_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LaneBoundaryRange::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_lane_2flane_2eproto_getter, &descriptor_table_lane_2flane_2eproto_once,
      file_level_metadata_lane_2flane_2eproto[2]);
}

// ===================================================================

class RoadBoundary::_Internal {
 public:
  using HasBits = decltype(std::declval<RoadBoundary>()._has_bits_);
  static const ::RoadPB::FeatureID& id(const RoadBoundary* msg);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::RoadPB::Polyline& geom(const RoadBoundary* msg);
  static void set_has_geom(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::RoadPB::FeatureID&
RoadBoundary::_Internal::id(const RoadBoundary* msg) {
  return *msg->id_;
}
const ::RoadPB::Polyline&
RoadBoundary::_Internal::geom(const RoadBoundary* msg) {
  return *msg->geom_;
}
void RoadBoundary::clear_id() {
  if (id_ != nullptr) id_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void RoadBoundary::clear_geom() {
  if (geom_ != nullptr) geom_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
RoadBoundary::RoadBoundary(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:RoadPB.RoadBoundary)
}
RoadBoundary::RoadBoundary(const RoadBoundary& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_id()) {
    id_ = new ::RoadPB::FeatureID(*from.id_);
  } else {
    id_ = nullptr;
  }
  if (from._internal_has_geom()) {
    geom_ = new ::RoadPB::Polyline(*from.geom_);
  } else {
    geom_ = nullptr;
  }
  type_ = from.type_;
  // @@protoc_insertion_point(copy_constructor:RoadPB.RoadBoundary)
}

inline void RoadBoundary::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&type_) -
    reinterpret_cast<char*>(&id_)) + sizeof(type_));
}

RoadBoundary::~RoadBoundary() {
  // @@protoc_insertion_point(destructor:RoadPB.RoadBoundary)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void RoadBoundary::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete id_;
  if (this != internal_default_instance()) delete geom_;
}

void RoadBoundary::ArenaDtor(void* object) {
  RoadBoundary* _this = reinterpret_cast< RoadBoundary* >(object);
  (void)_this;
}
void RoadBoundary::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RoadBoundary::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RoadBoundary::Clear() {
// @@protoc_insertion_point(message_clear_start:RoadPB.RoadBoundary)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(id_ != nullptr);
      id_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(geom_ != nullptr);
      geom_->Clear();
    }
  }
  type_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RoadBoundary::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .RoadPB.FeatureID id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_id(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_type(&has_bits);
          type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .RoadPB.Polyline geom = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_geom(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* RoadBoundary::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:RoadPB.RoadBoundary)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .RoadPB.FeatureID id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::id(this), target, stream);
  }

  // optional int32 type = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_type(), target);
  }

  // optional .RoadPB.Polyline geom = 10;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        10, _Internal::geom(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:RoadPB.RoadBoundary)
  return target;
}

size_t RoadBoundary::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:RoadPB.RoadBoundary)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .RoadPB.FeatureID id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *id_);
    }

    // optional .RoadPB.Polyline geom = 10;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *geom_);
    }

    // optional int32 type = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RoadBoundary::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    RoadBoundary::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RoadBoundary::GetClassData() const { return &_class_data_; }

void RoadBoundary::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to,
                      const ::PROTOBUF_NAMESPACE_ID::Message&from) {
  static_cast<RoadBoundary *>(to)->MergeFrom(
      static_cast<const RoadBoundary &>(from));
}


void RoadBoundary::MergeFrom(const RoadBoundary& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:RoadPB.RoadBoundary)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_id()->::RoadPB::FeatureID::MergeFrom(from._internal_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_geom()->::RoadPB::Polyline::MergeFrom(from._internal_geom());
    }
    if (cached_has_bits & 0x00000004u) {
      type_ = from.type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RoadBoundary::CopyFrom(const RoadBoundary& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:RoadPB.RoadBoundary)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RoadBoundary::IsInitialized() const {
  return true;
}

void RoadBoundary::InternalSwap(RoadBoundary* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RoadBoundary, type_)
      + sizeof(RoadBoundary::type_)
      - PROTOBUF_FIELD_OFFSET(RoadBoundary, id_)>(
          reinterpret_cast<char*>(&id_),
          reinterpret_cast<char*>(&other->id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RoadBoundary::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_lane_2flane_2eproto_getter, &descriptor_table_lane_2flane_2eproto_once,
      file_level_metadata_lane_2flane_2eproto[3]);
}

// ===================================================================

class LaneSection::_Internal {
 public:
  using HasBits = decltype(std::declval<LaneSection>()._has_bits_);
  static const ::RoadPB::LaneBoundaryRange& left_boundary(const LaneSection* msg);
  static void set_has_left_boundary(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::RoadPB::LaneBoundaryRange& right_boundary(const LaneSection* msg);
  static void set_has_right_boundary(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_width(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_height_limit(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_weight_limit(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_width_limit(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

const ::RoadPB::LaneBoundaryRange&
LaneSection::_Internal::left_boundary(const LaneSection* msg) {
  return *msg->left_boundary_;
}
const ::RoadPB::LaneBoundaryRange&
LaneSection::_Internal::right_boundary(const LaneSection* msg) {
  return *msg->right_boundary_;
}
void LaneSection::clear_speed_limits() {
  speed_limits_.Clear();
}
void LaneSection::clear_objects() {
  objects_.Clear();
}
void LaneSection::clear_traffics() {
  traffics_.Clear();
}
LaneSection::LaneSection(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  speed_limits_(arena),
  objects_(arena),
  traffics_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:RoadPB.LaneSection)
}
LaneSection::LaneSection(const LaneSection& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      speed_limits_(from.speed_limits_),
      objects_(from.objects_),
      traffics_(from.traffics_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_left_boundary()) {
    left_boundary_ = new ::RoadPB::LaneBoundaryRange(*from.left_boundary_);
  } else {
    left_boundary_ = nullptr;
  }
  if (from._internal_has_right_boundary()) {
    right_boundary_ = new ::RoadPB::LaneBoundaryRange(*from.right_boundary_);
  } else {
    right_boundary_ = nullptr;
  }
  ::memcpy(&width_, &from.width_,
    static_cast<size_t>(reinterpret_cast<char*>(&width_limit_) -
    reinterpret_cast<char*>(&width_)) + sizeof(width_limit_));
  // @@protoc_insertion_point(copy_constructor:RoadPB.LaneSection)
}

inline void LaneSection::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&left_boundary_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&width_limit_) -
    reinterpret_cast<char*>(&left_boundary_)) + sizeof(width_limit_));
}

LaneSection::~LaneSection() {
  // @@protoc_insertion_point(destructor:RoadPB.LaneSection)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void LaneSection::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete left_boundary_;
  if (this != internal_default_instance()) delete right_boundary_;
}

void LaneSection::ArenaDtor(void* object) {
  LaneSection* _this = reinterpret_cast< LaneSection* >(object);
  (void)_this;
}
void LaneSection::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LaneSection::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LaneSection::Clear() {
// @@protoc_insertion_point(message_clear_start:RoadPB.LaneSection)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  speed_limits_.Clear();
  objects_.Clear();
  traffics_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(left_boundary_ != nullptr);
      left_boundary_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(right_boundary_ != nullptr);
      right_boundary_->Clear();
    }
  }
  if (cached_has_bits & 0x0000003cu) {
    ::memset(&width_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&width_limit_) -
        reinterpret_cast<char*>(&width_)) + sizeof(width_limit_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LaneSection::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .RoadPB.LaneBoundaryRange left_boundary = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_left_boundary(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .RoadPB.LaneBoundaryRange right_boundary = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_right_boundary(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .RoadPB.FixedSpeedLimit speed_limits = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_speed_limits(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .RoadPB.FeatureID objects = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_objects(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .RoadPB.FeatureID traffics = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_traffics(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else goto handle_unusual;
        continue;
      // optional float width = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 61)) {
          _Internal::set_has_width(&has_bits);
          width_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float height_limit = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 69)) {
          _Internal::set_has_height_limit(&has_bits);
          height_limit_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float weight_limit = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 77)) {
          _Internal::set_has_weight_limit(&has_bits);
          weight_limit_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float width_limit = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 85)) {
          _Internal::set_has_width_limit(&has_bits);
          width_limit_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* LaneSection::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:RoadPB.LaneSection)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .RoadPB.LaneBoundaryRange left_boundary = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::left_boundary(this), target, stream);
  }

  // optional .RoadPB.LaneBoundaryRange right_boundary = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::right_boundary(this), target, stream);
  }

  // repeated .RoadPB.FixedSpeedLimit speed_limits = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_speed_limits_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_speed_limits(i), target, stream);
  }

  // repeated .RoadPB.FeatureID objects = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_objects_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, this->_internal_objects(i), target, stream);
  }

  // repeated .RoadPB.FeatureID traffics = 6;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_traffics_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, this->_internal_traffics(i), target, stream);
  }

  // optional float width = 7;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(7, this->_internal_width(), target);
  }

  // optional float height_limit = 8;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(8, this->_internal_height_limit(), target);
  }

  // optional float weight_limit = 9;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(9, this->_internal_weight_limit(), target);
  }

  // optional float width_limit = 10;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(10, this->_internal_width_limit(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:RoadPB.LaneSection)
  return target;
}

size_t LaneSection::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:RoadPB.LaneSection)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .RoadPB.FixedSpeedLimit speed_limits = 3;
  total_size += 1UL * this->_internal_speed_limits_size();
  for (const auto& msg : this->speed_limits_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .RoadPB.FeatureID objects = 5;
  total_size += 1UL * this->_internal_objects_size();
  for (const auto& msg : this->objects_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .RoadPB.FeatureID traffics = 6;
  total_size += 1UL * this->_internal_traffics_size();
  for (const auto& msg : this->traffics_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional .RoadPB.LaneBoundaryRange left_boundary = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *left_boundary_);
    }

    // optional .RoadPB.LaneBoundaryRange right_boundary = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *right_boundary_);
    }

    // optional float width = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float height_limit = 8;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional float weight_limit = 9;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional float width_limit = 10;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LaneSection::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    LaneSection::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LaneSection::GetClassData() const { return &_class_data_; }

void LaneSection::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to,
                      const ::PROTOBUF_NAMESPACE_ID::Message&from) {
  static_cast<LaneSection *>(to)->MergeFrom(
      static_cast<const LaneSection &>(from));
}


void LaneSection::MergeFrom(const LaneSection& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:RoadPB.LaneSection)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  speed_limits_.MergeFrom(from.speed_limits_);
  objects_.MergeFrom(from.objects_);
  traffics_.MergeFrom(from.traffics_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_left_boundary()->::RoadPB::LaneBoundaryRange::MergeFrom(from._internal_left_boundary());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_right_boundary()->::RoadPB::LaneBoundaryRange::MergeFrom(from._internal_right_boundary());
    }
    if (cached_has_bits & 0x00000004u) {
      width_ = from.width_;
    }
    if (cached_has_bits & 0x00000008u) {
      height_limit_ = from.height_limit_;
    }
    if (cached_has_bits & 0x00000010u) {
      weight_limit_ = from.weight_limit_;
    }
    if (cached_has_bits & 0x00000020u) {
      width_limit_ = from.width_limit_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LaneSection::CopyFrom(const LaneSection& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:RoadPB.LaneSection)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LaneSection::IsInitialized() const {
  return true;
}

void LaneSection::InternalSwap(LaneSection* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  speed_limits_.InternalSwap(&other->speed_limits_);
  objects_.InternalSwap(&other->objects_);
  traffics_.InternalSwap(&other->traffics_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LaneSection, width_limit_)
      + sizeof(LaneSection::width_limit_)
      - PROTOBUF_FIELD_OFFSET(LaneSection, left_boundary_)>(
          reinterpret_cast<char*>(&left_boundary_),
          reinterpret_cast<char*>(&other->left_boundary_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LaneSection::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_lane_2flane_2eproto_getter, &descriptor_table_lane_2flane_2eproto_once,
      file_level_metadata_lane_2flane_2eproto[4]);
}

// ===================================================================

class Lane::_Internal {
 public:
  using HasBits = decltype(std::declval<Lane>()._has_bits_);
  static const ::RoadPB::FeatureID& id(const Lane* msg);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_function(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_priority(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_length(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_seq_no(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_transition(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_turn_limit(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

const ::RoadPB::FeatureID&
Lane::_Internal::id(const Lane* msg) {
  return *msg->id_;
}
void Lane::clear_id() {
  if (id_ != nullptr) id_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void Lane::clear_drivelines() {
  drivelines_.Clear();
}
void Lane::clear_preds() {
  preds_.Clear();
}
void Lane::clear_succs() {
  succs_.Clear();
}
Lane::Lane(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  lanes_(arena),
  drivelines_(arena),
  directions_(arena),
  preds_(arena),
  succs_(arena),
  l_restrictions_(arena),
  r_restrictions_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:RoadPB.Lane)
}
Lane::Lane(const Lane& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      lanes_(from.lanes_),
      drivelines_(from.drivelines_),
      directions_(from.directions_),
      preds_(from.preds_),
      succs_(from.succs_),
      l_restrictions_(from.l_restrictions_),
      r_restrictions_(from.r_restrictions_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_id()) {
    id_ = new ::RoadPB::FeatureID(*from.id_);
  } else {
    id_ = nullptr;
  }
  ::memcpy(&type_, &from.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&turn_limit_) -
    reinterpret_cast<char*>(&type_)) + sizeof(turn_limit_));
  // @@protoc_insertion_point(copy_constructor:RoadPB.Lane)
}

inline void Lane::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&turn_limit_) -
    reinterpret_cast<char*>(&id_)) + sizeof(turn_limit_));
}

Lane::~Lane() {
  // @@protoc_insertion_point(destructor:RoadPB.Lane)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Lane::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete id_;
}

void Lane::ArenaDtor(void* object) {
  Lane* _this = reinterpret_cast< Lane* >(object);
  (void)_this;
}
void Lane::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Lane::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Lane::Clear() {
// @@protoc_insertion_point(message_clear_start:RoadPB.Lane)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  lanes_.Clear();
  drivelines_.Clear();
  directions_.Clear();
  preds_.Clear();
  succs_.Clear();
  l_restrictions_.Clear();
  r_restrictions_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(id_ != nullptr);
    id_->Clear();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&turn_limit_) -
        reinterpret_cast<char*>(&type_)) + sizeof(turn_limit_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Lane::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .RoadPB.FeatureID id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_id(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .RoadPB.LaneSection lanes = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_lanes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .RoadPB.FeatureID drivelines = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_drivelines(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else goto handle_unusual;
        continue;
      // optional int32 function = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_function(&has_bits);
          function_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 type = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_type(&has_bits);
          type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .RoadPB.LaneDirection directions = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_directions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else goto handle_unusual;
        continue;
      // optional int32 priority = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_priority(&has_bits);
          priority_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float length = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 77)) {
          _Internal::set_has_length(&has_bits);
          length_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional int32 seq_no = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          _Internal::set_has_seq_no(&has_bits);
          seq_no_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .RoadPB.FeatureID preds = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_preds(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .RoadPB.FeatureID succs = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 98)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_succs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<98>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated int32 l_restrictions = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 104)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_l_restrictions(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<104>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 106) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_l_restrictions(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated int32 r_restrictions = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 112)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_r_restrictions(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<112>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 114) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_r_restrictions(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 transition = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 120)) {
          _Internal::set_has_transition(&has_bits);
          transition_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 turn_limit = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 128)) {
          _Internal::set_has_turn_limit(&has_bits);
          turn_limit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Lane::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:RoadPB.Lane)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .RoadPB.FeatureID id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::id(this), target, stream);
  }

  // repeated .RoadPB.LaneSection lanes = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_lanes_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_lanes(i), target, stream);
  }

  // repeated .RoadPB.FeatureID drivelines = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_drivelines_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_drivelines(i), target, stream);
  }

  // optional int32 function = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_function(), target);
  }

  // optional uint64 type = 5;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(5, this->_internal_type(), target);
  }

  // repeated .RoadPB.LaneDirection directions = 7;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_directions_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, this->_internal_directions(i), target, stream);
  }

  // optional int32 priority = 8;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(8, this->_internal_priority(), target);
  }

  // optional float length = 9;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(9, this->_internal_length(), target);
  }

  // optional int32 seq_no = 10;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(10, this->_internal_seq_no(), target);
  }

  // repeated .RoadPB.FeatureID preds = 11;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_preds_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, this->_internal_preds(i), target, stream);
  }

  // repeated .RoadPB.FeatureID succs = 12;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_succs_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, this->_internal_succs(i), target, stream);
  }

  // repeated int32 l_restrictions = 13;
  for (int i = 0, n = this->_internal_l_restrictions_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(13, this->_internal_l_restrictions(i), target);
  }

  // repeated int32 r_restrictions = 14;
  for (int i = 0, n = this->_internal_r_restrictions_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(14, this->_internal_r_restrictions(i), target);
  }

  // optional int32 transition = 15;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(15, this->_internal_transition(), target);
  }

  // optional int32 turn_limit = 16;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(16, this->_internal_turn_limit(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:RoadPB.Lane)
  return target;
}

size_t Lane::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:RoadPB.Lane)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .RoadPB.LaneSection lanes = 2;
  total_size += 1UL * this->_internal_lanes_size();
  for (const auto& msg : this->lanes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .RoadPB.FeatureID drivelines = 3;
  total_size += 1UL * this->_internal_drivelines_size();
  for (const auto& msg : this->drivelines_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .RoadPB.LaneDirection directions = 7;
  total_size += 1UL * this->_internal_directions_size();
  for (const auto& msg : this->directions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .RoadPB.FeatureID preds = 11;
  total_size += 1UL * this->_internal_preds_size();
  for (const auto& msg : this->preds_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .RoadPB.FeatureID succs = 12;
  total_size += 1UL * this->_internal_succs_size();
  for (const auto& msg : this->succs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated int32 l_restrictions = 13;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->l_restrictions_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_l_restrictions_size());
    total_size += data_size;
  }

  // repeated int32 r_restrictions = 14;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->r_restrictions_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_r_restrictions_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .RoadPB.FeatureID id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *id_);
    }

    // optional uint64 type = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_type());
    }

    // optional int32 function = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_function());
    }

    // optional int32 priority = 8;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_priority());
    }

    // optional float length = 9;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional int32 seq_no = 10;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_seq_no());
    }

    // optional int32 transition = 15;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_transition());
    }

    // optional int32 turn_limit = 16;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_turn_limit());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Lane::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Lane::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Lane::GetClassData() const { return &_class_data_; }

void Lane::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to,
                      const ::PROTOBUF_NAMESPACE_ID::Message&from) {
  static_cast<Lane *>(to)->MergeFrom(
      static_cast<const Lane &>(from));
}


void Lane::MergeFrom(const Lane& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:RoadPB.Lane)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  lanes_.MergeFrom(from.lanes_);
  drivelines_.MergeFrom(from.drivelines_);
  directions_.MergeFrom(from.directions_);
  preds_.MergeFrom(from.preds_);
  succs_.MergeFrom(from.succs_);
  l_restrictions_.MergeFrom(from.l_restrictions_);
  r_restrictions_.MergeFrom(from.r_restrictions_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_id()->::RoadPB::FeatureID::MergeFrom(from._internal_id());
    }
    if (cached_has_bits & 0x00000002u) {
      type_ = from.type_;
    }
    if (cached_has_bits & 0x00000004u) {
      function_ = from.function_;
    }
    if (cached_has_bits & 0x00000008u) {
      priority_ = from.priority_;
    }
    if (cached_has_bits & 0x00000010u) {
      length_ = from.length_;
    }
    if (cached_has_bits & 0x00000020u) {
      seq_no_ = from.seq_no_;
    }
    if (cached_has_bits & 0x00000040u) {
      transition_ = from.transition_;
    }
    if (cached_has_bits & 0x00000080u) {
      turn_limit_ = from.turn_limit_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Lane::CopyFrom(const Lane& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:RoadPB.Lane)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Lane::IsInitialized() const {
  return true;
}

void Lane::InternalSwap(Lane* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  lanes_.InternalSwap(&other->lanes_);
  drivelines_.InternalSwap(&other->drivelines_);
  directions_.InternalSwap(&other->directions_);
  preds_.InternalSwap(&other->preds_);
  succs_.InternalSwap(&other->succs_);
  l_restrictions_.InternalSwap(&other->l_restrictions_);
  r_restrictions_.InternalSwap(&other->r_restrictions_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Lane, turn_limit_)
      + sizeof(Lane::turn_limit_)
      - PROTOBUF_FIELD_OFFSET(Lane, id_)>(
          reinterpret_cast<char*>(&id_),
          reinterpret_cast<char*>(&other->id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Lane::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_lane_2flane_2eproto_getter, &descriptor_table_lane_2flane_2eproto_once,
      file_level_metadata_lane_2flane_2eproto[5]);
}

// ===================================================================

class LaneGroup::_Internal {
 public:
  using HasBits = decltype(std::declval<LaneGroup>()._has_bits_);
  static const ::RoadPB::FeatureID& id(const LaneGroup* msg);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::RoadPB::FeatureID& link_id(const LaneGroup* msg);
  static void set_has_link_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::RoadPB::FeatureID&
LaneGroup::_Internal::id(const LaneGroup* msg) {
  return *msg->id_;
}
const ::RoadPB::FeatureID&
LaneGroup::_Internal::link_id(const LaneGroup* msg) {
  return *msg->link_id_;
}
void LaneGroup::clear_id() {
  if (id_ != nullptr) id_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void LaneGroup::clear_link_id() {
  if (link_id_ != nullptr) link_id_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
void LaneGroup::clear_left_boundarys() {
  left_boundarys_.Clear();
}
void LaneGroup::clear_right_boundarys() {
  right_boundarys_.Clear();
}
void LaneGroup::clear_lanes() {
  lanes_.Clear();
}
void LaneGroup::clear_preds() {
  preds_.Clear();
}
void LaneGroup::clear_succs() {
  succs_.Clear();
}
LaneGroup::LaneGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  types_(arena),
  left_boundarys_(arena),
  right_boundarys_(arena),
  lanes_(arena),
  preds_(arena),
  succs_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:RoadPB.LaneGroup)
}
LaneGroup::LaneGroup(const LaneGroup& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      types_(from.types_),
      left_boundarys_(from.left_boundarys_),
      right_boundarys_(from.right_boundarys_),
      lanes_(from.lanes_),
      preds_(from.preds_),
      succs_(from.succs_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_id()) {
    id_ = new ::RoadPB::FeatureID(*from.id_);
  } else {
    id_ = nullptr;
  }
  if (from._internal_has_link_id()) {
    link_id_ = new ::RoadPB::FeatureID(*from.link_id_);
  } else {
    link_id_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:RoadPB.LaneGroup)
}

inline void LaneGroup::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&link_id_) -
    reinterpret_cast<char*>(&id_)) + sizeof(link_id_));
}

LaneGroup::~LaneGroup() {
  // @@protoc_insertion_point(destructor:RoadPB.LaneGroup)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void LaneGroup::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete id_;
  if (this != internal_default_instance()) delete link_id_;
}

void LaneGroup::ArenaDtor(void* object) {
  LaneGroup* _this = reinterpret_cast< LaneGroup* >(object);
  (void)_this;
}
void LaneGroup::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LaneGroup::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LaneGroup::Clear() {
// @@protoc_insertion_point(message_clear_start:RoadPB.LaneGroup)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  types_.Clear();
  left_boundarys_.Clear();
  right_boundarys_.Clear();
  lanes_.Clear();
  preds_.Clear();
  succs_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(id_ != nullptr);
      id_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(link_id_ != nullptr);
      link_id_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LaneGroup::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .RoadPB.FeatureID id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_id(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .RoadPB.FeatureID link_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_link_id(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated int32 types = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_types(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<32>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_types(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .RoadPB.FeatureID left_boundarys = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_left_boundarys(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .RoadPB.FeatureID right_boundarys = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_right_boundarys(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .RoadPB.FeatureID lanes = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_lanes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .RoadPB.FeatureID preds = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_preds(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .RoadPB.FeatureID succs = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_succs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* LaneGroup::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:RoadPB.LaneGroup)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .RoadPB.FeatureID id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::id(this), target, stream);
  }

  // optional .RoadPB.FeatureID link_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::link_id(this), target, stream);
  }

  // repeated int32 types = 4;
  for (int i = 0, n = this->_internal_types_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_types(i), target);
  }

  // repeated .RoadPB.FeatureID left_boundarys = 6;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_left_boundarys_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, this->_internal_left_boundarys(i), target, stream);
  }

  // repeated .RoadPB.FeatureID right_boundarys = 7;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_right_boundarys_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, this->_internal_right_boundarys(i), target, stream);
  }

  // repeated .RoadPB.FeatureID lanes = 8;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_lanes_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, this->_internal_lanes(i), target, stream);
  }

  // repeated .RoadPB.FeatureID preds = 9;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_preds_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, this->_internal_preds(i), target, stream);
  }

  // repeated .RoadPB.FeatureID succs = 10;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_succs_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, this->_internal_succs(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:RoadPB.LaneGroup)
  return target;
}

size_t LaneGroup::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:RoadPB.LaneGroup)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 types = 4;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->types_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_types_size());
    total_size += data_size;
  }

  // repeated .RoadPB.FeatureID left_boundarys = 6;
  total_size += 1UL * this->_internal_left_boundarys_size();
  for (const auto& msg : this->left_boundarys_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .RoadPB.FeatureID right_boundarys = 7;
  total_size += 1UL * this->_internal_right_boundarys_size();
  for (const auto& msg : this->right_boundarys_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .RoadPB.FeatureID lanes = 8;
  total_size += 1UL * this->_internal_lanes_size();
  for (const auto& msg : this->lanes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .RoadPB.FeatureID preds = 9;
  total_size += 1UL * this->_internal_preds_size();
  for (const auto& msg : this->preds_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .RoadPB.FeatureID succs = 10;
  total_size += 1UL * this->_internal_succs_size();
  for (const auto& msg : this->succs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .RoadPB.FeatureID id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *id_);
    }

    // optional .RoadPB.FeatureID link_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *link_id_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LaneGroup::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    LaneGroup::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LaneGroup::GetClassData() const { return &_class_data_; }

void LaneGroup::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to,
                      const ::PROTOBUF_NAMESPACE_ID::Message&from) {
  static_cast<LaneGroup *>(to)->MergeFrom(
      static_cast<const LaneGroup &>(from));
}


void LaneGroup::MergeFrom(const LaneGroup& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:RoadPB.LaneGroup)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  types_.MergeFrom(from.types_);
  left_boundarys_.MergeFrom(from.left_boundarys_);
  right_boundarys_.MergeFrom(from.right_boundarys_);
  lanes_.MergeFrom(from.lanes_);
  preds_.MergeFrom(from.preds_);
  succs_.MergeFrom(from.succs_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_id()->::RoadPB::FeatureID::MergeFrom(from._internal_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_link_id()->::RoadPB::FeatureID::MergeFrom(from._internal_link_id());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LaneGroup::CopyFrom(const LaneGroup& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:RoadPB.LaneGroup)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LaneGroup::IsInitialized() const {
  return true;
}

void LaneGroup::InternalSwap(LaneGroup* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  types_.InternalSwap(&other->types_);
  left_boundarys_.InternalSwap(&other->left_boundarys_);
  right_boundarys_.InternalSwap(&other->right_boundarys_);
  lanes_.InternalSwap(&other->lanes_);
  preds_.InternalSwap(&other->preds_);
  succs_.InternalSwap(&other->succs_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LaneGroup, link_id_)
      + sizeof(LaneGroup::link_id_)
      - PROTOBUF_FIELD_OFFSET(LaneGroup, id_)>(
          reinterpret_cast<char*>(&id_),
          reinterpret_cast<char*>(&other->id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LaneGroup::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_lane_2flane_2eproto_getter, &descriptor_table_lane_2flane_2eproto_once,
      file_level_metadata_lane_2flane_2eproto[6]);
}

// ===================================================================

class ImpassableArea::_Internal {
 public:
  using HasBits = decltype(std::declval<ImpassableArea>()._has_bits_);
  static const ::RoadPB::Polygon& geom(const ImpassableArea* msg);
  static void set_has_geom(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_kind(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::RoadPB::Polygon&
ImpassableArea::_Internal::geom(const ImpassableArea* msg) {
  return *msg->geom_;
}
void ImpassableArea::clear_geom() {
  if (geom_ != nullptr) geom_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
ImpassableArea::ImpassableArea(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:RoadPB.ImpassableArea)
}
ImpassableArea::ImpassableArea(const ImpassableArea& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_geom()) {
    geom_ = new ::RoadPB::Polygon(*from.geom_);
  } else {
    geom_ = nullptr;
  }
  ::memcpy(&type_, &from.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&kind_) -
    reinterpret_cast<char*>(&type_)) + sizeof(kind_));
  // @@protoc_insertion_point(copy_constructor:RoadPB.ImpassableArea)
}

inline void ImpassableArea::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&geom_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&kind_) -
    reinterpret_cast<char*>(&geom_)) + sizeof(kind_));
}

ImpassableArea::~ImpassableArea() {
  // @@protoc_insertion_point(destructor:RoadPB.ImpassableArea)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ImpassableArea::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete geom_;
}

void ImpassableArea::ArenaDtor(void* object) {
  ImpassableArea* _this = reinterpret_cast< ImpassableArea* >(object);
  (void)_this;
}
void ImpassableArea::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ImpassableArea::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ImpassableArea::Clear() {
// @@protoc_insertion_point(message_clear_start:RoadPB.ImpassableArea)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(geom_ != nullptr);
    geom_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&kind_) -
        reinterpret_cast<char*>(&type_)) + sizeof(kind_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ImpassableArea::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .RoadPB.Polygon geom = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_geom(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_type(&has_bits);
          type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 kind = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_kind(&has_bits);
          kind_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ImpassableArea::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:RoadPB.ImpassableArea)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .RoadPB.Polygon geom = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::geom(this), target, stream);
  }

  // optional int32 type = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_type(), target);
  }

  // optional int32 kind = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_kind(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:RoadPB.ImpassableArea)
  return target;
}

size_t ImpassableArea::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:RoadPB.ImpassableArea)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .RoadPB.Polygon geom = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *geom_);
    }

    // optional int32 type = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_type());
    }

    // optional int32 kind = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_kind());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ImpassableArea::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ImpassableArea::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ImpassableArea::GetClassData() const { return &_class_data_; }

void ImpassableArea::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to,
                      const ::PROTOBUF_NAMESPACE_ID::Message&from) {
  static_cast<ImpassableArea *>(to)->MergeFrom(
      static_cast<const ImpassableArea &>(from));
}


void ImpassableArea::MergeFrom(const ImpassableArea& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:RoadPB.ImpassableArea)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_geom()->::RoadPB::Polygon::MergeFrom(from._internal_geom());
    }
    if (cached_has_bits & 0x00000002u) {
      type_ = from.type_;
    }
    if (cached_has_bits & 0x00000004u) {
      kind_ = from.kind_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ImpassableArea::CopyFrom(const ImpassableArea& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:RoadPB.ImpassableArea)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ImpassableArea::IsInitialized() const {
  return true;
}

void ImpassableArea::InternalSwap(ImpassableArea* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ImpassableArea, kind_)
      + sizeof(ImpassableArea::kind_)
      - PROTOBUF_FIELD_OFFSET(ImpassableArea, geom_)>(
          reinterpret_cast<char*>(&geom_),
          reinterpret_cast<char*>(&other->geom_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ImpassableArea::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_lane_2flane_2eproto_getter, &descriptor_table_lane_2flane_2eproto_once,
      file_level_metadata_lane_2flane_2eproto[7]);
}

// ===================================================================

class Junction::_Internal {
 public:
  using HasBits = decltype(std::declval<Junction>()._has_bits_);
  static const ::RoadPB::FeatureID& id(const Junction* msg);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::RoadPB::FeatureID& node_id(const Junction* msg);
  static void set_has_node_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::RoadPB::FeatureID&
Junction::_Internal::id(const Junction* msg) {
  return *msg->id_;
}
const ::RoadPB::FeatureID&
Junction::_Internal::node_id(const Junction* msg) {
  return *msg->node_id_;
}
void Junction::clear_id() {
  if (id_ != nullptr) id_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void Junction::clear_node_id() {
  if (node_id_ != nullptr) node_id_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
void Junction::clear_boundarys() {
  boundarys_.Clear();
}
void Junction::clear_conn_groups() {
  conn_groups_.Clear();
}
void Junction::clear_in_groups() {
  in_groups_.Clear();
}
void Junction::clear_out_groups() {
  out_groups_.Clear();
}
Junction::Junction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  areas_(arena),
  boundarys_(arena),
  conn_groups_(arena),
  in_groups_(arena),
  out_groups_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:RoadPB.Junction)
}
Junction::Junction(const Junction& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      areas_(from.areas_),
      boundarys_(from.boundarys_),
      conn_groups_(from.conn_groups_),
      in_groups_(from.in_groups_),
      out_groups_(from.out_groups_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_id()) {
    id_ = new ::RoadPB::FeatureID(*from.id_);
  } else {
    id_ = nullptr;
  }
  if (from._internal_has_node_id()) {
    node_id_ = new ::RoadPB::FeatureID(*from.node_id_);
  } else {
    node_id_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:RoadPB.Junction)
}

inline void Junction::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&node_id_) -
    reinterpret_cast<char*>(&id_)) + sizeof(node_id_));
}

Junction::~Junction() {
  // @@protoc_insertion_point(destructor:RoadPB.Junction)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Junction::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete id_;
  if (this != internal_default_instance()) delete node_id_;
}

void Junction::ArenaDtor(void* object) {
  Junction* _this = reinterpret_cast< Junction* >(object);
  (void)_this;
}
void Junction::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Junction::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Junction::Clear() {
// @@protoc_insertion_point(message_clear_start:RoadPB.Junction)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  areas_.Clear();
  boundarys_.Clear();
  conn_groups_.Clear();
  in_groups_.Clear();
  out_groups_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(id_ != nullptr);
      id_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(node_id_ != nullptr);
      node_id_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Junction::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .RoadPB.FeatureID id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_id(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .RoadPB.FeatureID node_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_node_id(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .RoadPB.ImpassableArea areas = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_areas(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .RoadPB.FeatureID boundarys = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_boundarys(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .RoadPB.FeatureID conn_groups = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_conn_groups(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .RoadPB.FeatureID in_groups = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_in_groups(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .RoadPB.FeatureID out_groups = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_out_groups(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Junction::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:RoadPB.Junction)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .RoadPB.FeatureID id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::id(this), target, stream);
  }

  // optional .RoadPB.FeatureID node_id = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::node_id(this), target, stream);
  }

  // repeated .RoadPB.ImpassableArea areas = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_areas_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, this->_internal_areas(i), target, stream);
  }

  // repeated .RoadPB.FeatureID boundarys = 6;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_boundarys_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, this->_internal_boundarys(i), target, stream);
  }

  // repeated .RoadPB.FeatureID conn_groups = 7;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_conn_groups_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, this->_internal_conn_groups(i), target, stream);
  }

  // repeated .RoadPB.FeatureID in_groups = 8;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_in_groups_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, this->_internal_in_groups(i), target, stream);
  }

  // repeated .RoadPB.FeatureID out_groups = 9;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_out_groups_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, this->_internal_out_groups(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:RoadPB.Junction)
  return target;
}

size_t Junction::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:RoadPB.Junction)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .RoadPB.ImpassableArea areas = 5;
  total_size += 1UL * this->_internal_areas_size();
  for (const auto& msg : this->areas_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .RoadPB.FeatureID boundarys = 6;
  total_size += 1UL * this->_internal_boundarys_size();
  for (const auto& msg : this->boundarys_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .RoadPB.FeatureID conn_groups = 7;
  total_size += 1UL * this->_internal_conn_groups_size();
  for (const auto& msg : this->conn_groups_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .RoadPB.FeatureID in_groups = 8;
  total_size += 1UL * this->_internal_in_groups_size();
  for (const auto& msg : this->in_groups_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .RoadPB.FeatureID out_groups = 9;
  total_size += 1UL * this->_internal_out_groups_size();
  for (const auto& msg : this->out_groups_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .RoadPB.FeatureID id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *id_);
    }

    // optional .RoadPB.FeatureID node_id = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *node_id_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Junction::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Junction::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Junction::GetClassData() const { return &_class_data_; }

void Junction::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to,
                      const ::PROTOBUF_NAMESPACE_ID::Message&from) {
  static_cast<Junction *>(to)->MergeFrom(
      static_cast<const Junction &>(from));
}


void Junction::MergeFrom(const Junction& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:RoadPB.Junction)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  areas_.MergeFrom(from.areas_);
  boundarys_.MergeFrom(from.boundarys_);
  conn_groups_.MergeFrom(from.conn_groups_);
  in_groups_.MergeFrom(from.in_groups_);
  out_groups_.MergeFrom(from.out_groups_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_id()->::RoadPB::FeatureID::MergeFrom(from._internal_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_node_id()->::RoadPB::FeatureID::MergeFrom(from._internal_node_id());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Junction::CopyFrom(const Junction& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:RoadPB.Junction)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Junction::IsInitialized() const {
  return true;
}

void Junction::InternalSwap(Junction* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  areas_.InternalSwap(&other->areas_);
  boundarys_.InternalSwap(&other->boundarys_);
  conn_groups_.InternalSwap(&other->conn_groups_);
  in_groups_.InternalSwap(&other->in_groups_);
  out_groups_.InternalSwap(&other->out_groups_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Junction, node_id_)
      + sizeof(Junction::node_id_)
      - PROTOBUF_FIELD_OFFSET(Junction, id_)>(
          reinterpret_cast<char*>(&id_),
          reinterpret_cast<char*>(&other->id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Junction::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_lane_2flane_2eproto_getter, &descriptor_table_lane_2flane_2eproto_once,
      file_level_metadata_lane_2flane_2eproto[8]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace RoadPB
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::RoadPB::LaneDirection* Arena::CreateMaybeMessage< ::RoadPB::LaneDirection >(Arena* arena) {
  return Arena::CreateMessageInternal< ::RoadPB::LaneDirection >(arena);
}
template<> PROTOBUF_NOINLINE ::RoadPB::LaneBoundary* Arena::CreateMaybeMessage< ::RoadPB::LaneBoundary >(Arena* arena) {
  return Arena::CreateMessageInternal< ::RoadPB::LaneBoundary >(arena);
}
template<> PROTOBUF_NOINLINE ::RoadPB::LaneBoundaryRange* Arena::CreateMaybeMessage< ::RoadPB::LaneBoundaryRange >(Arena* arena) {
  return Arena::CreateMessageInternal< ::RoadPB::LaneBoundaryRange >(arena);
}
template<> PROTOBUF_NOINLINE ::RoadPB::RoadBoundary* Arena::CreateMaybeMessage< ::RoadPB::RoadBoundary >(Arena* arena) {
  return Arena::CreateMessageInternal< ::RoadPB::RoadBoundary >(arena);
}
template<> PROTOBUF_NOINLINE ::RoadPB::LaneSection* Arena::CreateMaybeMessage< ::RoadPB::LaneSection >(Arena* arena) {
  return Arena::CreateMessageInternal< ::RoadPB::LaneSection >(arena);
}
template<> PROTOBUF_NOINLINE ::RoadPB::Lane* Arena::CreateMaybeMessage< ::RoadPB::Lane >(Arena* arena) {
  return Arena::CreateMessageInternal< ::RoadPB::Lane >(arena);
}
template<> PROTOBUF_NOINLINE ::RoadPB::LaneGroup* Arena::CreateMaybeMessage< ::RoadPB::LaneGroup >(Arena* arena) {
  return Arena::CreateMessageInternal< ::RoadPB::LaneGroup >(arena);
}
template<> PROTOBUF_NOINLINE ::RoadPB::ImpassableArea* Arena::CreateMaybeMessage< ::RoadPB::ImpassableArea >(Arena* arena) {
  return Arena::CreateMessageInternal< ::RoadPB::ImpassableArea >(arena);
}
template<> PROTOBUF_NOINLINE ::RoadPB::Junction* Arena::CreateMaybeMessage< ::RoadPB::Junction >(Arena* arena) {
  return Arena::CreateMessageInternal< ::RoadPB::Junction >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
