// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: topological_layer.proto

#ifndef PROTOBUF_topological_5flayer_2eproto__INCLUDED
#define PROTOBUF_topological_5flayer_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "base.pb.h"
#include "physical_layer.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_topological_5flayer_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[7];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsAreaImpl();
void InitDefaultsArea();
void InitDefaultsParkingImpl();
void InitDefaultsParking();
void InitDefaultsRoadNodeImpl();
void InitDefaultsRoadNode();
void InitDefaultsRoadEdgeImpl();
void InitDefaultsRoadEdge();
void InitDefaultsRoadImpl();
void InitDefaultsRoad();
void InitDefaultsTileImpl();
void InitDefaultsTile();
void InitDefaultsTopologicalLayerImpl();
void InitDefaultsTopologicalLayer();
inline void InitDefaults() {
  InitDefaultsArea();
  InitDefaultsParking();
  InitDefaultsRoadNode();
  InitDefaultsRoadEdge();
  InitDefaultsRoad();
  InitDefaultsTile();
  InitDefaultsTopologicalLayer();
}
}  // namespace protobuf_topological_5flayer_2eproto
namespace ndm_proto {
class Area;
class AreaDefaultTypeInternal;
extern AreaDefaultTypeInternal _Area_default_instance_;
class Parking;
class ParkingDefaultTypeInternal;
extern ParkingDefaultTypeInternal _Parking_default_instance_;
class Road;
class RoadDefaultTypeInternal;
extern RoadDefaultTypeInternal _Road_default_instance_;
class RoadEdge;
class RoadEdgeDefaultTypeInternal;
extern RoadEdgeDefaultTypeInternal _RoadEdge_default_instance_;
class RoadNode;
class RoadNodeDefaultTypeInternal;
extern RoadNodeDefaultTypeInternal _RoadNode_default_instance_;
class Tile;
class TileDefaultTypeInternal;
extern TileDefaultTypeInternal _Tile_default_instance_;
class TopologicalLayer;
class TopologicalLayerDefaultTypeInternal;
extern TopologicalLayerDefaultTypeInternal _TopologicalLayer_default_instance_;
}  // namespace ndm_proto
namespace ndm_proto {

enum Tile_TileRange {
  Tile_TileRange_T0 = 40,
  Tile_TileRange_T1 = 80,
  Tile_TileRange_T2 = 160,
  Tile_TileRange_T3 = 320
};
bool Tile_TileRange_IsValid(int value);
const Tile_TileRange Tile_TileRange_TileRange_MIN = Tile_TileRange_T0;
const Tile_TileRange Tile_TileRange_TileRange_MAX = Tile_TileRange_T3;
const int Tile_TileRange_TileRange_ARRAYSIZE = Tile_TileRange_TileRange_MAX + 1;

const ::google::protobuf::EnumDescriptor* Tile_TileRange_descriptor();
inline const ::std::string& Tile_TileRange_Name(Tile_TileRange value) {
  return ::google::protobuf::internal::NameOfEnum(
    Tile_TileRange_descriptor(), value);
}
inline bool Tile_TileRange_Parse(
    const ::std::string& name, Tile_TileRange* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Tile_TileRange>(
    Tile_TileRange_descriptor(), name, value);
}
enum FormOfWay {
  FormOfWay_Unknown = 0,
  FormOfWay_MultipleCarriageWay = 2,
  FormOfWay_SingleCarriageWay = 3,
  FormOfWay_RoundaboutCircle = 4,
  FormOfWay_Service = 13,
  FormOfWay_RampEntry = 16,
  FormOfWay_RampExit = 17,
  FormOfWay_CrossLink = 18,
  FormOfWay_JCT = 19,
  FormOfWay_SlipRoad = 20,
  FormOfWay_SideRoad = 21,
  FormOfWay_SlipAndJCT = 22,
  FormOfWay_TurnRightLineA = 23,
  FormOfWay_TurnRightLineB = 24,
  FormOfWay_TurnLeftLineA = 25,
  FormOfWay_TurnLeftLineB = 26,
  FormOfWay_TurnLeftRightLine = 27,
  FormOfWay_ServiceAndSlipRoad = 28,
  FormOfWay_ServiceAndJCT = 29,
  FormOfWay_ServiceAndSlipRoadAndJCT = 30,
  FormOfWay_Other = 99
};
bool FormOfWay_IsValid(int value);
const FormOfWay FormOfWay_MIN = FormOfWay_Unknown;
const FormOfWay FormOfWay_MAX = FormOfWay_Other;
const int FormOfWay_ARRAYSIZE = FormOfWay_MAX + 1;

const ::google::protobuf::EnumDescriptor* FormOfWay_descriptor();
inline const ::std::string& FormOfWay_Name(FormOfWay value) {
  return ::google::protobuf::internal::NameOfEnum(
    FormOfWay_descriptor(), value);
}
inline bool FormOfWay_Parse(
    const ::std::string& name, FormOfWay* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FormOfWay>(
    FormOfWay_descriptor(), name, value);
}
// ===================================================================

class Area : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.Area) */ {
 public:
  Area();
  virtual ~Area();

  Area(const Area& from);

  inline Area& operator=(const Area& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Area(Area&& from) noexcept
    : Area() {
    *this = ::std::move(from);
  }

  inline Area& operator=(Area&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Area& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Area* internal_default_instance() {
    return reinterpret_cast<const Area*>(
               &_Area_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Area* other);
  friend void swap(Area& a, Area& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Area* New() const PROTOBUF_FINAL { return New(NULL); }

  Area* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Area& from);
  void MergeFrom(const Area& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Area* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string areapolygon_ids = 2;
  int areapolygon_ids_size() const;
  void clear_areapolygon_ids();
  static const int kAreapolygonIdsFieldNumber = 2;
  const ::std::string& areapolygon_ids(int index) const;
  ::std::string* mutable_areapolygon_ids(int index);
  void set_areapolygon_ids(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_areapolygon_ids(int index, ::std::string&& value);
  #endif
  void set_areapolygon_ids(int index, const char* value);
  void set_areapolygon_ids(int index, const char* value, size_t size);
  ::std::string* add_areapolygon_ids();
  void add_areapolygon_ids(const ::std::string& value);
  #if LANG_CXX11
  void add_areapolygon_ids(::std::string&& value);
  #endif
  void add_areapolygon_ids(const char* value);
  void add_areapolygon_ids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& areapolygon_ids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_areapolygon_ids();

  // repeated string link_ids = 20;
  int link_ids_size() const;
  void clear_link_ids();
  static const int kLinkIdsFieldNumber = 20;
  const ::std::string& link_ids(int index) const;
  ::std::string* mutable_link_ids(int index);
  void set_link_ids(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_link_ids(int index, ::std::string&& value);
  #endif
  void set_link_ids(int index, const char* value);
  void set_link_ids(int index, const char* value, size_t size);
  ::std::string* add_link_ids();
  void add_link_ids(const ::std::string& value);
  #if LANG_CXX11
  void add_link_ids(::std::string&& value);
  #endif
  void add_link_ids(const char* value);
  void add_link_ids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& link_ids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_link_ids();

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // optional string name = 5;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 5;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required .ndm_proto.Polygon bounding_polygon = 3;
  bool has_bounding_polygon() const;
  void clear_bounding_polygon();
  static const int kBoundingPolygonFieldNumber = 3;
  const ::ndm_proto::Polygon& bounding_polygon() const;
  ::ndm_proto::Polygon* release_bounding_polygon();
  ::ndm_proto::Polygon* mutable_bounding_polygon();
  void set_allocated_bounding_polygon(::ndm_proto::Polygon* bounding_polygon);

  // optional .ndm_proto.AreaType type = 4;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 4;
  const ::ndm_proto::AreaType& type() const;
  ::ndm_proto::AreaType* release_type();
  ::ndm_proto::AreaType* mutable_type();
  void set_allocated_type(::ndm_proto::AreaType* type);

  // @@protoc_insertion_point(class_scope:ndm_proto.Area)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_bounding_polygon();
  void clear_has_bounding_polygon();
  void set_has_type();
  void clear_has_type();
  void set_has_name();
  void clear_has_name();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> areapolygon_ids_;
  ::google::protobuf::RepeatedPtrField< ::std::string> link_ids_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::ndm_proto::Polygon* bounding_polygon_;
  ::ndm_proto::AreaType* type_;
  friend struct ::protobuf_topological_5flayer_2eproto::TableStruct;
  friend void ::protobuf_topological_5flayer_2eproto::InitDefaultsAreaImpl();
};
// -------------------------------------------------------------------

class Parking : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.Parking) */ {
 public:
  Parking();
  virtual ~Parking();

  Parking(const Parking& from);

  inline Parking& operator=(const Parking& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Parking(Parking&& from) noexcept
    : Parking() {
    *this = ::std::move(from);
  }

  inline Parking& operator=(Parking&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Parking& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Parking* internal_default_instance() {
    return reinterpret_cast<const Parking*>(
               &_Parking_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Parking* other);
  friend void swap(Parking& a, Parking& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Parking* New() const PROTOBUF_FINAL { return New(NULL); }

  Parking* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Parking& from);
  void MergeFrom(const Parking& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Parking* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string section_ids = 3;
  int section_ids_size() const;
  void clear_section_ids();
  static const int kSectionIdsFieldNumber = 3;
  const ::std::string& section_ids(int index) const;
  ::std::string* mutable_section_ids(int index);
  void set_section_ids(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_section_ids(int index, ::std::string&& value);
  #endif
  void set_section_ids(int index, const char* value);
  void set_section_ids(int index, const char* value, size_t size);
  ::std::string* add_section_ids();
  void add_section_ids(const ::std::string& value);
  #if LANG_CXX11
  void add_section_ids(::std::string&& value);
  #endif
  void add_section_ids(const char* value);
  void add_section_ids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& section_ids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_section_ids();

  // repeated string junction_ids = 4;
  int junction_ids_size() const;
  void clear_junction_ids();
  static const int kJunctionIdsFieldNumber = 4;
  const ::std::string& junction_ids(int index) const;
  ::std::string* mutable_junction_ids(int index);
  void set_junction_ids(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_junction_ids(int index, ::std::string&& value);
  #endif
  void set_junction_ids(int index, const char* value);
  void set_junction_ids(int index, const char* value, size_t size);
  ::std::string* add_junction_ids();
  void add_junction_ids(const ::std::string& value);
  #if LANG_CXX11
  void add_junction_ids(::std::string&& value);
  #endif
  void add_junction_ids(const char* value);
  void add_junction_ids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& junction_ids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_junction_ids();

  // repeated string link_ids = 20;
  int link_ids_size() const;
  void clear_link_ids();
  static const int kLinkIdsFieldNumber = 20;
  const ::std::string& link_ids(int index) const;
  ::std::string* mutable_link_ids(int index);
  void set_link_ids(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_link_ids(int index, ::std::string&& value);
  #endif
  void set_link_ids(int index, const char* value);
  void set_link_ids(int index, const char* value, size_t size);
  ::std::string* add_link_ids();
  void add_link_ids(const ::std::string& value);
  #if LANG_CXX11
  void add_link_ids(::std::string&& value);
  #endif
  void add_link_ids(const char* value);
  void add_link_ids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& link_ids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_link_ids();

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // required string parkingspace_ids = 2;
  bool has_parkingspace_ids() const;
  void clear_parkingspace_ids();
  static const int kParkingspaceIdsFieldNumber = 2;
  const ::std::string& parkingspace_ids() const;
  void set_parkingspace_ids(const ::std::string& value);
  #if LANG_CXX11
  void set_parkingspace_ids(::std::string&& value);
  #endif
  void set_parkingspace_ids(const char* value);
  void set_parkingspace_ids(const char* value, size_t size);
  ::std::string* mutable_parkingspace_ids();
  ::std::string* release_parkingspace_ids();
  void set_allocated_parkingspace_ids(::std::string* parkingspace_ids);

  // optional string name = 6;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 6;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required .ndm_proto.Polygon bounding_polygon = 5;
  bool has_bounding_polygon() const;
  void clear_bounding_polygon();
  static const int kBoundingPolygonFieldNumber = 5;
  const ::ndm_proto::Polygon& bounding_polygon() const;
  ::ndm_proto::Polygon* release_bounding_polygon();
  ::ndm_proto::Polygon* mutable_bounding_polygon();
  void set_allocated_bounding_polygon(::ndm_proto::Polygon* bounding_polygon);

  // @@protoc_insertion_point(class_scope:ndm_proto.Parking)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_parkingspace_ids();
  void clear_has_parkingspace_ids();
  void set_has_bounding_polygon();
  void clear_has_bounding_polygon();
  void set_has_name();
  void clear_has_name();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> section_ids_;
  ::google::protobuf::RepeatedPtrField< ::std::string> junction_ids_;
  ::google::protobuf::RepeatedPtrField< ::std::string> link_ids_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr parkingspace_ids_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::ndm_proto::Polygon* bounding_polygon_;
  friend struct ::protobuf_topological_5flayer_2eproto::TableStruct;
  friend void ::protobuf_topological_5flayer_2eproto::InitDefaultsParkingImpl();
};
// -------------------------------------------------------------------

class RoadNode : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.RoadNode) */ {
 public:
  RoadNode();
  virtual ~RoadNode();

  RoadNode(const RoadNode& from);

  inline RoadNode& operator=(const RoadNode& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RoadNode(RoadNode&& from) noexcept
    : RoadNode() {
    *this = ::std::move(from);
  }

  inline RoadNode& operator=(RoadNode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoadNode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoadNode* internal_default_instance() {
    return reinterpret_cast<const RoadNode*>(
               &_RoadNode_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(RoadNode* other);
  friend void swap(RoadNode& a, RoadNode& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RoadNode* New() const PROTOBUF_FINAL { return New(NULL); }

  RoadNode* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RoadNode& from);
  void MergeFrom(const RoadNode& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RoadNode* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string include_ids = 2;
  int include_ids_size() const;
  void clear_include_ids();
  static const int kIncludeIdsFieldNumber = 2;
  const ::std::string& include_ids(int index) const;
  ::std::string* mutable_include_ids(int index);
  void set_include_ids(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_include_ids(int index, ::std::string&& value);
  #endif
  void set_include_ids(int index, const char* value);
  void set_include_ids(int index, const char* value, size_t size);
  ::std::string* add_include_ids();
  void add_include_ids(const ::std::string& value);
  #if LANG_CXX11
  void add_include_ids(::std::string&& value);
  #endif
  void add_include_ids(const char* value);
  void add_include_ids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& include_ids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_include_ids();

  // repeated string in_link_ids = 3;
  int in_link_ids_size() const;
  void clear_in_link_ids();
  static const int kInLinkIdsFieldNumber = 3;
  const ::std::string& in_link_ids(int index) const;
  ::std::string* mutable_in_link_ids(int index);
  void set_in_link_ids(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_in_link_ids(int index, ::std::string&& value);
  #endif
  void set_in_link_ids(int index, const char* value);
  void set_in_link_ids(int index, const char* value, size_t size);
  ::std::string* add_in_link_ids();
  void add_in_link_ids(const ::std::string& value);
  #if LANG_CXX11
  void add_in_link_ids(::std::string&& value);
  #endif
  void add_in_link_ids(const char* value);
  void add_in_link_ids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& in_link_ids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_in_link_ids();

  // repeated string out_link_ids = 4;
  int out_link_ids_size() const;
  void clear_out_link_ids();
  static const int kOutLinkIdsFieldNumber = 4;
  const ::std::string& out_link_ids(int index) const;
  ::std::string* mutable_out_link_ids(int index);
  void set_out_link_ids(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_out_link_ids(int index, ::std::string&& value);
  #endif
  void set_out_link_ids(int index, const char* value);
  void set_out_link_ids(int index, const char* value, size_t size);
  ::std::string* add_out_link_ids();
  void add_out_link_ids(const ::std::string& value);
  #if LANG_CXX11
  void add_out_link_ids(::std::string&& value);
  #endif
  void add_out_link_ids(const char* value);
  void add_out_link_ids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& out_link_ids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_out_link_ids();

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // optional float probability = 5;
  bool has_probability() const;
  void clear_probability();
  static const int kProbabilityFieldNumber = 5;
  float probability() const;
  void set_probability(float value);

  // optional float turn_angle = 6;
  bool has_turn_angle() const;
  void clear_turn_angle();
  static const int kTurnAngleFieldNumber = 6;
  float turn_angle() const;
  void set_turn_angle(float value);

  // @@protoc_insertion_point(class_scope:ndm_proto.RoadNode)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_probability();
  void clear_has_probability();
  void set_has_turn_angle();
  void clear_has_turn_angle();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> include_ids_;
  ::google::protobuf::RepeatedPtrField< ::std::string> in_link_ids_;
  ::google::protobuf::RepeatedPtrField< ::std::string> out_link_ids_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  float probability_;
  float turn_angle_;
  friend struct ::protobuf_topological_5flayer_2eproto::TableStruct;
  friend void ::protobuf_topological_5flayer_2eproto::InitDefaultsRoadNodeImpl();
};
// -------------------------------------------------------------------

class RoadEdge : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.RoadEdge) */ {
 public:
  RoadEdge();
  virtual ~RoadEdge();

  RoadEdge(const RoadEdge& from);

  inline RoadEdge& operator=(const RoadEdge& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RoadEdge(RoadEdge&& from) noexcept
    : RoadEdge() {
    *this = ::std::move(from);
  }

  inline RoadEdge& operator=(RoadEdge&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoadEdge& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoadEdge* internal_default_instance() {
    return reinterpret_cast<const RoadEdge*>(
               &_RoadEdge_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(RoadEdge* other);
  friend void swap(RoadEdge& a, RoadEdge& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RoadEdge* New() const PROTOBUF_FINAL { return New(NULL); }

  RoadEdge* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RoadEdge& from);
  void MergeFrom(const RoadEdge& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RoadEdge* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ndm_proto.Link sections = 2;
  int sections_size() const;
  void clear_sections();
  static const int kSectionsFieldNumber = 2;
  const ::ndm_proto::Link& sections(int index) const;
  ::ndm_proto::Link* mutable_sections(int index);
  ::ndm_proto::Link* add_sections();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Link >*
      mutable_sections();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Link >&
      sections() const;

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // @@protoc_insertion_point(class_scope:ndm_proto.RoadEdge)
 private:
  void set_has_id();
  void clear_has_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Link > sections_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  friend struct ::protobuf_topological_5flayer_2eproto::TableStruct;
  friend void ::protobuf_topological_5flayer_2eproto::InitDefaultsRoadEdgeImpl();
};
// -------------------------------------------------------------------

class Road : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.Road) */ {
 public:
  Road();
  virtual ~Road();

  Road(const Road& from);

  inline Road& operator=(const Road& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Road(Road&& from) noexcept
    : Road() {
    *this = ::std::move(from);
  }

  inline Road& operator=(Road&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Road& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Road* internal_default_instance() {
    return reinterpret_cast<const Road*>(
               &_Road_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(Road* other);
  friend void swap(Road& a, Road& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Road* New() const PROTOBUF_FINAL { return New(NULL); }

  Road* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Road& from);
  void MergeFrom(const Road& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Road* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ndm_proto.Link forward_links = 3;
  int forward_links_size() const;
  void clear_forward_links();
  static const int kForwardLinksFieldNumber = 3;
  const ::ndm_proto::Link& forward_links(int index) const;
  ::ndm_proto::Link* mutable_forward_links(int index);
  ::ndm_proto::Link* add_forward_links();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Link >*
      mutable_forward_links();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Link >&
      forward_links() const;

  // repeated .ndm_proto.Link backward_links = 4;
  int backward_links_size() const;
  void clear_backward_links();
  static const int kBackwardLinksFieldNumber = 4;
  const ::ndm_proto::Link& backward_links(int index) const;
  ::ndm_proto::Link* mutable_backward_links(int index);
  ::ndm_proto::Link* add_backward_links();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Link >*
      mutable_backward_links();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Link >&
      backward_links() const;

  // repeated .ndm_proto.Link links = 20;
  int links_size() const;
  void clear_links();
  static const int kLinksFieldNumber = 20;
  const ::ndm_proto::Link& links(int index) const;
  ::ndm_proto::Link* mutable_links(int index);
  ::ndm_proto::Link* add_links();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Link >*
      mutable_links();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Link >&
      links() const;

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // optional string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional .ndm_proto.FormOfWay form = 10;
  bool has_form() const;
  void clear_form();
  static const int kFormFieldNumber = 10;
  ::ndm_proto::FormOfWay form() const;
  void set_form(::ndm_proto::FormOfWay value);

  // optional uint32 function = 11;
  bool has_function() const;
  void clear_function();
  static const int kFunctionFieldNumber = 11;
  ::google::protobuf::uint32 function() const;
  void set_function(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ndm_proto.Road)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_name();
  void clear_has_name();
  void set_has_form();
  void clear_has_form();
  void set_has_function();
  void clear_has_function();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Link > forward_links_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Link > backward_links_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Link > links_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  int form_;
  ::google::protobuf::uint32 function_;
  friend struct ::protobuf_topological_5flayer_2eproto::TableStruct;
  friend void ::protobuf_topological_5flayer_2eproto::InitDefaultsRoadImpl();
};
// -------------------------------------------------------------------

class Tile : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.Tile) */ {
 public:
  Tile();
  virtual ~Tile();

  Tile(const Tile& from);

  inline Tile& operator=(const Tile& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Tile(Tile&& from) noexcept
    : Tile() {
    *this = ::std::move(from);
  }

  inline Tile& operator=(Tile&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Tile& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Tile* internal_default_instance() {
    return reinterpret_cast<const Tile*>(
               &_Tile_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(Tile* other);
  friend void swap(Tile& a, Tile& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Tile* New() const PROTOBUF_FINAL { return New(NULL); }

  Tile* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Tile& from);
  void MergeFrom(const Tile& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Tile* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Tile_TileRange TileRange;
  static const TileRange T0 =
    Tile_TileRange_T0;
  static const TileRange T1 =
    Tile_TileRange_T1;
  static const TileRange T2 =
    Tile_TileRange_T2;
  static const TileRange T3 =
    Tile_TileRange_T3;
  static inline bool TileRange_IsValid(int value) {
    return Tile_TileRange_IsValid(value);
  }
  static const TileRange TileRange_MIN =
    Tile_TileRange_TileRange_MIN;
  static const TileRange TileRange_MAX =
    Tile_TileRange_TileRange_MAX;
  static const int TileRange_ARRAYSIZE =
    Tile_TileRange_TileRange_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TileRange_descriptor() {
    return Tile_TileRange_descriptor();
  }
  static inline const ::std::string& TileRange_Name(TileRange value) {
    return Tile_TileRange_Name(value);
  }
  static inline bool TileRange_Parse(const ::std::string& name,
      TileRange* value) {
    return Tile_TileRange_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated string childs = 5;
  int childs_size() const;
  void clear_childs();
  static const int kChildsFieldNumber = 5;
  const ::std::string& childs(int index) const;
  ::std::string* mutable_childs(int index);
  void set_childs(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_childs(int index, ::std::string&& value);
  #endif
  void set_childs(int index, const char* value);
  void set_childs(int index, const char* value, size_t size);
  ::std::string* add_childs();
  void add_childs(const ::std::string& value);
  #if LANG_CXX11
  void add_childs(::std::string&& value);
  #endif
  void add_childs(const char* value);
  void add_childs(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& childs() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_childs();

  // repeated string link_ids = 20;
  int link_ids_size() const;
  void clear_link_ids();
  static const int kLinkIdsFieldNumber = 20;
  const ::std::string& link_ids(int index) const;
  ::std::string* mutable_link_ids(int index);
  void set_link_ids(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_link_ids(int index, ::std::string&& value);
  #endif
  void set_link_ids(int index, const char* value);
  void set_link_ids(int index, const char* value, size_t size);
  ::std::string* add_link_ids();
  void add_link_ids(const ::std::string& value);
  #if LANG_CXX11
  void add_link_ids(::std::string&& value);
  #endif
  void add_link_ids(const char* value);
  void add_link_ids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& link_ids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_link_ids();

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // optional string utm_zone = 6;
  bool has_utm_zone() const;
  void clear_utm_zone();
  static const int kUtmZoneFieldNumber = 6;
  const ::std::string& utm_zone() const;
  void set_utm_zone(const ::std::string& value);
  #if LANG_CXX11
  void set_utm_zone(::std::string&& value);
  #endif
  void set_utm_zone(const char* value);
  void set_utm_zone(const char* value, size_t size);
  ::std::string* mutable_utm_zone();
  ::std::string* release_utm_zone();
  void set_allocated_utm_zone(::std::string* utm_zone);

  // required .ndm_proto.Index index = 2;
  bool has_index() const;
  void clear_index();
  static const int kIndexFieldNumber = 2;
  const ::ndm_proto::Index& index() const;
  ::ndm_proto::Index* release_index();
  ::ndm_proto::Index* mutable_index();
  void set_allocated_index(::ndm_proto::Index* index);

  // required .ndm_proto.Point min_point = 3;
  bool has_min_point() const;
  void clear_min_point();
  static const int kMinPointFieldNumber = 3;
  const ::ndm_proto::Point& min_point() const;
  ::ndm_proto::Point* release_min_point();
  ::ndm_proto::Point* mutable_min_point();
  void set_allocated_min_point(::ndm_proto::Point* min_point);

  // required .ndm_proto.Tile.TileRange range = 4;
  bool has_range() const;
  void clear_range();
  static const int kRangeFieldNumber = 4;
  ::ndm_proto::Tile_TileRange range() const;
  void set_range(::ndm_proto::Tile_TileRange value);

  // @@protoc_insertion_point(class_scope:ndm_proto.Tile)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_index();
  void clear_has_index();
  void set_has_min_point();
  void clear_has_min_point();
  void set_has_range();
  void clear_has_range();
  void set_has_utm_zone();
  void clear_has_utm_zone();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> childs_;
  ::google::protobuf::RepeatedPtrField< ::std::string> link_ids_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr utm_zone_;
  ::ndm_proto::Index* index_;
  ::ndm_proto::Point* min_point_;
  int range_;
  friend struct ::protobuf_topological_5flayer_2eproto::TableStruct;
  friend void ::protobuf_topological_5flayer_2eproto::InitDefaultsTileImpl();
};
// -------------------------------------------------------------------

class TopologicalLayer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.TopologicalLayer) */ {
 public:
  TopologicalLayer();
  virtual ~TopologicalLayer();

  TopologicalLayer(const TopologicalLayer& from);

  inline TopologicalLayer& operator=(const TopologicalLayer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TopologicalLayer(TopologicalLayer&& from) noexcept
    : TopologicalLayer() {
    *this = ::std::move(from);
  }

  inline TopologicalLayer& operator=(TopologicalLayer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TopologicalLayer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TopologicalLayer* internal_default_instance() {
    return reinterpret_cast<const TopologicalLayer*>(
               &_TopologicalLayer_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(TopologicalLayer* other);
  friend void swap(TopologicalLayer& a, TopologicalLayer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TopologicalLayer* New() const PROTOBUF_FINAL { return New(NULL); }

  TopologicalLayer* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TopologicalLayer& from);
  void MergeFrom(const TopologicalLayer& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TopologicalLayer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ndm_proto.LaneLine reflines = 1;
  int reflines_size() const;
  void clear_reflines();
  static const int kReflinesFieldNumber = 1;
  const ::ndm_proto::LaneLine& reflines(int index) const;
  ::ndm_proto::LaneLine* mutable_reflines(int index);
  ::ndm_proto::LaneLine* add_reflines();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::LaneLine >*
      mutable_reflines();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::LaneLine >&
      reflines() const;

  // repeated .ndm_proto.Area areas = 3;
  int areas_size() const;
  void clear_areas();
  static const int kAreasFieldNumber = 3;
  const ::ndm_proto::Area& areas(int index) const;
  ::ndm_proto::Area* mutable_areas(int index);
  ::ndm_proto::Area* add_areas();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Area >*
      mutable_areas();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Area >&
      areas() const;

  // repeated .ndm_proto.Parking parkings = 4;
  int parkings_size() const;
  void clear_parkings();
  static const int kParkingsFieldNumber = 4;
  const ::ndm_proto::Parking& parkings(int index) const;
  ::ndm_proto::Parking* mutable_parkings(int index);
  ::ndm_proto::Parking* add_parkings();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Parking >*
      mutable_parkings();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Parking >&
      parkings() const;

  // repeated .ndm_proto.Road roads = 5;
  int roads_size() const;
  void clear_roads();
  static const int kRoadsFieldNumber = 5;
  const ::ndm_proto::Road& roads(int index) const;
  ::ndm_proto::Road* mutable_roads(int index);
  ::ndm_proto::Road* add_roads();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Road >*
      mutable_roads();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Road >&
      roads() const;

  // repeated .ndm_proto.Tile tiles = 6;
  int tiles_size() const;
  void clear_tiles();
  static const int kTilesFieldNumber = 6;
  const ::ndm_proto::Tile& tiles(int index) const;
  ::ndm_proto::Tile* mutable_tiles(int index);
  ::ndm_proto::Tile* add_tiles();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Tile >*
      mutable_tiles();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Tile >&
      tiles() const;

  // repeated .ndm_proto.RoadNode road_nodes = 7;
  int road_nodes_size() const;
  void clear_road_nodes();
  static const int kRoadNodesFieldNumber = 7;
  const ::ndm_proto::RoadNode& road_nodes(int index) const;
  ::ndm_proto::RoadNode* mutable_road_nodes(int index);
  ::ndm_proto::RoadNode* add_road_nodes();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::RoadNode >*
      mutable_road_nodes();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::RoadNode >&
      road_nodes() const;

  // repeated .ndm_proto.RoadEdge road_edges = 8;
  int road_edges_size() const;
  void clear_road_edges();
  static const int kRoadEdgesFieldNumber = 8;
  const ::ndm_proto::RoadEdge& road_edges(int index) const;
  ::ndm_proto::RoadEdge* mutable_road_edges(int index);
  ::ndm_proto::RoadEdge* add_road_edges();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::RoadEdge >*
      mutable_road_edges();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::RoadEdge >&
      road_edges() const;

  // @@protoc_insertion_point(class_scope:ndm_proto.TopologicalLayer)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::LaneLine > reflines_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Area > areas_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Parking > parkings_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Road > roads_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Tile > tiles_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::RoadNode > road_nodes_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::RoadEdge > road_edges_;
  friend struct ::protobuf_topological_5flayer_2eproto::TableStruct;
  friend void ::protobuf_topological_5flayer_2eproto::InitDefaultsTopologicalLayerImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Area

// required string id = 1;
inline bool Area::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Area::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Area::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Area::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& Area::id() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Area.id)
  return id_.GetNoArena();
}
inline void Area::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ndm_proto.Area.id)
}
#if LANG_CXX11
inline void Area::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ndm_proto.Area.id)
}
#endif
inline void Area::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ndm_proto.Area.id)
}
inline void Area::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.Area.id)
}
inline ::std::string* Area::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:ndm_proto.Area.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Area::release_id() {
  // @@protoc_insertion_point(field_release:ndm_proto.Area.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Area::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.Area.id)
}

// repeated string areapolygon_ids = 2;
inline int Area::areapolygon_ids_size() const {
  return areapolygon_ids_.size();
}
inline void Area::clear_areapolygon_ids() {
  areapolygon_ids_.Clear();
}
inline const ::std::string& Area::areapolygon_ids(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.Area.areapolygon_ids)
  return areapolygon_ids_.Get(index);
}
inline ::std::string* Area::mutable_areapolygon_ids(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.Area.areapolygon_ids)
  return areapolygon_ids_.Mutable(index);
}
inline void Area::set_areapolygon_ids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ndm_proto.Area.areapolygon_ids)
  areapolygon_ids_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Area::set_areapolygon_ids(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:ndm_proto.Area.areapolygon_ids)
  areapolygon_ids_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Area::set_areapolygon_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  areapolygon_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ndm_proto.Area.areapolygon_ids)
}
inline void Area::set_areapolygon_ids(int index, const char* value, size_t size) {
  areapolygon_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.Area.areapolygon_ids)
}
inline ::std::string* Area::add_areapolygon_ids() {
  // @@protoc_insertion_point(field_add_mutable:ndm_proto.Area.areapolygon_ids)
  return areapolygon_ids_.Add();
}
inline void Area::add_areapolygon_ids(const ::std::string& value) {
  areapolygon_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ndm_proto.Area.areapolygon_ids)
}
#if LANG_CXX11
inline void Area::add_areapolygon_ids(::std::string&& value) {
  areapolygon_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ndm_proto.Area.areapolygon_ids)
}
#endif
inline void Area::add_areapolygon_ids(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  areapolygon_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ndm_proto.Area.areapolygon_ids)
}
inline void Area::add_areapolygon_ids(const char* value, size_t size) {
  areapolygon_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ndm_proto.Area.areapolygon_ids)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Area::areapolygon_ids() const {
  // @@protoc_insertion_point(field_list:ndm_proto.Area.areapolygon_ids)
  return areapolygon_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Area::mutable_areapolygon_ids() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.Area.areapolygon_ids)
  return &areapolygon_ids_;
}

// required .ndm_proto.Polygon bounding_polygon = 3;
inline bool Area::has_bounding_polygon() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Area::set_has_bounding_polygon() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Area::clear_has_bounding_polygon() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ndm_proto::Polygon& Area::bounding_polygon() const {
  const ::ndm_proto::Polygon* p = bounding_polygon_;
  // @@protoc_insertion_point(field_get:ndm_proto.Area.bounding_polygon)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Polygon*>(
      &::ndm_proto::_Polygon_default_instance_);
}
inline ::ndm_proto::Polygon* Area::release_bounding_polygon() {
  // @@protoc_insertion_point(field_release:ndm_proto.Area.bounding_polygon)
  clear_has_bounding_polygon();
  ::ndm_proto::Polygon* temp = bounding_polygon_;
  bounding_polygon_ = NULL;
  return temp;
}
inline ::ndm_proto::Polygon* Area::mutable_bounding_polygon() {
  set_has_bounding_polygon();
  if (bounding_polygon_ == NULL) {
    bounding_polygon_ = new ::ndm_proto::Polygon;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.Area.bounding_polygon)
  return bounding_polygon_;
}
inline void Area::set_allocated_bounding_polygon(::ndm_proto::Polygon* bounding_polygon) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(bounding_polygon_);
  }
  if (bounding_polygon) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      bounding_polygon = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, bounding_polygon, submessage_arena);
    }
    set_has_bounding_polygon();
  } else {
    clear_has_bounding_polygon();
  }
  bounding_polygon_ = bounding_polygon;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.Area.bounding_polygon)
}

// optional .ndm_proto.AreaType type = 4;
inline bool Area::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Area::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Area::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::ndm_proto::AreaType& Area::type() const {
  const ::ndm_proto::AreaType* p = type_;
  // @@protoc_insertion_point(field_get:ndm_proto.Area.type)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::AreaType*>(
      &::ndm_proto::_AreaType_default_instance_);
}
inline ::ndm_proto::AreaType* Area::release_type() {
  // @@protoc_insertion_point(field_release:ndm_proto.Area.type)
  clear_has_type();
  ::ndm_proto::AreaType* temp = type_;
  type_ = NULL;
  return temp;
}
inline ::ndm_proto::AreaType* Area::mutable_type() {
  set_has_type();
  if (type_ == NULL) {
    type_ = new ::ndm_proto::AreaType;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.Area.type)
  return type_;
}
inline void Area::set_allocated_type(::ndm_proto::AreaType* type) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(type_);
  }
  if (type) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      type = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, type, submessage_arena);
    }
    set_has_type();
  } else {
    clear_has_type();
  }
  type_ = type;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.Area.type)
}

// optional string name = 5;
inline bool Area::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Area::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Area::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Area::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Area::name() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Area.name)
  return name_.GetNoArena();
}
inline void Area::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ndm_proto.Area.name)
}
#if LANG_CXX11
inline void Area::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ndm_proto.Area.name)
}
#endif
inline void Area::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ndm_proto.Area.name)
}
inline void Area::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.Area.name)
}
inline ::std::string* Area::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:ndm_proto.Area.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Area::release_name() {
  // @@protoc_insertion_point(field_release:ndm_proto.Area.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Area::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.Area.name)
}

// repeated string link_ids = 20;
inline int Area::link_ids_size() const {
  return link_ids_.size();
}
inline void Area::clear_link_ids() {
  link_ids_.Clear();
}
inline const ::std::string& Area::link_ids(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.Area.link_ids)
  return link_ids_.Get(index);
}
inline ::std::string* Area::mutable_link_ids(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.Area.link_ids)
  return link_ids_.Mutable(index);
}
inline void Area::set_link_ids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ndm_proto.Area.link_ids)
  link_ids_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Area::set_link_ids(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:ndm_proto.Area.link_ids)
  link_ids_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Area::set_link_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  link_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ndm_proto.Area.link_ids)
}
inline void Area::set_link_ids(int index, const char* value, size_t size) {
  link_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.Area.link_ids)
}
inline ::std::string* Area::add_link_ids() {
  // @@protoc_insertion_point(field_add_mutable:ndm_proto.Area.link_ids)
  return link_ids_.Add();
}
inline void Area::add_link_ids(const ::std::string& value) {
  link_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ndm_proto.Area.link_ids)
}
#if LANG_CXX11
inline void Area::add_link_ids(::std::string&& value) {
  link_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ndm_proto.Area.link_ids)
}
#endif
inline void Area::add_link_ids(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  link_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ndm_proto.Area.link_ids)
}
inline void Area::add_link_ids(const char* value, size_t size) {
  link_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ndm_proto.Area.link_ids)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Area::link_ids() const {
  // @@protoc_insertion_point(field_list:ndm_proto.Area.link_ids)
  return link_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Area::mutable_link_ids() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.Area.link_ids)
  return &link_ids_;
}

// -------------------------------------------------------------------

// Parking

// required string id = 1;
inline bool Parking::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Parking::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Parking::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Parking::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& Parking::id() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Parking.id)
  return id_.GetNoArena();
}
inline void Parking::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ndm_proto.Parking.id)
}
#if LANG_CXX11
inline void Parking::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ndm_proto.Parking.id)
}
#endif
inline void Parking::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ndm_proto.Parking.id)
}
inline void Parking::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.Parking.id)
}
inline ::std::string* Parking::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:ndm_proto.Parking.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Parking::release_id() {
  // @@protoc_insertion_point(field_release:ndm_proto.Parking.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Parking::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.Parking.id)
}

// required string parkingspace_ids = 2;
inline bool Parking::has_parkingspace_ids() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Parking::set_has_parkingspace_ids() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Parking::clear_has_parkingspace_ids() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Parking::clear_parkingspace_ids() {
  parkingspace_ids_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_parkingspace_ids();
}
inline const ::std::string& Parking::parkingspace_ids() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Parking.parkingspace_ids)
  return parkingspace_ids_.GetNoArena();
}
inline void Parking::set_parkingspace_ids(const ::std::string& value) {
  set_has_parkingspace_ids();
  parkingspace_ids_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ndm_proto.Parking.parkingspace_ids)
}
#if LANG_CXX11
inline void Parking::set_parkingspace_ids(::std::string&& value) {
  set_has_parkingspace_ids();
  parkingspace_ids_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ndm_proto.Parking.parkingspace_ids)
}
#endif
inline void Parking::set_parkingspace_ids(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_parkingspace_ids();
  parkingspace_ids_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ndm_proto.Parking.parkingspace_ids)
}
inline void Parking::set_parkingspace_ids(const char* value, size_t size) {
  set_has_parkingspace_ids();
  parkingspace_ids_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.Parking.parkingspace_ids)
}
inline ::std::string* Parking::mutable_parkingspace_ids() {
  set_has_parkingspace_ids();
  // @@protoc_insertion_point(field_mutable:ndm_proto.Parking.parkingspace_ids)
  return parkingspace_ids_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Parking::release_parkingspace_ids() {
  // @@protoc_insertion_point(field_release:ndm_proto.Parking.parkingspace_ids)
  clear_has_parkingspace_ids();
  return parkingspace_ids_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Parking::set_allocated_parkingspace_ids(::std::string* parkingspace_ids) {
  if (parkingspace_ids != NULL) {
    set_has_parkingspace_ids();
  } else {
    clear_has_parkingspace_ids();
  }
  parkingspace_ids_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), parkingspace_ids);
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.Parking.parkingspace_ids)
}

// repeated string section_ids = 3;
inline int Parking::section_ids_size() const {
  return section_ids_.size();
}
inline void Parking::clear_section_ids() {
  section_ids_.Clear();
}
inline const ::std::string& Parking::section_ids(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.Parking.section_ids)
  return section_ids_.Get(index);
}
inline ::std::string* Parking::mutable_section_ids(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.Parking.section_ids)
  return section_ids_.Mutable(index);
}
inline void Parking::set_section_ids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ndm_proto.Parking.section_ids)
  section_ids_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Parking::set_section_ids(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:ndm_proto.Parking.section_ids)
  section_ids_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Parking::set_section_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  section_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ndm_proto.Parking.section_ids)
}
inline void Parking::set_section_ids(int index, const char* value, size_t size) {
  section_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.Parking.section_ids)
}
inline ::std::string* Parking::add_section_ids() {
  // @@protoc_insertion_point(field_add_mutable:ndm_proto.Parking.section_ids)
  return section_ids_.Add();
}
inline void Parking::add_section_ids(const ::std::string& value) {
  section_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ndm_proto.Parking.section_ids)
}
#if LANG_CXX11
inline void Parking::add_section_ids(::std::string&& value) {
  section_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ndm_proto.Parking.section_ids)
}
#endif
inline void Parking::add_section_ids(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  section_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ndm_proto.Parking.section_ids)
}
inline void Parking::add_section_ids(const char* value, size_t size) {
  section_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ndm_proto.Parking.section_ids)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Parking::section_ids() const {
  // @@protoc_insertion_point(field_list:ndm_proto.Parking.section_ids)
  return section_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Parking::mutable_section_ids() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.Parking.section_ids)
  return &section_ids_;
}

// repeated string junction_ids = 4;
inline int Parking::junction_ids_size() const {
  return junction_ids_.size();
}
inline void Parking::clear_junction_ids() {
  junction_ids_.Clear();
}
inline const ::std::string& Parking::junction_ids(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.Parking.junction_ids)
  return junction_ids_.Get(index);
}
inline ::std::string* Parking::mutable_junction_ids(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.Parking.junction_ids)
  return junction_ids_.Mutable(index);
}
inline void Parking::set_junction_ids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ndm_proto.Parking.junction_ids)
  junction_ids_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Parking::set_junction_ids(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:ndm_proto.Parking.junction_ids)
  junction_ids_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Parking::set_junction_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  junction_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ndm_proto.Parking.junction_ids)
}
inline void Parking::set_junction_ids(int index, const char* value, size_t size) {
  junction_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.Parking.junction_ids)
}
inline ::std::string* Parking::add_junction_ids() {
  // @@protoc_insertion_point(field_add_mutable:ndm_proto.Parking.junction_ids)
  return junction_ids_.Add();
}
inline void Parking::add_junction_ids(const ::std::string& value) {
  junction_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ndm_proto.Parking.junction_ids)
}
#if LANG_CXX11
inline void Parking::add_junction_ids(::std::string&& value) {
  junction_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ndm_proto.Parking.junction_ids)
}
#endif
inline void Parking::add_junction_ids(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  junction_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ndm_proto.Parking.junction_ids)
}
inline void Parking::add_junction_ids(const char* value, size_t size) {
  junction_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ndm_proto.Parking.junction_ids)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Parking::junction_ids() const {
  // @@protoc_insertion_point(field_list:ndm_proto.Parking.junction_ids)
  return junction_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Parking::mutable_junction_ids() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.Parking.junction_ids)
  return &junction_ids_;
}

// required .ndm_proto.Polygon bounding_polygon = 5;
inline bool Parking::has_bounding_polygon() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Parking::set_has_bounding_polygon() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Parking::clear_has_bounding_polygon() {
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::ndm_proto::Polygon& Parking::bounding_polygon() const {
  const ::ndm_proto::Polygon* p = bounding_polygon_;
  // @@protoc_insertion_point(field_get:ndm_proto.Parking.bounding_polygon)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Polygon*>(
      &::ndm_proto::_Polygon_default_instance_);
}
inline ::ndm_proto::Polygon* Parking::release_bounding_polygon() {
  // @@protoc_insertion_point(field_release:ndm_proto.Parking.bounding_polygon)
  clear_has_bounding_polygon();
  ::ndm_proto::Polygon* temp = bounding_polygon_;
  bounding_polygon_ = NULL;
  return temp;
}
inline ::ndm_proto::Polygon* Parking::mutable_bounding_polygon() {
  set_has_bounding_polygon();
  if (bounding_polygon_ == NULL) {
    bounding_polygon_ = new ::ndm_proto::Polygon;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.Parking.bounding_polygon)
  return bounding_polygon_;
}
inline void Parking::set_allocated_bounding_polygon(::ndm_proto::Polygon* bounding_polygon) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(bounding_polygon_);
  }
  if (bounding_polygon) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      bounding_polygon = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, bounding_polygon, submessage_arena);
    }
    set_has_bounding_polygon();
  } else {
    clear_has_bounding_polygon();
  }
  bounding_polygon_ = bounding_polygon;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.Parking.bounding_polygon)
}

// optional string name = 6;
inline bool Parking::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Parking::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Parking::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Parking::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Parking::name() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Parking.name)
  return name_.GetNoArena();
}
inline void Parking::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ndm_proto.Parking.name)
}
#if LANG_CXX11
inline void Parking::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ndm_proto.Parking.name)
}
#endif
inline void Parking::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ndm_proto.Parking.name)
}
inline void Parking::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.Parking.name)
}
inline ::std::string* Parking::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:ndm_proto.Parking.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Parking::release_name() {
  // @@protoc_insertion_point(field_release:ndm_proto.Parking.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Parking::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.Parking.name)
}

// repeated string link_ids = 20;
inline int Parking::link_ids_size() const {
  return link_ids_.size();
}
inline void Parking::clear_link_ids() {
  link_ids_.Clear();
}
inline const ::std::string& Parking::link_ids(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.Parking.link_ids)
  return link_ids_.Get(index);
}
inline ::std::string* Parking::mutable_link_ids(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.Parking.link_ids)
  return link_ids_.Mutable(index);
}
inline void Parking::set_link_ids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ndm_proto.Parking.link_ids)
  link_ids_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Parking::set_link_ids(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:ndm_proto.Parking.link_ids)
  link_ids_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Parking::set_link_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  link_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ndm_proto.Parking.link_ids)
}
inline void Parking::set_link_ids(int index, const char* value, size_t size) {
  link_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.Parking.link_ids)
}
inline ::std::string* Parking::add_link_ids() {
  // @@protoc_insertion_point(field_add_mutable:ndm_proto.Parking.link_ids)
  return link_ids_.Add();
}
inline void Parking::add_link_ids(const ::std::string& value) {
  link_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ndm_proto.Parking.link_ids)
}
#if LANG_CXX11
inline void Parking::add_link_ids(::std::string&& value) {
  link_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ndm_proto.Parking.link_ids)
}
#endif
inline void Parking::add_link_ids(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  link_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ndm_proto.Parking.link_ids)
}
inline void Parking::add_link_ids(const char* value, size_t size) {
  link_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ndm_proto.Parking.link_ids)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Parking::link_ids() const {
  // @@protoc_insertion_point(field_list:ndm_proto.Parking.link_ids)
  return link_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Parking::mutable_link_ids() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.Parking.link_ids)
  return &link_ids_;
}

// -------------------------------------------------------------------

// RoadNode

// required string id = 1;
inline bool RoadNode::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoadNode::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoadNode::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoadNode::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& RoadNode::id() const {
  // @@protoc_insertion_point(field_get:ndm_proto.RoadNode.id)
  return id_.GetNoArena();
}
inline void RoadNode::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ndm_proto.RoadNode.id)
}
#if LANG_CXX11
inline void RoadNode::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ndm_proto.RoadNode.id)
}
#endif
inline void RoadNode::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ndm_proto.RoadNode.id)
}
inline void RoadNode::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.RoadNode.id)
}
inline ::std::string* RoadNode::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:ndm_proto.RoadNode.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RoadNode::release_id() {
  // @@protoc_insertion_point(field_release:ndm_proto.RoadNode.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RoadNode::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.RoadNode.id)
}

// repeated string include_ids = 2;
inline int RoadNode::include_ids_size() const {
  return include_ids_.size();
}
inline void RoadNode::clear_include_ids() {
  include_ids_.Clear();
}
inline const ::std::string& RoadNode::include_ids(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.RoadNode.include_ids)
  return include_ids_.Get(index);
}
inline ::std::string* RoadNode::mutable_include_ids(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.RoadNode.include_ids)
  return include_ids_.Mutable(index);
}
inline void RoadNode::set_include_ids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ndm_proto.RoadNode.include_ids)
  include_ids_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void RoadNode::set_include_ids(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:ndm_proto.RoadNode.include_ids)
  include_ids_.Mutable(index)->assign(std::move(value));
}
#endif
inline void RoadNode::set_include_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  include_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ndm_proto.RoadNode.include_ids)
}
inline void RoadNode::set_include_ids(int index, const char* value, size_t size) {
  include_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.RoadNode.include_ids)
}
inline ::std::string* RoadNode::add_include_ids() {
  // @@protoc_insertion_point(field_add_mutable:ndm_proto.RoadNode.include_ids)
  return include_ids_.Add();
}
inline void RoadNode::add_include_ids(const ::std::string& value) {
  include_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ndm_proto.RoadNode.include_ids)
}
#if LANG_CXX11
inline void RoadNode::add_include_ids(::std::string&& value) {
  include_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ndm_proto.RoadNode.include_ids)
}
#endif
inline void RoadNode::add_include_ids(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  include_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ndm_proto.RoadNode.include_ids)
}
inline void RoadNode::add_include_ids(const char* value, size_t size) {
  include_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ndm_proto.RoadNode.include_ids)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RoadNode::include_ids() const {
  // @@protoc_insertion_point(field_list:ndm_proto.RoadNode.include_ids)
  return include_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RoadNode::mutable_include_ids() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.RoadNode.include_ids)
  return &include_ids_;
}

// repeated string in_link_ids = 3;
inline int RoadNode::in_link_ids_size() const {
  return in_link_ids_.size();
}
inline void RoadNode::clear_in_link_ids() {
  in_link_ids_.Clear();
}
inline const ::std::string& RoadNode::in_link_ids(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.RoadNode.in_link_ids)
  return in_link_ids_.Get(index);
}
inline ::std::string* RoadNode::mutable_in_link_ids(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.RoadNode.in_link_ids)
  return in_link_ids_.Mutable(index);
}
inline void RoadNode::set_in_link_ids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ndm_proto.RoadNode.in_link_ids)
  in_link_ids_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void RoadNode::set_in_link_ids(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:ndm_proto.RoadNode.in_link_ids)
  in_link_ids_.Mutable(index)->assign(std::move(value));
}
#endif
inline void RoadNode::set_in_link_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  in_link_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ndm_proto.RoadNode.in_link_ids)
}
inline void RoadNode::set_in_link_ids(int index, const char* value, size_t size) {
  in_link_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.RoadNode.in_link_ids)
}
inline ::std::string* RoadNode::add_in_link_ids() {
  // @@protoc_insertion_point(field_add_mutable:ndm_proto.RoadNode.in_link_ids)
  return in_link_ids_.Add();
}
inline void RoadNode::add_in_link_ids(const ::std::string& value) {
  in_link_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ndm_proto.RoadNode.in_link_ids)
}
#if LANG_CXX11
inline void RoadNode::add_in_link_ids(::std::string&& value) {
  in_link_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ndm_proto.RoadNode.in_link_ids)
}
#endif
inline void RoadNode::add_in_link_ids(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  in_link_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ndm_proto.RoadNode.in_link_ids)
}
inline void RoadNode::add_in_link_ids(const char* value, size_t size) {
  in_link_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ndm_proto.RoadNode.in_link_ids)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RoadNode::in_link_ids() const {
  // @@protoc_insertion_point(field_list:ndm_proto.RoadNode.in_link_ids)
  return in_link_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RoadNode::mutable_in_link_ids() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.RoadNode.in_link_ids)
  return &in_link_ids_;
}

// repeated string out_link_ids = 4;
inline int RoadNode::out_link_ids_size() const {
  return out_link_ids_.size();
}
inline void RoadNode::clear_out_link_ids() {
  out_link_ids_.Clear();
}
inline const ::std::string& RoadNode::out_link_ids(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.RoadNode.out_link_ids)
  return out_link_ids_.Get(index);
}
inline ::std::string* RoadNode::mutable_out_link_ids(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.RoadNode.out_link_ids)
  return out_link_ids_.Mutable(index);
}
inline void RoadNode::set_out_link_ids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ndm_proto.RoadNode.out_link_ids)
  out_link_ids_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void RoadNode::set_out_link_ids(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:ndm_proto.RoadNode.out_link_ids)
  out_link_ids_.Mutable(index)->assign(std::move(value));
}
#endif
inline void RoadNode::set_out_link_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  out_link_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ndm_proto.RoadNode.out_link_ids)
}
inline void RoadNode::set_out_link_ids(int index, const char* value, size_t size) {
  out_link_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.RoadNode.out_link_ids)
}
inline ::std::string* RoadNode::add_out_link_ids() {
  // @@protoc_insertion_point(field_add_mutable:ndm_proto.RoadNode.out_link_ids)
  return out_link_ids_.Add();
}
inline void RoadNode::add_out_link_ids(const ::std::string& value) {
  out_link_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ndm_proto.RoadNode.out_link_ids)
}
#if LANG_CXX11
inline void RoadNode::add_out_link_ids(::std::string&& value) {
  out_link_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ndm_proto.RoadNode.out_link_ids)
}
#endif
inline void RoadNode::add_out_link_ids(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  out_link_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ndm_proto.RoadNode.out_link_ids)
}
inline void RoadNode::add_out_link_ids(const char* value, size_t size) {
  out_link_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ndm_proto.RoadNode.out_link_ids)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RoadNode::out_link_ids() const {
  // @@protoc_insertion_point(field_list:ndm_proto.RoadNode.out_link_ids)
  return out_link_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RoadNode::mutable_out_link_ids() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.RoadNode.out_link_ids)
  return &out_link_ids_;
}

// optional float probability = 5;
inline bool RoadNode::has_probability() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoadNode::set_has_probability() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoadNode::clear_has_probability() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoadNode::clear_probability() {
  probability_ = 0;
  clear_has_probability();
}
inline float RoadNode::probability() const {
  // @@protoc_insertion_point(field_get:ndm_proto.RoadNode.probability)
  return probability_;
}
inline void RoadNode::set_probability(float value) {
  set_has_probability();
  probability_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.RoadNode.probability)
}

// optional float turn_angle = 6;
inline bool RoadNode::has_turn_angle() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RoadNode::set_has_turn_angle() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RoadNode::clear_has_turn_angle() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RoadNode::clear_turn_angle() {
  turn_angle_ = 0;
  clear_has_turn_angle();
}
inline float RoadNode::turn_angle() const {
  // @@protoc_insertion_point(field_get:ndm_proto.RoadNode.turn_angle)
  return turn_angle_;
}
inline void RoadNode::set_turn_angle(float value) {
  set_has_turn_angle();
  turn_angle_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.RoadNode.turn_angle)
}

// -------------------------------------------------------------------

// RoadEdge

// required string id = 1;
inline bool RoadEdge::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoadEdge::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoadEdge::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoadEdge::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& RoadEdge::id() const {
  // @@protoc_insertion_point(field_get:ndm_proto.RoadEdge.id)
  return id_.GetNoArena();
}
inline void RoadEdge::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ndm_proto.RoadEdge.id)
}
#if LANG_CXX11
inline void RoadEdge::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ndm_proto.RoadEdge.id)
}
#endif
inline void RoadEdge::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ndm_proto.RoadEdge.id)
}
inline void RoadEdge::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.RoadEdge.id)
}
inline ::std::string* RoadEdge::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:ndm_proto.RoadEdge.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RoadEdge::release_id() {
  // @@protoc_insertion_point(field_release:ndm_proto.RoadEdge.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RoadEdge::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.RoadEdge.id)
}

// repeated .ndm_proto.Link sections = 2;
inline int RoadEdge::sections_size() const {
  return sections_.size();
}
inline const ::ndm_proto::Link& RoadEdge::sections(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.RoadEdge.sections)
  return sections_.Get(index);
}
inline ::ndm_proto::Link* RoadEdge::mutable_sections(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.RoadEdge.sections)
  return sections_.Mutable(index);
}
inline ::ndm_proto::Link* RoadEdge::add_sections() {
  // @@protoc_insertion_point(field_add:ndm_proto.RoadEdge.sections)
  return sections_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::Link >*
RoadEdge::mutable_sections() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.RoadEdge.sections)
  return &sections_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Link >&
RoadEdge::sections() const {
  // @@protoc_insertion_point(field_list:ndm_proto.RoadEdge.sections)
  return sections_;
}

// -------------------------------------------------------------------

// Road

// required string id = 1;
inline bool Road::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Road::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Road::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Road::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& Road::id() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Road.id)
  return id_.GetNoArena();
}
inline void Road::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ndm_proto.Road.id)
}
#if LANG_CXX11
inline void Road::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ndm_proto.Road.id)
}
#endif
inline void Road::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ndm_proto.Road.id)
}
inline void Road::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.Road.id)
}
inline ::std::string* Road::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:ndm_proto.Road.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Road::release_id() {
  // @@protoc_insertion_point(field_release:ndm_proto.Road.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Road::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.Road.id)
}

// optional string name = 2;
inline bool Road::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Road::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Road::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Road::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Road::name() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Road.name)
  return name_.GetNoArena();
}
inline void Road::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ndm_proto.Road.name)
}
#if LANG_CXX11
inline void Road::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ndm_proto.Road.name)
}
#endif
inline void Road::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ndm_proto.Road.name)
}
inline void Road::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.Road.name)
}
inline ::std::string* Road::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:ndm_proto.Road.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Road::release_name() {
  // @@protoc_insertion_point(field_release:ndm_proto.Road.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Road::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.Road.name)
}

// repeated .ndm_proto.Link forward_links = 3;
inline int Road::forward_links_size() const {
  return forward_links_.size();
}
inline const ::ndm_proto::Link& Road::forward_links(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.Road.forward_links)
  return forward_links_.Get(index);
}
inline ::ndm_proto::Link* Road::mutable_forward_links(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.Road.forward_links)
  return forward_links_.Mutable(index);
}
inline ::ndm_proto::Link* Road::add_forward_links() {
  // @@protoc_insertion_point(field_add:ndm_proto.Road.forward_links)
  return forward_links_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::Link >*
Road::mutable_forward_links() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.Road.forward_links)
  return &forward_links_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Link >&
Road::forward_links() const {
  // @@protoc_insertion_point(field_list:ndm_proto.Road.forward_links)
  return forward_links_;
}

// repeated .ndm_proto.Link backward_links = 4;
inline int Road::backward_links_size() const {
  return backward_links_.size();
}
inline const ::ndm_proto::Link& Road::backward_links(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.Road.backward_links)
  return backward_links_.Get(index);
}
inline ::ndm_proto::Link* Road::mutable_backward_links(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.Road.backward_links)
  return backward_links_.Mutable(index);
}
inline ::ndm_proto::Link* Road::add_backward_links() {
  // @@protoc_insertion_point(field_add:ndm_proto.Road.backward_links)
  return backward_links_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::Link >*
Road::mutable_backward_links() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.Road.backward_links)
  return &backward_links_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Link >&
Road::backward_links() const {
  // @@protoc_insertion_point(field_list:ndm_proto.Road.backward_links)
  return backward_links_;
}

// optional .ndm_proto.FormOfWay form = 10;
inline bool Road::has_form() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Road::set_has_form() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Road::clear_has_form() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Road::clear_form() {
  form_ = 0;
  clear_has_form();
}
inline ::ndm_proto::FormOfWay Road::form() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Road.form)
  return static_cast< ::ndm_proto::FormOfWay >(form_);
}
inline void Road::set_form(::ndm_proto::FormOfWay value) {
  assert(::ndm_proto::FormOfWay_IsValid(value));
  set_has_form();
  form_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.Road.form)
}

// optional uint32 function = 11;
inline bool Road::has_function() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Road::set_has_function() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Road::clear_has_function() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Road::clear_function() {
  function_ = 0u;
  clear_has_function();
}
inline ::google::protobuf::uint32 Road::function() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Road.function)
  return function_;
}
inline void Road::set_function(::google::protobuf::uint32 value) {
  set_has_function();
  function_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.Road.function)
}

// repeated .ndm_proto.Link links = 20;
inline int Road::links_size() const {
  return links_.size();
}
inline const ::ndm_proto::Link& Road::links(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.Road.links)
  return links_.Get(index);
}
inline ::ndm_proto::Link* Road::mutable_links(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.Road.links)
  return links_.Mutable(index);
}
inline ::ndm_proto::Link* Road::add_links() {
  // @@protoc_insertion_point(field_add:ndm_proto.Road.links)
  return links_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::Link >*
Road::mutable_links() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.Road.links)
  return &links_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Link >&
Road::links() const {
  // @@protoc_insertion_point(field_list:ndm_proto.Road.links)
  return links_;
}

// -------------------------------------------------------------------

// Tile

// required string id = 1;
inline bool Tile::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Tile::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Tile::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Tile::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& Tile::id() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Tile.id)
  return id_.GetNoArena();
}
inline void Tile::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ndm_proto.Tile.id)
}
#if LANG_CXX11
inline void Tile::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ndm_proto.Tile.id)
}
#endif
inline void Tile::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ndm_proto.Tile.id)
}
inline void Tile::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.Tile.id)
}
inline ::std::string* Tile::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:ndm_proto.Tile.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Tile::release_id() {
  // @@protoc_insertion_point(field_release:ndm_proto.Tile.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Tile::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.Tile.id)
}

// required .ndm_proto.Index index = 2;
inline bool Tile::has_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Tile::set_has_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Tile::clear_has_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ndm_proto::Index& Tile::index() const {
  const ::ndm_proto::Index* p = index_;
  // @@protoc_insertion_point(field_get:ndm_proto.Tile.index)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Index*>(
      &::ndm_proto::_Index_default_instance_);
}
inline ::ndm_proto::Index* Tile::release_index() {
  // @@protoc_insertion_point(field_release:ndm_proto.Tile.index)
  clear_has_index();
  ::ndm_proto::Index* temp = index_;
  index_ = NULL;
  return temp;
}
inline ::ndm_proto::Index* Tile::mutable_index() {
  set_has_index();
  if (index_ == NULL) {
    index_ = new ::ndm_proto::Index;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.Tile.index)
  return index_;
}
inline void Tile::set_allocated_index(::ndm_proto::Index* index) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(index_);
  }
  if (index) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      index = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, index, submessage_arena);
    }
    set_has_index();
  } else {
    clear_has_index();
  }
  index_ = index;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.Tile.index)
}

// required .ndm_proto.Point min_point = 3;
inline bool Tile::has_min_point() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Tile::set_has_min_point() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Tile::clear_has_min_point() {
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::ndm_proto::Point& Tile::min_point() const {
  const ::ndm_proto::Point* p = min_point_;
  // @@protoc_insertion_point(field_get:ndm_proto.Tile.min_point)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Point*>(
      &::ndm_proto::_Point_default_instance_);
}
inline ::ndm_proto::Point* Tile::release_min_point() {
  // @@protoc_insertion_point(field_release:ndm_proto.Tile.min_point)
  clear_has_min_point();
  ::ndm_proto::Point* temp = min_point_;
  min_point_ = NULL;
  return temp;
}
inline ::ndm_proto::Point* Tile::mutable_min_point() {
  set_has_min_point();
  if (min_point_ == NULL) {
    min_point_ = new ::ndm_proto::Point;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.Tile.min_point)
  return min_point_;
}
inline void Tile::set_allocated_min_point(::ndm_proto::Point* min_point) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(min_point_);
  }
  if (min_point) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      min_point = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, min_point, submessage_arena);
    }
    set_has_min_point();
  } else {
    clear_has_min_point();
  }
  min_point_ = min_point;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.Tile.min_point)
}

// required .ndm_proto.Tile.TileRange range = 4;
inline bool Tile::has_range() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Tile::set_has_range() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Tile::clear_has_range() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Tile::clear_range() {
  range_ = 40;
  clear_has_range();
}
inline ::ndm_proto::Tile_TileRange Tile::range() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Tile.range)
  return static_cast< ::ndm_proto::Tile_TileRange >(range_);
}
inline void Tile::set_range(::ndm_proto::Tile_TileRange value) {
  assert(::ndm_proto::Tile_TileRange_IsValid(value));
  set_has_range();
  range_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.Tile.range)
}

// repeated string childs = 5;
inline int Tile::childs_size() const {
  return childs_.size();
}
inline void Tile::clear_childs() {
  childs_.Clear();
}
inline const ::std::string& Tile::childs(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.Tile.childs)
  return childs_.Get(index);
}
inline ::std::string* Tile::mutable_childs(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.Tile.childs)
  return childs_.Mutable(index);
}
inline void Tile::set_childs(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ndm_proto.Tile.childs)
  childs_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Tile::set_childs(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:ndm_proto.Tile.childs)
  childs_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Tile::set_childs(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  childs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ndm_proto.Tile.childs)
}
inline void Tile::set_childs(int index, const char* value, size_t size) {
  childs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.Tile.childs)
}
inline ::std::string* Tile::add_childs() {
  // @@protoc_insertion_point(field_add_mutable:ndm_proto.Tile.childs)
  return childs_.Add();
}
inline void Tile::add_childs(const ::std::string& value) {
  childs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ndm_proto.Tile.childs)
}
#if LANG_CXX11
inline void Tile::add_childs(::std::string&& value) {
  childs_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ndm_proto.Tile.childs)
}
#endif
inline void Tile::add_childs(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  childs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ndm_proto.Tile.childs)
}
inline void Tile::add_childs(const char* value, size_t size) {
  childs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ndm_proto.Tile.childs)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Tile::childs() const {
  // @@protoc_insertion_point(field_list:ndm_proto.Tile.childs)
  return childs_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Tile::mutable_childs() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.Tile.childs)
  return &childs_;
}

// optional string utm_zone = 6;
inline bool Tile::has_utm_zone() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Tile::set_has_utm_zone() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Tile::clear_has_utm_zone() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Tile::clear_utm_zone() {
  utm_zone_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_utm_zone();
}
inline const ::std::string& Tile::utm_zone() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Tile.utm_zone)
  return utm_zone_.GetNoArena();
}
inline void Tile::set_utm_zone(const ::std::string& value) {
  set_has_utm_zone();
  utm_zone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ndm_proto.Tile.utm_zone)
}
#if LANG_CXX11
inline void Tile::set_utm_zone(::std::string&& value) {
  set_has_utm_zone();
  utm_zone_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ndm_proto.Tile.utm_zone)
}
#endif
inline void Tile::set_utm_zone(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_utm_zone();
  utm_zone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ndm_proto.Tile.utm_zone)
}
inline void Tile::set_utm_zone(const char* value, size_t size) {
  set_has_utm_zone();
  utm_zone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.Tile.utm_zone)
}
inline ::std::string* Tile::mutable_utm_zone() {
  set_has_utm_zone();
  // @@protoc_insertion_point(field_mutable:ndm_proto.Tile.utm_zone)
  return utm_zone_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Tile::release_utm_zone() {
  // @@protoc_insertion_point(field_release:ndm_proto.Tile.utm_zone)
  clear_has_utm_zone();
  return utm_zone_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Tile::set_allocated_utm_zone(::std::string* utm_zone) {
  if (utm_zone != NULL) {
    set_has_utm_zone();
  } else {
    clear_has_utm_zone();
  }
  utm_zone_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), utm_zone);
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.Tile.utm_zone)
}

// repeated string link_ids = 20;
inline int Tile::link_ids_size() const {
  return link_ids_.size();
}
inline void Tile::clear_link_ids() {
  link_ids_.Clear();
}
inline const ::std::string& Tile::link_ids(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.Tile.link_ids)
  return link_ids_.Get(index);
}
inline ::std::string* Tile::mutable_link_ids(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.Tile.link_ids)
  return link_ids_.Mutable(index);
}
inline void Tile::set_link_ids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ndm_proto.Tile.link_ids)
  link_ids_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Tile::set_link_ids(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:ndm_proto.Tile.link_ids)
  link_ids_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Tile::set_link_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  link_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ndm_proto.Tile.link_ids)
}
inline void Tile::set_link_ids(int index, const char* value, size_t size) {
  link_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.Tile.link_ids)
}
inline ::std::string* Tile::add_link_ids() {
  // @@protoc_insertion_point(field_add_mutable:ndm_proto.Tile.link_ids)
  return link_ids_.Add();
}
inline void Tile::add_link_ids(const ::std::string& value) {
  link_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ndm_proto.Tile.link_ids)
}
#if LANG_CXX11
inline void Tile::add_link_ids(::std::string&& value) {
  link_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ndm_proto.Tile.link_ids)
}
#endif
inline void Tile::add_link_ids(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  link_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ndm_proto.Tile.link_ids)
}
inline void Tile::add_link_ids(const char* value, size_t size) {
  link_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ndm_proto.Tile.link_ids)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Tile::link_ids() const {
  // @@protoc_insertion_point(field_list:ndm_proto.Tile.link_ids)
  return link_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Tile::mutable_link_ids() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.Tile.link_ids)
  return &link_ids_;
}

// -------------------------------------------------------------------

// TopologicalLayer

// repeated .ndm_proto.LaneLine reflines = 1;
inline int TopologicalLayer::reflines_size() const {
  return reflines_.size();
}
inline const ::ndm_proto::LaneLine& TopologicalLayer::reflines(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.TopologicalLayer.reflines)
  return reflines_.Get(index);
}
inline ::ndm_proto::LaneLine* TopologicalLayer::mutable_reflines(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.TopologicalLayer.reflines)
  return reflines_.Mutable(index);
}
inline ::ndm_proto::LaneLine* TopologicalLayer::add_reflines() {
  // @@protoc_insertion_point(field_add:ndm_proto.TopologicalLayer.reflines)
  return reflines_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::LaneLine >*
TopologicalLayer::mutable_reflines() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.TopologicalLayer.reflines)
  return &reflines_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::LaneLine >&
TopologicalLayer::reflines() const {
  // @@protoc_insertion_point(field_list:ndm_proto.TopologicalLayer.reflines)
  return reflines_;
}

// repeated .ndm_proto.Area areas = 3;
inline int TopologicalLayer::areas_size() const {
  return areas_.size();
}
inline void TopologicalLayer::clear_areas() {
  areas_.Clear();
}
inline const ::ndm_proto::Area& TopologicalLayer::areas(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.TopologicalLayer.areas)
  return areas_.Get(index);
}
inline ::ndm_proto::Area* TopologicalLayer::mutable_areas(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.TopologicalLayer.areas)
  return areas_.Mutable(index);
}
inline ::ndm_proto::Area* TopologicalLayer::add_areas() {
  // @@protoc_insertion_point(field_add:ndm_proto.TopologicalLayer.areas)
  return areas_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::Area >*
TopologicalLayer::mutable_areas() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.TopologicalLayer.areas)
  return &areas_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Area >&
TopologicalLayer::areas() const {
  // @@protoc_insertion_point(field_list:ndm_proto.TopologicalLayer.areas)
  return areas_;
}

// repeated .ndm_proto.Parking parkings = 4;
inline int TopologicalLayer::parkings_size() const {
  return parkings_.size();
}
inline void TopologicalLayer::clear_parkings() {
  parkings_.Clear();
}
inline const ::ndm_proto::Parking& TopologicalLayer::parkings(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.TopologicalLayer.parkings)
  return parkings_.Get(index);
}
inline ::ndm_proto::Parking* TopologicalLayer::mutable_parkings(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.TopologicalLayer.parkings)
  return parkings_.Mutable(index);
}
inline ::ndm_proto::Parking* TopologicalLayer::add_parkings() {
  // @@protoc_insertion_point(field_add:ndm_proto.TopologicalLayer.parkings)
  return parkings_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::Parking >*
TopologicalLayer::mutable_parkings() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.TopologicalLayer.parkings)
  return &parkings_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Parking >&
TopologicalLayer::parkings() const {
  // @@protoc_insertion_point(field_list:ndm_proto.TopologicalLayer.parkings)
  return parkings_;
}

// repeated .ndm_proto.Road roads = 5;
inline int TopologicalLayer::roads_size() const {
  return roads_.size();
}
inline void TopologicalLayer::clear_roads() {
  roads_.Clear();
}
inline const ::ndm_proto::Road& TopologicalLayer::roads(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.TopologicalLayer.roads)
  return roads_.Get(index);
}
inline ::ndm_proto::Road* TopologicalLayer::mutable_roads(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.TopologicalLayer.roads)
  return roads_.Mutable(index);
}
inline ::ndm_proto::Road* TopologicalLayer::add_roads() {
  // @@protoc_insertion_point(field_add:ndm_proto.TopologicalLayer.roads)
  return roads_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::Road >*
TopologicalLayer::mutable_roads() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.TopologicalLayer.roads)
  return &roads_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Road >&
TopologicalLayer::roads() const {
  // @@protoc_insertion_point(field_list:ndm_proto.TopologicalLayer.roads)
  return roads_;
}

// repeated .ndm_proto.Tile tiles = 6;
inline int TopologicalLayer::tiles_size() const {
  return tiles_.size();
}
inline void TopologicalLayer::clear_tiles() {
  tiles_.Clear();
}
inline const ::ndm_proto::Tile& TopologicalLayer::tiles(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.TopologicalLayer.tiles)
  return tiles_.Get(index);
}
inline ::ndm_proto::Tile* TopologicalLayer::mutable_tiles(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.TopologicalLayer.tiles)
  return tiles_.Mutable(index);
}
inline ::ndm_proto::Tile* TopologicalLayer::add_tiles() {
  // @@protoc_insertion_point(field_add:ndm_proto.TopologicalLayer.tiles)
  return tiles_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::Tile >*
TopologicalLayer::mutable_tiles() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.TopologicalLayer.tiles)
  return &tiles_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Tile >&
TopologicalLayer::tiles() const {
  // @@protoc_insertion_point(field_list:ndm_proto.TopologicalLayer.tiles)
  return tiles_;
}

// repeated .ndm_proto.RoadNode road_nodes = 7;
inline int TopologicalLayer::road_nodes_size() const {
  return road_nodes_.size();
}
inline void TopologicalLayer::clear_road_nodes() {
  road_nodes_.Clear();
}
inline const ::ndm_proto::RoadNode& TopologicalLayer::road_nodes(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.TopologicalLayer.road_nodes)
  return road_nodes_.Get(index);
}
inline ::ndm_proto::RoadNode* TopologicalLayer::mutable_road_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.TopologicalLayer.road_nodes)
  return road_nodes_.Mutable(index);
}
inline ::ndm_proto::RoadNode* TopologicalLayer::add_road_nodes() {
  // @@protoc_insertion_point(field_add:ndm_proto.TopologicalLayer.road_nodes)
  return road_nodes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::RoadNode >*
TopologicalLayer::mutable_road_nodes() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.TopologicalLayer.road_nodes)
  return &road_nodes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::RoadNode >&
TopologicalLayer::road_nodes() const {
  // @@protoc_insertion_point(field_list:ndm_proto.TopologicalLayer.road_nodes)
  return road_nodes_;
}

// repeated .ndm_proto.RoadEdge road_edges = 8;
inline int TopologicalLayer::road_edges_size() const {
  return road_edges_.size();
}
inline void TopologicalLayer::clear_road_edges() {
  road_edges_.Clear();
}
inline const ::ndm_proto::RoadEdge& TopologicalLayer::road_edges(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.TopologicalLayer.road_edges)
  return road_edges_.Get(index);
}
inline ::ndm_proto::RoadEdge* TopologicalLayer::mutable_road_edges(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.TopologicalLayer.road_edges)
  return road_edges_.Mutable(index);
}
inline ::ndm_proto::RoadEdge* TopologicalLayer::add_road_edges() {
  // @@protoc_insertion_point(field_add:ndm_proto.TopologicalLayer.road_edges)
  return road_edges_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::RoadEdge >*
TopologicalLayer::mutable_road_edges() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.TopologicalLayer.road_edges)
  return &road_edges_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::RoadEdge >&
TopologicalLayer::road_edges() const {
  // @@protoc_insertion_point(field_list:ndm_proto.TopologicalLayer.road_edges)
  return road_edges_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ndm_proto

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::ndm_proto::Tile_TileRange> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ndm_proto::Tile_TileRange>() {
  return ::ndm_proto::Tile_TileRange_descriptor();
}
template <> struct is_proto_enum< ::ndm_proto::FormOfWay> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ndm_proto::FormOfWay>() {
  return ::ndm_proto::FormOfWay_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_topological_5flayer_2eproto__INCLUDED
