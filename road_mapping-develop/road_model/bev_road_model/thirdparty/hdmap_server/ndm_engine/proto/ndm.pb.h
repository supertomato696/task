// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ndm.proto

#ifndef PROTOBUF_ndm_2eproto__INCLUDED
#define PROTOBUF_ndm_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "base.pb.h"
#include "physical_layer.pb.h"
#include "logical_layer.pb.h"
#include "topological_layer.pb.h"
#include "dynamic_layer.pb.h"
#include "location.pb.h"
#include "debug.pb.h"
#include "navigation.pb.h"
#include "ego_layer.pb.h"
#include "loc_eval.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_ndm_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[11];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsNDMHeaderImpl();
void InitDefaultsNDMHeader();
void InitDefaultsGlobalDataImpl();
void InitDefaultsGlobalData();
void InitDefaultsLocationMsgImpl();
void InitDefaultsLocationMsg();
void InitDefaultsNavigationMsgImpl();
void InitDefaultsNavigationMsg();
void InitDefaultsLogMsgImpl();
void InitDefaultsLogMsg();
void InitDefaultsDebugMsgImpl();
void InitDefaultsDebugMsg();
void InitDefaultsSessionInfoMsgImpl();
void InitDefaultsSessionInfoMsg();
void InitDefaultsMapEnvMsgImpl();
void InitDefaultsMapEnvMsg();
void InitDefaultsNDMMessageImpl();
void InitDefaultsNDMMessage();
void InitDefaultsDataPackImpl();
void InitDefaultsDataPack();
void InitDefaultsDataHolderImpl();
void InitDefaultsDataHolder();
inline void InitDefaults() {
  InitDefaultsNDMHeader();
  InitDefaultsGlobalData();
  InitDefaultsLocationMsg();
  InitDefaultsNavigationMsg();
  InitDefaultsLogMsg();
  InitDefaultsDebugMsg();
  InitDefaultsSessionInfoMsg();
  InitDefaultsMapEnvMsg();
  InitDefaultsNDMMessage();
  InitDefaultsDataPack();
  InitDefaultsDataHolder();
}
}  // namespace protobuf_ndm_2eproto
namespace ndm_proto {
class DataHolder;
class DataHolderDefaultTypeInternal;
extern DataHolderDefaultTypeInternal _DataHolder_default_instance_;
class DataPack;
class DataPackDefaultTypeInternal;
extern DataPackDefaultTypeInternal _DataPack_default_instance_;
class DebugMsg;
class DebugMsgDefaultTypeInternal;
extern DebugMsgDefaultTypeInternal _DebugMsg_default_instance_;
class GlobalData;
class GlobalDataDefaultTypeInternal;
extern GlobalDataDefaultTypeInternal _GlobalData_default_instance_;
class LocationMsg;
class LocationMsgDefaultTypeInternal;
extern LocationMsgDefaultTypeInternal _LocationMsg_default_instance_;
class LogMsg;
class LogMsgDefaultTypeInternal;
extern LogMsgDefaultTypeInternal _LogMsg_default_instance_;
class MapEnvMsg;
class MapEnvMsgDefaultTypeInternal;
extern MapEnvMsgDefaultTypeInternal _MapEnvMsg_default_instance_;
class NDMHeader;
class NDMHeaderDefaultTypeInternal;
extern NDMHeaderDefaultTypeInternal _NDMHeader_default_instance_;
class NDMMessage;
class NDMMessageDefaultTypeInternal;
extern NDMMessageDefaultTypeInternal _NDMMessage_default_instance_;
class NavigationMsg;
class NavigationMsgDefaultTypeInternal;
extern NavigationMsgDefaultTypeInternal _NavigationMsg_default_instance_;
class SessionInfoMsg;
class SessionInfoMsgDefaultTypeInternal;
extern SessionInfoMsgDefaultTypeInternal _SessionInfoMsg_default_instance_;
}  // namespace ndm_proto
namespace ndm_proto {

enum DrivingSide {
  DrivingSide_RightHandDriving = 0,
  DrivingSide_LeftHandDriving = 1
};
bool DrivingSide_IsValid(int value);
const DrivingSide DrivingSide_MIN = DrivingSide_RightHandDriving;
const DrivingSide DrivingSide_MAX = DrivingSide_LeftHandDriving;
const int DrivingSide_ARRAYSIZE = DrivingSide_MAX + 1;

const ::google::protobuf::EnumDescriptor* DrivingSide_descriptor();
inline const ::std::string& DrivingSide_Name(DrivingSide value) {
  return ::google::protobuf::internal::NameOfEnum(
    DrivingSide_descriptor(), value);
}
inline bool DrivingSide_Parse(
    const ::std::string& name, DrivingSide* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DrivingSide>(
    DrivingSide_descriptor(), name, value);
}
enum UnitOfSystem {
  UnitOfSystem_Imperial = 0,
  UnitOfSystem_Metric = 1
};
bool UnitOfSystem_IsValid(int value);
const UnitOfSystem UnitOfSystem_MIN = UnitOfSystem_Imperial;
const UnitOfSystem UnitOfSystem_MAX = UnitOfSystem_Metric;
const int UnitOfSystem_ARRAYSIZE = UnitOfSystem_MAX + 1;

const ::google::protobuf::EnumDescriptor* UnitOfSystem_descriptor();
inline const ::std::string& UnitOfSystem_Name(UnitOfSystem value) {
  return ::google::protobuf::internal::NameOfEnum(
    UnitOfSystem_descriptor(), value);
}
inline bool UnitOfSystem_Parse(
    const ::std::string& name, UnitOfSystem* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UnitOfSystem>(
    UnitOfSystem_descriptor(), name, value);
}
enum MapProvider {
  MapProvider_provider_Unknown = 0,
  MapProvider_provider_AND = 1,
  MapProvider_provider_AutoNavi = 2,
  MapProvider_provider_HERE = 3,
  MapProvider_provider_Hyundai = 4,
  MapProvider_provider_Navinfo = 5,
  MapProvider_provider_TomTom = 6,
  MapProvider_provider_Zenrin = 7,
  MapProvider_provider_HORIZON = 8
};
bool MapProvider_IsValid(int value);
const MapProvider MapProvider_MIN = MapProvider_provider_Unknown;
const MapProvider MapProvider_MAX = MapProvider_provider_HORIZON;
const int MapProvider_ARRAYSIZE = MapProvider_MAX + 1;

const ::google::protobuf::EnumDescriptor* MapProvider_descriptor();
inline const ::std::string& MapProvider_Name(MapProvider value) {
  return ::google::protobuf::internal::NameOfEnum(
    MapProvider_descriptor(), value);
}
inline bool MapProvider_Parse(
    const ::std::string& name, MapProvider* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MapProvider>(
    MapProvider_descriptor(), name, value);
}
enum MapStatus {
  MapStatus_mapNotAvailable = 0,
  MapStatus_mapLoading = 1,
  MapStatus_mapAvailable = 2
};
bool MapStatus_IsValid(int value);
const MapStatus MapStatus_MIN = MapStatus_mapNotAvailable;
const MapStatus MapStatus_MAX = MapStatus_mapAvailable;
const int MapStatus_ARRAYSIZE = MapStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* MapStatus_descriptor();
inline const ::std::string& MapStatus_Name(MapStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    MapStatus_descriptor(), value);
}
inline bool MapStatus_Parse(
    const ::std::string& name, MapStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MapStatus>(
    MapStatus_descriptor(), name, value);
}
// ===================================================================

class NDMHeader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.NDMHeader) */ {
 public:
  NDMHeader();
  virtual ~NDMHeader();

  NDMHeader(const NDMHeader& from);

  inline NDMHeader& operator=(const NDMHeader& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NDMHeader(NDMHeader&& from) noexcept
    : NDMHeader() {
    *this = ::std::move(from);
  }

  inline NDMHeader& operator=(NDMHeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NDMHeader& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NDMHeader* internal_default_instance() {
    return reinterpret_cast<const NDMHeader*>(
               &_NDMHeader_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(NDMHeader* other);
  friend void swap(NDMHeader& a, NDMHeader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NDMHeader* New() const PROTOBUF_FINAL { return New(NULL); }

  NDMHeader* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NDMHeader& from);
  void MergeFrom(const NDMHeader& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NDMHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string version = 1;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // required string date = 2;
  bool has_date() const;
  void clear_date();
  static const int kDateFieldNumber = 2;
  const ::std::string& date() const;
  void set_date(const ::std::string& value);
  #if LANG_CXX11
  void set_date(::std::string&& value);
  #endif
  void set_date(const char* value);
  void set_date(const char* value, size_t size);
  ::std::string* mutable_date();
  ::std::string* release_date();
  void set_allocated_date(::std::string* date);

  // required string projection = 6;
  bool has_projection() const;
  void clear_projection();
  static const int kProjectionFieldNumber = 6;
  const ::std::string& projection() const;
  void set_projection(const ::std::string& value);
  #if LANG_CXX11
  void set_projection(::std::string&& value);
  #endif
  void set_projection(const char* value);
  void set_projection(const char* value, size_t size);
  ::std::string* mutable_projection();
  ::std::string* release_projection();
  void set_allocated_projection(::std::string* projection);

  // optional string utm_zone = 7;
  bool has_utm_zone() const;
  void clear_utm_zone();
  static const int kUtmZoneFieldNumber = 7;
  const ::std::string& utm_zone() const;
  void set_utm_zone(const ::std::string& value);
  #if LANG_CXX11
  void set_utm_zone(::std::string&& value);
  #endif
  void set_utm_zone(const char* value);
  void set_utm_zone(const char* value, size_t size);
  ::std::string* mutable_utm_zone();
  ::std::string* release_utm_zone();
  void set_allocated_utm_zone(::std::string* utm_zone);

  // optional .ndm_proto.Point base_offset = 8;
  bool has_base_offset() const;
  void clear_base_offset();
  static const int kBaseOffsetFieldNumber = 8;
  const ::ndm_proto::Point& base_offset() const;
  ::ndm_proto::Point* release_base_offset();
  ::ndm_proto::Point* mutable_base_offset();
  void set_allocated_base_offset(::ndm_proto::Point* base_offset);

  // optional .ndm_proto.GlobalData global_data = 9;
  bool has_global_data() const;
  void clear_global_data();
  static const int kGlobalDataFieldNumber = 9;
  const ::ndm_proto::GlobalData& global_data() const;
  ::ndm_proto::GlobalData* release_global_data();
  ::ndm_proto::GlobalData* mutable_global_data();
  void set_allocated_global_data(::ndm_proto::GlobalData* global_data);

  // required uint64 stamp = 3;
  bool has_stamp() const;
  void clear_stamp();
  static const int kStampFieldNumber = 3;
  ::google::protobuf::uint64 stamp() const;
  void set_stamp(::google::protobuf::uint64 value);

  // optional uint64 seq_id = 4;
  bool has_seq_id() const;
  void clear_seq_id();
  static const int kSeqIdFieldNumber = 4;
  ::google::protobuf::uint64 seq_id() const;
  void set_seq_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:ndm_proto.NDMHeader)
 private:
  void set_has_version();
  void clear_has_version();
  void set_has_date();
  void clear_has_date();
  void set_has_stamp();
  void clear_has_stamp();
  void set_has_seq_id();
  void clear_has_seq_id();
  void set_has_projection();
  void clear_has_projection();
  void set_has_utm_zone();
  void clear_has_utm_zone();
  void set_has_base_offset();
  void clear_has_base_offset();
  void set_has_global_data();
  void clear_has_global_data();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr date_;
  ::google::protobuf::internal::ArenaStringPtr projection_;
  ::google::protobuf::internal::ArenaStringPtr utm_zone_;
  ::ndm_proto::Point* base_offset_;
  ::ndm_proto::GlobalData* global_data_;
  ::google::protobuf::uint64 stamp_;
  ::google::protobuf::uint64 seq_id_;
  friend struct ::protobuf_ndm_2eproto::TableStruct;
  friend void ::protobuf_ndm_2eproto::InitDefaultsNDMHeaderImpl();
};
// -------------------------------------------------------------------

class GlobalData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.GlobalData) */ {
 public:
  GlobalData();
  virtual ~GlobalData();

  GlobalData(const GlobalData& from);

  inline GlobalData& operator=(const GlobalData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GlobalData(GlobalData&& from) noexcept
    : GlobalData() {
    *this = ::std::move(from);
  }

  inline GlobalData& operator=(GlobalData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GlobalData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GlobalData* internal_default_instance() {
    return reinterpret_cast<const GlobalData*>(
               &_GlobalData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(GlobalData* other);
  friend void swap(GlobalData& a, GlobalData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GlobalData* New() const PROTOBUF_FINAL { return New(NULL); }

  GlobalData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GlobalData& from);
  void MergeFrom(const GlobalData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GlobalData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 country_code = 1;
  bool has_country_code() const;
  void clear_country_code();
  static const int kCountryCodeFieldNumber = 1;
  ::google::protobuf::uint32 country_code() const;
  void set_country_code(::google::protobuf::uint32 value);

  // optional uint32 region_code = 2;
  bool has_region_code() const;
  void clear_region_code();
  static const int kRegionCodeFieldNumber = 2;
  ::google::protobuf::uint32 region_code() const;
  void set_region_code(::google::protobuf::uint32 value);

  // optional .ndm_proto.DrivingSide driving_side = 3;
  bool has_driving_side() const;
  void clear_driving_side();
  static const int kDrivingSideFieldNumber = 3;
  ::ndm_proto::DrivingSide driving_side() const;
  void set_driving_side(::ndm_proto::DrivingSide value);

  // optional .ndm_proto.UnitOfSystem unit = 4;
  bool has_unit() const;
  void clear_unit();
  static const int kUnitFieldNumber = 4;
  ::ndm_proto::UnitOfSystem unit() const;
  void set_unit(::ndm_proto::UnitOfSystem value);

  // optional uint32 protocol_version = 5;
  bool has_protocol_version() const;
  void clear_protocol_version();
  static const int kProtocolVersionFieldNumber = 5;
  ::google::protobuf::uint32 protocol_version() const;
  void set_protocol_version(::google::protobuf::uint32 value);

  // optional uint32 hardware_version = 6;
  bool has_hardware_version() const;
  void clear_hardware_version();
  static const int kHardwareVersionFieldNumber = 6;
  ::google::protobuf::uint32 hardware_version() const;
  void set_hardware_version(::google::protobuf::uint32 value);

  // optional uint32 map_version = 7;
  bool has_map_version() const;
  void clear_map_version();
  static const int kMapVersionFieldNumber = 7;
  ::google::protobuf::uint32 map_version() const;
  void set_map_version(::google::protobuf::uint32 value);

  // optional uint32 map_age = 8;
  bool has_map_age() const;
  void clear_map_age();
  static const int kMapAgeFieldNumber = 8;
  ::google::protobuf::uint32 map_age() const;
  void set_map_age(::google::protobuf::uint32 value);

  // optional .ndm_proto.MapProvider map_provider = 9;
  bool has_map_provider() const;
  void clear_map_provider();
  static const int kMapProviderFieldNumber = 9;
  ::ndm_proto::MapProvider map_provider() const;
  void set_map_provider(::ndm_proto::MapProvider value);

  // optional .ndm_proto.MapStatus map_status = 10;
  bool has_map_status() const;
  void clear_map_status();
  static const int kMapStatusFieldNumber = 10;
  ::ndm_proto::MapStatus map_status() const;
  void set_map_status(::ndm_proto::MapStatus value);

  // optional int32 time_zone_offset = 11;
  bool has_time_zone_offset() const;
  void clear_time_zone_offset();
  static const int kTimeZoneOffsetFieldNumber = 11;
  ::google::protobuf::int32 time_zone_offset() const;
  void set_time_zone_offset(::google::protobuf::int32 value);

  // optional uint32 mapping_version = 12;
  bool has_mapping_version() const;
  void clear_mapping_version();
  static const int kMappingVersionFieldNumber = 12;
  ::google::protobuf::uint32 mapping_version() const;
  void set_mapping_version(::google::protobuf::uint32 value);

  // optional uint32 aggregation_version = 13;
  bool has_aggregation_version() const;
  void clear_aggregation_version();
  static const int kAggregationVersionFieldNumber = 13;
  ::google::protobuf::uint32 aggregation_version() const;
  void set_aggregation_version(::google::protobuf::uint32 value);

  // optional uint32 ota_status = 14;
  bool has_ota_status() const;
  void clear_ota_status();
  static const int kOtaStatusFieldNumber = 14;
  ::google::protobuf::uint32 ota_status() const;
  void set_ota_status(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ndm_proto.GlobalData)
 private:
  void set_has_country_code();
  void clear_has_country_code();
  void set_has_region_code();
  void clear_has_region_code();
  void set_has_driving_side();
  void clear_has_driving_side();
  void set_has_unit();
  void clear_has_unit();
  void set_has_protocol_version();
  void clear_has_protocol_version();
  void set_has_hardware_version();
  void clear_has_hardware_version();
  void set_has_map_version();
  void clear_has_map_version();
  void set_has_map_age();
  void clear_has_map_age();
  void set_has_map_provider();
  void clear_has_map_provider();
  void set_has_map_status();
  void clear_has_map_status();
  void set_has_time_zone_offset();
  void clear_has_time_zone_offset();
  void set_has_mapping_version();
  void clear_has_mapping_version();
  void set_has_aggregation_version();
  void clear_has_aggregation_version();
  void set_has_ota_status();
  void clear_has_ota_status();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 country_code_;
  ::google::protobuf::uint32 region_code_;
  int driving_side_;
  int unit_;
  ::google::protobuf::uint32 protocol_version_;
  ::google::protobuf::uint32 hardware_version_;
  ::google::protobuf::uint32 map_version_;
  ::google::protobuf::uint32 map_age_;
  int map_provider_;
  int map_status_;
  ::google::protobuf::int32 time_zone_offset_;
  ::google::protobuf::uint32 mapping_version_;
  ::google::protobuf::uint32 aggregation_version_;
  ::google::protobuf::uint32 ota_status_;
  friend struct ::protobuf_ndm_2eproto::TableStruct;
  friend void ::protobuf_ndm_2eproto::InitDefaultsGlobalDataImpl();
};
// -------------------------------------------------------------------

class LocationMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.LocationMsg) */ {
 public:
  LocationMsg();
  virtual ~LocationMsg();

  LocationMsg(const LocationMsg& from);

  inline LocationMsg& operator=(const LocationMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LocationMsg(LocationMsg&& from) noexcept
    : LocationMsg() {
    *this = ::std::move(from);
  }

  inline LocationMsg& operator=(LocationMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LocationMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LocationMsg* internal_default_instance() {
    return reinterpret_cast<const LocationMsg*>(
               &_LocationMsg_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(LocationMsg* other);
  friend void swap(LocationMsg& a, LocationMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LocationMsg* New() const PROTOBUF_FINAL { return New(NULL); }

  LocationMsg* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LocationMsg& from);
  void MergeFrom(const LocationMsg& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LocationMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ndm_proto.Odometry relative_odom = 3;
  int relative_odom_size() const;
  void clear_relative_odom();
  static const int kRelativeOdomFieldNumber = 3;
  const ::ndm_proto::Odometry& relative_odom(int index) const;
  ::ndm_proto::Odometry* mutable_relative_odom(int index);
  ::ndm_proto::Odometry* add_relative_odom();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Odometry >*
      mutable_relative_odom();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Odometry >&
      relative_odom() const;

  // repeated .ndm_proto.RelativePosition relative_position = 4;
  int relative_position_size() const;
  void clear_relative_position();
  static const int kRelativePositionFieldNumber = 4;
  const ::ndm_proto::RelativePosition& relative_position(int index) const;
  ::ndm_proto::RelativePosition* mutable_relative_position(int index);
  ::ndm_proto::RelativePosition* add_relative_position();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::RelativePosition >*
      mutable_relative_position();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::RelativePosition >&
      relative_position() const;

  // required .ndm_proto.NDMHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::ndm_proto::NDMHeader& header() const;
  ::ndm_proto::NDMHeader* release_header();
  ::ndm_proto::NDMHeader* mutable_header();
  void set_allocated_header(::ndm_proto::NDMHeader* header);

  // required .ndm_proto.Location location = 2;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 2;
  const ::ndm_proto::Location& location() const;
  ::ndm_proto::Location* release_location();
  ::ndm_proto::Location* mutable_location();
  void set_allocated_location(::ndm_proto::Location* location);

  // @@protoc_insertion_point(class_scope:ndm_proto.LocationMsg)
 private:
  void set_has_header();
  void clear_has_header();
  void set_has_location();
  void clear_has_location();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::Odometry > relative_odom_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::RelativePosition > relative_position_;
  ::ndm_proto::NDMHeader* header_;
  ::ndm_proto::Location* location_;
  friend struct ::protobuf_ndm_2eproto::TableStruct;
  friend void ::protobuf_ndm_2eproto::InitDefaultsLocationMsgImpl();
};
// -------------------------------------------------------------------

class NavigationMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.NavigationMsg) */ {
 public:
  NavigationMsg();
  virtual ~NavigationMsg();

  NavigationMsg(const NavigationMsg& from);

  inline NavigationMsg& operator=(const NavigationMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NavigationMsg(NavigationMsg&& from) noexcept
    : NavigationMsg() {
    *this = ::std::move(from);
  }

  inline NavigationMsg& operator=(NavigationMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NavigationMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NavigationMsg* internal_default_instance() {
    return reinterpret_cast<const NavigationMsg*>(
               &_NavigationMsg_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(NavigationMsg* other);
  friend void swap(NavigationMsg& a, NavigationMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NavigationMsg* New() const PROTOBUF_FINAL { return New(NULL); }

  NavigationMsg* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NavigationMsg& from);
  void MergeFrom(const NavigationMsg& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NavigationMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ndm_proto.NDMHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::ndm_proto::NDMHeader& header() const;
  ::ndm_proto::NDMHeader* release_header();
  ::ndm_proto::NDMHeader* mutable_header();
  void set_allocated_header(::ndm_proto::NDMHeader* header);

  // required .ndm_proto.Navigation navigation = 2;
  bool has_navigation() const;
  void clear_navigation();
  static const int kNavigationFieldNumber = 2;
  const ::ndm_proto::Navigation& navigation() const;
  ::ndm_proto::Navigation* release_navigation();
  ::ndm_proto::Navigation* mutable_navigation();
  void set_allocated_navigation(::ndm_proto::Navigation* navigation);

  // @@protoc_insertion_point(class_scope:ndm_proto.NavigationMsg)
 private:
  void set_has_header();
  void clear_has_header();
  void set_has_navigation();
  void clear_has_navigation();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::ndm_proto::NDMHeader* header_;
  ::ndm_proto::Navigation* navigation_;
  friend struct ::protobuf_ndm_2eproto::TableStruct;
  friend void ::protobuf_ndm_2eproto::InitDefaultsNavigationMsgImpl();
};
// -------------------------------------------------------------------

class LogMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.LogMsg) */ {
 public:
  LogMsg();
  virtual ~LogMsg();

  LogMsg(const LogMsg& from);

  inline LogMsg& operator=(const LogMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LogMsg(LogMsg&& from) noexcept
    : LogMsg() {
    *this = ::std::move(from);
  }

  inline LogMsg& operator=(LogMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LogMsg* internal_default_instance() {
    return reinterpret_cast<const LogMsg*>(
               &_LogMsg_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(LogMsg* other);
  friend void swap(LogMsg& a, LogMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LogMsg* New() const PROTOBUF_FINAL { return New(NULL); }

  LogMsg* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LogMsg& from);
  void MergeFrom(const LogMsg& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LogMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string log = 2;
  int log_size() const;
  void clear_log();
  static const int kLogFieldNumber = 2;
  const ::std::string& log(int index) const;
  ::std::string* mutable_log(int index);
  void set_log(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_log(int index, ::std::string&& value);
  #endif
  void set_log(int index, const char* value);
  void set_log(int index, const char* value, size_t size);
  ::std::string* add_log();
  void add_log(const ::std::string& value);
  #if LANG_CXX11
  void add_log(::std::string&& value);
  #endif
  void add_log(const char* value);
  void add_log(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& log() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_log();

  // required .ndm_proto.NDMHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::ndm_proto::NDMHeader& header() const;
  ::ndm_proto::NDMHeader* release_header();
  ::ndm_proto::NDMHeader* mutable_header();
  void set_allocated_header(::ndm_proto::NDMHeader* header);

  // @@protoc_insertion_point(class_scope:ndm_proto.LogMsg)
 private:
  void set_has_header();
  void clear_has_header();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> log_;
  ::ndm_proto::NDMHeader* header_;
  friend struct ::protobuf_ndm_2eproto::TableStruct;
  friend void ::protobuf_ndm_2eproto::InitDefaultsLogMsgImpl();
};
// -------------------------------------------------------------------

class DebugMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.DebugMsg) */ {
 public:
  DebugMsg();
  virtual ~DebugMsg();

  DebugMsg(const DebugMsg& from);

  inline DebugMsg& operator=(const DebugMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DebugMsg(DebugMsg&& from) noexcept
    : DebugMsg() {
    *this = ::std::move(from);
  }

  inline DebugMsg& operator=(DebugMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DebugMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DebugMsg* internal_default_instance() {
    return reinterpret_cast<const DebugMsg*>(
               &_DebugMsg_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(DebugMsg* other);
  friend void swap(DebugMsg& a, DebugMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DebugMsg* New() const PROTOBUF_FINAL { return New(NULL); }

  DebugMsg* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DebugMsg& from);
  void MergeFrom(const DebugMsg& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DebugMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ndm_proto.NDMHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::ndm_proto::NDMHeader& header() const;
  ::ndm_proto::NDMHeader* release_header();
  ::ndm_proto::NDMHeader* mutable_header();
  void set_allocated_header(::ndm_proto::NDMHeader* header);

  // required .ndm_proto.Debug debug = 2;
  bool has_debug() const;
  void clear_debug();
  static const int kDebugFieldNumber = 2;
  const ::ndm_proto::Debug& debug() const;
  ::ndm_proto::Debug* release_debug();
  ::ndm_proto::Debug* mutable_debug();
  void set_allocated_debug(::ndm_proto::Debug* debug);

  // @@protoc_insertion_point(class_scope:ndm_proto.DebugMsg)
 private:
  void set_has_header();
  void clear_has_header();
  void set_has_debug();
  void clear_has_debug();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::ndm_proto::NDMHeader* header_;
  ::ndm_proto::Debug* debug_;
  friend struct ::protobuf_ndm_2eproto::TableStruct;
  friend void ::protobuf_ndm_2eproto::InitDefaultsDebugMsgImpl();
};
// -------------------------------------------------------------------

class SessionInfoMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.SessionInfoMsg) */ {
 public:
  SessionInfoMsg();
  virtual ~SessionInfoMsg();

  SessionInfoMsg(const SessionInfoMsg& from);

  inline SessionInfoMsg& operator=(const SessionInfoMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SessionInfoMsg(SessionInfoMsg&& from) noexcept
    : SessionInfoMsg() {
    *this = ::std::move(from);
  }

  inline SessionInfoMsg& operator=(SessionInfoMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SessionInfoMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SessionInfoMsg* internal_default_instance() {
    return reinterpret_cast<const SessionInfoMsg*>(
               &_SessionInfoMsg_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(SessionInfoMsg* other);
  friend void swap(SessionInfoMsg& a, SessionInfoMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SessionInfoMsg* New() const PROTOBUF_FINAL { return New(NULL); }

  SessionInfoMsg* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SessionInfoMsg& from);
  void MergeFrom(const SessionInfoMsg& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SessionInfoMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ndm_proto.NDMHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::ndm_proto::NDMHeader& header() const;
  ::ndm_proto::NDMHeader* release_header();
  ::ndm_proto::NDMHeader* mutable_header();
  void set_allocated_header(::ndm_proto::NDMHeader* header);

  // required .ndm_proto.SessionInfo session = 2;
  bool has_session() const;
  void clear_session();
  static const int kSessionFieldNumber = 2;
  const ::ndm_proto::SessionInfo& session() const;
  ::ndm_proto::SessionInfo* release_session();
  ::ndm_proto::SessionInfo* mutable_session();
  void set_allocated_session(::ndm_proto::SessionInfo* session);

  // @@protoc_insertion_point(class_scope:ndm_proto.SessionInfoMsg)
 private:
  void set_has_header();
  void clear_has_header();
  void set_has_session();
  void clear_has_session();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::ndm_proto::NDMHeader* header_;
  ::ndm_proto::SessionInfo* session_;
  friend struct ::protobuf_ndm_2eproto::TableStruct;
  friend void ::protobuf_ndm_2eproto::InitDefaultsSessionInfoMsgImpl();
};
// -------------------------------------------------------------------

class MapEnvMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.MapEnvMsg) */ {
 public:
  MapEnvMsg();
  virtual ~MapEnvMsg();

  MapEnvMsg(const MapEnvMsg& from);

  inline MapEnvMsg& operator=(const MapEnvMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MapEnvMsg(MapEnvMsg&& from) noexcept
    : MapEnvMsg() {
    *this = ::std::move(from);
  }

  inline MapEnvMsg& operator=(MapEnvMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapEnvMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapEnvMsg* internal_default_instance() {
    return reinterpret_cast<const MapEnvMsg*>(
               &_MapEnvMsg_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(MapEnvMsg* other);
  friend void swap(MapEnvMsg& a, MapEnvMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MapEnvMsg* New() const PROTOBUF_FINAL { return New(NULL); }

  MapEnvMsg* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MapEnvMsg& from);
  void MergeFrom(const MapEnvMsg& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MapEnvMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ndm_proto.NDMHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::ndm_proto::NDMHeader& header() const;
  ::ndm_proto::NDMHeader* release_header();
  ::ndm_proto::NDMHeader* mutable_header();
  void set_allocated_header(::ndm_proto::NDMHeader* header);

  // optional .ndm_proto.PhysicalLayer physical_layer = 2;
  bool has_physical_layer() const;
  void clear_physical_layer();
  static const int kPhysicalLayerFieldNumber = 2;
  const ::ndm_proto::PhysicalLayer& physical_layer() const;
  ::ndm_proto::PhysicalLayer* release_physical_layer();
  ::ndm_proto::PhysicalLayer* mutable_physical_layer();
  void set_allocated_physical_layer(::ndm_proto::PhysicalLayer* physical_layer);

  // optional .ndm_proto.LogicalLayer logical_layer = 3;
  bool has_logical_layer() const;
  void clear_logical_layer();
  static const int kLogicalLayerFieldNumber = 3;
  const ::ndm_proto::LogicalLayer& logical_layer() const;
  ::ndm_proto::LogicalLayer* release_logical_layer();
  ::ndm_proto::LogicalLayer* mutable_logical_layer();
  void set_allocated_logical_layer(::ndm_proto::LogicalLayer* logical_layer);

  // optional .ndm_proto.TopologicalLayer topological_layer = 4;
  bool has_topological_layer() const;
  void clear_topological_layer();
  static const int kTopologicalLayerFieldNumber = 4;
  const ::ndm_proto::TopologicalLayer& topological_layer() const;
  ::ndm_proto::TopologicalLayer* release_topological_layer();
  ::ndm_proto::TopologicalLayer* mutable_topological_layer();
  void set_allocated_topological_layer(::ndm_proto::TopologicalLayer* topological_layer);

  // optional .ndm_proto.DynamicLayer dynamic_layer = 5;
  bool has_dynamic_layer() const;
  void clear_dynamic_layer();
  static const int kDynamicLayerFieldNumber = 5;
  const ::ndm_proto::DynamicLayer& dynamic_layer() const;
  ::ndm_proto::DynamicLayer* release_dynamic_layer();
  ::ndm_proto::DynamicLayer* mutable_dynamic_layer();
  void set_allocated_dynamic_layer(::ndm_proto::DynamicLayer* dynamic_layer);

  // optional .ndm_proto.EgoLayer ego_layer = 6;
  bool has_ego_layer() const;
  void clear_ego_layer();
  static const int kEgoLayerFieldNumber = 6;
  const ::ndm_proto::EgoLayer& ego_layer() const;
  ::ndm_proto::EgoLayer* release_ego_layer();
  ::ndm_proto::EgoLayer* mutable_ego_layer();
  void set_allocated_ego_layer(::ndm_proto::EgoLayer* ego_layer);

  // @@protoc_insertion_point(class_scope:ndm_proto.MapEnvMsg)
 private:
  void set_has_header();
  void clear_has_header();
  void set_has_physical_layer();
  void clear_has_physical_layer();
  void set_has_logical_layer();
  void clear_has_logical_layer();
  void set_has_topological_layer();
  void clear_has_topological_layer();
  void set_has_dynamic_layer();
  void clear_has_dynamic_layer();
  void set_has_ego_layer();
  void clear_has_ego_layer();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::ndm_proto::NDMHeader* header_;
  ::ndm_proto::PhysicalLayer* physical_layer_;
  ::ndm_proto::LogicalLayer* logical_layer_;
  ::ndm_proto::TopologicalLayer* topological_layer_;
  ::ndm_proto::DynamicLayer* dynamic_layer_;
  ::ndm_proto::EgoLayer* ego_layer_;
  friend struct ::protobuf_ndm_2eproto::TableStruct;
  friend void ::protobuf_ndm_2eproto::InitDefaultsMapEnvMsgImpl();
};
// -------------------------------------------------------------------

class NDMMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.NDMMessage) */ {
 public:
  NDMMessage();
  virtual ~NDMMessage();

  NDMMessage(const NDMMessage& from);

  inline NDMMessage& operator=(const NDMMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NDMMessage(NDMMessage&& from) noexcept
    : NDMMessage() {
    *this = ::std::move(from);
  }

  inline NDMMessage& operator=(NDMMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NDMMessage& default_instance();

  enum MessageCase {
    kMapenvMsg = 3,
    kLocationMsg = 4,
    kNavigationMsg = 5,
    kLogMsg = 6,
    kDebugMsg = 7,
    MESSAGE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NDMMessage* internal_default_instance() {
    return reinterpret_cast<const NDMMessage*>(
               &_NDMMessage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(NDMMessage* other);
  friend void swap(NDMMessage& a, NDMMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NDMMessage* New() const PROTOBUF_FINAL { return New(NULL); }

  NDMMessage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NDMMessage& from);
  void MergeFrom(const NDMMessage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NDMMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 cyclic_counter = 1;
  bool has_cyclic_counter() const;
  void clear_cyclic_counter();
  static const int kCyclicCounterFieldNumber = 1;
  ::google::protobuf::uint32 cyclic_counter() const;
  void set_cyclic_counter(::google::protobuf::uint32 value);

  // required uint32 msg_type = 2;
  bool has_msg_type() const;
  void clear_msg_type();
  static const int kMsgTypeFieldNumber = 2;
  ::google::protobuf::uint32 msg_type() const;
  void set_msg_type(::google::protobuf::uint32 value);

  // optional .ndm_proto.MapEnvMsg mapenv_msg = 3;
  bool has_mapenv_msg() const;
  void clear_mapenv_msg();
  static const int kMapenvMsgFieldNumber = 3;
  const ::ndm_proto::MapEnvMsg& mapenv_msg() const;
  ::ndm_proto::MapEnvMsg* release_mapenv_msg();
  ::ndm_proto::MapEnvMsg* mutable_mapenv_msg();
  void set_allocated_mapenv_msg(::ndm_proto::MapEnvMsg* mapenv_msg);

  // optional .ndm_proto.LocationMsg location_msg = 4;
  bool has_location_msg() const;
  void clear_location_msg();
  static const int kLocationMsgFieldNumber = 4;
  const ::ndm_proto::LocationMsg& location_msg() const;
  ::ndm_proto::LocationMsg* release_location_msg();
  ::ndm_proto::LocationMsg* mutable_location_msg();
  void set_allocated_location_msg(::ndm_proto::LocationMsg* location_msg);

  // optional .ndm_proto.NavigationMsg navigation_msg = 5;
  bool has_navigation_msg() const;
  void clear_navigation_msg();
  static const int kNavigationMsgFieldNumber = 5;
  const ::ndm_proto::NavigationMsg& navigation_msg() const;
  ::ndm_proto::NavigationMsg* release_navigation_msg();
  ::ndm_proto::NavigationMsg* mutable_navigation_msg();
  void set_allocated_navigation_msg(::ndm_proto::NavigationMsg* navigation_msg);

  // optional .ndm_proto.LogMsg log_msg = 6;
  bool has_log_msg() const;
  void clear_log_msg();
  static const int kLogMsgFieldNumber = 6;
  const ::ndm_proto::LogMsg& log_msg() const;
  ::ndm_proto::LogMsg* release_log_msg();
  ::ndm_proto::LogMsg* mutable_log_msg();
  void set_allocated_log_msg(::ndm_proto::LogMsg* log_msg);

  // optional .ndm_proto.DebugMsg debug_msg = 7;
  bool has_debug_msg() const;
  void clear_debug_msg();
  static const int kDebugMsgFieldNumber = 7;
  const ::ndm_proto::DebugMsg& debug_msg() const;
  ::ndm_proto::DebugMsg* release_debug_msg();
  ::ndm_proto::DebugMsg* mutable_debug_msg();
  void set_allocated_debug_msg(::ndm_proto::DebugMsg* debug_msg);

  MessageCase message_case() const;
  // @@protoc_insertion_point(class_scope:ndm_proto.NDMMessage)
 private:
  void set_has_cyclic_counter();
  void clear_has_cyclic_counter();
  void set_has_msg_type();
  void clear_has_msg_type();
  void set_has_mapenv_msg();
  void set_has_location_msg();
  void set_has_navigation_msg();
  void set_has_log_msg();
  void set_has_debug_msg();

  inline bool has_message() const;
  void clear_message();
  inline void clear_has_message();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 cyclic_counter_;
  ::google::protobuf::uint32 msg_type_;
  union MessageUnion {
    MessageUnion() {}
    ::ndm_proto::MapEnvMsg* mapenv_msg_;
    ::ndm_proto::LocationMsg* location_msg_;
    ::ndm_proto::NavigationMsg* navigation_msg_;
    ::ndm_proto::LogMsg* log_msg_;
    ::ndm_proto::DebugMsg* debug_msg_;
  } message_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_ndm_2eproto::TableStruct;
  friend void ::protobuf_ndm_2eproto::InitDefaultsNDMMessageImpl();
};
// -------------------------------------------------------------------

class DataPack : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.DataPack) */ {
 public:
  DataPack();
  virtual ~DataPack();

  DataPack(const DataPack& from);

  inline DataPack& operator=(const DataPack& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DataPack(DataPack&& from) noexcept
    : DataPack() {
    *this = ::std::move(from);
  }

  inline DataPack& operator=(DataPack&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DataPack& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DataPack* internal_default_instance() {
    return reinterpret_cast<const DataPack*>(
               &_DataPack_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(DataPack* other);
  friend void swap(DataPack& a, DataPack& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DataPack* New() const PROTOBUF_FINAL { return New(NULL); }

  DataPack* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DataPack& from);
  void MergeFrom(const DataPack& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DataPack* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ndm_proto.DataHolder data_holders = 1;
  int data_holders_size() const;
  void clear_data_holders();
  static const int kDataHoldersFieldNumber = 1;
  const ::ndm_proto::DataHolder& data_holders(int index) const;
  ::ndm_proto::DataHolder* mutable_data_holders(int index);
  ::ndm_proto::DataHolder* add_data_holders();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::DataHolder >*
      mutable_data_holders();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::DataHolder >&
      data_holders() const;

  // @@protoc_insertion_point(class_scope:ndm_proto.DataPack)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::DataHolder > data_holders_;
  friend struct ::protobuf_ndm_2eproto::TableStruct;
  friend void ::protobuf_ndm_2eproto::InitDefaultsDataPackImpl();
};
// -------------------------------------------------------------------

class DataHolder : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.DataHolder) */ {
 public:
  DataHolder();
  virtual ~DataHolder();

  DataHolder(const DataHolder& from);

  inline DataHolder& operator=(const DataHolder& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DataHolder(DataHolder&& from) noexcept
    : DataHolder() {
    *this = ::std::move(from);
  }

  inline DataHolder& operator=(DataHolder&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DataHolder& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DataHolder* internal_default_instance() {
    return reinterpret_cast<const DataHolder*>(
               &_DataHolder_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(DataHolder* other);
  friend void swap(DataHolder& a, DataHolder& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DataHolder* New() const PROTOBUF_FINAL { return New(NULL); }

  DataHolder* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DataHolder& from);
  void MergeFrom(const DataHolder& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DataHolder* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 3;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required bytes data_bts = 5;
  bool has_data_bts() const;
  void clear_data_bts();
  static const int kDataBtsFieldNumber = 5;
  const ::std::string& data_bts() const;
  void set_data_bts(const ::std::string& value);
  #if LANG_CXX11
  void set_data_bts(::std::string&& value);
  #endif
  void set_data_bts(const char* value);
  void set_data_bts(const void* value, size_t size);
  ::std::string* mutable_data_bts();
  ::std::string* release_data_bts();
  void set_allocated_data_bts(::std::string* data_bts);

  // required uint64 timestamp = 1;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  ::google::protobuf::uint64 timestamp() const;
  void set_timestamp(::google::protobuf::uint64 value);

  // required uint32 type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::google::protobuf::uint32 type() const;
  void set_type(::google::protobuf::uint32 value);

  // required uint32 data_len = 4;
  bool has_data_len() const;
  void clear_data_len();
  static const int kDataLenFieldNumber = 4;
  ::google::protobuf::uint32 data_len() const;
  void set_data_len(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ndm_proto.DataHolder)
 private:
  void set_has_timestamp();
  void clear_has_timestamp();
  void set_has_type();
  void clear_has_type();
  void set_has_name();
  void clear_has_name();
  void set_has_data_len();
  void clear_has_data_len();
  void set_has_data_bts();
  void clear_has_data_bts();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr data_bts_;
  ::google::protobuf::uint64 timestamp_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 data_len_;
  friend struct ::protobuf_ndm_2eproto::TableStruct;
  friend void ::protobuf_ndm_2eproto::InitDefaultsDataHolderImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// NDMHeader

// required string version = 1;
inline bool NDMHeader::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NDMHeader::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NDMHeader::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NDMHeader::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_version();
}
inline const ::std::string& NDMHeader::version() const {
  // @@protoc_insertion_point(field_get:ndm_proto.NDMHeader.version)
  return version_.GetNoArena();
}
inline void NDMHeader::set_version(const ::std::string& value) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ndm_proto.NDMHeader.version)
}
#if LANG_CXX11
inline void NDMHeader::set_version(::std::string&& value) {
  set_has_version();
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ndm_proto.NDMHeader.version)
}
#endif
inline void NDMHeader::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ndm_proto.NDMHeader.version)
}
inline void NDMHeader::set_version(const char* value, size_t size) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.NDMHeader.version)
}
inline ::std::string* NDMHeader::mutable_version() {
  set_has_version();
  // @@protoc_insertion_point(field_mutable:ndm_proto.NDMHeader.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NDMHeader::release_version() {
  // @@protoc_insertion_point(field_release:ndm_proto.NDMHeader.version)
  clear_has_version();
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NDMHeader::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    set_has_version();
  } else {
    clear_has_version();
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.NDMHeader.version)
}

// required string date = 2;
inline bool NDMHeader::has_date() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NDMHeader::set_has_date() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NDMHeader::clear_has_date() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NDMHeader::clear_date() {
  date_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_date();
}
inline const ::std::string& NDMHeader::date() const {
  // @@protoc_insertion_point(field_get:ndm_proto.NDMHeader.date)
  return date_.GetNoArena();
}
inline void NDMHeader::set_date(const ::std::string& value) {
  set_has_date();
  date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ndm_proto.NDMHeader.date)
}
#if LANG_CXX11
inline void NDMHeader::set_date(::std::string&& value) {
  set_has_date();
  date_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ndm_proto.NDMHeader.date)
}
#endif
inline void NDMHeader::set_date(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_date();
  date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ndm_proto.NDMHeader.date)
}
inline void NDMHeader::set_date(const char* value, size_t size) {
  set_has_date();
  date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.NDMHeader.date)
}
inline ::std::string* NDMHeader::mutable_date() {
  set_has_date();
  // @@protoc_insertion_point(field_mutable:ndm_proto.NDMHeader.date)
  return date_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NDMHeader::release_date() {
  // @@protoc_insertion_point(field_release:ndm_proto.NDMHeader.date)
  clear_has_date();
  return date_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NDMHeader::set_allocated_date(::std::string* date) {
  if (date != NULL) {
    set_has_date();
  } else {
    clear_has_date();
  }
  date_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), date);
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.NDMHeader.date)
}

// required uint64 stamp = 3;
inline bool NDMHeader::has_stamp() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void NDMHeader::set_has_stamp() {
  _has_bits_[0] |= 0x00000040u;
}
inline void NDMHeader::clear_has_stamp() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void NDMHeader::clear_stamp() {
  stamp_ = GOOGLE_ULONGLONG(0);
  clear_has_stamp();
}
inline ::google::protobuf::uint64 NDMHeader::stamp() const {
  // @@protoc_insertion_point(field_get:ndm_proto.NDMHeader.stamp)
  return stamp_;
}
inline void NDMHeader::set_stamp(::google::protobuf::uint64 value) {
  set_has_stamp();
  stamp_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.NDMHeader.stamp)
}

// optional uint64 seq_id = 4;
inline bool NDMHeader::has_seq_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void NDMHeader::set_has_seq_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void NDMHeader::clear_has_seq_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void NDMHeader::clear_seq_id() {
  seq_id_ = GOOGLE_ULONGLONG(0);
  clear_has_seq_id();
}
inline ::google::protobuf::uint64 NDMHeader::seq_id() const {
  // @@protoc_insertion_point(field_get:ndm_proto.NDMHeader.seq_id)
  return seq_id_;
}
inline void NDMHeader::set_seq_id(::google::protobuf::uint64 value) {
  set_has_seq_id();
  seq_id_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.NDMHeader.seq_id)
}

// required string projection = 6;
inline bool NDMHeader::has_projection() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NDMHeader::set_has_projection() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NDMHeader::clear_has_projection() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NDMHeader::clear_projection() {
  projection_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_projection();
}
inline const ::std::string& NDMHeader::projection() const {
  // @@protoc_insertion_point(field_get:ndm_proto.NDMHeader.projection)
  return projection_.GetNoArena();
}
inline void NDMHeader::set_projection(const ::std::string& value) {
  set_has_projection();
  projection_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ndm_proto.NDMHeader.projection)
}
#if LANG_CXX11
inline void NDMHeader::set_projection(::std::string&& value) {
  set_has_projection();
  projection_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ndm_proto.NDMHeader.projection)
}
#endif
inline void NDMHeader::set_projection(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_projection();
  projection_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ndm_proto.NDMHeader.projection)
}
inline void NDMHeader::set_projection(const char* value, size_t size) {
  set_has_projection();
  projection_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.NDMHeader.projection)
}
inline ::std::string* NDMHeader::mutable_projection() {
  set_has_projection();
  // @@protoc_insertion_point(field_mutable:ndm_proto.NDMHeader.projection)
  return projection_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NDMHeader::release_projection() {
  // @@protoc_insertion_point(field_release:ndm_proto.NDMHeader.projection)
  clear_has_projection();
  return projection_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NDMHeader::set_allocated_projection(::std::string* projection) {
  if (projection != NULL) {
    set_has_projection();
  } else {
    clear_has_projection();
  }
  projection_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), projection);
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.NDMHeader.projection)
}

// optional string utm_zone = 7;
inline bool NDMHeader::has_utm_zone() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NDMHeader::set_has_utm_zone() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NDMHeader::clear_has_utm_zone() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NDMHeader::clear_utm_zone() {
  utm_zone_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_utm_zone();
}
inline const ::std::string& NDMHeader::utm_zone() const {
  // @@protoc_insertion_point(field_get:ndm_proto.NDMHeader.utm_zone)
  return utm_zone_.GetNoArena();
}
inline void NDMHeader::set_utm_zone(const ::std::string& value) {
  set_has_utm_zone();
  utm_zone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ndm_proto.NDMHeader.utm_zone)
}
#if LANG_CXX11
inline void NDMHeader::set_utm_zone(::std::string&& value) {
  set_has_utm_zone();
  utm_zone_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ndm_proto.NDMHeader.utm_zone)
}
#endif
inline void NDMHeader::set_utm_zone(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_utm_zone();
  utm_zone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ndm_proto.NDMHeader.utm_zone)
}
inline void NDMHeader::set_utm_zone(const char* value, size_t size) {
  set_has_utm_zone();
  utm_zone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.NDMHeader.utm_zone)
}
inline ::std::string* NDMHeader::mutable_utm_zone() {
  set_has_utm_zone();
  // @@protoc_insertion_point(field_mutable:ndm_proto.NDMHeader.utm_zone)
  return utm_zone_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NDMHeader::release_utm_zone() {
  // @@protoc_insertion_point(field_release:ndm_proto.NDMHeader.utm_zone)
  clear_has_utm_zone();
  return utm_zone_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NDMHeader::set_allocated_utm_zone(::std::string* utm_zone) {
  if (utm_zone != NULL) {
    set_has_utm_zone();
  } else {
    clear_has_utm_zone();
  }
  utm_zone_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), utm_zone);
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.NDMHeader.utm_zone)
}

// optional .ndm_proto.Point base_offset = 8;
inline bool NDMHeader::has_base_offset() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NDMHeader::set_has_base_offset() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NDMHeader::clear_has_base_offset() {
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::ndm_proto::Point& NDMHeader::base_offset() const {
  const ::ndm_proto::Point* p = base_offset_;
  // @@protoc_insertion_point(field_get:ndm_proto.NDMHeader.base_offset)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Point*>(
      &::ndm_proto::_Point_default_instance_);
}
inline ::ndm_proto::Point* NDMHeader::release_base_offset() {
  // @@protoc_insertion_point(field_release:ndm_proto.NDMHeader.base_offset)
  clear_has_base_offset();
  ::ndm_proto::Point* temp = base_offset_;
  base_offset_ = NULL;
  return temp;
}
inline ::ndm_proto::Point* NDMHeader::mutable_base_offset() {
  set_has_base_offset();
  if (base_offset_ == NULL) {
    base_offset_ = new ::ndm_proto::Point;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.NDMHeader.base_offset)
  return base_offset_;
}
inline void NDMHeader::set_allocated_base_offset(::ndm_proto::Point* base_offset) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(base_offset_);
  }
  if (base_offset) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      base_offset = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, base_offset, submessage_arena);
    }
    set_has_base_offset();
  } else {
    clear_has_base_offset();
  }
  base_offset_ = base_offset;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.NDMHeader.base_offset)
}

// optional .ndm_proto.GlobalData global_data = 9;
inline bool NDMHeader::has_global_data() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NDMHeader::set_has_global_data() {
  _has_bits_[0] |= 0x00000020u;
}
inline void NDMHeader::clear_has_global_data() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void NDMHeader::clear_global_data() {
  if (global_data_ != NULL) global_data_->Clear();
  clear_has_global_data();
}
inline const ::ndm_proto::GlobalData& NDMHeader::global_data() const {
  const ::ndm_proto::GlobalData* p = global_data_;
  // @@protoc_insertion_point(field_get:ndm_proto.NDMHeader.global_data)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::GlobalData*>(
      &::ndm_proto::_GlobalData_default_instance_);
}
inline ::ndm_proto::GlobalData* NDMHeader::release_global_data() {
  // @@protoc_insertion_point(field_release:ndm_proto.NDMHeader.global_data)
  clear_has_global_data();
  ::ndm_proto::GlobalData* temp = global_data_;
  global_data_ = NULL;
  return temp;
}
inline ::ndm_proto::GlobalData* NDMHeader::mutable_global_data() {
  set_has_global_data();
  if (global_data_ == NULL) {
    global_data_ = new ::ndm_proto::GlobalData;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.NDMHeader.global_data)
  return global_data_;
}
inline void NDMHeader::set_allocated_global_data(::ndm_proto::GlobalData* global_data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete global_data_;
  }
  if (global_data) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      global_data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, global_data, submessage_arena);
    }
    set_has_global_data();
  } else {
    clear_has_global_data();
  }
  global_data_ = global_data;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.NDMHeader.global_data)
}

// -------------------------------------------------------------------

// GlobalData

// optional uint32 country_code = 1;
inline bool GlobalData::has_country_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GlobalData::set_has_country_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GlobalData::clear_has_country_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GlobalData::clear_country_code() {
  country_code_ = 0u;
  clear_has_country_code();
}
inline ::google::protobuf::uint32 GlobalData::country_code() const {
  // @@protoc_insertion_point(field_get:ndm_proto.GlobalData.country_code)
  return country_code_;
}
inline void GlobalData::set_country_code(::google::protobuf::uint32 value) {
  set_has_country_code();
  country_code_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.GlobalData.country_code)
}

// optional uint32 region_code = 2;
inline bool GlobalData::has_region_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GlobalData::set_has_region_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GlobalData::clear_has_region_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GlobalData::clear_region_code() {
  region_code_ = 0u;
  clear_has_region_code();
}
inline ::google::protobuf::uint32 GlobalData::region_code() const {
  // @@protoc_insertion_point(field_get:ndm_proto.GlobalData.region_code)
  return region_code_;
}
inline void GlobalData::set_region_code(::google::protobuf::uint32 value) {
  set_has_region_code();
  region_code_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.GlobalData.region_code)
}

// optional .ndm_proto.DrivingSide driving_side = 3;
inline bool GlobalData::has_driving_side() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GlobalData::set_has_driving_side() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GlobalData::clear_has_driving_side() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GlobalData::clear_driving_side() {
  driving_side_ = 0;
  clear_has_driving_side();
}
inline ::ndm_proto::DrivingSide GlobalData::driving_side() const {
  // @@protoc_insertion_point(field_get:ndm_proto.GlobalData.driving_side)
  return static_cast< ::ndm_proto::DrivingSide >(driving_side_);
}
inline void GlobalData::set_driving_side(::ndm_proto::DrivingSide value) {
  assert(::ndm_proto::DrivingSide_IsValid(value));
  set_has_driving_side();
  driving_side_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.GlobalData.driving_side)
}

// optional .ndm_proto.UnitOfSystem unit = 4;
inline bool GlobalData::has_unit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GlobalData::set_has_unit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GlobalData::clear_has_unit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GlobalData::clear_unit() {
  unit_ = 0;
  clear_has_unit();
}
inline ::ndm_proto::UnitOfSystem GlobalData::unit() const {
  // @@protoc_insertion_point(field_get:ndm_proto.GlobalData.unit)
  return static_cast< ::ndm_proto::UnitOfSystem >(unit_);
}
inline void GlobalData::set_unit(::ndm_proto::UnitOfSystem value) {
  assert(::ndm_proto::UnitOfSystem_IsValid(value));
  set_has_unit();
  unit_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.GlobalData.unit)
}

// optional uint32 protocol_version = 5;
inline bool GlobalData::has_protocol_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GlobalData::set_has_protocol_version() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GlobalData::clear_has_protocol_version() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GlobalData::clear_protocol_version() {
  protocol_version_ = 0u;
  clear_has_protocol_version();
}
inline ::google::protobuf::uint32 GlobalData::protocol_version() const {
  // @@protoc_insertion_point(field_get:ndm_proto.GlobalData.protocol_version)
  return protocol_version_;
}
inline void GlobalData::set_protocol_version(::google::protobuf::uint32 value) {
  set_has_protocol_version();
  protocol_version_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.GlobalData.protocol_version)
}

// optional uint32 hardware_version = 6;
inline bool GlobalData::has_hardware_version() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GlobalData::set_has_hardware_version() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GlobalData::clear_has_hardware_version() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GlobalData::clear_hardware_version() {
  hardware_version_ = 0u;
  clear_has_hardware_version();
}
inline ::google::protobuf::uint32 GlobalData::hardware_version() const {
  // @@protoc_insertion_point(field_get:ndm_proto.GlobalData.hardware_version)
  return hardware_version_;
}
inline void GlobalData::set_hardware_version(::google::protobuf::uint32 value) {
  set_has_hardware_version();
  hardware_version_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.GlobalData.hardware_version)
}

// optional uint32 map_version = 7;
inline bool GlobalData::has_map_version() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GlobalData::set_has_map_version() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GlobalData::clear_has_map_version() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GlobalData::clear_map_version() {
  map_version_ = 0u;
  clear_has_map_version();
}
inline ::google::protobuf::uint32 GlobalData::map_version() const {
  // @@protoc_insertion_point(field_get:ndm_proto.GlobalData.map_version)
  return map_version_;
}
inline void GlobalData::set_map_version(::google::protobuf::uint32 value) {
  set_has_map_version();
  map_version_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.GlobalData.map_version)
}

// optional uint32 map_age = 8;
inline bool GlobalData::has_map_age() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GlobalData::set_has_map_age() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GlobalData::clear_has_map_age() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GlobalData::clear_map_age() {
  map_age_ = 0u;
  clear_has_map_age();
}
inline ::google::protobuf::uint32 GlobalData::map_age() const {
  // @@protoc_insertion_point(field_get:ndm_proto.GlobalData.map_age)
  return map_age_;
}
inline void GlobalData::set_map_age(::google::protobuf::uint32 value) {
  set_has_map_age();
  map_age_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.GlobalData.map_age)
}

// optional .ndm_proto.MapProvider map_provider = 9;
inline bool GlobalData::has_map_provider() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GlobalData::set_has_map_provider() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GlobalData::clear_has_map_provider() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GlobalData::clear_map_provider() {
  map_provider_ = 0;
  clear_has_map_provider();
}
inline ::ndm_proto::MapProvider GlobalData::map_provider() const {
  // @@protoc_insertion_point(field_get:ndm_proto.GlobalData.map_provider)
  return static_cast< ::ndm_proto::MapProvider >(map_provider_);
}
inline void GlobalData::set_map_provider(::ndm_proto::MapProvider value) {
  assert(::ndm_proto::MapProvider_IsValid(value));
  set_has_map_provider();
  map_provider_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.GlobalData.map_provider)
}

// optional .ndm_proto.MapStatus map_status = 10;
inline bool GlobalData::has_map_status() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GlobalData::set_has_map_status() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GlobalData::clear_has_map_status() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GlobalData::clear_map_status() {
  map_status_ = 0;
  clear_has_map_status();
}
inline ::ndm_proto::MapStatus GlobalData::map_status() const {
  // @@protoc_insertion_point(field_get:ndm_proto.GlobalData.map_status)
  return static_cast< ::ndm_proto::MapStatus >(map_status_);
}
inline void GlobalData::set_map_status(::ndm_proto::MapStatus value) {
  assert(::ndm_proto::MapStatus_IsValid(value));
  set_has_map_status();
  map_status_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.GlobalData.map_status)
}

// optional int32 time_zone_offset = 11;
inline bool GlobalData::has_time_zone_offset() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GlobalData::set_has_time_zone_offset() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GlobalData::clear_has_time_zone_offset() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GlobalData::clear_time_zone_offset() {
  time_zone_offset_ = 0;
  clear_has_time_zone_offset();
}
inline ::google::protobuf::int32 GlobalData::time_zone_offset() const {
  // @@protoc_insertion_point(field_get:ndm_proto.GlobalData.time_zone_offset)
  return time_zone_offset_;
}
inline void GlobalData::set_time_zone_offset(::google::protobuf::int32 value) {
  set_has_time_zone_offset();
  time_zone_offset_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.GlobalData.time_zone_offset)
}

// optional uint32 mapping_version = 12;
inline bool GlobalData::has_mapping_version() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void GlobalData::set_has_mapping_version() {
  _has_bits_[0] |= 0x00000800u;
}
inline void GlobalData::clear_has_mapping_version() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void GlobalData::clear_mapping_version() {
  mapping_version_ = 0u;
  clear_has_mapping_version();
}
inline ::google::protobuf::uint32 GlobalData::mapping_version() const {
  // @@protoc_insertion_point(field_get:ndm_proto.GlobalData.mapping_version)
  return mapping_version_;
}
inline void GlobalData::set_mapping_version(::google::protobuf::uint32 value) {
  set_has_mapping_version();
  mapping_version_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.GlobalData.mapping_version)
}

// optional uint32 aggregation_version = 13;
inline bool GlobalData::has_aggregation_version() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void GlobalData::set_has_aggregation_version() {
  _has_bits_[0] |= 0x00001000u;
}
inline void GlobalData::clear_has_aggregation_version() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void GlobalData::clear_aggregation_version() {
  aggregation_version_ = 0u;
  clear_has_aggregation_version();
}
inline ::google::protobuf::uint32 GlobalData::aggregation_version() const {
  // @@protoc_insertion_point(field_get:ndm_proto.GlobalData.aggregation_version)
  return aggregation_version_;
}
inline void GlobalData::set_aggregation_version(::google::protobuf::uint32 value) {
  set_has_aggregation_version();
  aggregation_version_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.GlobalData.aggregation_version)
}

// optional uint32 ota_status = 14;
inline bool GlobalData::has_ota_status() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void GlobalData::set_has_ota_status() {
  _has_bits_[0] |= 0x00002000u;
}
inline void GlobalData::clear_has_ota_status() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void GlobalData::clear_ota_status() {
  ota_status_ = 0u;
  clear_has_ota_status();
}
inline ::google::protobuf::uint32 GlobalData::ota_status() const {
  // @@protoc_insertion_point(field_get:ndm_proto.GlobalData.ota_status)
  return ota_status_;
}
inline void GlobalData::set_ota_status(::google::protobuf::uint32 value) {
  set_has_ota_status();
  ota_status_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.GlobalData.ota_status)
}

// -------------------------------------------------------------------

// LocationMsg

// required .ndm_proto.NDMHeader header = 1;
inline bool LocationMsg::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LocationMsg::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LocationMsg::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LocationMsg::clear_header() {
  if (header_ != NULL) header_->Clear();
  clear_has_header();
}
inline const ::ndm_proto::NDMHeader& LocationMsg::header() const {
  const ::ndm_proto::NDMHeader* p = header_;
  // @@protoc_insertion_point(field_get:ndm_proto.LocationMsg.header)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::NDMHeader*>(
      &::ndm_proto::_NDMHeader_default_instance_);
}
inline ::ndm_proto::NDMHeader* LocationMsg::release_header() {
  // @@protoc_insertion_point(field_release:ndm_proto.LocationMsg.header)
  clear_has_header();
  ::ndm_proto::NDMHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::ndm_proto::NDMHeader* LocationMsg::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::ndm_proto::NDMHeader;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.LocationMsg.header)
  return header_;
}
inline void LocationMsg::set_allocated_header(::ndm_proto::NDMHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    set_has_header();
  } else {
    clear_has_header();
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.LocationMsg.header)
}

// required .ndm_proto.Location location = 2;
inline bool LocationMsg::has_location() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LocationMsg::set_has_location() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LocationMsg::clear_has_location() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ndm_proto::Location& LocationMsg::location() const {
  const ::ndm_proto::Location* p = location_;
  // @@protoc_insertion_point(field_get:ndm_proto.LocationMsg.location)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Location*>(
      &::ndm_proto::_Location_default_instance_);
}
inline ::ndm_proto::Location* LocationMsg::release_location() {
  // @@protoc_insertion_point(field_release:ndm_proto.LocationMsg.location)
  clear_has_location();
  ::ndm_proto::Location* temp = location_;
  location_ = NULL;
  return temp;
}
inline ::ndm_proto::Location* LocationMsg::mutable_location() {
  set_has_location();
  if (location_ == NULL) {
    location_ = new ::ndm_proto::Location;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.LocationMsg.location)
  return location_;
}
inline void LocationMsg::set_allocated_location(::ndm_proto::Location* location) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(location_);
  }
  if (location) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      location = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    set_has_location();
  } else {
    clear_has_location();
  }
  location_ = location;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.LocationMsg.location)
}

// repeated .ndm_proto.Odometry relative_odom = 3;
inline int LocationMsg::relative_odom_size() const {
  return relative_odom_.size();
}
inline const ::ndm_proto::Odometry& LocationMsg::relative_odom(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.LocationMsg.relative_odom)
  return relative_odom_.Get(index);
}
inline ::ndm_proto::Odometry* LocationMsg::mutable_relative_odom(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.LocationMsg.relative_odom)
  return relative_odom_.Mutable(index);
}
inline ::ndm_proto::Odometry* LocationMsg::add_relative_odom() {
  // @@protoc_insertion_point(field_add:ndm_proto.LocationMsg.relative_odom)
  return relative_odom_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::Odometry >*
LocationMsg::mutable_relative_odom() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.LocationMsg.relative_odom)
  return &relative_odom_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::Odometry >&
LocationMsg::relative_odom() const {
  // @@protoc_insertion_point(field_list:ndm_proto.LocationMsg.relative_odom)
  return relative_odom_;
}

// repeated .ndm_proto.RelativePosition relative_position = 4;
inline int LocationMsg::relative_position_size() const {
  return relative_position_.size();
}
inline const ::ndm_proto::RelativePosition& LocationMsg::relative_position(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.LocationMsg.relative_position)
  return relative_position_.Get(index);
}
inline ::ndm_proto::RelativePosition* LocationMsg::mutable_relative_position(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.LocationMsg.relative_position)
  return relative_position_.Mutable(index);
}
inline ::ndm_proto::RelativePosition* LocationMsg::add_relative_position() {
  // @@protoc_insertion_point(field_add:ndm_proto.LocationMsg.relative_position)
  return relative_position_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::RelativePosition >*
LocationMsg::mutable_relative_position() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.LocationMsg.relative_position)
  return &relative_position_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::RelativePosition >&
LocationMsg::relative_position() const {
  // @@protoc_insertion_point(field_list:ndm_proto.LocationMsg.relative_position)
  return relative_position_;
}

// -------------------------------------------------------------------

// NavigationMsg

// required .ndm_proto.NDMHeader header = 1;
inline bool NavigationMsg::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NavigationMsg::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NavigationMsg::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NavigationMsg::clear_header() {
  if (header_ != NULL) header_->Clear();
  clear_has_header();
}
inline const ::ndm_proto::NDMHeader& NavigationMsg::header() const {
  const ::ndm_proto::NDMHeader* p = header_;
  // @@protoc_insertion_point(field_get:ndm_proto.NavigationMsg.header)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::NDMHeader*>(
      &::ndm_proto::_NDMHeader_default_instance_);
}
inline ::ndm_proto::NDMHeader* NavigationMsg::release_header() {
  // @@protoc_insertion_point(field_release:ndm_proto.NavigationMsg.header)
  clear_has_header();
  ::ndm_proto::NDMHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::ndm_proto::NDMHeader* NavigationMsg::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::ndm_proto::NDMHeader;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.NavigationMsg.header)
  return header_;
}
inline void NavigationMsg::set_allocated_header(::ndm_proto::NDMHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    set_has_header();
  } else {
    clear_has_header();
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.NavigationMsg.header)
}

// required .ndm_proto.Navigation navigation = 2;
inline bool NavigationMsg::has_navigation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NavigationMsg::set_has_navigation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NavigationMsg::clear_has_navigation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ndm_proto::Navigation& NavigationMsg::navigation() const {
  const ::ndm_proto::Navigation* p = navigation_;
  // @@protoc_insertion_point(field_get:ndm_proto.NavigationMsg.navigation)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Navigation*>(
      &::ndm_proto::_Navigation_default_instance_);
}
inline ::ndm_proto::Navigation* NavigationMsg::release_navigation() {
  // @@protoc_insertion_point(field_release:ndm_proto.NavigationMsg.navigation)
  clear_has_navigation();
  ::ndm_proto::Navigation* temp = navigation_;
  navigation_ = NULL;
  return temp;
}
inline ::ndm_proto::Navigation* NavigationMsg::mutable_navigation() {
  set_has_navigation();
  if (navigation_ == NULL) {
    navigation_ = new ::ndm_proto::Navigation;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.NavigationMsg.navigation)
  return navigation_;
}
inline void NavigationMsg::set_allocated_navigation(::ndm_proto::Navigation* navigation) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(navigation_);
  }
  if (navigation) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      navigation = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, navigation, submessage_arena);
    }
    set_has_navigation();
  } else {
    clear_has_navigation();
  }
  navigation_ = navigation;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.NavigationMsg.navigation)
}

// -------------------------------------------------------------------

// LogMsg

// required .ndm_proto.NDMHeader header = 1;
inline bool LogMsg::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogMsg::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogMsg::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogMsg::clear_header() {
  if (header_ != NULL) header_->Clear();
  clear_has_header();
}
inline const ::ndm_proto::NDMHeader& LogMsg::header() const {
  const ::ndm_proto::NDMHeader* p = header_;
  // @@protoc_insertion_point(field_get:ndm_proto.LogMsg.header)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::NDMHeader*>(
      &::ndm_proto::_NDMHeader_default_instance_);
}
inline ::ndm_proto::NDMHeader* LogMsg::release_header() {
  // @@protoc_insertion_point(field_release:ndm_proto.LogMsg.header)
  clear_has_header();
  ::ndm_proto::NDMHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::ndm_proto::NDMHeader* LogMsg::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::ndm_proto::NDMHeader;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.LogMsg.header)
  return header_;
}
inline void LogMsg::set_allocated_header(::ndm_proto::NDMHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    set_has_header();
  } else {
    clear_has_header();
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.LogMsg.header)
}

// repeated string log = 2;
inline int LogMsg::log_size() const {
  return log_.size();
}
inline void LogMsg::clear_log() {
  log_.Clear();
}
inline const ::std::string& LogMsg::log(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.LogMsg.log)
  return log_.Get(index);
}
inline ::std::string* LogMsg::mutable_log(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.LogMsg.log)
  return log_.Mutable(index);
}
inline void LogMsg::set_log(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ndm_proto.LogMsg.log)
  log_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void LogMsg::set_log(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:ndm_proto.LogMsg.log)
  log_.Mutable(index)->assign(std::move(value));
}
#endif
inline void LogMsg::set_log(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  log_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ndm_proto.LogMsg.log)
}
inline void LogMsg::set_log(int index, const char* value, size_t size) {
  log_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.LogMsg.log)
}
inline ::std::string* LogMsg::add_log() {
  // @@protoc_insertion_point(field_add_mutable:ndm_proto.LogMsg.log)
  return log_.Add();
}
inline void LogMsg::add_log(const ::std::string& value) {
  log_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ndm_proto.LogMsg.log)
}
#if LANG_CXX11
inline void LogMsg::add_log(::std::string&& value) {
  log_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ndm_proto.LogMsg.log)
}
#endif
inline void LogMsg::add_log(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  log_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ndm_proto.LogMsg.log)
}
inline void LogMsg::add_log(const char* value, size_t size) {
  log_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ndm_proto.LogMsg.log)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
LogMsg::log() const {
  // @@protoc_insertion_point(field_list:ndm_proto.LogMsg.log)
  return log_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
LogMsg::mutable_log() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.LogMsg.log)
  return &log_;
}

// -------------------------------------------------------------------

// DebugMsg

// required .ndm_proto.NDMHeader header = 1;
inline bool DebugMsg::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DebugMsg::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DebugMsg::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DebugMsg::clear_header() {
  if (header_ != NULL) header_->Clear();
  clear_has_header();
}
inline const ::ndm_proto::NDMHeader& DebugMsg::header() const {
  const ::ndm_proto::NDMHeader* p = header_;
  // @@protoc_insertion_point(field_get:ndm_proto.DebugMsg.header)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::NDMHeader*>(
      &::ndm_proto::_NDMHeader_default_instance_);
}
inline ::ndm_proto::NDMHeader* DebugMsg::release_header() {
  // @@protoc_insertion_point(field_release:ndm_proto.DebugMsg.header)
  clear_has_header();
  ::ndm_proto::NDMHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::ndm_proto::NDMHeader* DebugMsg::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::ndm_proto::NDMHeader;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.DebugMsg.header)
  return header_;
}
inline void DebugMsg::set_allocated_header(::ndm_proto::NDMHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    set_has_header();
  } else {
    clear_has_header();
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.DebugMsg.header)
}

// required .ndm_proto.Debug debug = 2;
inline bool DebugMsg::has_debug() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DebugMsg::set_has_debug() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DebugMsg::clear_has_debug() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ndm_proto::Debug& DebugMsg::debug() const {
  const ::ndm_proto::Debug* p = debug_;
  // @@protoc_insertion_point(field_get:ndm_proto.DebugMsg.debug)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Debug*>(
      &::ndm_proto::_Debug_default_instance_);
}
inline ::ndm_proto::Debug* DebugMsg::release_debug() {
  // @@protoc_insertion_point(field_release:ndm_proto.DebugMsg.debug)
  clear_has_debug();
  ::ndm_proto::Debug* temp = debug_;
  debug_ = NULL;
  return temp;
}
inline ::ndm_proto::Debug* DebugMsg::mutable_debug() {
  set_has_debug();
  if (debug_ == NULL) {
    debug_ = new ::ndm_proto::Debug;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.DebugMsg.debug)
  return debug_;
}
inline void DebugMsg::set_allocated_debug(::ndm_proto::Debug* debug) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(debug_);
  }
  if (debug) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      debug = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, debug, submessage_arena);
    }
    set_has_debug();
  } else {
    clear_has_debug();
  }
  debug_ = debug;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.DebugMsg.debug)
}

// -------------------------------------------------------------------

// SessionInfoMsg

// required .ndm_proto.NDMHeader header = 1;
inline bool SessionInfoMsg::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SessionInfoMsg::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SessionInfoMsg::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SessionInfoMsg::clear_header() {
  if (header_ != NULL) header_->Clear();
  clear_has_header();
}
inline const ::ndm_proto::NDMHeader& SessionInfoMsg::header() const {
  const ::ndm_proto::NDMHeader* p = header_;
  // @@protoc_insertion_point(field_get:ndm_proto.SessionInfoMsg.header)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::NDMHeader*>(
      &::ndm_proto::_NDMHeader_default_instance_);
}
inline ::ndm_proto::NDMHeader* SessionInfoMsg::release_header() {
  // @@protoc_insertion_point(field_release:ndm_proto.SessionInfoMsg.header)
  clear_has_header();
  ::ndm_proto::NDMHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::ndm_proto::NDMHeader* SessionInfoMsg::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::ndm_proto::NDMHeader;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.SessionInfoMsg.header)
  return header_;
}
inline void SessionInfoMsg::set_allocated_header(::ndm_proto::NDMHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    set_has_header();
  } else {
    clear_has_header();
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.SessionInfoMsg.header)
}

// required .ndm_proto.SessionInfo session = 2;
inline bool SessionInfoMsg::has_session() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SessionInfoMsg::set_has_session() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SessionInfoMsg::clear_has_session() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ndm_proto::SessionInfo& SessionInfoMsg::session() const {
  const ::ndm_proto::SessionInfo* p = session_;
  // @@protoc_insertion_point(field_get:ndm_proto.SessionInfoMsg.session)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::SessionInfo*>(
      &::ndm_proto::_SessionInfo_default_instance_);
}
inline ::ndm_proto::SessionInfo* SessionInfoMsg::release_session() {
  // @@protoc_insertion_point(field_release:ndm_proto.SessionInfoMsg.session)
  clear_has_session();
  ::ndm_proto::SessionInfo* temp = session_;
  session_ = NULL;
  return temp;
}
inline ::ndm_proto::SessionInfo* SessionInfoMsg::mutable_session() {
  set_has_session();
  if (session_ == NULL) {
    session_ = new ::ndm_proto::SessionInfo;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.SessionInfoMsg.session)
  return session_;
}
inline void SessionInfoMsg::set_allocated_session(::ndm_proto::SessionInfo* session) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(session_);
  }
  if (session) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      session = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, session, submessage_arena);
    }
    set_has_session();
  } else {
    clear_has_session();
  }
  session_ = session;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.SessionInfoMsg.session)
}

// -------------------------------------------------------------------

// MapEnvMsg

// optional .ndm_proto.NDMHeader header = 1;
inline bool MapEnvMsg::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapEnvMsg::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapEnvMsg::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapEnvMsg::clear_header() {
  if (header_ != NULL) header_->Clear();
  clear_has_header();
}
inline const ::ndm_proto::NDMHeader& MapEnvMsg::header() const {
  const ::ndm_proto::NDMHeader* p = header_;
  // @@protoc_insertion_point(field_get:ndm_proto.MapEnvMsg.header)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::NDMHeader*>(
      &::ndm_proto::_NDMHeader_default_instance_);
}
inline ::ndm_proto::NDMHeader* MapEnvMsg::release_header() {
  // @@protoc_insertion_point(field_release:ndm_proto.MapEnvMsg.header)
  clear_has_header();
  ::ndm_proto::NDMHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::ndm_proto::NDMHeader* MapEnvMsg::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::ndm_proto::NDMHeader;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.MapEnvMsg.header)
  return header_;
}
inline void MapEnvMsg::set_allocated_header(::ndm_proto::NDMHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    set_has_header();
  } else {
    clear_has_header();
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.MapEnvMsg.header)
}

// optional .ndm_proto.PhysicalLayer physical_layer = 2;
inline bool MapEnvMsg::has_physical_layer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapEnvMsg::set_has_physical_layer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MapEnvMsg::clear_has_physical_layer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ndm_proto::PhysicalLayer& MapEnvMsg::physical_layer() const {
  const ::ndm_proto::PhysicalLayer* p = physical_layer_;
  // @@protoc_insertion_point(field_get:ndm_proto.MapEnvMsg.physical_layer)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::PhysicalLayer*>(
      &::ndm_proto::_PhysicalLayer_default_instance_);
}
inline ::ndm_proto::PhysicalLayer* MapEnvMsg::release_physical_layer() {
  // @@protoc_insertion_point(field_release:ndm_proto.MapEnvMsg.physical_layer)
  clear_has_physical_layer();
  ::ndm_proto::PhysicalLayer* temp = physical_layer_;
  physical_layer_ = NULL;
  return temp;
}
inline ::ndm_proto::PhysicalLayer* MapEnvMsg::mutable_physical_layer() {
  set_has_physical_layer();
  if (physical_layer_ == NULL) {
    physical_layer_ = new ::ndm_proto::PhysicalLayer;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.MapEnvMsg.physical_layer)
  return physical_layer_;
}
inline void MapEnvMsg::set_allocated_physical_layer(::ndm_proto::PhysicalLayer* physical_layer) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(physical_layer_);
  }
  if (physical_layer) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      physical_layer = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, physical_layer, submessage_arena);
    }
    set_has_physical_layer();
  } else {
    clear_has_physical_layer();
  }
  physical_layer_ = physical_layer;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.MapEnvMsg.physical_layer)
}

// optional .ndm_proto.LogicalLayer logical_layer = 3;
inline bool MapEnvMsg::has_logical_layer() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MapEnvMsg::set_has_logical_layer() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MapEnvMsg::clear_has_logical_layer() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ndm_proto::LogicalLayer& MapEnvMsg::logical_layer() const {
  const ::ndm_proto::LogicalLayer* p = logical_layer_;
  // @@protoc_insertion_point(field_get:ndm_proto.MapEnvMsg.logical_layer)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::LogicalLayer*>(
      &::ndm_proto::_LogicalLayer_default_instance_);
}
inline ::ndm_proto::LogicalLayer* MapEnvMsg::release_logical_layer() {
  // @@protoc_insertion_point(field_release:ndm_proto.MapEnvMsg.logical_layer)
  clear_has_logical_layer();
  ::ndm_proto::LogicalLayer* temp = logical_layer_;
  logical_layer_ = NULL;
  return temp;
}
inline ::ndm_proto::LogicalLayer* MapEnvMsg::mutable_logical_layer() {
  set_has_logical_layer();
  if (logical_layer_ == NULL) {
    logical_layer_ = new ::ndm_proto::LogicalLayer;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.MapEnvMsg.logical_layer)
  return logical_layer_;
}
inline void MapEnvMsg::set_allocated_logical_layer(::ndm_proto::LogicalLayer* logical_layer) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(logical_layer_);
  }
  if (logical_layer) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      logical_layer = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, logical_layer, submessage_arena);
    }
    set_has_logical_layer();
  } else {
    clear_has_logical_layer();
  }
  logical_layer_ = logical_layer;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.MapEnvMsg.logical_layer)
}

// optional .ndm_proto.TopologicalLayer topological_layer = 4;
inline bool MapEnvMsg::has_topological_layer() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MapEnvMsg::set_has_topological_layer() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MapEnvMsg::clear_has_topological_layer() {
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::ndm_proto::TopologicalLayer& MapEnvMsg::topological_layer() const {
  const ::ndm_proto::TopologicalLayer* p = topological_layer_;
  // @@protoc_insertion_point(field_get:ndm_proto.MapEnvMsg.topological_layer)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::TopologicalLayer*>(
      &::ndm_proto::_TopologicalLayer_default_instance_);
}
inline ::ndm_proto::TopologicalLayer* MapEnvMsg::release_topological_layer() {
  // @@protoc_insertion_point(field_release:ndm_proto.MapEnvMsg.topological_layer)
  clear_has_topological_layer();
  ::ndm_proto::TopologicalLayer* temp = topological_layer_;
  topological_layer_ = NULL;
  return temp;
}
inline ::ndm_proto::TopologicalLayer* MapEnvMsg::mutable_topological_layer() {
  set_has_topological_layer();
  if (topological_layer_ == NULL) {
    topological_layer_ = new ::ndm_proto::TopologicalLayer;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.MapEnvMsg.topological_layer)
  return topological_layer_;
}
inline void MapEnvMsg::set_allocated_topological_layer(::ndm_proto::TopologicalLayer* topological_layer) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(topological_layer_);
  }
  if (topological_layer) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      topological_layer = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, topological_layer, submessage_arena);
    }
    set_has_topological_layer();
  } else {
    clear_has_topological_layer();
  }
  topological_layer_ = topological_layer;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.MapEnvMsg.topological_layer)
}

// optional .ndm_proto.DynamicLayer dynamic_layer = 5;
inline bool MapEnvMsg::has_dynamic_layer() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MapEnvMsg::set_has_dynamic_layer() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MapEnvMsg::clear_has_dynamic_layer() {
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::ndm_proto::DynamicLayer& MapEnvMsg::dynamic_layer() const {
  const ::ndm_proto::DynamicLayer* p = dynamic_layer_;
  // @@protoc_insertion_point(field_get:ndm_proto.MapEnvMsg.dynamic_layer)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::DynamicLayer*>(
      &::ndm_proto::_DynamicLayer_default_instance_);
}
inline ::ndm_proto::DynamicLayer* MapEnvMsg::release_dynamic_layer() {
  // @@protoc_insertion_point(field_release:ndm_proto.MapEnvMsg.dynamic_layer)
  clear_has_dynamic_layer();
  ::ndm_proto::DynamicLayer* temp = dynamic_layer_;
  dynamic_layer_ = NULL;
  return temp;
}
inline ::ndm_proto::DynamicLayer* MapEnvMsg::mutable_dynamic_layer() {
  set_has_dynamic_layer();
  if (dynamic_layer_ == NULL) {
    dynamic_layer_ = new ::ndm_proto::DynamicLayer;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.MapEnvMsg.dynamic_layer)
  return dynamic_layer_;
}
inline void MapEnvMsg::set_allocated_dynamic_layer(::ndm_proto::DynamicLayer* dynamic_layer) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(dynamic_layer_);
  }
  if (dynamic_layer) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      dynamic_layer = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, dynamic_layer, submessage_arena);
    }
    set_has_dynamic_layer();
  } else {
    clear_has_dynamic_layer();
  }
  dynamic_layer_ = dynamic_layer;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.MapEnvMsg.dynamic_layer)
}

// optional .ndm_proto.EgoLayer ego_layer = 6;
inline bool MapEnvMsg::has_ego_layer() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MapEnvMsg::set_has_ego_layer() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MapEnvMsg::clear_has_ego_layer() {
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::ndm_proto::EgoLayer& MapEnvMsg::ego_layer() const {
  const ::ndm_proto::EgoLayer* p = ego_layer_;
  // @@protoc_insertion_point(field_get:ndm_proto.MapEnvMsg.ego_layer)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::EgoLayer*>(
      &::ndm_proto::_EgoLayer_default_instance_);
}
inline ::ndm_proto::EgoLayer* MapEnvMsg::release_ego_layer() {
  // @@protoc_insertion_point(field_release:ndm_proto.MapEnvMsg.ego_layer)
  clear_has_ego_layer();
  ::ndm_proto::EgoLayer* temp = ego_layer_;
  ego_layer_ = NULL;
  return temp;
}
inline ::ndm_proto::EgoLayer* MapEnvMsg::mutable_ego_layer() {
  set_has_ego_layer();
  if (ego_layer_ == NULL) {
    ego_layer_ = new ::ndm_proto::EgoLayer;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.MapEnvMsg.ego_layer)
  return ego_layer_;
}
inline void MapEnvMsg::set_allocated_ego_layer(::ndm_proto::EgoLayer* ego_layer) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(ego_layer_);
  }
  if (ego_layer) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ego_layer = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ego_layer, submessage_arena);
    }
    set_has_ego_layer();
  } else {
    clear_has_ego_layer();
  }
  ego_layer_ = ego_layer;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.MapEnvMsg.ego_layer)
}

// -------------------------------------------------------------------

// NDMMessage

// required uint32 cyclic_counter = 1;
inline bool NDMMessage::has_cyclic_counter() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NDMMessage::set_has_cyclic_counter() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NDMMessage::clear_has_cyclic_counter() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NDMMessage::clear_cyclic_counter() {
  cyclic_counter_ = 0u;
  clear_has_cyclic_counter();
}
inline ::google::protobuf::uint32 NDMMessage::cyclic_counter() const {
  // @@protoc_insertion_point(field_get:ndm_proto.NDMMessage.cyclic_counter)
  return cyclic_counter_;
}
inline void NDMMessage::set_cyclic_counter(::google::protobuf::uint32 value) {
  set_has_cyclic_counter();
  cyclic_counter_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.NDMMessage.cyclic_counter)
}

// required uint32 msg_type = 2;
inline bool NDMMessage::has_msg_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NDMMessage::set_has_msg_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NDMMessage::clear_has_msg_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NDMMessage::clear_msg_type() {
  msg_type_ = 0u;
  clear_has_msg_type();
}
inline ::google::protobuf::uint32 NDMMessage::msg_type() const {
  // @@protoc_insertion_point(field_get:ndm_proto.NDMMessage.msg_type)
  return msg_type_;
}
inline void NDMMessage::set_msg_type(::google::protobuf::uint32 value) {
  set_has_msg_type();
  msg_type_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.NDMMessage.msg_type)
}

// optional .ndm_proto.MapEnvMsg mapenv_msg = 3;
inline bool NDMMessage::has_mapenv_msg() const {
  return message_case() == kMapenvMsg;
}
inline void NDMMessage::set_has_mapenv_msg() {
  _oneof_case_[0] = kMapenvMsg;
}
inline void NDMMessage::clear_mapenv_msg() {
  if (has_mapenv_msg()) {
    delete message_.mapenv_msg_;
    clear_has_message();
  }
}
inline ::ndm_proto::MapEnvMsg* NDMMessage::release_mapenv_msg() {
  // @@protoc_insertion_point(field_release:ndm_proto.NDMMessage.mapenv_msg)
  if (has_mapenv_msg()) {
    clear_has_message();
      ::ndm_proto::MapEnvMsg* temp = message_.mapenv_msg_;
    message_.mapenv_msg_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::ndm_proto::MapEnvMsg& NDMMessage::mapenv_msg() const {
  // @@protoc_insertion_point(field_get:ndm_proto.NDMMessage.mapenv_msg)
  return has_mapenv_msg()
      ? *message_.mapenv_msg_
      : *reinterpret_cast< ::ndm_proto::MapEnvMsg*>(&::ndm_proto::_MapEnvMsg_default_instance_);
}
inline ::ndm_proto::MapEnvMsg* NDMMessage::mutable_mapenv_msg() {
  if (!has_mapenv_msg()) {
    clear_message();
    set_has_mapenv_msg();
    message_.mapenv_msg_ = new ::ndm_proto::MapEnvMsg;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.NDMMessage.mapenv_msg)
  return message_.mapenv_msg_;
}

// optional .ndm_proto.LocationMsg location_msg = 4;
inline bool NDMMessage::has_location_msg() const {
  return message_case() == kLocationMsg;
}
inline void NDMMessage::set_has_location_msg() {
  _oneof_case_[0] = kLocationMsg;
}
inline void NDMMessage::clear_location_msg() {
  if (has_location_msg()) {
    delete message_.location_msg_;
    clear_has_message();
  }
}
inline ::ndm_proto::LocationMsg* NDMMessage::release_location_msg() {
  // @@protoc_insertion_point(field_release:ndm_proto.NDMMessage.location_msg)
  if (has_location_msg()) {
    clear_has_message();
      ::ndm_proto::LocationMsg* temp = message_.location_msg_;
    message_.location_msg_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::ndm_proto::LocationMsg& NDMMessage::location_msg() const {
  // @@protoc_insertion_point(field_get:ndm_proto.NDMMessage.location_msg)
  return has_location_msg()
      ? *message_.location_msg_
      : *reinterpret_cast< ::ndm_proto::LocationMsg*>(&::ndm_proto::_LocationMsg_default_instance_);
}
inline ::ndm_proto::LocationMsg* NDMMessage::mutable_location_msg() {
  if (!has_location_msg()) {
    clear_message();
    set_has_location_msg();
    message_.location_msg_ = new ::ndm_proto::LocationMsg;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.NDMMessage.location_msg)
  return message_.location_msg_;
}

// optional .ndm_proto.NavigationMsg navigation_msg = 5;
inline bool NDMMessage::has_navigation_msg() const {
  return message_case() == kNavigationMsg;
}
inline void NDMMessage::set_has_navigation_msg() {
  _oneof_case_[0] = kNavigationMsg;
}
inline void NDMMessage::clear_navigation_msg() {
  if (has_navigation_msg()) {
    delete message_.navigation_msg_;
    clear_has_message();
  }
}
inline ::ndm_proto::NavigationMsg* NDMMessage::release_navigation_msg() {
  // @@protoc_insertion_point(field_release:ndm_proto.NDMMessage.navigation_msg)
  if (has_navigation_msg()) {
    clear_has_message();
      ::ndm_proto::NavigationMsg* temp = message_.navigation_msg_;
    message_.navigation_msg_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::ndm_proto::NavigationMsg& NDMMessage::navigation_msg() const {
  // @@protoc_insertion_point(field_get:ndm_proto.NDMMessage.navigation_msg)
  return has_navigation_msg()
      ? *message_.navigation_msg_
      : *reinterpret_cast< ::ndm_proto::NavigationMsg*>(&::ndm_proto::_NavigationMsg_default_instance_);
}
inline ::ndm_proto::NavigationMsg* NDMMessage::mutable_navigation_msg() {
  if (!has_navigation_msg()) {
    clear_message();
    set_has_navigation_msg();
    message_.navigation_msg_ = new ::ndm_proto::NavigationMsg;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.NDMMessage.navigation_msg)
  return message_.navigation_msg_;
}

// optional .ndm_proto.LogMsg log_msg = 6;
inline bool NDMMessage::has_log_msg() const {
  return message_case() == kLogMsg;
}
inline void NDMMessage::set_has_log_msg() {
  _oneof_case_[0] = kLogMsg;
}
inline void NDMMessage::clear_log_msg() {
  if (has_log_msg()) {
    delete message_.log_msg_;
    clear_has_message();
  }
}
inline ::ndm_proto::LogMsg* NDMMessage::release_log_msg() {
  // @@protoc_insertion_point(field_release:ndm_proto.NDMMessage.log_msg)
  if (has_log_msg()) {
    clear_has_message();
      ::ndm_proto::LogMsg* temp = message_.log_msg_;
    message_.log_msg_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::ndm_proto::LogMsg& NDMMessage::log_msg() const {
  // @@protoc_insertion_point(field_get:ndm_proto.NDMMessage.log_msg)
  return has_log_msg()
      ? *message_.log_msg_
      : *reinterpret_cast< ::ndm_proto::LogMsg*>(&::ndm_proto::_LogMsg_default_instance_);
}
inline ::ndm_proto::LogMsg* NDMMessage::mutable_log_msg() {
  if (!has_log_msg()) {
    clear_message();
    set_has_log_msg();
    message_.log_msg_ = new ::ndm_proto::LogMsg;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.NDMMessage.log_msg)
  return message_.log_msg_;
}

// optional .ndm_proto.DebugMsg debug_msg = 7;
inline bool NDMMessage::has_debug_msg() const {
  return message_case() == kDebugMsg;
}
inline void NDMMessage::set_has_debug_msg() {
  _oneof_case_[0] = kDebugMsg;
}
inline void NDMMessage::clear_debug_msg() {
  if (has_debug_msg()) {
    delete message_.debug_msg_;
    clear_has_message();
  }
}
inline ::ndm_proto::DebugMsg* NDMMessage::release_debug_msg() {
  // @@protoc_insertion_point(field_release:ndm_proto.NDMMessage.debug_msg)
  if (has_debug_msg()) {
    clear_has_message();
      ::ndm_proto::DebugMsg* temp = message_.debug_msg_;
    message_.debug_msg_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::ndm_proto::DebugMsg& NDMMessage::debug_msg() const {
  // @@protoc_insertion_point(field_get:ndm_proto.NDMMessage.debug_msg)
  return has_debug_msg()
      ? *message_.debug_msg_
      : *reinterpret_cast< ::ndm_proto::DebugMsg*>(&::ndm_proto::_DebugMsg_default_instance_);
}
inline ::ndm_proto::DebugMsg* NDMMessage::mutable_debug_msg() {
  if (!has_debug_msg()) {
    clear_message();
    set_has_debug_msg();
    message_.debug_msg_ = new ::ndm_proto::DebugMsg;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.NDMMessage.debug_msg)
  return message_.debug_msg_;
}

inline bool NDMMessage::has_message() const {
  return message_case() != MESSAGE_NOT_SET;
}
inline void NDMMessage::clear_has_message() {
  _oneof_case_[0] = MESSAGE_NOT_SET;
}
inline NDMMessage::MessageCase NDMMessage::message_case() const {
  return NDMMessage::MessageCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// DataPack

// repeated .ndm_proto.DataHolder data_holders = 1;
inline int DataPack::data_holders_size() const {
  return data_holders_.size();
}
inline void DataPack::clear_data_holders() {
  data_holders_.Clear();
}
inline const ::ndm_proto::DataHolder& DataPack::data_holders(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.DataPack.data_holders)
  return data_holders_.Get(index);
}
inline ::ndm_proto::DataHolder* DataPack::mutable_data_holders(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.DataPack.data_holders)
  return data_holders_.Mutable(index);
}
inline ::ndm_proto::DataHolder* DataPack::add_data_holders() {
  // @@protoc_insertion_point(field_add:ndm_proto.DataPack.data_holders)
  return data_holders_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::DataHolder >*
DataPack::mutable_data_holders() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.DataPack.data_holders)
  return &data_holders_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::DataHolder >&
DataPack::data_holders() const {
  // @@protoc_insertion_point(field_list:ndm_proto.DataPack.data_holders)
  return data_holders_;
}

// -------------------------------------------------------------------

// DataHolder

// required uint64 timestamp = 1;
inline bool DataHolder::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DataHolder::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DataHolder::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DataHolder::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 DataHolder::timestamp() const {
  // @@protoc_insertion_point(field_get:ndm_proto.DataHolder.timestamp)
  return timestamp_;
}
inline void DataHolder::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.DataHolder.timestamp)
}

// required uint32 type = 2;
inline bool DataHolder::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DataHolder::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DataHolder::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DataHolder::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 DataHolder::type() const {
  // @@protoc_insertion_point(field_get:ndm_proto.DataHolder.type)
  return type_;
}
inline void DataHolder::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.DataHolder.type)
}

// required string name = 3;
inline bool DataHolder::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DataHolder::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DataHolder::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DataHolder::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& DataHolder::name() const {
  // @@protoc_insertion_point(field_get:ndm_proto.DataHolder.name)
  return name_.GetNoArena();
}
inline void DataHolder::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ndm_proto.DataHolder.name)
}
#if LANG_CXX11
inline void DataHolder::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ndm_proto.DataHolder.name)
}
#endif
inline void DataHolder::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ndm_proto.DataHolder.name)
}
inline void DataHolder::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.DataHolder.name)
}
inline ::std::string* DataHolder::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:ndm_proto.DataHolder.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DataHolder::release_name() {
  // @@protoc_insertion_point(field_release:ndm_proto.DataHolder.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DataHolder::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.DataHolder.name)
}

// required uint32 data_len = 4;
inline bool DataHolder::has_data_len() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DataHolder::set_has_data_len() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DataHolder::clear_has_data_len() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DataHolder::clear_data_len() {
  data_len_ = 0u;
  clear_has_data_len();
}
inline ::google::protobuf::uint32 DataHolder::data_len() const {
  // @@protoc_insertion_point(field_get:ndm_proto.DataHolder.data_len)
  return data_len_;
}
inline void DataHolder::set_data_len(::google::protobuf::uint32 value) {
  set_has_data_len();
  data_len_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.DataHolder.data_len)
}

// required bytes data_bts = 5;
inline bool DataHolder::has_data_bts() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DataHolder::set_has_data_bts() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DataHolder::clear_has_data_bts() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DataHolder::clear_data_bts() {
  data_bts_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data_bts();
}
inline const ::std::string& DataHolder::data_bts() const {
  // @@protoc_insertion_point(field_get:ndm_proto.DataHolder.data_bts)
  return data_bts_.GetNoArena();
}
inline void DataHolder::set_data_bts(const ::std::string& value) {
  set_has_data_bts();
  data_bts_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ndm_proto.DataHolder.data_bts)
}
#if LANG_CXX11
inline void DataHolder::set_data_bts(::std::string&& value) {
  set_has_data_bts();
  data_bts_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ndm_proto.DataHolder.data_bts)
}
#endif
inline void DataHolder::set_data_bts(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_data_bts();
  data_bts_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ndm_proto.DataHolder.data_bts)
}
inline void DataHolder::set_data_bts(const void* value, size_t size) {
  set_has_data_bts();
  data_bts_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.DataHolder.data_bts)
}
inline ::std::string* DataHolder::mutable_data_bts() {
  set_has_data_bts();
  // @@protoc_insertion_point(field_mutable:ndm_proto.DataHolder.data_bts)
  return data_bts_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DataHolder::release_data_bts() {
  // @@protoc_insertion_point(field_release:ndm_proto.DataHolder.data_bts)
  clear_has_data_bts();
  return data_bts_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DataHolder::set_allocated_data_bts(::std::string* data_bts) {
  if (data_bts != NULL) {
    set_has_data_bts();
  } else {
    clear_has_data_bts();
  }
  data_bts_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data_bts);
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.DataHolder.data_bts)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ndm_proto

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::ndm_proto::DrivingSide> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ndm_proto::DrivingSide>() {
  return ::ndm_proto::DrivingSide_descriptor();
}
template <> struct is_proto_enum< ::ndm_proto::UnitOfSystem> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ndm_proto::UnitOfSystem>() {
  return ::ndm_proto::UnitOfSystem_descriptor();
}
template <> struct is_proto_enum< ::ndm_proto::MapProvider> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ndm_proto::MapProvider>() {
  return ::ndm_proto::MapProvider_descriptor();
}
template <> struct is_proto_enum< ::ndm_proto::MapStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ndm_proto::MapStatus>() {
  return ::ndm_proto::MapStatus_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ndm_2eproto__INCLUDED
