// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: navigation.proto

#ifndef PROTOBUF_navigation_2eproto__INCLUDED
#define PROTOBUF_navigation_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "base.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_navigation_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[8];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsRoadRouteImpl();
void InitDefaultsRoadRoute();
void InitDefaultsLaneRouteImpl();
void InitDefaultsLaneRoute();
void InitDefaultsLaneOrientationImpl();
void InitDefaultsLaneOrientation();
void InitDefaultsNaviGuideInfoImpl();
void InitDefaultsNaviGuideInfo();
void InitDefaultsRecommendLaneImpl();
void InitDefaultsRecommendLane();
void InitDefaultsNaviLaneInfoImpl();
void InitDefaultsNaviLaneInfo();
void InitDefaultsRoadNaviImpl();
void InitDefaultsRoadNavi();
void InitDefaultsNavigationImpl();
void InitDefaultsNavigation();
inline void InitDefaults() {
  InitDefaultsRoadRoute();
  InitDefaultsLaneRoute();
  InitDefaultsLaneOrientation();
  InitDefaultsNaviGuideInfo();
  InitDefaultsRecommendLane();
  InitDefaultsNaviLaneInfo();
  InitDefaultsRoadNavi();
  InitDefaultsNavigation();
}
}  // namespace protobuf_navigation_2eproto
namespace ndm_proto {
class LaneOrientation;
class LaneOrientationDefaultTypeInternal;
extern LaneOrientationDefaultTypeInternal _LaneOrientation_default_instance_;
class LaneRoute;
class LaneRouteDefaultTypeInternal;
extern LaneRouteDefaultTypeInternal _LaneRoute_default_instance_;
class NaviGuideInfo;
class NaviGuideInfoDefaultTypeInternal;
extern NaviGuideInfoDefaultTypeInternal _NaviGuideInfo_default_instance_;
class NaviLaneInfo;
class NaviLaneInfoDefaultTypeInternal;
extern NaviLaneInfoDefaultTypeInternal _NaviLaneInfo_default_instance_;
class Navigation;
class NavigationDefaultTypeInternal;
extern NavigationDefaultTypeInternal _Navigation_default_instance_;
class RecommendLane;
class RecommendLaneDefaultTypeInternal;
extern RecommendLaneDefaultTypeInternal _RecommendLane_default_instance_;
class RoadNavi;
class RoadNaviDefaultTypeInternal;
extern RoadNaviDefaultTypeInternal _RoadNavi_default_instance_;
class RoadRoute;
class RoadRouteDefaultTypeInternal;
extern RoadRouteDefaultTypeInternal _RoadRoute_default_instance_;
}  // namespace ndm_proto
namespace ndm_proto {

enum NaviAction {
  NaviAction_Invalid = 0,
  NaviAction_Straight = 1,
  NaviAction_HalfRight = 2,
  NaviAction_Right = 3,
  NaviAction_MuchRight = 4,
  NaviAction_Uturn = 5,
  NaviAction_Left = 6,
  NaviAction_HalfLeft = 7,
  NaviAction_None = 8
};
bool NaviAction_IsValid(int value);
const NaviAction NaviAction_MIN = NaviAction_Invalid;
const NaviAction NaviAction_MAX = NaviAction_None;
const int NaviAction_ARRAYSIZE = NaviAction_MAX + 1;

const ::google::protobuf::EnumDescriptor* NaviAction_descriptor();
inline const ::std::string& NaviAction_Name(NaviAction value) {
  return ::google::protobuf::internal::NameOfEnum(
    NaviAction_descriptor(), value);
}
inline bool NaviAction_Parse(
    const ::std::string& name, NaviAction* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NaviAction>(
    NaviAction_descriptor(), name, value);
}
// ===================================================================

class RoadRoute : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.RoadRoute) */ {
 public:
  RoadRoute();
  virtual ~RoadRoute();

  RoadRoute(const RoadRoute& from);

  inline RoadRoute& operator=(const RoadRoute& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RoadRoute(RoadRoute&& from) noexcept
    : RoadRoute() {
    *this = ::std::move(from);
  }

  inline RoadRoute& operator=(RoadRoute&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoadRoute& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoadRoute* internal_default_instance() {
    return reinterpret_cast<const RoadRoute*>(
               &_RoadRoute_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(RoadRoute* other);
  friend void swap(RoadRoute& a, RoadRoute& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RoadRoute* New() const PROTOBUF_FINAL { return New(NULL); }

  RoadRoute* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RoadRoute& from);
  void MergeFrom(const RoadRoute& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RoadRoute* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string link_ids = 3;
  int link_ids_size() const;
  void clear_link_ids();
  static const int kLinkIdsFieldNumber = 3;
  const ::std::string& link_ids(int index) const;
  ::std::string* mutable_link_ids(int index);
  void set_link_ids(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_link_ids(int index, ::std::string&& value);
  #endif
  void set_link_ids(int index, const char* value);
  void set_link_ids(int index, const char* value, size_t size);
  ::std::string* add_link_ids();
  void add_link_ids(const ::std::string& value);
  #if LANG_CXX11
  void add_link_ids(::std::string&& value);
  #endif
  void add_link_ids(const char* value);
  void add_link_ids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& link_ids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_link_ids();

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // required uint64 stamp = 2;
  bool has_stamp() const;
  void clear_stamp();
  static const int kStampFieldNumber = 2;
  ::google::protobuf::uint64 stamp() const;
  void set_stamp(::google::protobuf::uint64 value);

  // required float time_cost_in_minutes = 10;
  bool has_time_cost_in_minutes() const;
  void clear_time_cost_in_minutes();
  static const int kTimeCostInMinutesFieldNumber = 10;
  float time_cost_in_minutes() const;
  void set_time_cost_in_minutes(float value);

  // required float distance_cost_in_meters = 11;
  bool has_distance_cost_in_meters() const;
  void clear_distance_cost_in_meters();
  static const int kDistanceCostInMetersFieldNumber = 11;
  float distance_cost_in_meters() const;
  void set_distance_cost_in_meters(float value);

  // @@protoc_insertion_point(class_scope:ndm_proto.RoadRoute)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_stamp();
  void clear_has_stamp();
  void set_has_time_cost_in_minutes();
  void clear_has_time_cost_in_minutes();
  void set_has_distance_cost_in_meters();
  void clear_has_distance_cost_in_meters();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> link_ids_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::uint64 stamp_;
  float time_cost_in_minutes_;
  float distance_cost_in_meters_;
  friend struct ::protobuf_navigation_2eproto::TableStruct;
  friend void ::protobuf_navigation_2eproto::InitDefaultsRoadRouteImpl();
};
// -------------------------------------------------------------------

class LaneRoute : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.LaneRoute) */ {
 public:
  LaneRoute();
  virtual ~LaneRoute();

  LaneRoute(const LaneRoute& from);

  inline LaneRoute& operator=(const LaneRoute& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LaneRoute(LaneRoute&& from) noexcept
    : LaneRoute() {
    *this = ::std::move(from);
  }

  inline LaneRoute& operator=(LaneRoute&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LaneRoute& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LaneRoute* internal_default_instance() {
    return reinterpret_cast<const LaneRoute*>(
               &_LaneRoute_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(LaneRoute* other);
  friend void swap(LaneRoute& a, LaneRoute& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LaneRoute* New() const PROTOBUF_FINAL { return New(NULL); }

  LaneRoute* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LaneRoute& from);
  void MergeFrom(const LaneRoute& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LaneRoute* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string lane_ids = 3;
  int lane_ids_size() const;
  void clear_lane_ids();
  static const int kLaneIdsFieldNumber = 3;
  const ::std::string& lane_ids(int index) const;
  ::std::string* mutable_lane_ids(int index);
  void set_lane_ids(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_lane_ids(int index, ::std::string&& value);
  #endif
  void set_lane_ids(int index, const char* value);
  void set_lane_ids(int index, const char* value, size_t size);
  ::std::string* add_lane_ids();
  void add_lane_ids(const ::std::string& value);
  #if LANG_CXX11
  void add_lane_ids(::std::string&& value);
  #endif
  void add_lane_ids(const char* value);
  void add_lane_ids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& lane_ids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_lane_ids();

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // required string road_route_id = 4;
  bool has_road_route_id() const;
  void clear_road_route_id();
  static const int kRoadRouteIdFieldNumber = 4;
  const ::std::string& road_route_id() const;
  void set_road_route_id(const ::std::string& value);
  #if LANG_CXX11
  void set_road_route_id(::std::string&& value);
  #endif
  void set_road_route_id(const char* value);
  void set_road_route_id(const char* value, size_t size);
  ::std::string* mutable_road_route_id();
  ::std::string* release_road_route_id();
  void set_allocated_road_route_id(::std::string* road_route_id);

  // required uint64 stamp = 2;
  bool has_stamp() const;
  void clear_stamp();
  static const int kStampFieldNumber = 2;
  ::google::protobuf::uint64 stamp() const;
  void set_stamp(::google::protobuf::uint64 value);

  // optional bool recommendation = 12;
  bool has_recommendation() const;
  void clear_recommendation();
  static const int kRecommendationFieldNumber = 12;
  bool recommendation() const;
  void set_recommendation(bool value);

  // required float time_cost_in_minutes = 10;
  bool has_time_cost_in_minutes() const;
  void clear_time_cost_in_minutes();
  static const int kTimeCostInMinutesFieldNumber = 10;
  float time_cost_in_minutes() const;
  void set_time_cost_in_minutes(float value);

  // required float distance_cost_in_meters = 11;
  bool has_distance_cost_in_meters() const;
  void clear_distance_cost_in_meters();
  static const int kDistanceCostInMetersFieldNumber = 11;
  float distance_cost_in_meters() const;
  void set_distance_cost_in_meters(float value);

  // @@protoc_insertion_point(class_scope:ndm_proto.LaneRoute)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_stamp();
  void clear_has_stamp();
  void set_has_road_route_id();
  void clear_has_road_route_id();
  void set_has_time_cost_in_minutes();
  void clear_has_time_cost_in_minutes();
  void set_has_distance_cost_in_meters();
  void clear_has_distance_cost_in_meters();
  void set_has_recommendation();
  void clear_has_recommendation();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> lane_ids_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr road_route_id_;
  ::google::protobuf::uint64 stamp_;
  bool recommendation_;
  float time_cost_in_minutes_;
  float distance_cost_in_meters_;
  friend struct ::protobuf_navigation_2eproto::TableStruct;
  friend void ::protobuf_navigation_2eproto::InitDefaultsLaneRouteImpl();
};
// -------------------------------------------------------------------

class LaneOrientation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.LaneOrientation) */ {
 public:
  LaneOrientation();
  virtual ~LaneOrientation();

  LaneOrientation(const LaneOrientation& from);

  inline LaneOrientation& operator=(const LaneOrientation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LaneOrientation(LaneOrientation&& from) noexcept
    : LaneOrientation() {
    *this = ::std::move(from);
  }

  inline LaneOrientation& operator=(LaneOrientation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LaneOrientation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LaneOrientation* internal_default_instance() {
    return reinterpret_cast<const LaneOrientation*>(
               &_LaneOrientation_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(LaneOrientation* other);
  friend void swap(LaneOrientation& a, LaneOrientation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LaneOrientation* New() const PROTOBUF_FINAL { return New(NULL); }

  LaneOrientation* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LaneOrientation& from);
  void MergeFrom(const LaneOrientation& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LaneOrientation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool uturn_able = 1;
  bool has_uturn_able() const;
  void clear_uturn_able();
  static const int kUturnAbleFieldNumber = 1;
  bool uturn_able() const;
  void set_uturn_able(bool value);

  // required bool left_able = 2;
  bool has_left_able() const;
  void clear_left_able();
  static const int kLeftAbleFieldNumber = 2;
  bool left_able() const;
  void set_left_able(bool value);

  // required bool straight_able = 3;
  bool has_straight_able() const;
  void clear_straight_able();
  static const int kStraightAbleFieldNumber = 3;
  bool straight_able() const;
  void set_straight_able(bool value);

  // required bool right_able = 4;
  bool has_right_able() const;
  void clear_right_able();
  static const int kRightAbleFieldNumber = 4;
  bool right_able() const;
  void set_right_able(bool value);

  // required bool bus_only = 5;
  bool has_bus_only() const;
  void clear_bus_only();
  static const int kBusOnlyFieldNumber = 5;
  bool bus_only() const;
  void set_bus_only(bool value);

  // required bool change_able = 6;
  bool has_change_able() const;
  void clear_change_able();
  static const int kChangeAbleFieldNumber = 6;
  bool change_able() const;
  void set_change_able(bool value);

  // required bool right_uturn = 7;
  bool has_right_uturn() const;
  void clear_right_uturn();
  static const int kRightUturnFieldNumber = 7;
  bool right_uturn() const;
  void set_right_uturn(bool value);

  // required bool highlight = 8;
  bool has_highlight() const;
  void clear_highlight();
  static const int kHighlightFieldNumber = 8;
  bool highlight() const;
  void set_highlight(bool value);

  // @@protoc_insertion_point(class_scope:ndm_proto.LaneOrientation)
 private:
  void set_has_uturn_able();
  void clear_has_uturn_able();
  void set_has_left_able();
  void clear_has_left_able();
  void set_has_straight_able();
  void clear_has_straight_able();
  void set_has_right_able();
  void clear_has_right_able();
  void set_has_bus_only();
  void clear_has_bus_only();
  void set_has_change_able();
  void clear_has_change_able();
  void set_has_right_uturn();
  void clear_has_right_uturn();
  void set_has_highlight();
  void clear_has_highlight();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  bool uturn_able_;
  bool left_able_;
  bool straight_able_;
  bool right_able_;
  bool bus_only_;
  bool change_able_;
  bool right_uturn_;
  bool highlight_;
  friend struct ::protobuf_navigation_2eproto::TableStruct;
  friend void ::protobuf_navigation_2eproto::InitDefaultsLaneOrientationImpl();
};
// -------------------------------------------------------------------

class NaviGuideInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.NaviGuideInfo) */ {
 public:
  NaviGuideInfo();
  virtual ~NaviGuideInfo();

  NaviGuideInfo(const NaviGuideInfo& from);

  inline NaviGuideInfo& operator=(const NaviGuideInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NaviGuideInfo(NaviGuideInfo&& from) noexcept
    : NaviGuideInfo() {
    *this = ::std::move(from);
  }

  inline NaviGuideInfo& operator=(NaviGuideInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NaviGuideInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NaviGuideInfo* internal_default_instance() {
    return reinterpret_cast<const NaviGuideInfo*>(
               &_NaviGuideInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(NaviGuideInfo* other);
  friend void swap(NaviGuideInfo& a, NaviGuideInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NaviGuideInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  NaviGuideInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NaviGuideInfo& from);
  void MergeFrom(const NaviGuideInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NaviGuideInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string next_road_name = 4;
  bool has_next_road_name() const;
  void clear_next_road_name();
  static const int kNextRoadNameFieldNumber = 4;
  const ::std::string& next_road_name() const;
  void set_next_road_name(const ::std::string& value);
  #if LANG_CXX11
  void set_next_road_name(::std::string&& value);
  #endif
  void set_next_road_name(const char* value);
  void set_next_road_name(const char* value, size_t size);
  ::std::string* mutable_next_road_name();
  ::std::string* release_next_road_name();
  void set_allocated_next_road_name(::std::string* next_road_name);

  // optional .ndm_proto.NaviAction navi_action = 1;
  bool has_navi_action() const;
  void clear_navi_action();
  static const int kNaviActionFieldNumber = 1;
  ::ndm_proto::NaviAction navi_action() const;
  void set_navi_action(::ndm_proto::NaviAction value);

  // optional float speed_limit = 2;
  bool has_speed_limit() const;
  void clear_speed_limit();
  static const int kSpeedLimitFieldNumber = 2;
  float speed_limit() const;
  void set_speed_limit(float value);

  // optional float remain_distance = 3;
  bool has_remain_distance() const;
  void clear_remain_distance();
  static const int kRemainDistanceFieldNumber = 3;
  float remain_distance() const;
  void set_remain_distance(float value);

  // @@protoc_insertion_point(class_scope:ndm_proto.NaviGuideInfo)
 private:
  void set_has_navi_action();
  void clear_has_navi_action();
  void set_has_speed_limit();
  void clear_has_speed_limit();
  void set_has_remain_distance();
  void clear_has_remain_distance();
  void set_has_next_road_name();
  void clear_has_next_road_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr next_road_name_;
  int navi_action_;
  float speed_limit_;
  float remain_distance_;
  friend struct ::protobuf_navigation_2eproto::TableStruct;
  friend void ::protobuf_navigation_2eproto::InitDefaultsNaviGuideInfoImpl();
};
// -------------------------------------------------------------------

class RecommendLane : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.RecommendLane) */ {
 public:
  RecommendLane();
  virtual ~RecommendLane();

  RecommendLane(const RecommendLane& from);

  inline RecommendLane& operator=(const RecommendLane& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RecommendLane(RecommendLane&& from) noexcept
    : RecommendLane() {
    *this = ::std::move(from);
  }

  inline RecommendLane& operator=(RecommendLane&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RecommendLane& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RecommendLane* internal_default_instance() {
    return reinterpret_cast<const RecommendLane*>(
               &_RecommendLane_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(RecommendLane* other);
  friend void swap(RecommendLane& a, RecommendLane& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RecommendLane* New() const PROTOBUF_FINAL { return New(NULL); }

  RecommendLane* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RecommendLane& from);
  void MergeFrom(const RecommendLane& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RecommendLane* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ndm_proto.LaneOrientation lane_orientation = 2;
  bool has_lane_orientation() const;
  void clear_lane_orientation();
  static const int kLaneOrientationFieldNumber = 2;
  const ::ndm_proto::LaneOrientation& lane_orientation() const;
  ::ndm_proto::LaneOrientation* release_lane_orientation();
  ::ndm_proto::LaneOrientation* mutable_lane_orientation();
  void set_allocated_lane_orientation(::ndm_proto::LaneOrientation* lane_orientation);

  // required uint32 idx = 1;
  bool has_idx() const;
  void clear_idx();
  static const int kIdxFieldNumber = 1;
  ::google::protobuf::uint32 idx() const;
  void set_idx(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ndm_proto.RecommendLane)
 private:
  void set_has_idx();
  void clear_has_idx();
  void set_has_lane_orientation();
  void clear_has_lane_orientation();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::ndm_proto::LaneOrientation* lane_orientation_;
  ::google::protobuf::uint32 idx_;
  friend struct ::protobuf_navigation_2eproto::TableStruct;
  friend void ::protobuf_navigation_2eproto::InitDefaultsRecommendLaneImpl();
};
// -------------------------------------------------------------------

class NaviLaneInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.NaviLaneInfo) */ {
 public:
  NaviLaneInfo();
  virtual ~NaviLaneInfo();

  NaviLaneInfo(const NaviLaneInfo& from);

  inline NaviLaneInfo& operator=(const NaviLaneInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NaviLaneInfo(NaviLaneInfo&& from) noexcept
    : NaviLaneInfo() {
    *this = ::std::move(from);
  }

  inline NaviLaneInfo& operator=(NaviLaneInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NaviLaneInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NaviLaneInfo* internal_default_instance() {
    return reinterpret_cast<const NaviLaneInfo*>(
               &_NaviLaneInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(NaviLaneInfo* other);
  friend void swap(NaviLaneInfo& a, NaviLaneInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NaviLaneInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  NaviLaneInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NaviLaneInfo& from);
  void MergeFrom(const NaviLaneInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NaviLaneInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ndm_proto.RecommendLane recommend_lanes = 2;
  int recommend_lanes_size() const;
  void clear_recommend_lanes();
  static const int kRecommendLanesFieldNumber = 2;
  const ::ndm_proto::RecommendLane& recommend_lanes(int index) const;
  ::ndm_proto::RecommendLane* mutable_recommend_lanes(int index);
  ::ndm_proto::RecommendLane* add_recommend_lanes();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::RecommendLane >*
      mutable_recommend_lanes();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::RecommendLane >&
      recommend_lanes() const;

  // required uint32 total_lane_num = 1;
  bool has_total_lane_num() const;
  void clear_total_lane_num();
  static const int kTotalLaneNumFieldNumber = 1;
  ::google::protobuf::uint32 total_lane_num() const;
  void set_total_lane_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ndm_proto.NaviLaneInfo)
 private:
  void set_has_total_lane_num();
  void clear_has_total_lane_num();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::RecommendLane > recommend_lanes_;
  ::google::protobuf::uint32 total_lane_num_;
  friend struct ::protobuf_navigation_2eproto::TableStruct;
  friend void ::protobuf_navigation_2eproto::InitDefaultsNaviLaneInfoImpl();
};
// -------------------------------------------------------------------

class RoadNavi : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.RoadNavi) */ {
 public:
  RoadNavi();
  virtual ~RoadNavi();

  RoadNavi(const RoadNavi& from);

  inline RoadNavi& operator=(const RoadNavi& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RoadNavi(RoadNavi&& from) noexcept
    : RoadNavi() {
    *this = ::std::move(from);
  }

  inline RoadNavi& operator=(RoadNavi&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoadNavi& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoadNavi* internal_default_instance() {
    return reinterpret_cast<const RoadNavi*>(
               &_RoadNavi_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(RoadNavi* other);
  friend void swap(RoadNavi& a, RoadNavi& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RoadNavi* New() const PROTOBUF_FINAL { return New(NULL); }

  RoadNavi* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RoadNavi& from);
  void MergeFrom(const RoadNavi& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RoadNavi* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // optional .ndm_proto.NaviGuideInfo navi_guide_info = 3;
  bool has_navi_guide_info() const;
  void clear_navi_guide_info();
  static const int kNaviGuideInfoFieldNumber = 3;
  const ::ndm_proto::NaviGuideInfo& navi_guide_info() const;
  ::ndm_proto::NaviGuideInfo* release_navi_guide_info();
  ::ndm_proto::NaviGuideInfo* mutable_navi_guide_info();
  void set_allocated_navi_guide_info(::ndm_proto::NaviGuideInfo* navi_guide_info);

  // optional .ndm_proto.NaviLaneInfo navi_lane_info = 4;
  bool has_navi_lane_info() const;
  void clear_navi_lane_info();
  static const int kNaviLaneInfoFieldNumber = 4;
  const ::ndm_proto::NaviLaneInfo& navi_lane_info() const;
  ::ndm_proto::NaviLaneInfo* release_navi_lane_info();
  ::ndm_proto::NaviLaneInfo* mutable_navi_lane_info();
  void set_allocated_navi_lane_info(::ndm_proto::NaviLaneInfo* navi_lane_info);

  // required uint64 stamp = 2;
  bool has_stamp() const;
  void clear_stamp();
  static const int kStampFieldNumber = 2;
  ::google::protobuf::uint64 stamp() const;
  void set_stamp(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:ndm_proto.RoadNavi)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_stamp();
  void clear_has_stamp();
  void set_has_navi_guide_info();
  void clear_has_navi_guide_info();
  void set_has_navi_lane_info();
  void clear_has_navi_lane_info();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::ndm_proto::NaviGuideInfo* navi_guide_info_;
  ::ndm_proto::NaviLaneInfo* navi_lane_info_;
  ::google::protobuf::uint64 stamp_;
  friend struct ::protobuf_navigation_2eproto::TableStruct;
  friend void ::protobuf_navigation_2eproto::InitDefaultsRoadNaviImpl();
};
// -------------------------------------------------------------------

class Navigation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ndm_proto.Navigation) */ {
 public:
  Navigation();
  virtual ~Navigation();

  Navigation(const Navigation& from);

  inline Navigation& operator=(const Navigation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Navigation(Navigation&& from) noexcept
    : Navigation() {
    *this = ::std::move(from);
  }

  inline Navigation& operator=(Navigation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Navigation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Navigation* internal_default_instance() {
    return reinterpret_cast<const Navigation*>(
               &_Navigation_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(Navigation* other);
  friend void swap(Navigation& a, Navigation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Navigation* New() const PROTOBUF_FINAL { return New(NULL); }

  Navigation* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Navigation& from);
  void MergeFrom(const Navigation& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Navigation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ndm_proto.RoadRoute road_routes = 7;
  int road_routes_size() const;
  void clear_road_routes();
  static const int kRoadRoutesFieldNumber = 7;
  const ::ndm_proto::RoadRoute& road_routes(int index) const;
  ::ndm_proto::RoadRoute* mutable_road_routes(int index);
  ::ndm_proto::RoadRoute* add_road_routes();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::RoadRoute >*
      mutable_road_routes();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::RoadRoute >&
      road_routes() const;

  // repeated .ndm_proto.LaneRoute lane_routes = 8;
  int lane_routes_size() const;
  void clear_lane_routes();
  static const int kLaneRoutesFieldNumber = 8;
  const ::ndm_proto::LaneRoute& lane_routes(int index) const;
  ::ndm_proto::LaneRoute* mutable_lane_routes(int index);
  ::ndm_proto::LaneRoute* add_lane_routes();
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::LaneRoute >*
      mutable_lane_routes();
  const ::google::protobuf::RepeatedPtrField< ::ndm_proto::LaneRoute >&
      lane_routes() const;

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // required .ndm_proto.Point start_location = 3;
  bool has_start_location() const;
  void clear_start_location();
  static const int kStartLocationFieldNumber = 3;
  const ::ndm_proto::Point& start_location() const;
  ::ndm_proto::Point* release_start_location();
  ::ndm_proto::Point* mutable_start_location();
  void set_allocated_start_location(::ndm_proto::Point* start_location);

  // required .ndm_proto.Point destination = 4;
  bool has_destination() const;
  void clear_destination();
  static const int kDestinationFieldNumber = 4;
  const ::ndm_proto::Point& destination() const;
  ::ndm_proto::Point* release_destination();
  ::ndm_proto::Point* mutable_destination();
  void set_allocated_destination(::ndm_proto::Point* destination);

  // optional .ndm_proto.RoadNavi road_navi = 9;
  bool has_road_navi() const;
  void clear_road_navi();
  static const int kRoadNaviFieldNumber = 9;
  const ::ndm_proto::RoadNavi& road_navi() const;
  ::ndm_proto::RoadNavi* release_road_navi();
  ::ndm_proto::RoadNavi* mutable_road_navi();
  void set_allocated_road_navi(::ndm_proto::RoadNavi* road_navi);

  // required uint64 stamp = 2;
  bool has_stamp() const;
  void clear_stamp();
  static const int kStampFieldNumber = 2;
  ::google::protobuf::uint64 stamp() const;
  void set_stamp(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:ndm_proto.Navigation)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_stamp();
  void clear_has_stamp();
  void set_has_start_location();
  void clear_has_start_location();
  void set_has_destination();
  void clear_has_destination();
  void set_has_road_navi();
  void clear_has_road_navi();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::RoadRoute > road_routes_;
  ::google::protobuf::RepeatedPtrField< ::ndm_proto::LaneRoute > lane_routes_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::ndm_proto::Point* start_location_;
  ::ndm_proto::Point* destination_;
  ::ndm_proto::RoadNavi* road_navi_;
  ::google::protobuf::uint64 stamp_;
  friend struct ::protobuf_navigation_2eproto::TableStruct;
  friend void ::protobuf_navigation_2eproto::InitDefaultsNavigationImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RoadRoute

// required string id = 1;
inline bool RoadRoute::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoadRoute::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoadRoute::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoadRoute::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& RoadRoute::id() const {
  // @@protoc_insertion_point(field_get:ndm_proto.RoadRoute.id)
  return id_.GetNoArena();
}
inline void RoadRoute::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ndm_proto.RoadRoute.id)
}
#if LANG_CXX11
inline void RoadRoute::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ndm_proto.RoadRoute.id)
}
#endif
inline void RoadRoute::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ndm_proto.RoadRoute.id)
}
inline void RoadRoute::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.RoadRoute.id)
}
inline ::std::string* RoadRoute::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:ndm_proto.RoadRoute.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RoadRoute::release_id() {
  // @@protoc_insertion_point(field_release:ndm_proto.RoadRoute.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RoadRoute::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.RoadRoute.id)
}

// required uint64 stamp = 2;
inline bool RoadRoute::has_stamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoadRoute::set_has_stamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoadRoute::clear_has_stamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoadRoute::clear_stamp() {
  stamp_ = GOOGLE_ULONGLONG(0);
  clear_has_stamp();
}
inline ::google::protobuf::uint64 RoadRoute::stamp() const {
  // @@protoc_insertion_point(field_get:ndm_proto.RoadRoute.stamp)
  return stamp_;
}
inline void RoadRoute::set_stamp(::google::protobuf::uint64 value) {
  set_has_stamp();
  stamp_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.RoadRoute.stamp)
}

// repeated string link_ids = 3;
inline int RoadRoute::link_ids_size() const {
  return link_ids_.size();
}
inline void RoadRoute::clear_link_ids() {
  link_ids_.Clear();
}
inline const ::std::string& RoadRoute::link_ids(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.RoadRoute.link_ids)
  return link_ids_.Get(index);
}
inline ::std::string* RoadRoute::mutable_link_ids(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.RoadRoute.link_ids)
  return link_ids_.Mutable(index);
}
inline void RoadRoute::set_link_ids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ndm_proto.RoadRoute.link_ids)
  link_ids_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void RoadRoute::set_link_ids(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:ndm_proto.RoadRoute.link_ids)
  link_ids_.Mutable(index)->assign(std::move(value));
}
#endif
inline void RoadRoute::set_link_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  link_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ndm_proto.RoadRoute.link_ids)
}
inline void RoadRoute::set_link_ids(int index, const char* value, size_t size) {
  link_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.RoadRoute.link_ids)
}
inline ::std::string* RoadRoute::add_link_ids() {
  // @@protoc_insertion_point(field_add_mutable:ndm_proto.RoadRoute.link_ids)
  return link_ids_.Add();
}
inline void RoadRoute::add_link_ids(const ::std::string& value) {
  link_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ndm_proto.RoadRoute.link_ids)
}
#if LANG_CXX11
inline void RoadRoute::add_link_ids(::std::string&& value) {
  link_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ndm_proto.RoadRoute.link_ids)
}
#endif
inline void RoadRoute::add_link_ids(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  link_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ndm_proto.RoadRoute.link_ids)
}
inline void RoadRoute::add_link_ids(const char* value, size_t size) {
  link_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ndm_proto.RoadRoute.link_ids)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RoadRoute::link_ids() const {
  // @@protoc_insertion_point(field_list:ndm_proto.RoadRoute.link_ids)
  return link_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RoadRoute::mutable_link_ids() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.RoadRoute.link_ids)
  return &link_ids_;
}

// required float time_cost_in_minutes = 10;
inline bool RoadRoute::has_time_cost_in_minutes() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RoadRoute::set_has_time_cost_in_minutes() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RoadRoute::clear_has_time_cost_in_minutes() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RoadRoute::clear_time_cost_in_minutes() {
  time_cost_in_minutes_ = 0;
  clear_has_time_cost_in_minutes();
}
inline float RoadRoute::time_cost_in_minutes() const {
  // @@protoc_insertion_point(field_get:ndm_proto.RoadRoute.time_cost_in_minutes)
  return time_cost_in_minutes_;
}
inline void RoadRoute::set_time_cost_in_minutes(float value) {
  set_has_time_cost_in_minutes();
  time_cost_in_minutes_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.RoadRoute.time_cost_in_minutes)
}

// required float distance_cost_in_meters = 11;
inline bool RoadRoute::has_distance_cost_in_meters() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RoadRoute::set_has_distance_cost_in_meters() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RoadRoute::clear_has_distance_cost_in_meters() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RoadRoute::clear_distance_cost_in_meters() {
  distance_cost_in_meters_ = 0;
  clear_has_distance_cost_in_meters();
}
inline float RoadRoute::distance_cost_in_meters() const {
  // @@protoc_insertion_point(field_get:ndm_proto.RoadRoute.distance_cost_in_meters)
  return distance_cost_in_meters_;
}
inline void RoadRoute::set_distance_cost_in_meters(float value) {
  set_has_distance_cost_in_meters();
  distance_cost_in_meters_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.RoadRoute.distance_cost_in_meters)
}

// -------------------------------------------------------------------

// LaneRoute

// required string id = 1;
inline bool LaneRoute::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LaneRoute::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LaneRoute::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LaneRoute::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& LaneRoute::id() const {
  // @@protoc_insertion_point(field_get:ndm_proto.LaneRoute.id)
  return id_.GetNoArena();
}
inline void LaneRoute::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ndm_proto.LaneRoute.id)
}
#if LANG_CXX11
inline void LaneRoute::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ndm_proto.LaneRoute.id)
}
#endif
inline void LaneRoute::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ndm_proto.LaneRoute.id)
}
inline void LaneRoute::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.LaneRoute.id)
}
inline ::std::string* LaneRoute::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:ndm_proto.LaneRoute.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LaneRoute::release_id() {
  // @@protoc_insertion_point(field_release:ndm_proto.LaneRoute.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LaneRoute::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.LaneRoute.id)
}

// required uint64 stamp = 2;
inline bool LaneRoute::has_stamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LaneRoute::set_has_stamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LaneRoute::clear_has_stamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LaneRoute::clear_stamp() {
  stamp_ = GOOGLE_ULONGLONG(0);
  clear_has_stamp();
}
inline ::google::protobuf::uint64 LaneRoute::stamp() const {
  // @@protoc_insertion_point(field_get:ndm_proto.LaneRoute.stamp)
  return stamp_;
}
inline void LaneRoute::set_stamp(::google::protobuf::uint64 value) {
  set_has_stamp();
  stamp_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.LaneRoute.stamp)
}

// repeated string lane_ids = 3;
inline int LaneRoute::lane_ids_size() const {
  return lane_ids_.size();
}
inline void LaneRoute::clear_lane_ids() {
  lane_ids_.Clear();
}
inline const ::std::string& LaneRoute::lane_ids(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.LaneRoute.lane_ids)
  return lane_ids_.Get(index);
}
inline ::std::string* LaneRoute::mutable_lane_ids(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.LaneRoute.lane_ids)
  return lane_ids_.Mutable(index);
}
inline void LaneRoute::set_lane_ids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ndm_proto.LaneRoute.lane_ids)
  lane_ids_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void LaneRoute::set_lane_ids(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:ndm_proto.LaneRoute.lane_ids)
  lane_ids_.Mutable(index)->assign(std::move(value));
}
#endif
inline void LaneRoute::set_lane_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  lane_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ndm_proto.LaneRoute.lane_ids)
}
inline void LaneRoute::set_lane_ids(int index, const char* value, size_t size) {
  lane_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.LaneRoute.lane_ids)
}
inline ::std::string* LaneRoute::add_lane_ids() {
  // @@protoc_insertion_point(field_add_mutable:ndm_proto.LaneRoute.lane_ids)
  return lane_ids_.Add();
}
inline void LaneRoute::add_lane_ids(const ::std::string& value) {
  lane_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ndm_proto.LaneRoute.lane_ids)
}
#if LANG_CXX11
inline void LaneRoute::add_lane_ids(::std::string&& value) {
  lane_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ndm_proto.LaneRoute.lane_ids)
}
#endif
inline void LaneRoute::add_lane_ids(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  lane_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ndm_proto.LaneRoute.lane_ids)
}
inline void LaneRoute::add_lane_ids(const char* value, size_t size) {
  lane_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ndm_proto.LaneRoute.lane_ids)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
LaneRoute::lane_ids() const {
  // @@protoc_insertion_point(field_list:ndm_proto.LaneRoute.lane_ids)
  return lane_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
LaneRoute::mutable_lane_ids() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.LaneRoute.lane_ids)
  return &lane_ids_;
}

// required string road_route_id = 4;
inline bool LaneRoute::has_road_route_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LaneRoute::set_has_road_route_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LaneRoute::clear_has_road_route_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LaneRoute::clear_road_route_id() {
  road_route_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_road_route_id();
}
inline const ::std::string& LaneRoute::road_route_id() const {
  // @@protoc_insertion_point(field_get:ndm_proto.LaneRoute.road_route_id)
  return road_route_id_.GetNoArena();
}
inline void LaneRoute::set_road_route_id(const ::std::string& value) {
  set_has_road_route_id();
  road_route_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ndm_proto.LaneRoute.road_route_id)
}
#if LANG_CXX11
inline void LaneRoute::set_road_route_id(::std::string&& value) {
  set_has_road_route_id();
  road_route_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ndm_proto.LaneRoute.road_route_id)
}
#endif
inline void LaneRoute::set_road_route_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_road_route_id();
  road_route_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ndm_proto.LaneRoute.road_route_id)
}
inline void LaneRoute::set_road_route_id(const char* value, size_t size) {
  set_has_road_route_id();
  road_route_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.LaneRoute.road_route_id)
}
inline ::std::string* LaneRoute::mutable_road_route_id() {
  set_has_road_route_id();
  // @@protoc_insertion_point(field_mutable:ndm_proto.LaneRoute.road_route_id)
  return road_route_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LaneRoute::release_road_route_id() {
  // @@protoc_insertion_point(field_release:ndm_proto.LaneRoute.road_route_id)
  clear_has_road_route_id();
  return road_route_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LaneRoute::set_allocated_road_route_id(::std::string* road_route_id) {
  if (road_route_id != NULL) {
    set_has_road_route_id();
  } else {
    clear_has_road_route_id();
  }
  road_route_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), road_route_id);
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.LaneRoute.road_route_id)
}

// required float time_cost_in_minutes = 10;
inline bool LaneRoute::has_time_cost_in_minutes() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LaneRoute::set_has_time_cost_in_minutes() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LaneRoute::clear_has_time_cost_in_minutes() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LaneRoute::clear_time_cost_in_minutes() {
  time_cost_in_minutes_ = 0;
  clear_has_time_cost_in_minutes();
}
inline float LaneRoute::time_cost_in_minutes() const {
  // @@protoc_insertion_point(field_get:ndm_proto.LaneRoute.time_cost_in_minutes)
  return time_cost_in_minutes_;
}
inline void LaneRoute::set_time_cost_in_minutes(float value) {
  set_has_time_cost_in_minutes();
  time_cost_in_minutes_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.LaneRoute.time_cost_in_minutes)
}

// required float distance_cost_in_meters = 11;
inline bool LaneRoute::has_distance_cost_in_meters() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LaneRoute::set_has_distance_cost_in_meters() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LaneRoute::clear_has_distance_cost_in_meters() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LaneRoute::clear_distance_cost_in_meters() {
  distance_cost_in_meters_ = 0;
  clear_has_distance_cost_in_meters();
}
inline float LaneRoute::distance_cost_in_meters() const {
  // @@protoc_insertion_point(field_get:ndm_proto.LaneRoute.distance_cost_in_meters)
  return distance_cost_in_meters_;
}
inline void LaneRoute::set_distance_cost_in_meters(float value) {
  set_has_distance_cost_in_meters();
  distance_cost_in_meters_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.LaneRoute.distance_cost_in_meters)
}

// optional bool recommendation = 12;
inline bool LaneRoute::has_recommendation() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LaneRoute::set_has_recommendation() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LaneRoute::clear_has_recommendation() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LaneRoute::clear_recommendation() {
  recommendation_ = false;
  clear_has_recommendation();
}
inline bool LaneRoute::recommendation() const {
  // @@protoc_insertion_point(field_get:ndm_proto.LaneRoute.recommendation)
  return recommendation_;
}
inline void LaneRoute::set_recommendation(bool value) {
  set_has_recommendation();
  recommendation_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.LaneRoute.recommendation)
}

// -------------------------------------------------------------------

// LaneOrientation

// required bool uturn_able = 1;
inline bool LaneOrientation::has_uturn_able() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LaneOrientation::set_has_uturn_able() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LaneOrientation::clear_has_uturn_able() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LaneOrientation::clear_uturn_able() {
  uturn_able_ = false;
  clear_has_uturn_able();
}
inline bool LaneOrientation::uturn_able() const {
  // @@protoc_insertion_point(field_get:ndm_proto.LaneOrientation.uturn_able)
  return uturn_able_;
}
inline void LaneOrientation::set_uturn_able(bool value) {
  set_has_uturn_able();
  uturn_able_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.LaneOrientation.uturn_able)
}

// required bool left_able = 2;
inline bool LaneOrientation::has_left_able() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LaneOrientation::set_has_left_able() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LaneOrientation::clear_has_left_able() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LaneOrientation::clear_left_able() {
  left_able_ = false;
  clear_has_left_able();
}
inline bool LaneOrientation::left_able() const {
  // @@protoc_insertion_point(field_get:ndm_proto.LaneOrientation.left_able)
  return left_able_;
}
inline void LaneOrientation::set_left_able(bool value) {
  set_has_left_able();
  left_able_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.LaneOrientation.left_able)
}

// required bool straight_able = 3;
inline bool LaneOrientation::has_straight_able() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LaneOrientation::set_has_straight_able() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LaneOrientation::clear_has_straight_able() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LaneOrientation::clear_straight_able() {
  straight_able_ = false;
  clear_has_straight_able();
}
inline bool LaneOrientation::straight_able() const {
  // @@protoc_insertion_point(field_get:ndm_proto.LaneOrientation.straight_able)
  return straight_able_;
}
inline void LaneOrientation::set_straight_able(bool value) {
  set_has_straight_able();
  straight_able_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.LaneOrientation.straight_able)
}

// required bool right_able = 4;
inline bool LaneOrientation::has_right_able() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LaneOrientation::set_has_right_able() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LaneOrientation::clear_has_right_able() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LaneOrientation::clear_right_able() {
  right_able_ = false;
  clear_has_right_able();
}
inline bool LaneOrientation::right_able() const {
  // @@protoc_insertion_point(field_get:ndm_proto.LaneOrientation.right_able)
  return right_able_;
}
inline void LaneOrientation::set_right_able(bool value) {
  set_has_right_able();
  right_able_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.LaneOrientation.right_able)
}

// required bool bus_only = 5;
inline bool LaneOrientation::has_bus_only() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LaneOrientation::set_has_bus_only() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LaneOrientation::clear_has_bus_only() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LaneOrientation::clear_bus_only() {
  bus_only_ = false;
  clear_has_bus_only();
}
inline bool LaneOrientation::bus_only() const {
  // @@protoc_insertion_point(field_get:ndm_proto.LaneOrientation.bus_only)
  return bus_only_;
}
inline void LaneOrientation::set_bus_only(bool value) {
  set_has_bus_only();
  bus_only_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.LaneOrientation.bus_only)
}

// required bool change_able = 6;
inline bool LaneOrientation::has_change_able() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LaneOrientation::set_has_change_able() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LaneOrientation::clear_has_change_able() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LaneOrientation::clear_change_able() {
  change_able_ = false;
  clear_has_change_able();
}
inline bool LaneOrientation::change_able() const {
  // @@protoc_insertion_point(field_get:ndm_proto.LaneOrientation.change_able)
  return change_able_;
}
inline void LaneOrientation::set_change_able(bool value) {
  set_has_change_able();
  change_able_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.LaneOrientation.change_able)
}

// required bool right_uturn = 7;
inline bool LaneOrientation::has_right_uturn() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LaneOrientation::set_has_right_uturn() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LaneOrientation::clear_has_right_uturn() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LaneOrientation::clear_right_uturn() {
  right_uturn_ = false;
  clear_has_right_uturn();
}
inline bool LaneOrientation::right_uturn() const {
  // @@protoc_insertion_point(field_get:ndm_proto.LaneOrientation.right_uturn)
  return right_uturn_;
}
inline void LaneOrientation::set_right_uturn(bool value) {
  set_has_right_uturn();
  right_uturn_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.LaneOrientation.right_uturn)
}

// required bool highlight = 8;
inline bool LaneOrientation::has_highlight() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LaneOrientation::set_has_highlight() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LaneOrientation::clear_has_highlight() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LaneOrientation::clear_highlight() {
  highlight_ = false;
  clear_has_highlight();
}
inline bool LaneOrientation::highlight() const {
  // @@protoc_insertion_point(field_get:ndm_proto.LaneOrientation.highlight)
  return highlight_;
}
inline void LaneOrientation::set_highlight(bool value) {
  set_has_highlight();
  highlight_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.LaneOrientation.highlight)
}

// -------------------------------------------------------------------

// NaviGuideInfo

// optional .ndm_proto.NaviAction navi_action = 1;
inline bool NaviGuideInfo::has_navi_action() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NaviGuideInfo::set_has_navi_action() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NaviGuideInfo::clear_has_navi_action() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NaviGuideInfo::clear_navi_action() {
  navi_action_ = 0;
  clear_has_navi_action();
}
inline ::ndm_proto::NaviAction NaviGuideInfo::navi_action() const {
  // @@protoc_insertion_point(field_get:ndm_proto.NaviGuideInfo.navi_action)
  return static_cast< ::ndm_proto::NaviAction >(navi_action_);
}
inline void NaviGuideInfo::set_navi_action(::ndm_proto::NaviAction value) {
  assert(::ndm_proto::NaviAction_IsValid(value));
  set_has_navi_action();
  navi_action_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.NaviGuideInfo.navi_action)
}

// optional float speed_limit = 2;
inline bool NaviGuideInfo::has_speed_limit() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NaviGuideInfo::set_has_speed_limit() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NaviGuideInfo::clear_has_speed_limit() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NaviGuideInfo::clear_speed_limit() {
  speed_limit_ = 0;
  clear_has_speed_limit();
}
inline float NaviGuideInfo::speed_limit() const {
  // @@protoc_insertion_point(field_get:ndm_proto.NaviGuideInfo.speed_limit)
  return speed_limit_;
}
inline void NaviGuideInfo::set_speed_limit(float value) {
  set_has_speed_limit();
  speed_limit_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.NaviGuideInfo.speed_limit)
}

// optional float remain_distance = 3;
inline bool NaviGuideInfo::has_remain_distance() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NaviGuideInfo::set_has_remain_distance() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NaviGuideInfo::clear_has_remain_distance() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NaviGuideInfo::clear_remain_distance() {
  remain_distance_ = 0;
  clear_has_remain_distance();
}
inline float NaviGuideInfo::remain_distance() const {
  // @@protoc_insertion_point(field_get:ndm_proto.NaviGuideInfo.remain_distance)
  return remain_distance_;
}
inline void NaviGuideInfo::set_remain_distance(float value) {
  set_has_remain_distance();
  remain_distance_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.NaviGuideInfo.remain_distance)
}

// optional string next_road_name = 4;
inline bool NaviGuideInfo::has_next_road_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NaviGuideInfo::set_has_next_road_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NaviGuideInfo::clear_has_next_road_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NaviGuideInfo::clear_next_road_name() {
  next_road_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_next_road_name();
}
inline const ::std::string& NaviGuideInfo::next_road_name() const {
  // @@protoc_insertion_point(field_get:ndm_proto.NaviGuideInfo.next_road_name)
  return next_road_name_.GetNoArena();
}
inline void NaviGuideInfo::set_next_road_name(const ::std::string& value) {
  set_has_next_road_name();
  next_road_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ndm_proto.NaviGuideInfo.next_road_name)
}
#if LANG_CXX11
inline void NaviGuideInfo::set_next_road_name(::std::string&& value) {
  set_has_next_road_name();
  next_road_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ndm_proto.NaviGuideInfo.next_road_name)
}
#endif
inline void NaviGuideInfo::set_next_road_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_next_road_name();
  next_road_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ndm_proto.NaviGuideInfo.next_road_name)
}
inline void NaviGuideInfo::set_next_road_name(const char* value, size_t size) {
  set_has_next_road_name();
  next_road_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.NaviGuideInfo.next_road_name)
}
inline ::std::string* NaviGuideInfo::mutable_next_road_name() {
  set_has_next_road_name();
  // @@protoc_insertion_point(field_mutable:ndm_proto.NaviGuideInfo.next_road_name)
  return next_road_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NaviGuideInfo::release_next_road_name() {
  // @@protoc_insertion_point(field_release:ndm_proto.NaviGuideInfo.next_road_name)
  clear_has_next_road_name();
  return next_road_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NaviGuideInfo::set_allocated_next_road_name(::std::string* next_road_name) {
  if (next_road_name != NULL) {
    set_has_next_road_name();
  } else {
    clear_has_next_road_name();
  }
  next_road_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), next_road_name);
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.NaviGuideInfo.next_road_name)
}

// -------------------------------------------------------------------

// RecommendLane

// required uint32 idx = 1;
inline bool RecommendLane::has_idx() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RecommendLane::set_has_idx() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RecommendLane::clear_has_idx() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RecommendLane::clear_idx() {
  idx_ = 0u;
  clear_has_idx();
}
inline ::google::protobuf::uint32 RecommendLane::idx() const {
  // @@protoc_insertion_point(field_get:ndm_proto.RecommendLane.idx)
  return idx_;
}
inline void RecommendLane::set_idx(::google::protobuf::uint32 value) {
  set_has_idx();
  idx_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.RecommendLane.idx)
}

// required .ndm_proto.LaneOrientation lane_orientation = 2;
inline bool RecommendLane::has_lane_orientation() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RecommendLane::set_has_lane_orientation() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RecommendLane::clear_has_lane_orientation() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RecommendLane::clear_lane_orientation() {
  if (lane_orientation_ != NULL) lane_orientation_->Clear();
  clear_has_lane_orientation();
}
inline const ::ndm_proto::LaneOrientation& RecommendLane::lane_orientation() const {
  const ::ndm_proto::LaneOrientation* p = lane_orientation_;
  // @@protoc_insertion_point(field_get:ndm_proto.RecommendLane.lane_orientation)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::LaneOrientation*>(
      &::ndm_proto::_LaneOrientation_default_instance_);
}
inline ::ndm_proto::LaneOrientation* RecommendLane::release_lane_orientation() {
  // @@protoc_insertion_point(field_release:ndm_proto.RecommendLane.lane_orientation)
  clear_has_lane_orientation();
  ::ndm_proto::LaneOrientation* temp = lane_orientation_;
  lane_orientation_ = NULL;
  return temp;
}
inline ::ndm_proto::LaneOrientation* RecommendLane::mutable_lane_orientation() {
  set_has_lane_orientation();
  if (lane_orientation_ == NULL) {
    lane_orientation_ = new ::ndm_proto::LaneOrientation;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.RecommendLane.lane_orientation)
  return lane_orientation_;
}
inline void RecommendLane::set_allocated_lane_orientation(::ndm_proto::LaneOrientation* lane_orientation) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete lane_orientation_;
  }
  if (lane_orientation) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      lane_orientation = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, lane_orientation, submessage_arena);
    }
    set_has_lane_orientation();
  } else {
    clear_has_lane_orientation();
  }
  lane_orientation_ = lane_orientation;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.RecommendLane.lane_orientation)
}

// -------------------------------------------------------------------

// NaviLaneInfo

// required uint32 total_lane_num = 1;
inline bool NaviLaneInfo::has_total_lane_num() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NaviLaneInfo::set_has_total_lane_num() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NaviLaneInfo::clear_has_total_lane_num() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NaviLaneInfo::clear_total_lane_num() {
  total_lane_num_ = 0u;
  clear_has_total_lane_num();
}
inline ::google::protobuf::uint32 NaviLaneInfo::total_lane_num() const {
  // @@protoc_insertion_point(field_get:ndm_proto.NaviLaneInfo.total_lane_num)
  return total_lane_num_;
}
inline void NaviLaneInfo::set_total_lane_num(::google::protobuf::uint32 value) {
  set_has_total_lane_num();
  total_lane_num_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.NaviLaneInfo.total_lane_num)
}

// repeated .ndm_proto.RecommendLane recommend_lanes = 2;
inline int NaviLaneInfo::recommend_lanes_size() const {
  return recommend_lanes_.size();
}
inline void NaviLaneInfo::clear_recommend_lanes() {
  recommend_lanes_.Clear();
}
inline const ::ndm_proto::RecommendLane& NaviLaneInfo::recommend_lanes(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.NaviLaneInfo.recommend_lanes)
  return recommend_lanes_.Get(index);
}
inline ::ndm_proto::RecommendLane* NaviLaneInfo::mutable_recommend_lanes(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.NaviLaneInfo.recommend_lanes)
  return recommend_lanes_.Mutable(index);
}
inline ::ndm_proto::RecommendLane* NaviLaneInfo::add_recommend_lanes() {
  // @@protoc_insertion_point(field_add:ndm_proto.NaviLaneInfo.recommend_lanes)
  return recommend_lanes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::RecommendLane >*
NaviLaneInfo::mutable_recommend_lanes() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.NaviLaneInfo.recommend_lanes)
  return &recommend_lanes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::RecommendLane >&
NaviLaneInfo::recommend_lanes() const {
  // @@protoc_insertion_point(field_list:ndm_proto.NaviLaneInfo.recommend_lanes)
  return recommend_lanes_;
}

// -------------------------------------------------------------------

// RoadNavi

// required string id = 1;
inline bool RoadNavi::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoadNavi::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoadNavi::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoadNavi::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& RoadNavi::id() const {
  // @@protoc_insertion_point(field_get:ndm_proto.RoadNavi.id)
  return id_.GetNoArena();
}
inline void RoadNavi::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ndm_proto.RoadNavi.id)
}
#if LANG_CXX11
inline void RoadNavi::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ndm_proto.RoadNavi.id)
}
#endif
inline void RoadNavi::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ndm_proto.RoadNavi.id)
}
inline void RoadNavi::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.RoadNavi.id)
}
inline ::std::string* RoadNavi::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:ndm_proto.RoadNavi.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RoadNavi::release_id() {
  // @@protoc_insertion_point(field_release:ndm_proto.RoadNavi.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RoadNavi::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.RoadNavi.id)
}

// required uint64 stamp = 2;
inline bool RoadNavi::has_stamp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RoadNavi::set_has_stamp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RoadNavi::clear_has_stamp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RoadNavi::clear_stamp() {
  stamp_ = GOOGLE_ULONGLONG(0);
  clear_has_stamp();
}
inline ::google::protobuf::uint64 RoadNavi::stamp() const {
  // @@protoc_insertion_point(field_get:ndm_proto.RoadNavi.stamp)
  return stamp_;
}
inline void RoadNavi::set_stamp(::google::protobuf::uint64 value) {
  set_has_stamp();
  stamp_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.RoadNavi.stamp)
}

// optional .ndm_proto.NaviGuideInfo navi_guide_info = 3;
inline bool RoadNavi::has_navi_guide_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoadNavi::set_has_navi_guide_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoadNavi::clear_has_navi_guide_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoadNavi::clear_navi_guide_info() {
  if (navi_guide_info_ != NULL) navi_guide_info_->Clear();
  clear_has_navi_guide_info();
}
inline const ::ndm_proto::NaviGuideInfo& RoadNavi::navi_guide_info() const {
  const ::ndm_proto::NaviGuideInfo* p = navi_guide_info_;
  // @@protoc_insertion_point(field_get:ndm_proto.RoadNavi.navi_guide_info)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::NaviGuideInfo*>(
      &::ndm_proto::_NaviGuideInfo_default_instance_);
}
inline ::ndm_proto::NaviGuideInfo* RoadNavi::release_navi_guide_info() {
  // @@protoc_insertion_point(field_release:ndm_proto.RoadNavi.navi_guide_info)
  clear_has_navi_guide_info();
  ::ndm_proto::NaviGuideInfo* temp = navi_guide_info_;
  navi_guide_info_ = NULL;
  return temp;
}
inline ::ndm_proto::NaviGuideInfo* RoadNavi::mutable_navi_guide_info() {
  set_has_navi_guide_info();
  if (navi_guide_info_ == NULL) {
    navi_guide_info_ = new ::ndm_proto::NaviGuideInfo;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.RoadNavi.navi_guide_info)
  return navi_guide_info_;
}
inline void RoadNavi::set_allocated_navi_guide_info(::ndm_proto::NaviGuideInfo* navi_guide_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete navi_guide_info_;
  }
  if (navi_guide_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      navi_guide_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, navi_guide_info, submessage_arena);
    }
    set_has_navi_guide_info();
  } else {
    clear_has_navi_guide_info();
  }
  navi_guide_info_ = navi_guide_info;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.RoadNavi.navi_guide_info)
}

// optional .ndm_proto.NaviLaneInfo navi_lane_info = 4;
inline bool RoadNavi::has_navi_lane_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RoadNavi::set_has_navi_lane_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RoadNavi::clear_has_navi_lane_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RoadNavi::clear_navi_lane_info() {
  if (navi_lane_info_ != NULL) navi_lane_info_->Clear();
  clear_has_navi_lane_info();
}
inline const ::ndm_proto::NaviLaneInfo& RoadNavi::navi_lane_info() const {
  const ::ndm_proto::NaviLaneInfo* p = navi_lane_info_;
  // @@protoc_insertion_point(field_get:ndm_proto.RoadNavi.navi_lane_info)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::NaviLaneInfo*>(
      &::ndm_proto::_NaviLaneInfo_default_instance_);
}
inline ::ndm_proto::NaviLaneInfo* RoadNavi::release_navi_lane_info() {
  // @@protoc_insertion_point(field_release:ndm_proto.RoadNavi.navi_lane_info)
  clear_has_navi_lane_info();
  ::ndm_proto::NaviLaneInfo* temp = navi_lane_info_;
  navi_lane_info_ = NULL;
  return temp;
}
inline ::ndm_proto::NaviLaneInfo* RoadNavi::mutable_navi_lane_info() {
  set_has_navi_lane_info();
  if (navi_lane_info_ == NULL) {
    navi_lane_info_ = new ::ndm_proto::NaviLaneInfo;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.RoadNavi.navi_lane_info)
  return navi_lane_info_;
}
inline void RoadNavi::set_allocated_navi_lane_info(::ndm_proto::NaviLaneInfo* navi_lane_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete navi_lane_info_;
  }
  if (navi_lane_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      navi_lane_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, navi_lane_info, submessage_arena);
    }
    set_has_navi_lane_info();
  } else {
    clear_has_navi_lane_info();
  }
  navi_lane_info_ = navi_lane_info;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.RoadNavi.navi_lane_info)
}

// -------------------------------------------------------------------

// Navigation

// required string id = 1;
inline bool Navigation::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Navigation::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Navigation::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Navigation::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& Navigation::id() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Navigation.id)
  return id_.GetNoArena();
}
inline void Navigation::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ndm_proto.Navigation.id)
}
#if LANG_CXX11
inline void Navigation::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ndm_proto.Navigation.id)
}
#endif
inline void Navigation::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ndm_proto.Navigation.id)
}
inline void Navigation::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ndm_proto.Navigation.id)
}
inline ::std::string* Navigation::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:ndm_proto.Navigation.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Navigation::release_id() {
  // @@protoc_insertion_point(field_release:ndm_proto.Navigation.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Navigation::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.Navigation.id)
}

// required uint64 stamp = 2;
inline bool Navigation::has_stamp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Navigation::set_has_stamp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Navigation::clear_has_stamp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Navigation::clear_stamp() {
  stamp_ = GOOGLE_ULONGLONG(0);
  clear_has_stamp();
}
inline ::google::protobuf::uint64 Navigation::stamp() const {
  // @@protoc_insertion_point(field_get:ndm_proto.Navigation.stamp)
  return stamp_;
}
inline void Navigation::set_stamp(::google::protobuf::uint64 value) {
  set_has_stamp();
  stamp_ = value;
  // @@protoc_insertion_point(field_set:ndm_proto.Navigation.stamp)
}

// required .ndm_proto.Point start_location = 3;
inline bool Navigation::has_start_location() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Navigation::set_has_start_location() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Navigation::clear_has_start_location() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ndm_proto::Point& Navigation::start_location() const {
  const ::ndm_proto::Point* p = start_location_;
  // @@protoc_insertion_point(field_get:ndm_proto.Navigation.start_location)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Point*>(
      &::ndm_proto::_Point_default_instance_);
}
inline ::ndm_proto::Point* Navigation::release_start_location() {
  // @@protoc_insertion_point(field_release:ndm_proto.Navigation.start_location)
  clear_has_start_location();
  ::ndm_proto::Point* temp = start_location_;
  start_location_ = NULL;
  return temp;
}
inline ::ndm_proto::Point* Navigation::mutable_start_location() {
  set_has_start_location();
  if (start_location_ == NULL) {
    start_location_ = new ::ndm_proto::Point;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.Navigation.start_location)
  return start_location_;
}
inline void Navigation::set_allocated_start_location(::ndm_proto::Point* start_location) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(start_location_);
  }
  if (start_location) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      start_location = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, start_location, submessage_arena);
    }
    set_has_start_location();
  } else {
    clear_has_start_location();
  }
  start_location_ = start_location;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.Navigation.start_location)
}

// required .ndm_proto.Point destination = 4;
inline bool Navigation::has_destination() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Navigation::set_has_destination() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Navigation::clear_has_destination() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ndm_proto::Point& Navigation::destination() const {
  const ::ndm_proto::Point* p = destination_;
  // @@protoc_insertion_point(field_get:ndm_proto.Navigation.destination)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::Point*>(
      &::ndm_proto::_Point_default_instance_);
}
inline ::ndm_proto::Point* Navigation::release_destination() {
  // @@protoc_insertion_point(field_release:ndm_proto.Navigation.destination)
  clear_has_destination();
  ::ndm_proto::Point* temp = destination_;
  destination_ = NULL;
  return temp;
}
inline ::ndm_proto::Point* Navigation::mutable_destination() {
  set_has_destination();
  if (destination_ == NULL) {
    destination_ = new ::ndm_proto::Point;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.Navigation.destination)
  return destination_;
}
inline void Navigation::set_allocated_destination(::ndm_proto::Point* destination) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(destination_);
  }
  if (destination) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      destination = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, destination, submessage_arena);
    }
    set_has_destination();
  } else {
    clear_has_destination();
  }
  destination_ = destination;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.Navigation.destination)
}

// repeated .ndm_proto.RoadRoute road_routes = 7;
inline int Navigation::road_routes_size() const {
  return road_routes_.size();
}
inline void Navigation::clear_road_routes() {
  road_routes_.Clear();
}
inline const ::ndm_proto::RoadRoute& Navigation::road_routes(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.Navigation.road_routes)
  return road_routes_.Get(index);
}
inline ::ndm_proto::RoadRoute* Navigation::mutable_road_routes(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.Navigation.road_routes)
  return road_routes_.Mutable(index);
}
inline ::ndm_proto::RoadRoute* Navigation::add_road_routes() {
  // @@protoc_insertion_point(field_add:ndm_proto.Navigation.road_routes)
  return road_routes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::RoadRoute >*
Navigation::mutable_road_routes() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.Navigation.road_routes)
  return &road_routes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::RoadRoute >&
Navigation::road_routes() const {
  // @@protoc_insertion_point(field_list:ndm_proto.Navigation.road_routes)
  return road_routes_;
}

// repeated .ndm_proto.LaneRoute lane_routes = 8;
inline int Navigation::lane_routes_size() const {
  return lane_routes_.size();
}
inline void Navigation::clear_lane_routes() {
  lane_routes_.Clear();
}
inline const ::ndm_proto::LaneRoute& Navigation::lane_routes(int index) const {
  // @@protoc_insertion_point(field_get:ndm_proto.Navigation.lane_routes)
  return lane_routes_.Get(index);
}
inline ::ndm_proto::LaneRoute* Navigation::mutable_lane_routes(int index) {
  // @@protoc_insertion_point(field_mutable:ndm_proto.Navigation.lane_routes)
  return lane_routes_.Mutable(index);
}
inline ::ndm_proto::LaneRoute* Navigation::add_lane_routes() {
  // @@protoc_insertion_point(field_add:ndm_proto.Navigation.lane_routes)
  return lane_routes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ndm_proto::LaneRoute >*
Navigation::mutable_lane_routes() {
  // @@protoc_insertion_point(field_mutable_list:ndm_proto.Navigation.lane_routes)
  return &lane_routes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ndm_proto::LaneRoute >&
Navigation::lane_routes() const {
  // @@protoc_insertion_point(field_list:ndm_proto.Navigation.lane_routes)
  return lane_routes_;
}

// optional .ndm_proto.RoadNavi road_navi = 9;
inline bool Navigation::has_road_navi() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Navigation::set_has_road_navi() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Navigation::clear_has_road_navi() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Navigation::clear_road_navi() {
  if (road_navi_ != NULL) road_navi_->Clear();
  clear_has_road_navi();
}
inline const ::ndm_proto::RoadNavi& Navigation::road_navi() const {
  const ::ndm_proto::RoadNavi* p = road_navi_;
  // @@protoc_insertion_point(field_get:ndm_proto.Navigation.road_navi)
  return p != NULL ? *p : *reinterpret_cast<const ::ndm_proto::RoadNavi*>(
      &::ndm_proto::_RoadNavi_default_instance_);
}
inline ::ndm_proto::RoadNavi* Navigation::release_road_navi() {
  // @@protoc_insertion_point(field_release:ndm_proto.Navigation.road_navi)
  clear_has_road_navi();
  ::ndm_proto::RoadNavi* temp = road_navi_;
  road_navi_ = NULL;
  return temp;
}
inline ::ndm_proto::RoadNavi* Navigation::mutable_road_navi() {
  set_has_road_navi();
  if (road_navi_ == NULL) {
    road_navi_ = new ::ndm_proto::RoadNavi;
  }
  // @@protoc_insertion_point(field_mutable:ndm_proto.Navigation.road_navi)
  return road_navi_;
}
inline void Navigation::set_allocated_road_navi(::ndm_proto::RoadNavi* road_navi) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete road_navi_;
  }
  if (road_navi) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      road_navi = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, road_navi, submessage_arena);
    }
    set_has_road_navi();
  } else {
    clear_has_road_navi();
  }
  road_navi_ = road_navi;
  // @@protoc_insertion_point(field_set_allocated:ndm_proto.Navigation.road_navi)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ndm_proto

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::ndm_proto::NaviAction> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ndm_proto::NaviAction>() {
  return ::ndm_proto::NaviAction_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_navigation_2eproto__INCLUDED
